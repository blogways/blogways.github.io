<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
 <title>www.blogways.net</title>
 <link href="http://www.blogways.net/atom.xml" rel="self"/>
 <link href="http://www.blogways.net/"/>
 <updated>2017-02-08T12:47:45+08:00</updated>
 <id>http://www.blogways.net/</id>
 <author>
   <name>www.blogways.net</name>
   <email>tangzhi@asiainfo-linkage</email>
 </author>

 
 <entry>
   <title>Scrapy 爬虫框架入门</title>
   <link href="http://www.blogways.net/blog/2017/01/08/scrapy.html"/>
   <updated>2017-01-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2017/01/08/scrapy</id>
   <content type="html">&lt;h2 id=&quot;一网络爬虫&quot;&gt;一、网络爬虫&lt;/h2&gt;
&lt;p&gt;网络爬虫或者叫网络机器人是用来自动采集网络内容的工具，通常被用于搜索引擎。基于我自己的理解，要写一个网络爬虫通常要解决以下几个问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;有哪些网络资源是需要被爬取的。网络上的资源多种多样，有单纯的HTML页面，也有各种格式的文件、音频或视频等等，在本文中我仅爬取HTML页面中的文本，所以这里的首要问题是哪些URL是爬虫要处理的。&lt;/li&gt;
  &lt;li&gt;如何从文本中提取到我想要的信息。HTML文本中包含了很多无用的信息，包括标签等，网络爬虫最终提供给我的应该是我感兴趣的内容。&lt;/li&gt;
  &lt;li&gt;如何把爬取到的信息保存下来。爬虫得到的有用信息要通过数据库或其他有效途径保存下来。&lt;/li&gt;
  &lt;li&gt;其他问题：包括网站的反爬虫策略、爬虫策略、错误处理能力等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上几个问题如果单独提出来可能大家都有解决的办法，但是整合到一起处理，还是有一些麻烦的。Scrapy这个爬虫框架就提供给我们一个简单的解决方案。&lt;/p&gt;

&lt;h2 id=&quot;二scrapy&quot;&gt;二、Scrapy&lt;/h2&gt;
&lt;p&gt;Scrapy是一个为了爬取网站数据，提取结构性数据而编写的应用框架。它包含了几大组件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Scrapy engine：它负责数据流在系统中所有组件中流动，相当于爬虫的“大脑”，是调度中心。&lt;/li&gt;
  &lt;li&gt;Downloader：负责获取页面并提供给引擎。&lt;/li&gt;
  &lt;li&gt;Spider：是真正的爬虫，负责URL和解析HTML提供item。&lt;/li&gt;
  &lt;li&gt;Pipeline：负责处理spider提供的item。典型的应用有清理错误、持久化等。&lt;/li&gt;
  &lt;li&gt;Middlewares：处理spider的输入和输出。典型的应用有网络代理验证。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/scrapy_workflow.png&quot; alt=&quot;scrapy_workflow.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三新建一个项目&quot;&gt;三、新建一个项目&lt;/h2&gt;
&lt;p&gt;在写爬虫之前我们要新建一个项目，Scrapy非常贴心的为我们提供了一个命令帮助我们建立项目框架：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;scrapy startproject [project_name]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个命令建立的项目框架如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;project_name/
  scrapy.cfg
  db/
    __init__.py
    config.py
  spiders/
    __init__.py
    spider.py
  items.py
  pipelines.py
  settings.py
  spiders/
      __init__.py
      ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;scrapy.cfg: 项目的配置文件。&lt;/li&gt;
  &lt;li&gt;db/config.py：数据库的设置文件。&lt;/li&gt;
  &lt;li&gt;spiders/：爬虫所在的目录。&lt;/li&gt;
  &lt;li&gt;project_name/items.py: 项目中的item文件。&lt;/li&gt;
  &lt;li&gt;project_name/pipelines.py: 项目中的pipelines文件。&lt;/li&gt;
  &lt;li&gt;project_name/settings.py: 项目的设置文件。包括数据库设置等。&lt;/li&gt;
  &lt;li&gt;project_name/spiders/: 放置spider代码的目录。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四编写一个爬虫&quot;&gt;四、编写一个爬虫&lt;/h2&gt;
&lt;p&gt;房子这两年大热，这里我写一个爬取链家网二手房的爬虫为例。打开&lt;a href=&quot;http://nj.lianjia.com/ershoufang/&quot;&gt;网页&lt;/a&gt;来观察一下结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/page_example.png&quot; alt=&quot;page_example.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;网页看上去十分规整，包含了很多我们想要的信息，包括总价、单价、面积和位置等。&lt;/p&gt;

&lt;h3 id=&quot;声明item&quot;&gt;声明item&lt;/h3&gt;
&lt;p&gt;Item是spider得到的结构化数据。&lt;/p&gt;

&lt;p&gt;打开items.py，用Python简单的class定义语法来新建一个类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import scrapy
from scrapy.loader.processors import MapCompose, TakeFirst

class HomeLinkItem(scrapy.Item):
    hid = scrapy.Field()
    url = scrapy.Field()
    title = scrapy.Field()
    price = scrapy.Field()
    room = scrapy.Field()
    htype = scrapy.Field()
    area = scrapy.Field()
    areaName = scrapy.Field()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;爬虫&quot;&gt;爬虫&lt;/h3&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;spiders/&lt;/code&gt;目录下新建home_link.py，作为爬虫。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class HomeSpider(CrawlSpider):
    name = &quot;home_link&quot;

    def parse_item(self, response):
        ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;爬虫要知道从哪里爬取，所以第一步是告诉爬虫域名和开始的URL：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;allow_domains = ['nj.lianjia.com']
start_urls = ['http://nj.lianjia.com/ershoufang/']
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;爬虫开始抓取网页之后还有告诉爬虫哪些URL是要处理的，也就是爬取的规则：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rules = (
    Rule(LinkExtractor(allow=(r'\d+\.html', r'pg\d+\\')), callback='parse_item', follow=True),
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大家可以打开刚才那个网页中的任意一个房子，观察它的URL。可以发现，URL都是域名加一串数字构成的。如：
  &lt;code class=&quot;highlighter-rouge&quot;&gt;http://nj.lianjia.com/ershoufang/103100443605.html&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;这里可以用正则表达式写多个规则，我在这里只写了一个。&lt;/p&gt;

&lt;h3 id=&quot;解析网页&quot;&gt;解析网页&lt;/h3&gt;
&lt;p&gt;爬虫中的&lt;code class=&quot;highlighter-rouge&quot;&gt;parse_item&lt;/code&gt;方法就是用来解析网页，并返回一个item的。&lt;/p&gt;

&lt;p&gt;Python有很多解析HTML的优秀库，如&lt;code class=&quot;highlighter-rouge&quot;&gt;BeautifulSoup&lt;/code&gt;，我在这里专注于爬虫就不用这些库了。实际上我们可以非常简单地通过XPath语法来获取网页上我们感兴趣的内容。XPath非常简单，只要熟悉CSS选择器就可以快速上手。&lt;/p&gt;

&lt;p&gt;我们再来看一下网页的源码，如我们感兴趣的&lt;em&gt;总价&lt;/em&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/price_tag.png&quot; alt=&quot;price_tag.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到&lt;em&gt;总价&lt;/em&gt;位于&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;price&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;div&lt;/code&gt;中的class为&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;div&lt;/code&gt;中（为看起来方便没有截更多，实际上他们还被&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;content&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;div&lt;/code&gt;包含）。&lt;/p&gt;

&lt;p&gt;那么要取得总价，XPath写成：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;//div[@class=&quot;content&quot;]/div[@class=&quot;price &quot;]/span[@class=&quot;total&quot;]/text()&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其他的字段都是类似我就不再赘述。&lt;/p&gt;

&lt;p&gt;最终&lt;code class=&quot;highlighter-rouge&quot;&gt;parse_item&lt;/code&gt;方法写成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def parse_item(self, response):
    l = ItemLoader(item=HomeLinkItem(), response=response)
    l.add_xpath('hid', '//div[@class=&quot;content&quot;]/span[@class=&quot;sharethis&quot;]/span[@class=&quot;erweibox&quot;]/img')
    l.add_value('url', response.url)
    l.add_xpath('title', '//title/text()')
    l.add_xpath('price', '//div[@class=&quot;content&quot;]/div[@class=&quot;price &quot;]/span[@class=&quot;total&quot;]/text()')
    l.add_xpath('room', '//div[@class=&quot;content&quot;]/div[@class=&quot;houseInfo&quot;]/div[@class=&quot;room&quot;]'
                        '/div[@class=&quot;mainInfo&quot;]/text()')
    l.add_xpath('htype', '//div[@class=&quot;content&quot;]/div[@class=&quot;houseInfo&quot;]/div[@class=&quot;type&quot;]'
                         '/div[@class=&quot;mainInfo&quot;]/text()')
    l.add_xpath('area', '//div[@class=&quot;content&quot;]/div[@class=&quot;houseInfo&quot;]/div[@class=&quot;area&quot;]'
                        '/div[@class=&quot;mainInfo&quot;]/text()')
    l.add_xpath('areaName', '//div[@class=&quot;content&quot;]/div[@class=&quot;aroundInfo&quot;]/div[@class=&quot;communityName&quot;]'
                            '/a[@class=&quot;info&quot;]/text()')
    return l.load_item()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回一个item。&lt;/p&gt;

&lt;h3 id=&quot;表的定义&quot;&gt;表的定义&lt;/h3&gt;
&lt;p&gt;最终我们想把数据保存在数据库中。Scrapy使用SQLAlchemy来帮助完成持久化，它相当于Hibernate，工作原理类似。&lt;/p&gt;

&lt;p&gt;定义一个类&lt;code class=&quot;highlighter-rouge&quot;&gt;house&lt;/code&gt;来保存数据，它对应数据库表&lt;code class=&quot;highlighter-rouge&quot;&gt;house&lt;/code&gt;。sqlalchemy.Column()这句代码定义字段和它的类型等。
在db/下新建house.py：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import sqlalchemy
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class House(Base):
    __tablename__ = 'house'

    hid = sqlalchemy.Column(sqlalchemy.String, primary_key=True, name='id')
    url = sqlalchemy.Column(sqlalchemy.String)
    title = sqlalchemy.Column(sqlalchemy.String)
    price = sqlalchemy.Column(sqlalchemy.String)
    room = sqlalchemy.Column(sqlalchemy.String)
    htype = sqlalchemy.Column(sqlalchemy.String, name='type')
    area = sqlalchemy.Column(sqlalchemy.String)
    areaName = sqlalchemy.Column(sqlalchemy.String, name='area_name')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数据库表&lt;code class=&quot;highlighter-rouge&quot;&gt;house&lt;/code&gt;的定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE `house` (
  `id` varchar(30) NOT NULL DEFAULT '',
  `url` varchar(256) DEFAULT NULL,
  `title` varchar(200) DEFAULT NULL,
  `price` varchar(10) DEFAULT NULL,
  `room` varchar(100) DEFAULT NULL,
  `type` varchar(100) DEFAULT NULL,
  `area` varchar(50) DEFAULT NULL,
  `area_name` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我使用的是MySQL，打开db/config.py，写入数据库连接字符串：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;engine = create_engine('mysql+mysqlconnector://user:pasword@localhost:3306/test')
DBSession = sessionmaker(bind=engine)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;保存结果&quot;&gt;保存结果&lt;/h3&gt;
&lt;p&gt;Pipelines的典型应用就是持久化数据。它接收Spider返回的item对象并对item进行处理。在这里我们把item包装成House类，并持久化。
打开&lt;code class=&quot;highlighter-rouge&quot;&gt;pipelines.py&lt;/code&gt;，并加入以下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DataBasePipeline(object):
    def open_spider(self, spider):
        self.session = DBSession()

    def process_item(self, item, spider):
        h = House(
            hid=item.get('hid'),
            url=item.get('url'),
            title=item.get('title'),
            price=item.get('price'),
            room=item.get('room'),
            htype=item.get('htype'),
            area=item.get('area'),
            areaName=item.get('areaName')
        )
        self.session.add(h)
        self.session.commit()

    def close_spider(self, spider):
        self.session.close()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;open_spider&lt;/code&gt;方法取得数据库session。&lt;code class=&quot;highlighter-rouge&quot;&gt;process_item&lt;/code&gt;方法处理对象，这里是将House对象存到数据库。&lt;/p&gt;

&lt;h3 id=&quot;运行爬虫&quot;&gt;运行爬虫&lt;/h3&gt;
&lt;p&gt;CD到项目目录，运行命令：&lt;code class=&quot;highlighter-rouge&quot;&gt;scrapy crawl home_link&lt;/code&gt;。（home_link是爬虫的名字）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/scrapy_run.png&quot; alt=&quot;scrapy_run.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到Scrapy取得了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;house&lt;/code&gt;。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mysql入门及在nodejs下的简单应用</title>
   <link href="http://www.blogways.net/blog/2016/12/22/mysql-introduce.html"/>
   <updated>2016-12-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/22/mysql-introduce</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#p1&quot;&gt;mysql安装&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#p2&quot;&gt;mysql基本命令&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#p3&quot;&gt;mysql在nodejs中的简单应用&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;p1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql安装&quot;&gt;mysql安装&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;MySQL安装文件有两种，一种是msi格式的，一种是zip格式的，这就决定了mysql的安装有两种。&lt;/li&gt;
  &lt;li&gt;如果你下载的文件是msi格式的，可以直接点击安装，按照它给出的安装提示进行安装（相信大家的英文可以看懂英文提示），该步骤较为复杂，
我之前用过这种安装方法，大概有好几十步。该安装方法没什么好说的，一路next基本上没什么问题了。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zip格式解压后进行配置可以使用了，该方法较为简便，值得推荐。
   解压后把文件放在一个合适的位置，最好重命名为Mysql_server+版本号，可以放在任意目录下。&lt;/p&gt;

    &lt;p&gt;然后配置环境变量，右击我的电脑-&amp;gt;属性-&amp;gt;高级-&amp;gt;环境变量，选择PATH,在其后面添加:你的mysql bin文件夹的路径(如D:\software\mysql-5.7\bin),
PATH=…….;D:\software\mysql-5.7\bin;(注意是追加,不是覆盖)。&lt;/p&gt;

    &lt;p&gt;接着修改mysql的配置文件my.ini,该文件在mysql_server目录下。用文本编辑器打开，修改或添加配置，&lt;/p&gt;

    &lt;p&gt;[mysqld]&lt;/p&gt;

    &lt;p&gt;basedir=D:\software\mysql-5.7（mysql所在目录）&lt;/p&gt;

    &lt;p&gt;datadir=D:\software\mysql-5.7data（mysql所在目录\data）&lt;/p&gt;

    &lt;p&gt;以管理员身份运行cmd（必须要用管理员身份运行，不然权限不够），键入 cd D:\software\mysql-5.7\bin,回车。再键入mysqld -install，若前面操作正确系统会提示安装成功。&lt;/p&gt;

    &lt;p&gt;安装成功后就要启动服务了，继续在cmd中输入:net start mysql。&lt;/p&gt;

    &lt;p&gt;然后登录：&lt;/p&gt;

    &lt;p&gt;输入mysql -u root -p（第一次登录没有密码，直接按回车过）,登录成功！&lt;/p&gt;

    &lt;p&gt;登录之后建议立即设置密码，输入一下命令：mysqladmin -u root -p[oldpass] password newpass&lt;/p&gt;

    &lt;p&gt;注意oldpass(老密码)可选，如果root默认密码为空，则不需要输入，如果需要更改老密码，请注意老密码与-p之间不要有空格，否则会报错，另外password和newpass(新密码)之间以空格分隔。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a id=&quot;p2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql基本命令&quot;&gt;mysql基本命令&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;创建数据库 create database dbname;&lt;/li&gt;
  &lt;li&gt;删除数据库 drop database dbname;&lt;/li&gt;
  &lt;li&gt;进入数据库 use dbname;&lt;/li&gt;
  &lt;li&gt;创建表 CREATE TABLE table_name (column_name column_type);&lt;/li&gt;
  &lt;li&gt;修改表名 alter table table_name rename table_new_name;&lt;/li&gt;
  &lt;li&gt;修改字段名 alter table table_name change old_column_name new_column_name column_type&lt;/li&gt;
  &lt;li&gt;修改字段类型 alter table table_name modify column table_name column_type;&lt;/li&gt;
  &lt;li&gt;增加字段 alter table table_name add COLUMN new_column_name column_type;&lt;/li&gt;
  &lt;li&gt;删除字段 alter table table_name DROP COLUMN column_name;&lt;/li&gt;
  &lt;li&gt;删除主键 alter table table_name drop primary key;&lt;/li&gt;
  &lt;li&gt;把某字段设为主键 alter table table_name add primary key(column_name);&lt;/li&gt;
  &lt;li&gt;删除表 drop table table_name;&lt;/li&gt;
  &lt;li&gt;增加记录 insert into table values(record);&lt;/li&gt;
  &lt;li&gt;删除记录 delete from table (不加where则删除全部记录）;&lt;/li&gt;
  &lt;li&gt;修改记录 update table set column=’new record’(不加条件则修改全部记录）&lt;/li&gt;
  &lt;li&gt;查询记录 select * from table;
注意：在mysql命令行中输入命令结尾处必须有’;’&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a id=&quot;p3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;mysql在nodejs中的简单应用&quot;&gt;mysql在nodejs中的简单应用&lt;/h2&gt;
&lt;p&gt;结合我的”图书管理系统”项目，简单谈一下mysql在nodejs中的应用。nodejs开发的web项目，把dao层和控制层糅合在一起。因此mysql放在控制层中。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;下载mysql模块 npm install mysql&lt;/li&gt;
  &lt;li&gt;引入模块 var mysql = require(‘mysql’);&lt;/li&gt;
  &lt;li&gt;创建连接 var conn = mysql.createConnection({
 host:’localhost’,
 user:’root’,
 password:’123qwe’,
 database:’hqh’,
 port:3306
});host是数据库地址，user用户名，password为密码，database为要连接的数据库，port是mysql的端口，默认是3306。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;无论增删改查，对sql的执行语句都是conn.query(sql)&lt;br /&gt;
如：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;conn.query(‘select * from book where book_status=0’ ,function(err, rows, fields) {
   //具体业务逻辑
    });&lt;/p&gt;

&lt;p&gt;conn.query(‘update book set book_status=1 where book_name=(?)’,[book_name],function(err,result){
            //具体业务逻辑
        });&lt;/p&gt;

&lt;p&gt;conn.query(‘delete from borrowing  where book_name=(?)’,[book_name],function(err,result){
        //具体业务逻辑
    });&lt;/p&gt;

&lt;p&gt;conn.query(‘insert into user VALUES(?,?,1)’,[name,pwd], function(err, result) {
                   //具体业务逻辑
                });&lt;/p&gt;

&lt;p&gt;注意：如有牵涉到对条件的操作，可在sql中用’?’做占位符，紧接着在[]中传入条件。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>PM2-NodeJs生产系统进程管理器</title>
   <link href="http://www.blogways.net/blog/2016/12/19/pm2.html"/>
   <updated>2016-12-19T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/19/pm2</id>
   <content type="html">&lt;h2 id=&quot;一node程序异常解决方案&quot;&gt;一、node程序异常解决方案&lt;/h2&gt;
&lt;p&gt;由于nodeJs是单线程机制，在实际生产中开发人员一个小小的bug就可能导致整个系统的崩溃，这样导致整个系统的稳定性大大降低。如在我们自己开发的凤来平台日常维护中目前经常就会碰到前台程序无法访问的情况。对于此类问题，我总结了大概能有以下几种解决方案：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;程序bug问题就直接修复bug，解决让系统异常停止的bug，但是这个无法最终解决问题，因为我们不能保证我们系统一定没有bug了；&lt;/li&gt;
  &lt;li&gt;通过捕捉uncaughtException系统异常来阻止Node进程结束，这种做法无法获取异常明细，而且有内存泄露的风险，不建议这样做；&lt;/li&gt;
  &lt;li&gt;通过forever、PM2等工具实时监控node进程和集群，并能保证系统进程正常运行及实时故障日志排查。PM2较forever支持更多功能，所以本文也就主要介绍PM2。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二为什么选择pm2&quot;&gt;二、为什么选择PM2&lt;/h2&gt;

&lt;h3 id=&quot;pm2的主要特性有&quot;&gt;PM2的主要特性有：&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;内建负载均衡&lt;/li&gt;
  &lt;li&gt;后台运行&lt;/li&gt;
  &lt;li&gt;0秒停机重载，能够保证服务进程时刻运行&lt;/li&gt;
  &lt;li&gt;支持自定义启动脚本&lt;/li&gt;
  &lt;li&gt;自动停止不稳定的进程&lt;/li&gt;
  &lt;li&gt;控制台检测&lt;/li&gt;
  &lt;li&gt;提供 HTTP API&lt;/li&gt;
  &lt;li&gt;支持第三方扩展监控&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三pm2安装及使用&quot;&gt;三、PM2安装及使用&lt;/h2&gt;

&lt;h3 id=&quot;pm2安装&quot;&gt;PM2安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	npm install pm2 -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;pm2-常用命令&quot;&gt;PM2 常用命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;General&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 start app.js              # Start, Daemonize and auto-restart application (Node)
  $ pm2 start app.py              # Start, Daemonize and auto-restart application (Python)
  $ pm2 start npm -- start        # Start, Daemonize and auto-restart Node application
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cluster Mode (Node.js only)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 start app.js -i 4         # Start 4 instances of application in cluster mode
                                  # it will load balance network queries to each app
  $ pm2 reload all                # Zero Second Downtime Reload
  $ pm2 scale [app-name] 10       # Scale Cluster app to 10 process
	 
  # Process Monitoring
  $ pm2 list                      # List all processes started with PM2
  $ pm2 monit                     # Display memory and cpu usage of each app
  $ pm2 show [app-name]           # Show all informations about application
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Log management&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 logs                      # Display logs of all apps
  $ pm2 logs [app-name]           # Display logs for a specific app
  $ pm2 logs --json               # Logs in JSON format
  $ pm2 flush
  $ pm2 reloadLogs
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Process State Management&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 start app.js --name=&quot;api&quot; # Start application and name it &quot;api&quot;
  $ pm2 start app.js -- -a 34     # Start app and pass option &quot;-a 34&quot; as argument
  $ pm2 start app.js --watch      # Restart application on file change
  $ pm2 start script.sh           # Start bash script
  $ pm2 start app.json            # Start all applications declared in app.json
  $ pm2 reset [app-name]          # Reset all counters
  $ pm2 stop all                  # Stop all apps
  $ pm2 stop 0                    # Stop process with id 0
  $ pm2 restart all               # Restart all apps
  $ pm2 gracefulReload all        # Graceful reload all apps in cluster mode
  $ pm2 delete all                # Kill and delete all apps
  $ pm2 delete 0                  # Delete app with id 0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Startup/Boot management&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 startup                   # Detect init system, generate and configure pm2 boot on startup
  $ pm2 save                      # Save current process list
  $ pm2 resurrect                 # Restore previously save processes
  $ pm2 unstartup                 # Disable and remove startup system
	 
  $ pm2 update                    # Save processes, kill PM2 and restore processes
  $ pm2 generate                  # Generate a sample json configuration file
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Deployment&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 deploy app.json prod setup    # Setup &quot;prod&quot; remote server
  $ pm2 deploy app.json prod          # Update &quot;prod&quot; remote server
  $ pm2 deploy app.json prod revert 2 # Revert &quot;prod&quot; remote server by 2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Module system&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ pm2 module:generate [name]    # Generate sample module with name [name]
  $ pm2 install pm2-logrotate     # Install module (here a log rotation system)
  $ pm2 uninstall pm2-logrotate   # Uninstall module
  $ pm2 publish                   # Increment version, git push and npm publish	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四pangu-web部署例子&quot;&gt;四、pangu-web部署例子&lt;/h2&gt;

&lt;h3 id=&quot;shell方式启动这里只是简单例子实际可以改造成node-集群方式&quot;&gt;shell方式启动（这里只是简单例子，实际可以改造成node 集群方式）&lt;/h3&gt;

&lt;p&gt;1 新建startWeb.sh:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;
	node web_server.js --host 127.0.0.1 -xx 27017 -oo 27017 --noauth --port 5000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2 启动web进程 pm2 start startWeb.sh&lt;/p&gt;

&lt;p&gt;3 查看pm2列表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/pm2-list.png&quot; alt=&quot;pm2-list&quot; /&gt;&lt;/p&gt;

&lt;p&gt;4 PM2监控进程cpu、内存&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/pm2-monit.png&quot; alt=&quot;pm2-monit&quot; /&gt;&lt;/p&gt;

&lt;p&gt;5 PM2 http api&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/pm2-api.png&quot; alt=&quot;pm2-api&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;五pm2-扩展应用&quot;&gt;五、PM2 扩展应用&lt;/h2&gt;

&lt;h3 id=&quot;使用keymetrics实时监控nodejs程序&quot;&gt;使用keymetrics实时监控Node.js程序&lt;/h3&gt;

&lt;p&gt;PM2配合keymetrics能实时监控node.js程序的运行，达到监控node.js程序的目的，以下为PM2官网监控截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/pm2-Keymetrics.png&quot; alt=&quot;pm2-Keymetrics&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;pm25-开源node服务监控平台&quot;&gt;PM25 开源node服务监控平台&lt;/h3&gt;

&lt;p&gt;由于Keymetrics是一款商业服务且价格不菲，虽有两台服务器的免费配额但对于有着众多服务器的团队或者公司来说运用免费的显然不够。而且大多数公司也不想将自己的数据存放在第三方平台，这时Keymetrics监控就不太适合了。&lt;/p&gt;

&lt;p&gt;PM25是美团开源的基于PM2开发的一款node服务监控平台，其支持的功能有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持用户的管理（登录作为中间件）&lt;/li&gt;
  &lt;li&gt;被监控机器的分桶管理&lt;/li&gt;
  &lt;li&gt;机器列表、快速过滤和主机的指标信息（进程数、CPU数、负载、上线时长、内存占用）&lt;/li&gt;
  &lt;li&gt;进程的详细指标信息（PID、进程名、重启次数、上线时长、状态、CPU占用、内存占用、错误日志）&lt;/li&gt;
  &lt;li&gt;同Falcon整合，支持监控报警管理（核心指标同步Falcon，可以查看历史图表或者配置监控报警）&lt;/li&gt;
  &lt;li&gt;支持扩展包，引入扩展包后可以收集统计服务端慢路由信息&lt;/li&gt;
  &lt;li&gt;支持进程的远程控制，可以在云端对进程进行远程操作（比如重启、重载）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于PM25的详细信息可查看：https://github.com/PaulGuo/PM25&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>测试框架 Mocha入门</title>
   <link href="http://www.blogways.net/blog/2016/12/18/mocha-introduction.html"/>
   <updated>2016-12-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/18/mocha-introduction</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link1&quot;&gt;Mocha测试框架简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link2&quot;&gt;安装Mocha&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;测试脚本的写法&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;测试脚本的写法&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;心得体会&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一mocha测试框架简介&quot;&gt;一.Mocha测试框架简介&lt;/h2&gt;

&lt;p&gt;Mocha是一款功能丰富的javascript单元测试框架，它既可以运行在nodejs环境中，也可以运行在浏览器环境中。&lt;/p&gt;

&lt;p&gt;javascript是一门单线程语言，最显著的特点就是有很多异步执行。同步代码的测试比较简单，直接判断函数的返回值是否符合预期就行了，而异步的函数，就需要测试框架支持回调、promise或其他的方式来判断测试结果的正确性了。mocha可以良好的支持javascript异步的单元测试。&lt;/p&gt;

&lt;p&gt;mocha会串行地执行我们编写的测试用例，可以在将未捕获异常指向对应用例的同时，保证输出灵活准确的测试结果报告。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二mocha测试框架安装&quot;&gt;二.Mocha测试框架安装&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;安装nodejs&lt;/li&gt;
  &lt;li&gt;npm install –global mocha&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;link3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三mocha测试脚本的写法&quot;&gt;三.Mocha测试脚本的写法&lt;/h2&gt;

&lt;p&gt;Mocha的作用是运行测试脚本，首先必须学会写测试脚本。所谓”测试脚本”，就是用来测试源码的脚本。&lt;/p&gt;

&lt;p&gt;下面是一个加载模块add.js的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function add(x, y) {
  return x + y;
}

module.exports = add;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要测试这个加法模块是否正确，就要写测试脚本。&lt;/p&gt;

&lt;p&gt;通常，测试脚本与所要测试的源码脚本同名，但是后缀名为.test.js（表示测试）或者.spec.js（表示规格）。比如，add.js的测试脚本名字就是add.test.js。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var add = require('./add.js');
var expect = require('chai').expect;

describe('加法函数的测试', function() {
  it('1 加 1 应该等于 2', function() {
    expect(add(1, 1)).to.be.equal(2);
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面这段代码，就是测试脚本，它可以独立执行。测试脚本里面应该包括一个或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;describe&lt;/code&gt;块，每个describe块应该包括一个或多个it块。
describe块称为”测试套件”（test suite），表示一组相关的测试。它是一个函数，第一个参数是测试套件的名称（”加法函数的测试”），第二个参数是一个实际执行的函数。&lt;/p&gt;

&lt;p&gt;it块称为”测试用例”（test case），表示一个单独的测试，是测试的最小单位。它也是一个函数，第一个参数是测试用例的名称（”1 加 1 应该等于 2”），第二个参数是一个实际执行的函数。&lt;/p&gt;

&lt;p&gt;写完测试脚本后，使用Mocha来测试它。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mocha add.test.js

  加法函数的测试
    ✓ 1 加 1 应该等于 2

  1 passing (9ms)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的运行结果表示，测试脚本通过了测试，一共只有1个测试用例，耗时是9毫秒。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四mocha命令参数&quot;&gt;四.mocha命令参数&lt;/h2&gt;

&lt;p&gt;mocha支持任何可以抛出一个错误的断言模块。例如：should.js、better-assert、expect.js、unexpected、chai等。这些断言库各有各的特点，大家可以了解一下它们的特点，根据使用场景来选择断言库。&lt;/p&gt;

&lt;p&gt;mocha命令的基本格式是：mocha [debug] [options] [files]
options包括下面这些，我翻译了一部分目前能理解的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; -h, --help                              输出帮助信息    
 -V, --version                           输出mucha版本    
 -A, --async-only                        强制让所有测试用例必须使用callback或者返回promise的方式来异步判断正确性    
 -c, --colors                            启用报告中颜色    
 -C, --no-colors                         禁用报告中颜色    
 -G, --growl                             enable growl notification support    
 -O, --reporter-options &amp;lt;k=v,k2=v2,...&amp;gt;  reporter-specific options    
 -R, --reporter &amp;lt;name&amp;gt;                   specify the reporter to use    
 -S, --sort                              排序测试文件    
 -b, --bail                              bail after first test failure    
 -d, --debug                             enable node's debugger, synonym for node --debug
 -g, --grep &amp;lt;pattern&amp;gt;                    只执行满足 &amp;lt;pattern&amp;gt;格式的用例    
 -f, --fgrep &amp;lt;string&amp;gt;                    只执行含有 &amp;lt;string&amp;gt; 的用例    
 -gc, --expose-gc                        展示gc回收的log    
 -i, --invert                            让 --grep 和 --fgrep 的匹配取反    
 -r, --require &amp;lt;name&amp;gt;                    require一下&amp;lt;name&amp;gt;指定的模块    
 -s, --slow &amp;lt;ms&amp;gt;                         指定slow时间（单位ms，默认75ms）    
 -t, --timeout &amp;lt;ms&amp;gt;                      指定超时时间（单位ms，默认2000ms）    
 -u, --ui &amp;lt;name&amp;gt;                         指定user-interface (bdd|tdd|exports)    
 -w, --watch                             观察用例文件变化，并重新执行    
 --check-leaks                           检测未回收global变量泄露    
 --compilers &amp;lt;ext&amp;gt;:&amp;lt;module&amp;gt;,...          用指定的模块来编译文件    
 --debug-brk                             启用node的debug模式    
 --delay                                 等待异步的用例集（见前边的）    
 --es_staging                            enable all staged features    
 --full-trace                            display the full stack trace    
 --globals &amp;lt;names&amp;gt;                       allow the given comma-delimited global [names]    
 --harmony                               enable all harmony features (except typeof)    
 --harmony-collections                   enable harmony collections (sets, maps, and weak maps)    
 --harmony-generators                    enable harmony generators    
 --harmony-proxies                       enable harmony proxies    
 --harmony_arrow_functions               enable &quot;harmony arrow functions&quot; (iojs)    
 --harmony_classes                       enable &quot;harmony classes&quot; (iojs)    
 --harmony_proxies                       enable &quot;harmony proxies&quot; (iojs)    
 --harmony_shipping                      enable all shipped harmony features (iojs)    
 --inline-diffs                          显示预期和实际结果的string差异比较    
 --interfaces                            display available interfaces    
 --no-deprecation                        silence deprecation warnings    
 --no-exit                               require a clean shutdown of the event loop: mocha will not call process.exit    
 --no-timeouts                           禁用timeout，可通过--debug隐式指定    
 --opts &amp;lt;path&amp;gt;                           定义option文件路径    
 --prof                                  显示统计信息    
 --recursive                             包含子目录    
 --reporters                             展示可用报告    
 --retries                               设置失败用例重试次数    
 --throw-deprecation                     每次调用deprecated函数的时候都抛出一个异常    
 --trace                                 显示函数调用栈    
 --trace-deprecation                     启用的时候显示调用栈    
 --watch-extensions &amp;lt;ext&amp;gt;,...            --watch监控的扩展    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是官方文档对部分命令的详细说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-W, –WATCH&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用例一旦更新立即执行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;–COMPILERS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如–compilers coffee:coffee-script编译CoffeeScript 1.6，或者–compilers coffee:coffee-script/register编译CoffeeScript 1.7+&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-B, –BAIL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如果只对第一个抛出的异常感兴趣，可以使用此命令。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-D, –DEBUG&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开启nodejs的debug模式，可以在debugger语句处暂停执行。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;–GLOBALS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;names是一个以逗号分隔的列表，如果你的模块需要暴露出一些全局的变量，可以使用此命令，例如mocha –globals app,YUI。
这个命令还可以接受通配符，例如–globals ‘*bar。参数传入 * 的话，会忽略所有全局变量。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;–CHECK-LEAKS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下，mocha并不会去检查应用暴露出来的全局变量，加上这个配置后就会去检查，此时某全局变量如果没有用上面的–GLOBALS去配置为可接受，mocha就会报错&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-R, –REQUIRE&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个命令可以用来引入一些依赖的模块，比如should.js等，这个命令相当于在测试目录下每个js文件头部运行一下require(‘should.js’),模块中对Object、Array等对象的扩展会生效，也可以用–require ./test/helper.js这样的命令去引入指定的本地模块。
但是… 很鸡肋的是，如果要引用模块导出的对象，还是需要require，var should = require(‘should’)这样搞。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-U, –UI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;–ui选项可以用来指定所使用的测试接口，默认是“bdd”&lt;/p&gt;

&lt;p&gt;-R, –REPORTER&lt;/p&gt;

&lt;p&gt;这个命令可以用来指定报告格式，默认是“spec”。可以使用第三方的报告样式，例如：
npm install mocha-lcov-reporter,–reporter mocha-lcov-reporter&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-T, –TIMEOUT&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来指定用例超时时间&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-S, –SLOW&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;用来指定慢用例判定时间，默认是75ms&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-G, –GREP&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;grep pattern可以用来筛选要执行的用例或用例集，pattern参数在mocha内部会被编译成一个正则表达式。
假如有下面的测试用例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;describe('api', function() {
  describe('GET /api/users', function() {
    it('respond with an array of users', function() {
      // ...
    });
  });
});

describe('app', function() {
  describe('GET /users', function() {
    it('respond with an array of users', function() {
      // ...
    });
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以用–grep api、–grep app、–grep users、–grep GET，来筛选出要执行的用例。&lt;/p&gt;

&lt;h2 id=&quot;五心得与体会&quot;&gt;五.心得与体会&lt;/h2&gt;

&lt;p&gt;接触Mocha是在上年实习的时候，感觉这个针对nodejs下的单元测试还是很好用的，但是用好Mocha要对断言库有一定的了解，断言接触不多，以后还会继续分析Mocha的一些比较好的测试案例。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>canvas学习[3]--文本和图片</title>
   <link href="http://www.blogways.net/blog/2016/12/18/canvas-3.html"/>
   <updated>2016-12-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/18/canvas-3</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part1&quot;&gt;文本 Text&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part2&quot;&gt;图像 Images&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;part1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-文本-text&quot;&gt;1. 文本 Text&lt;/h2&gt;

&lt;h3 id=&quot;11-绘制文本&quot;&gt;1.1 绘制文本&lt;/h3&gt;

&lt;p&gt;canvas 提供了两种方法来渲染文本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;fillText(text, x, y [, maxWidth])&lt;/p&gt;

    &lt;p&gt;在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;strokeText(text, x, y [, maxWidth])&lt;/p&gt;

    &lt;p&gt;在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面是绘制文本和文本边框的示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw1() {
	var ctx = document.getElementById('cvs1').getContext('2d');
	ctx.font = &quot;48px serif&quot;;
	ctx.fillText(&quot;Blog Ways&quot;, 10, 50);
	ctx.font = &quot;48px serif&quot;;
	ctx.strokeText(&quot;Blog Ways&quot;, 10, 100);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;font&lt;/code&gt;用于指定文本的大小和字体，具体效果如下：&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;
	&lt;canvas id=&quot;cvs1&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;script&gt;
	function draw1() {
		var ctx = document.getElementById('cvs1').getContext('2d');
		ctx.font = &quot;48px serif&quot;;
		ctx.fillText(&quot;Blog Ways&quot;, 10, 50);
		ctx.font = &quot;48px serif&quot;;
  		ctx.strokeText(&quot;Blog Ways&quot;, 10, 100);
	}
	draw1();
&lt;/script&gt;

&lt;h3 id=&quot;12-文本样式&quot;&gt;1.2 文本样式&lt;/h3&gt;

&lt;p&gt;在上面的例子使用了 font 来改变文本的大小和字体，除此外还有更多属性可以改变canvas显示文本的方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;font = value&lt;/p&gt;

    &lt;p&gt;当前用来绘制文本的样式，value的使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;textAlign = value&lt;/p&gt;

    &lt;p&gt;文本对齐选项. 可选项包括：start, end, left, right 或者 center. 默认值是 start。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;textBaseline = value&lt;/p&gt;

    &lt;p&gt;基线对齐选项. 可选项包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;direction = value&lt;/p&gt;

    &lt;p&gt;文本方向。可选项包括：ltr, rtl, inherit。默认值是 inherit。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以在下面例子的textarea中编辑尝试不同选项的效果。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;textBaseLine 可选值 top, hanging, middle, alphabetic, ideographic, bottom;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;direction 可选值 ltr, rtl, inherit;&lt;/code&gt;&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;canvas id=&quot;cvs2&quot; width=&quot;800px&quot;&gt;&lt;/canvas&gt;

&lt;textarea id=&quot;area1&quot; style=&quot;width:80%; height: 150px; font: 16px serif&quot;&gt;
ctx.font = &quot;48px serif&quot;;
ctx.textAlign = &quot;start&quot;;
ctx.textBaseline = &quot;hanging&quot;;
ctx.direction = &quot;inherit&quot;;
&lt;/textarea&gt;

&lt;/div&gt;

&lt;script&gt;
var area1 = document.getElementById('area1');
function draw2() {
  var ctx = document.getElementById('cvs2').getContext('2d');
  var option = document.getElementById('area1').value;
  ctx.clearRect(0, 0, 800, 200);
  eval(option);
  ctx.fillText(&quot;Blog Way&quot;, 200, 50);
}
area1.oninput = draw2;
area1.onpropertychange = draw2;
draw2();
&lt;/script&gt;

&lt;p&gt;&lt;a id=&quot;part2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-图像-images&quot;&gt;2. 图像 Images&lt;/h2&gt;

&lt;p&gt;canvas 对图像的处理功能可以用于动态的图片合成或者作背景，以及用于游戏界面（Sprites）等等。浏览器支持的任意格式的外部图片都可以使用，比如PNG、GIF或者JPEG，也可以将同一个页面中其他canvas元素生成的图片作为图片源。&lt;/p&gt;

&lt;p&gt;引入图像到canvas里需要以下两步基本操作：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;获得一个指向HTMLImageElement的对象或者另一个canvas元素的引用作为源，也可以通过提供一个URL的方式来使用图片；&lt;/li&gt;
  &lt;li&gt;使用drawImage()函数将图片绘制到画布上。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;21-图像获取方式&quot;&gt;2.1 图像获取方式&lt;/h3&gt;

&lt;p&gt;canvas可以使用下面的方法来获取图片：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;HTMLImageElement&lt;/p&gt;

    &lt;p&gt;这些图片是由Image()函数构造出来的，或者任何的img元素；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTMLVideoElement&lt;/p&gt;

    &lt;p&gt;选择一个HTML的video元素作为图片源，此方法可以从视频中抓取当前帧作为一个图像；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTMLCanvasElement&lt;/p&gt;

    &lt;p&gt;使用同一页面中的canvas元素作为你的图片源。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面来分别介绍。&lt;/p&gt;

&lt;h3 id=&quot;22-绘制图像&quot;&gt;2.2 绘制图像&lt;/h3&gt;

&lt;p&gt;使用脚本创建一个新的 HTMLImageElement 对象，设置图片路径。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;
var img = new Image();   // 创建一个&amp;lt;img&amp;gt;元素
img.src = '/images/wanghui/canvas3/img.jpg'; // 设置图片源地址
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;当脚本执行后，图片开始加载。&lt;/p&gt;

&lt;p&gt;若调用drawImage()的时候图片还没加载完，那么将不会生成图片（在一些旧的浏览器中可能会抛出异常）。因此应该用load事件来保证图片加载完毕。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var img = new Image();   // 创建img元素
img.onload = function(){
  // 执行drawImage语句
}
img.src = 'myImage.png'; // 设置图片源地址
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;出了使用路径加载外，还可以通过 data:url 的方式来引用图像。Data urls 允许用一串 Base64 编码的字符串的方式来定义一个图片，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;img.src = 'data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式的优点是图片内容即时可用，无须再到服务器兜一圈。（还有一个优点是，可以将 CSS，JavaScript，HTML 和 图片全部封装在一起，迁移起来十分方便。）缺点就是图像没法缓存，图片大的话内嵌的 url 数据会相当的长。&lt;/p&gt;

&lt;p&gt;下面来看看具体的绘制示例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw4() {
	   var ctx = document.getElementById('cvs4').getContext('2d');
	   var img = new Image();
	   img.onload = function() {
	     ctx.drawImage(img, 0, 0);
	   };
	   img.src = '/images/wanghui/canvas3/img1.png';
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是基本的加载并绘制图片的方式，通过监听load事件确保图片加载完毕。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;canvas id=&quot;cvs4&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt;

&lt;/div&gt;

&lt;script&gt;
	function draw4() {
	   var ctx = document.getElementById('cvs4').getContext('2d');
	   var img = new Image();
	   img.onload = function() {
	     ctx.drawImage(img, 0, 0);
	   };
	   img.src = '/images/wanghui/canvas3/img1.png';
	}
	draw4();
&lt;/script&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw5() {
	   var ctx = document.getElementById('cvs5').getContext('2d');
	   var img = new Image();
	   img.onload = function() {
	      for (var i=0;i&amp;lt;3;i++){
            for (var j=0;j&amp;lt;3;j++){
              ctx.drawImage(img,j*50,i*50,50,38);
            }
          }
	   };
	   img.src = '/images/wanghui/canvas3/img1.png';
	}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本例使用了drawImage方法的一种重载，增加了两个用于控制图像在canvas中缩放的参数。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;drawImage(image, x, y, width, height)&lt;/p&gt;

    &lt;p&gt;这个方法多了2个参数：width 和 height，这两个参数用来控制 当像canvas画入时应该缩放的大小。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用此方式可以实现图像的平铺，具体示例如下：&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;canvas id=&quot;cvs5&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt;

&lt;/div&gt;

&lt;script&gt;
	function draw5() {
	   var ctx = document.getElementById('cvs5').getContext('2d');
	   var img = new Image();
	   img.onload = function() {
	      for (var i=0;i&lt;3;i++){
            for (var j=0;j&lt;3;j++){
              ctx.drawImage(img,j*50,i*50,50,38);
            }
          }
	   };
	   img.src = '/images/wanghui/canvas3/img1.png';
	}
	draw5();
&lt;/script&gt;

&lt;p&gt;drawImage 方法的另一个重载，也是最后一个变种，共有8个参数，用于控制做切片显示。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)&lt;/p&gt;

    &lt;p&gt;第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw67() {
   var ctx6 = document.getElementById('cvs6').getContext('2d');
   var ctx7 = document.getElementById('cvs7').getContext('2d');
   var img = new Image();
   img.onload = function() {
     ctx6.drawImage(img, 0, 0);
     ctx7.drawImage(img, 55,65, 85,85, 10,45, 100,100);
   };
   img.src = '/images/wanghui/canvas3/img1.png';
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以对比两张图片来看，8个参数中：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sx - 定义切片的x坐标；&lt;/li&gt;
  &lt;li&gt;sy - 定义切片的y坐标；&lt;/li&gt;
  &lt;li&gt;sWidth - 定义切片的长度；&lt;/li&gt;
  &lt;li&gt;sHeight - 定义切片的高度；&lt;/li&gt;
  &lt;li&gt;dx - 定义切片生成后，位于canvas中的x坐标位置；&lt;/li&gt;
  &lt;li&gt;dy - 定义切片生成后，位于canvas中的y坐标位置；&lt;/li&gt;
  &lt;li&gt;dWidth - 定义切片后生成图片的长度；&lt;/li&gt;
  &lt;li&gt;dHeight - 定义切片后生成图片的高度。&lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;canvas id=&quot;cvs6&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;cvs7&quot; height=&quot;200px&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;script&gt;
	function draw67() {
	   var ctx6 = document.getElementById('cvs6').getContext('2d');
	   var ctx7 = document.getElementById('cvs7').getContext('2d');
	   var img = new Image();
	   img.onload = function() {
	     ctx6.drawImage(img, 0, 0);
        ctx7.drawImage(img, 55,65, 85,85, 10,45, 100,100);
	   };
	   img.src = '/images/wanghui/canvas3/img1.png';
	}
	draw67();
&lt;/script&gt;

&lt;p&gt;除了引用图片，还可以引用 video中的视频帧。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw3() {
  		 var ctx = document.getElementById('cvs3').getContext('2d');
  		 var video = document.getElementById('v1');
  		 video.addEventListener(&quot;timeupdate&quot;, function(){
		    ctx.drawImage(video, 0, 0);
		 }, true);
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码监听了视频的timeudate事件，并在canvas里实时绘制视频图像。第一个是video元素加载的视频，第二个是canvas实时绘制的内容。&lt;/p&gt;

&lt;div style=&quot;text-align: center;&quot;&gt;

&lt;video id=&quot;v1&quot; src=&quot;/images/wanghui/canvas3/video1.mp4&quot; controls=&quot;controls&quot;&gt;&lt;/video&gt;

&lt;canvas id=&quot;cvs3&quot; width=&quot;568px&quot; height=&quot;320px&quot;&gt;&lt;/canvas&gt;

&lt;/div&gt;

&lt;script&gt;
	function draw3() {
  		 var ctx = document.getElementById('cvs3').getContext('2d');
  		 var video = document.getElementById('v1');
  		 video.addEventListener(&quot;timeupdate&quot;, function(){
		    ctx.drawImage(video, 0, 0);
		 }, true);
	}
	draw3();
&lt;/script&gt;

&lt;p&gt;文本与图像的内容就介绍到这里，下一篇将介绍变形、合成与裁剪。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>canvas学习[2]--样式与颜色</title>
   <link href="http://www.blogways.net/blog/2016/12/18/canvas-2.html"/>
   <updated>2016-12-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/18/canvas-2</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part1&quot;&gt;色彩 Color&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part2&quot;&gt;透明度 Transparency&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part3&quot;&gt;线型 Line styles&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part4&quot;&gt;渐变 Gradients&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;part1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-色彩-color&quot;&gt;1. 色彩 Color&lt;/h2&gt;

&lt;p&gt;如果想要给图形上色，有两个重要的属性可以做到：fillStyle 和 strokeStyle。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;fillStyle = color&lt;/p&gt;

    &lt;p&gt;设置图形的填充颜色。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;strokeStyle = color&lt;/p&gt;

    &lt;p&gt;设置图形轮廓的颜色。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;color 可以是表示 CSS 颜色值的字符串，渐变对象或者图案对象。默认情况下，线条和填充颜色都是黑色（CSS 颜色值 #000000）。&lt;/p&gt;

&lt;p&gt;一旦设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果要给每个图形上不同的颜色，需要重新设置 fillStyle 或 strokeStyle 的值。&lt;/p&gt;

&lt;p&gt;canvas接受所有符合 CSS3 颜色值标准 的有效字符串。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 以下 fillStyle 的值均为 '橙色'
ctx.fillStyle = &quot;orange&quot;;
ctx.fillStyle = &quot;#FFA500&quot;;
ctx.fillStyle = &quot;rgb(255,165,0)&quot;;
ctx.fillStyle = &quot;rgba(255,165,0,1)&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面来看一个fillStyle的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw() {
  var ctx = document.getElementById('canvas').getContext('2d');
  for (var i=0;i&amp;lt;6;i++){
    for (var j=0;j&amp;lt;6;j++){
      ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' + 
                       Math.floor(255-42.5*j) + ',0)';
      ctx.fillRect(j*25,i*25,25,25);
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在本示例里使用了两层 for 循环来绘制方格阵列，每个方格不同的颜色，结果如下图所示。&lt;/p&gt;

&lt;p&gt;代码中使用了两个变量 i 和 j 来为每一个方格产生唯一的 RGB 色彩值，其中仅修改红色和绿色通道的值，而保持蓝色通道的值不变。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs1&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw1() {
  var ctx = document.getElementById('cvs1').getContext('2d');
  for (var i=0;i&lt;6;i++){
    for (var j=0;j&lt;6;j++){
      ctx.fillStyle = 'rgb(' + Math.floor(255-42.5*i) + ',' + 
                       Math.floor(255-42.5*j) + ',0)';
      ctx.fillRect(j*25,i*25,25,25);
    }
  }
}
draw1()
&lt;/script&gt;

&lt;p&gt;了解了fillStyle后，下面来看看strokeStyle。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw2() {
  var ctx = document.getElementById('cvs2').getContext('2d');
  for (var i=0;i&amp;lt;6;i++){
      for (var j=0;j&amp;lt;6;j++){
        ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + 
                         Math.floor(255-42.5*j) + ')';
        ctx.beginPath();
        ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true);
        ctx.stroke();
      }
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与上一个例子类似，只不过本例中使用的是 strokeStyle 属性，保持不变的是红色通道值，画的不是方格，而是用 arc 方法来画圆。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs2&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw2() {
  var ctx = document.getElementById('cvs2').getContext('2d');
  for (var i=0;i&lt;6;i++){
      for (var j=0;j&lt;6;j++){
        ctx.strokeStyle = 'rgb(0,' + Math.floor(255-42.5*i) + ',' + 
                         Math.floor(255-42.5*j) + ')';
        ctx.beginPath();
        ctx.arc(12.5+j*25,12.5+i*25,10,0,Math.PI*2,true);
        ctx.stroke();
      }
  }
}
draw2()
&lt;/script&gt;

&lt;p&gt;&lt;a id=&quot;part2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-透明度-transparency&quot;&gt;2. 透明度 Transparency&lt;/h2&gt;

&lt;p&gt;除了可以绘制实色图形，还可以用 canvas 来绘制半透明的图形。通过设置 globalAlpha 属性或者使用一个半透明颜色作为轮廓或填充的样式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;globalAlpha = transparencyValue&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。&lt;/p&gt;

&lt;p&gt;globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。在绘制透明度比较多变的图形时，下面的方法可操作性更强一点。&lt;/p&gt;

&lt;p&gt;因为 strokeStyle 和 fillStyle 属性接受符合 CSS 3 规范的颜色值，那我们可以用下面的写法来设置具有透明度的颜色。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 指定透明颜色，用于描边和填充样式
ctx.strokeStyle = &quot;rgba(255,0,0,0.5)&quot;;
ctx.fillStyle = &quot;rgba(255,0,0,0.5)&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;rgba() 方法与 rgb() 方法类似，就多了一个用于设置色彩透明度的参数。它的有效范围是从 0.0（完全透明）到 1.0（完全不透明）。&lt;/p&gt;

&lt;p&gt;下面来分别看看两种方式的示例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw3() {
  var ctx = document.getElementById('cvs3').getContext('2d');
  ctx.fillStyle = '#FD0';
  ctx.fillRect(0,0,75,75);
  ctx.fillStyle = '#6C0';
  ctx.fillRect(75,0,75,75);
  ctx.fillStyle = '#09F';
  ctx.fillRect(0,75,75,75);
  ctx.fillStyle = '#F30';
  ctx.fillRect(75,75,75,75);
  ctx.fillStyle = '#FFF';

  // 设置透明度值
  ctx.globalAlpha = 0.2;

  // 画半透明圆
  for (var i=0;i&amp;lt;7;i++){
      ctx.beginPath();
      ctx.arc(75,75,10+10*i,0,Math.PI*2,true);
      ctx.fill();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;先来看看globalAlpha。&lt;/p&gt;

&lt;p&gt;在本例中，将用四色格作为背景，设置 globalAlpha 为 0.2 后，在上面画一系列半径递增的半透明圆。最终结果是一个径向渐变效果。圆叠加得越更多，原先所画的圆的透明度会越低。通过增加循环次数，画更多的圆，背景图的中心部分会完全消失。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs3&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw3() {
  var ctx = document.getElementById('cvs3').getContext('2d');
  ctx.fillStyle = '#FD0';
  ctx.fillRect(0,0,75,75);
  ctx.fillStyle = '#6C0';
  ctx.fillRect(75,0,75,75);
  ctx.fillStyle = '#09F';
  ctx.fillRect(0,75,75,75);
  ctx.fillStyle = '#F30';
  ctx.fillRect(75,75,75,75);
  ctx.fillStyle = '#FFF';

  // 设置透明度值
  ctx.globalAlpha = 0.2;

  // 画半透明圆
  for (var i=0;i&lt;7;i++){
      ctx.beginPath();
      ctx.arc(75,75,10+10*i,0,Math.PI*2,true);
      ctx.fill();
  }
}
draw3()
&lt;/script&gt;

&lt;p&gt;下面是rgba()的示例。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw4() {
  var ctx = document.getElementById('cvs4').getContext('2d');
  ctx.fillStyle = 'rgb(255,221,0)';
  ctx.fillRect(0,0,150,37.5);
  ctx.fillStyle = 'rgb(102,204,0)';
  ctx.fillRect(0,37.5,150,37.5);
  ctx.fillStyle = 'rgb(0,153,255)';
  ctx.fillRect(0,75,150,37.5);
  ctx.fillStyle = 'rgb(255,51,0)';
  ctx.fillRect(0,112.5,150,37.5);

  // 画半透明矩形
  for (var i=0;i&amp;lt;10;i++){
    ctx.fillStyle = 'rgba(255,255,255,'+(i+1)/10+')';
    for (var j=0;j&amp;lt;4;j++){
      ctx.fillRect(5+i*14,5+j*37.5,14,27.5)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与前一个例子类似，不过不是画圆，而是画矩形。这里还可以看出，rgba() 可以分别设置轮廓和填充样式，因而具有更好的可操作性和使用灵活性。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs4&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw4() {
  var ctx = document.getElementById('cvs4').getContext('2d');
  ctx.fillStyle = 'rgb(255,221,0)';
  ctx.fillRect(0,0,150,37.5);
  ctx.fillStyle = 'rgb(102,204,0)';
  ctx.fillRect(0,37.5,150,37.5);
  ctx.fillStyle = 'rgb(0,153,255)';
  ctx.fillRect(0,75,150,37.5);
  ctx.fillStyle = 'rgb(255,51,0)';
  ctx.fillRect(0,112.5,150,37.5);

  // 画半透明矩形
  for (var i=0;i&lt;10;i++){
    ctx.fillStyle = 'rgba(255,255,255,'+(i+1)/10+')';
    for (var j=0;j&lt;4;j++){
      ctx.fillRect(5+i*14,5+j*37.5,14,27.5)
    }
  }
}
draw4()
&lt;/script&gt;

&lt;p&gt;&lt;a id=&quot;part3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-线型-line-styles&quot;&gt;3. 线型 Line styles&lt;/h2&gt;

&lt;p&gt;上一篇博文中的线条十分单调，这里将介绍一系列属性用于修饰线条的样式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;lineWidth = value&lt;/p&gt;

    &lt;p&gt;设置线条宽度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lineCap = type&lt;/p&gt;

    &lt;p&gt;设置线条末端样式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lineJoin = type&lt;/p&gt;

    &lt;p&gt;设定线条与线条间接合处的样式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;getLineDash()
  返回一个包含当前虚线样式，长度为非负偶数的数组。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;setLineDash(segments)&lt;/p&gt;

    &lt;p&gt;设置当前虚线样式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lineDashOffset = value&lt;/p&gt;

    &lt;p&gt;设置虚线样式的起始偏移量。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面来分别看看各属性的例子，首先是lineWidth。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw5() {
  var ctx = document.getElementById('cvs5').getContext('2d');
  for (var i = 0; i &amp;lt; 10; i++){
    ctx.lineWidth = 1+i;
    ctx.beginPath();
    ctx.moveTo(5+i*14,5);
    ctx.lineTo(5+i*14,140);
    ctx.stroke();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;lineWidth属性设置当前绘线的粗细。属性值必须为正数。默认值是1.0。&lt;/p&gt;

&lt;p&gt;lineWidth是指给定路径的中心到两边的粗细。换句话说就是在路径的两边各绘制线宽的一半。因为画布的坐标并不和像素直接对应，当需要获得精确的水平或垂直线的时候要特别注意。&lt;/p&gt;

&lt;p&gt;本例中使用递增的宽度绘制了10条直线。最左边的线宽1.0单位。&lt;/p&gt;

&lt;p&gt;最左边的以及所有宽度为奇数的线颜色出现偏差，这就是因为路径的定位问题导致。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs5&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw5() {
  var ctx = document.getElementById('cvs5').getContext('2d');
  for (var i = 0; i &lt; 10; i++){
    ctx.lineWidth = 1+i;
    ctx.beginPath();
    ctx.moveTo(5+i*14,5);
    ctx.lineTo(5+i*14,140);
    ctx.stroke();
  }
}
draw5()
&lt;/script&gt;

&lt;p&gt;想要获得精确的线条，就得知道线条是如何描绘出来。&lt;/p&gt;

&lt;p&gt;下图用网格来代表 canvas 的坐标格，每一格对应屏幕上一个像素点。在第一个图中，填充了 (2,1) 至 (5,5) 的矩形，整个区域的边界刚好落在像素边缘上，这样就可以得到的矩形有着清晰的边缘。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/canvas2/img1.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果想要绘制一条从 (3,1) 到 (3,5)，宽度是 1.0 的线条，结果将会是第二幅图。&lt;/p&gt;

&lt;p&gt;实际填充区域（深蓝色部分）仅仅延伸至路径两旁各一半像素。而另外半个像素会以笔触颜色一半的色调进行渲染，于是线条颜色被渲染为浅蓝和深蓝两个部分。这就是上例中为何宽度为 1.0 的线并不准确的原因。&lt;/p&gt;

&lt;p&gt;要解决这个问题，必须对路径施以更加精确的控制。已知粗 1.0 的线条会在路径两边各延伸半像素，那么像第三幅图那样绘制从 (3.5,1) 到 (3.5,5) 的线条，其边缘正好落在像素边界，填充出来就是准确的宽为 1.0 的线条。&lt;/p&gt;

&lt;p&gt;以上是lineWidth，下面来看看lineCap属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw6() {
  var ctx = document.getElementById('cvs6').getContext('2d');
  var lineCap = ['butt','round','square'];
  ctx.strokeStyle = '#09f';
  ctx.beginPath();
  ctx.moveTo(10,10);
  ctx.lineTo(140,10);
  ctx.moveTo(10,140);
  ctx.lineTo(140,140);
  ctx.stroke();

  // 画线条
  ctx.strokeStyle = 'black';
  for (var i=0;i&amp;lt;lineCap.length;i++){
    ctx.lineWidth = 15;
    ctx.lineCap = lineCap[i];
    ctx.beginPath();
    ctx.moveTo(25+i*50,10);
    ctx.lineTo(25+i*50,140);
    ctx.stroke();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;lineCap属性决定了线条端点显示的样子。可选值为：butt，round 和 square。默认是 butt。&lt;/p&gt;

&lt;p&gt;本例中绘制了三条直线，分别赋予不同的 lineCap 值。还有两条辅助线是为了看清它们之间的区别，三条线的起点终点都落在辅助线上。&lt;/p&gt;

&lt;p&gt;最左边的线用了默认的 butt 。可以注意到它是与辅助线齐平的。中间的是 round 的效果，端点处加上了半径为一半线宽的半圆。右边的是 square 的效果，端点处加上了等宽且高度为一半线宽的方块。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs6&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw6() {
  var ctx = document.getElementById('cvs6').getContext('2d');
  var lineCap = ['butt','round','square'];
  ctx.strokeStyle = '#09f';
  ctx.beginPath();
  ctx.moveTo(10,10);
  ctx.lineTo(140,10);
  ctx.moveTo(10,140);
  ctx.lineTo(140,140);
  ctx.stroke();

  // 画线条
  ctx.strokeStyle = 'black';
  for (var i=0;i&lt;lineCap.length;i++){
    ctx.lineWidth = 15;
    ctx.lineCap = lineCap[i];
    ctx.beginPath();
    ctx.moveTo(25+i*50,10);
    ctx.lineTo(25+i*50,140);
    ctx.stroke();
  }
}
draw6()
&lt;/script&gt;

&lt;p&gt;接下来是lineJoin属性。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw7() {
  var ctx = document.getElementById('cvs7').getContext('2d');
  var lineJoin = ['round','bevel','miter'];
  ctx.lineWidth = 10;
  for (var i=0;i&amp;lt;lineJoin.length;i++){
    ctx.lineJoin = lineJoin[i];
    ctx.beginPath();
    ctx.moveTo(-5,5+i*40);
    ctx.lineTo(35,45+i*40);
    ctx.lineTo(75,5+i*40);
    ctx.lineTo(115,45+i*40);
    ctx.lineTo(155,5+i*40);
    ctx.stroke();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;lineJoin的属性决定了图形中两线段连接处所显示的样子。可选值为：round, bevel 和 miter。默认是 miter。&lt;/p&gt;

&lt;p&gt;同样用三条折线来做例子，分别设置不同的 lineJoin 值。最上面一条是 round 的效果，边角处被磨圆了，圆的半径等于线宽。中间和最下面一条分别是 bevel 和 miter 的效果。当值是 miter 的时候，线段会在连接处外侧延伸直至交于一点。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
	&lt;canvas id=&quot;cvs7&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw7() {
  var ctx = document.getElementById('cvs7').getContext('2d');
  var lineJoin = ['round','bevel','miter'];
  ctx.lineWidth = 10;
  for (var i=0;i&lt;lineJoin.length;i++){
    ctx.lineJoin = lineJoin[i];
    ctx.beginPath();
    ctx.moveTo(-5,5+i*40);
    ctx.lineTo(35,45+i*40);
    ctx.lineTo(75,5+i*40);
    ctx.lineTo(115,45+i*40);
    ctx.lineTo(155,5+i*40);
    ctx.stroke();
  }
}
draw7();
&lt;/script&gt;

&lt;p&gt;最后介绍虚线的使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var canvas8 = document.getElementById('cvs8');
var ctx8 = document.getElementById('cvs8').getContext('2d');
var offset = 0;
function draw8() {
  ctx8.clearRect(0,0, canvas8.width, canvas8.height);
  ctx8.setLineDash([4, 2]);
  ctx8.lineDashOffset = -offset;
  ctx8.strokeRect(10,10, 100, 100);
}

function march() {
  offset++;
  if (offset &amp;gt; 16) {
    offset = 0;
  }
  draw8();
  setTimeout(march, 20);
}
march();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式。&lt;/p&gt;

&lt;p&gt;setLineDash 方法接受一个数组，来指定线段与间隙的交替，数组第一个值表示虚线的长度，第二个值表示虚线之前的空隙。&lt;/p&gt;

&lt;p&gt;lineDashOffset 属性设置起始偏移量。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs8&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
var canvas8 = document.getElementById('cvs8');
var ctx8 = document.getElementById('cvs8').getContext('2d');
var offset = 0;
function draw8() {
  ctx8.clearRect(0,0, canvas8.width, canvas8.height);
  ctx8.setLineDash([4, 2]);
  ctx8.lineDashOffset = -offset;
  ctx8.strokeRect(10,10, 100, 100);
}

function march() {
  offset++;
  if (offset &gt; 16) {
    offset = 0;
  }
  draw8();
  setTimeout(march, 20);
}
march();
&lt;/script&gt;

&lt;p&gt;&lt;a id=&quot;part4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-渐变-gradients&quot;&gt;4. 渐变 Gradients&lt;/h2&gt;

&lt;p&gt;与CSS3和SVG一样，canvas也有自己的渐变功能，同样分为 线性渐变 和 径向渐变。&lt;/p&gt;

&lt;p&gt;使用下面的方法可以新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性，从而实现渐变效果。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;createLinearGradient(x1, y1, x2, y2)&lt;/p&gt;

    &lt;p&gt;createLinearGradient 线性渐变方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;createRadialGradient(x1, y1, r1, x2, y2, r2)&lt;/p&gt;

    &lt;p&gt;createRadialGradient 径向渐变方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var lineargradient = ctx.createLinearGradient(0,0,150,150);
var radialgradient = ctx.createRadialGradient(75,75,0,75,75,100);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建出 canvasGradient 对象后，可以用 addColorStop 方法上色。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;gradient.addColorStop(position, color)&lt;/p&gt;

    &lt;p&gt;addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可以根据需要添加任意多个色标（color stops）。下面是最简单的线性黑白渐变的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw9() {
  var ctx = document.getElementById('cvs9').getContext('2d');
  var lineargradient = ctx.createLinearGradient(0,0,130,130);
  lineargradient.addColorStop(0,'white');
  lineargradient.addColorStop(0.5,'grey');
  lineargradient.addColorStop(1,'black');
  
  ctx.fillStyle = lineargradient;
  // draw shapes
  ctx.fillRect(10,10,130,130);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs9&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw9() {
  var ctx = document.getElementById('cvs9').getContext('2d');
  var lineargradient = ctx.createLinearGradient(0,0,130,130);
  lineargradient.addColorStop(0,'white');
  lineargradient.addColorStop(0.5,'grey');
  lineargradient.addColorStop(1,'black');
  
  ctx.fillStyle = lineargradient;
  // draw shapes
  ctx.fillRect(10,10,130,130);
}
draw9();
&lt;/script&gt;

&lt;p&gt;然后来看看径向渐变。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw10() {
  var ctx = document.getElementById('cvs10').getContext('2d');
  var radgrad = ctx.createRadialGradient(45,45,10,52,50,30);
  radgrad.addColorStop(0, '#A7D30C');
  radgrad.addColorStop(0.9, '#019F62');
  radgrad.addColorStop(1, 'rgba(1,159,98,0)');
  
  var radgrad2 = ctx.createRadialGradient(105,105,20,112,120,50);
  radgrad2.addColorStop(0, '#FF5F98');
  radgrad2.addColorStop(0.75, '#FF0188');
  radgrad2.addColorStop(1, 'rgba(255,1,136,0)');

  var radgrad3 = ctx.createRadialGradient(95,15,15,102,20,40);
  radgrad3.addColorStop(0, '#00C9FF');
  radgrad3.addColorStop(0.8, '#00B5E2');
  radgrad3.addColorStop(1, 'rgba(0,201,255,0)');

  var radgrad4 = ctx.createRadialGradient(0,150,50,0,140,90);
  radgrad4.addColorStop(0, '#F4F201');
  radgrad4.addColorStop(0.8, '#E4C700');
  radgrad4.addColorStop(1, 'rgba(228,199,0,0)');
  
  // 画图形
  ctx.fillStyle = radgrad4;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad3;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad2;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad;
  ctx.fillRect(0,0,150,150);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本例定义了4个不同的径向渐变。由于可以控制渐变的起始与结束点，所以可以实现稍微复杂的效果。&lt;/p&gt;

&lt;p&gt;比如这里让起点稍微偏离终点，这样达到了一种球状3D效果，但最好不要让里圆与外圆部分交叠。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs10&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
function draw10() {
  var ctx = document.getElementById('cvs10').getContext('2d');
  var radgrad = ctx.createRadialGradient(45,45,10,52,50,30);
  radgrad.addColorStop(0, '#A7D30C');
  radgrad.addColorStop(0.9, '#019F62');
  radgrad.addColorStop(1, 'rgba(1,159,98,0)');
  
  var radgrad2 = ctx.createRadialGradient(105,105,20,112,120,50);
  radgrad2.addColorStop(0, '#FF5F98');
  radgrad2.addColorStop(0.75, '#FF0188');
  radgrad2.addColorStop(1, 'rgba(255,1,136,0)');

  var radgrad3 = ctx.createRadialGradient(95,15,15,102,20,40);
  radgrad3.addColorStop(0, '#00C9FF');
  radgrad3.addColorStop(0.8, '#00B5E2');
  radgrad3.addColorStop(1, 'rgba(0,201,255,0)');

  var radgrad4 = ctx.createRadialGradient(0,150,50,0,140,90);
  radgrad4.addColorStop(0, '#F4F201');
  radgrad4.addColorStop(0.8, '#E4C700');
  radgrad4.addColorStop(1, 'rgba(228,199,0,0)');
  
  // 画图形
  ctx.fillStyle = radgrad4;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad3;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad2;
  ctx.fillRect(0,0,150,150);
  ctx.fillStyle = radgrad;
  ctx.fillRect(0,0,150,150);
}
draw10();
&lt;/script&gt;

&lt;p&gt;样式的介绍就到这里，下一篇博文将介绍文本的绘制和图片的使用。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>canvas学习[1]--绘制基本图形</title>
   <link href="http://www.blogways.net/blog/2016/12/18/canvas-1.html"/>
   <updated>2016-12-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/18/canvas-1</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part1&quot;&gt;canvas简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part2&quot;&gt;基本用法&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part3&quot;&gt;绘制基本图形&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part4&quot;&gt;组合使用&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;part1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1canvas简介&quot;&gt;1.canvas简介&lt;/h2&gt;

&lt;p&gt;canvas 是 HTML5 新增的元素，与JavaScript结合使用来绘制图形。例如：画图，合成照片，创建动画甚至实时视频处理与渲染。很多js图标插件都是基于canvas来实现的，比如charts.js、echats3。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;canvas 首先是由 Apple 引入的，用于 OS X Dashboard 和 Safari。&lt;/li&gt;
  &lt;li&gt;Mozilla 程序从 Gecko 1.8 (Firefox 1.5) 开始支持 canvas。&lt;/li&gt;
  &lt;li&gt;Internet Explorer 从IE9开始canvas ，更旧版本的IE可以引入 Google 的 Explorer Canvas 项目中的脚本来获得canvas支持。&lt;/li&gt;
  &lt;li&gt;Chrome和Opera 9+ 也支持 canvas。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;part2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2基本用法&quot;&gt;2.基本用法&lt;/h2&gt;

&lt;h3 id=&quot;21-canvas元素&quot;&gt;2.1 canvas元素&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;150&quot; height=&quot;150&quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;canvas 标签只有两个属性—— width和height。当没有设置宽度和高度的时候，canvas会初始化宽度为300像素和高度为150像素。canvas可以使用CSS来定义大小，但在绘制时图像会伸缩以适应它的框架尺寸：如果CSS的尺寸与初始画布的比例不一致，canvas中的图像会被扭曲。&lt;/p&gt;

&lt;h3 id=&quot;22-替换内容&quot;&gt;2.2 替换内容&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;canvas id=&quot;currentTime&quot; width=&quot;150&quot; height=&quot;150&quot;&amp;gt;
  &amp;lt;img src=&quot;images/currentTime.png&quot; width=&quot;150&quot; height=&quot;150&quot; alt=&quot;&quot;/&amp;gt;
&amp;lt;/canvas&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可在canvas的标签内部定义替换内容。&lt;/p&gt;

&lt;p&gt;当某些较老的浏览器不支持 canvas 时，浏览器会加载canvas标签内部的元素展示。&lt;/p&gt;

&lt;p&gt;当浏览器支持 canvas 是，浏览器会忽略canvas标签包含的内容，正常渲染canvas。&lt;/p&gt;

&lt;h3 id=&quot;23-渲染上下文the-rendering-context&quot;&gt;2.3 渲染上下文（The rendering context）&lt;/h3&gt;

&lt;p&gt;canvas 元素创造了一个固定大小的画布，它公开了一个或多个渲染上下文，用来绘制和处理要展示的内容。&lt;/p&gt;

&lt;p&gt;canvas起初是空白的。为了展示，首先脚本需要找到渲染上下文，然后在它的上面绘制。canvas 元素的 getContext() 的方法，就是是用来获得渲染上下文和它的绘画功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext('2d'); 

// 虽然参数2d会让人有想法，但是很遗憾目前html5不提供3d服务。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码的第一行通过使用 document.getElementById() 方法来为 canvas 元素得到DOM对象。一旦有了元素对象，便可以通过使用它的getContext() 方法来访问绘画上下文。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;part2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-绘制基本图形&quot;&gt;3. 绘制基本图形&lt;/h2&gt;

&lt;h3 id=&quot;31-栅格&quot;&gt;3.1 栅格&lt;/h3&gt;

&lt;p&gt;在开始画图之前，需要了解一下画布栅格（canvas grid）以及坐标空间。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/canvas1/img1.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如上图所示，canvas元素默认被网格所覆盖。通常网格中的一个单元相当于canvas元素中的一像素。&lt;/p&gt;

&lt;p&gt;栅格的起点为左上角（坐标为（0,0））。所有元素的位置都相对于原点定位。&lt;/p&gt;

&lt;p&gt;所以图中蓝色方形左上角的坐标为距离左边（Y轴）x像素，距离上边（X轴）y像素（坐标为（x,y））。&lt;/p&gt;

&lt;h3 id=&quot;32-绘制矩形&quot;&gt;3.2 绘制矩形&lt;/h3&gt;

&lt;p&gt;不同于SVG，HTML中的元素canvas只支持一种原生的图形绘制：矩形。所有其他的图形的绘制都至少需要生成一条路径。不过很多的路径生成方法让复杂图形的绘制成为了可能。下面来看一下矩形的绘制。&lt;/p&gt;

&lt;p&gt;canvas提供了三个矩形绘制相关的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 绘制一个填充的矩形
fillRect(x, y, width, height)

// 绘制一个矩形的边框
strokeRect(x, y, width, height)

// 清除指定矩形区域，让清除部分完全透明。
clearRect(x, y, width, height)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面提供的方法之中每一个都包含了相同的参数。x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。&lt;/p&gt;

&lt;p&gt;下面来看一个具体的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;
	var canvas = document.getElementById('cvs1');
	var ctx = canvas.getContext('2d');
	if (canvas.getContext) {
	    var ctx = canvas.getContext('2d');
		
		 // fillRect()绘制了一个边长为100px的黑色正方形
	    ctx.fillRect(25,25,100,100);
	    
	    // clearRect()从正方形的中心开始擦除了一个60*60px的正方形
	    ctx.clearRect(45,45,60,60); 
	    
	    // strokeRect()在清除区域内生成一个50*50的正方形边框。
	    ctx.strokeRect(50,50,50,50); 
	}
&amp;lt;/script&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该例子的输出如下图所示。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs1&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw1() {
    var canvas = document.getElementById('cvs1');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      ctx.fillRect(25,25,100,100);
      ctx.clearRect(45,45,60,60);
      ctx.strokeRect(50,50,50,50);
    }
  }
  draw1();
&lt;/script&gt;

&lt;p&gt;不同于下面所要介绍的路径函数（path function），以上的三个函数绘制之后会马上显现在canvas上，即时生效。&lt;/p&gt;

&lt;h3 id=&quot;33-绘制路径&quot;&gt;3.3 绘制路径&lt;/h3&gt;

&lt;h4 id=&quot;331-路径简介&quot;&gt;3.3.1 路径简介&lt;/h4&gt;

&lt;p&gt;图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先，需要创建路径起始点。&lt;/li&gt;
  &lt;li&gt;然后使用画图命令去画出路径。&lt;/li&gt;
  &lt;li&gt;之后把路径封闭。&lt;/li&gt;
  &lt;li&gt;一旦路径生成，就能通过描边或填充路径区域来渲染图形。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;以下是所要用到的函数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;beginPath()&lt;/p&gt;

    &lt;p&gt;新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;closePath()&lt;/p&gt;

    &lt;p&gt;闭合路径之后图形绘制命令又重新指向到上下文中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;stroke()&lt;/p&gt;

    &lt;p&gt;通过线条来绘制图形轮廓。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;fill()&lt;/p&gt;

    &lt;p&gt;通过填充路径的内容区域生成实心的图形。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，然后我们就可以重新绘制新的图形。&lt;/p&gt;

&lt;p&gt;第二步就是调用函数指定绘制路径。&lt;/p&gt;

&lt;p&gt;第三，就是闭合路径closePath()，此步不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。&lt;/p&gt;

&lt;p&gt;而当调用fill()函数时，没有闭合的形状都会自动闭合，所以不需要调用closePath()函数。但是调用stroke()时不会自动闭合。&lt;/p&gt;

&lt;p&gt;下面来通过路径绘制一个三角形。&lt;/p&gt;

&lt;h4 id=&quot;332-绘制三角形&quot;&gt;3.3.2 绘制三角形&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw2() {
  var canvas = document.getElementById('canvas');
  if (canvas.getContext){
    var ctx = canvas.getContext('2d');
    
    // 新建路径
    ctx.beginPath();
    
    // 移动笔触
    ctx.moveTo(75,50);
    
    // 划一条直线至(x,y)点
    ctx.lineTo(100,75);
    ctx.lineTo(100,25);
    
    // 填充
    ctx.fill();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;输出如下：&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs2&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw2() {
    var canvas = document.getElementById('cvs2');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      ctx.beginPath();
      ctx.moveTo(100,45);
      ctx.lineTo(75,75);
      ctx.lineTo(125,75);
      ctx.fill();
    }
  }
  draw2();
&lt;/script&gt;

&lt;p&gt;例子所用到的moveTo()函数和lineTo()函数，下面来分别介绍。&lt;/p&gt;

&lt;h4 id=&quot;323-移动笔触&quot;&gt;3.2.3 移动笔触&lt;/h4&gt;

&lt;p&gt;moveTo()函数是移动笔触的函数。&lt;/p&gt;

&lt;p&gt;这个函数实际上并不能画出任何东西，仅仅是将绘制点移动至某个坐标。可以想象一下在纸上作业，一支笔的笔尖从一个点到另一个点的移动过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;moveTo(x, y)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将笔触移动到指定的坐标x以及y上。&lt;/p&gt;

&lt;p&gt;当canvas初始化或者beginPath()调用后，通常会使用moveTo()函数设置起点。&lt;/p&gt;

&lt;p&gt;也可以使用moveTo()绘制一些不连续的路径，比如下面这个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw3() {
    var canvas = document.getElementById('cvs3');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      ctx.beginPath();
      ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制
      ctx.moveTo(110,75);
      ctx.arc(75,75,35,0,Math.PI,false);   // 口(顺时针)
      ctx.moveTo(65,65);
      ctx.arc(60,65,5,0,Math.PI*2,true);  // 左眼
      ctx.moveTo(95,65);
      ctx.arc(90,65,5,0,Math.PI*2,true);  // 右眼
      ctx.stroke();
    }
  }
   function draw4() {
    var canvas = document.getElementById('cvs4');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      ctx.beginPath();
      ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制
      // ctx.moveTo(110,75);
      ctx.arc(75,75,35,0,Math.PI,false);   // 口(顺时针)
      // ctx.moveTo(65,65);
      ctx.arc(60,65,5,0,Math.PI*2,true);  // 左眼
      // ctx.moveTo(95,65);
      ctx.arc(90,65,5,0,Math.PI*2,true);  // 右眼
      ctx.stroke();
    }
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;左边是使用moveTo()的效果，右边是不使用moveTo()的效果，至于例子中的arc()函数会在下面介绍。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs3&quot;&gt;&lt;/canvas&gt;
    &lt;canvas id=&quot;cvs4&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw3() {
    var canvas = document.getElementById('cvs3');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      ctx.beginPath();
      ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制
      ctx.moveTo(110,75);
      ctx.arc(75,75,35,0,Math.PI,false);   // 口(顺时针)
      ctx.moveTo(65,65);
      ctx.arc(60,65,5,0,Math.PI*2,true);  // 左眼
      ctx.moveTo(95,65);
      ctx.arc(90,65,5,0,Math.PI*2,true);  // 右眼
      ctx.stroke();
    }
  }
   function draw4() {
    var canvas = document.getElementById('cvs4');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      ctx.beginPath();
      ctx.arc(75,75,50,0,Math.PI*2,true); // 绘制
      // ctx.moveTo(110,75);
      ctx.arc(75,75,35,0,Math.PI,false);   // 口(顺时针)
      // ctx.moveTo(65,65);
      ctx.arc(60,65,5,0,Math.PI*2,true);  // 左眼
      // ctx.moveTo(95,65);
      ctx.arc(90,65,5,0,Math.PI*2,true);  // 右眼
      ctx.stroke();
    }
  }
  draw3();
  draw4();
&lt;/script&gt;

&lt;h4 id=&quot;324-直线&quot;&gt;3.2.4 直线&lt;/h4&gt;

&lt;p&gt;绘制直线，用到的方法是lineTo()。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;lineTo(x, y)&lt;/p&gt;

    &lt;p&gt;绘制一条从当前位置到指定x以及y位置的直线。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;该方法有两个参数：x以及y，代表坐标系中直线结束的点。&lt;/p&gt;

&lt;p&gt;开始点和之前的绘制路径有关，之前路径的结束点就是接下来的开始点，开始点也可以通过moveTo()函数改变。&lt;/p&gt;

&lt;p&gt;下面的例子绘制两个三角形，一个是填充的，另一个是描边的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw5() {
    var canvas = document.getElementById('cvs5');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      // 填充三角形
      ctx.beginPath();
      ctx.moveTo(25,25);
      ctx.lineTo(105,25);
      ctx.lineTo(25,105);
      ctx.fill();

      // 描边三角形
      ctx.beginPath();
      ctx.moveTo(125,125);
      ctx.lineTo(125,45);
      ctx.lineTo(45,125);
      ctx.closePath();
      ctx.stroke();
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以注意到填充与描边三角形步骤有所不同。&lt;/p&gt;

&lt;p&gt;正如上面所提到的，因为路径使用填充（filled）时，路径自动闭合，使用描边（stroked）则不会闭合路径。&lt;/p&gt;

&lt;p&gt;如果没有添加闭合路径closePath()到描述三角形函数中，则只绘制了两条线段，并不是一个完整的三角形。&lt;/p&gt;

&lt;p&gt;例子输出如下：&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs5&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw5() {
    var canvas = document.getElementById('cvs5');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      // 填充三角形
      ctx.beginPath();
      ctx.moveTo(25,25);
      ctx.lineTo(105,25);
      ctx.lineTo(25,105);
      ctx.fill();

      // 描边三角形
      ctx.beginPath();
      ctx.moveTo(125,125);
      ctx.lineTo(125,45);
      ctx.lineTo(45,125);
      ctx.closePath();
      ctx.stroke();
    }
  }
  draw5();
&lt;/script&gt;

&lt;h4 id=&quot;325-圆弧&quot;&gt;3.2.5 圆弧&lt;/h4&gt;

&lt;p&gt;绘制圆弧或者圆，可以使用arc()函数和arcTo()函数，然而根据MDN的说法，arcTo()函数的实现不是很靠谱，所以这里不作详细介绍。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;arc(x, y, radius, startAngle, endAngle, anticlockwise)&lt;/p&gt;

    &lt;p&gt;画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;arcTo(x1, y1, x2, y2, radius)&lt;/p&gt;

    &lt;p&gt;根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;arc()函数有五个参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;x,y为绘制圆弧所在圆上的圆心坐标。&lt;/li&gt;
  &lt;li&gt;radius为半径。&lt;/li&gt;
  &lt;li&gt;startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准。&lt;/li&gt;
  &lt;li&gt;参数anticlockwise 为一个布尔值。为true时，是逆时针方向，否则顺时针方向。&lt;/li&gt;
&lt;/ul&gt;

&lt;font style=&quot;color: red;&quot;&gt;arc()函数中的角度单位是弧度，不是度数。角度与弧度的js表达式:radians=(Math.PI/180)*degrees。&lt;/font&gt;

&lt;p&gt;下面的例子比上面的要复杂一下，下面绘制了12个不同的角度以及填充的圆弧。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw6() {
    var canvas = document.getElementById('cvs6');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      for(var i=0;i&amp;lt;4;i++){
        for(var j=0;j&amp;lt;3;j++){
          ctx.beginPath();
          var x              = 25+j*50;               // x 坐标值
          var y              = 25+i*50;               // y 坐标值
          var radius         = 20;                    // 圆弧半径
          var startAngle     = 0;                     // 开始点
          var endAngle       = Math.PI+(Math.PI*j)/2; // 结束点
          var anticlockwise  = i%2==0 ? false : true; // 顺时针或逆时针

          ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);

          if (i&amp;gt;1){
            ctx.fill();
          } else {
            ctx.stroke();
          }
        }
      } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两个for循环，生成圆弧的行列（x,y）坐标。每一段圆弧的开始都调用beginPath()。&lt;/p&gt;

&lt;p&gt;x,y坐标是可变的。半径（radius）和开始角度（startAngle）都是固定的。结束角度（endAngle）在第一列开始时是180度（半圆）然后每列增加90度。最后一列形成一个完整的圆。&lt;/p&gt;

&lt;p&gt;clockwise 语句作用于第一、三行是顺时针的圆弧，anticlockwise作用于二、四行为逆时针圆弧。if 语句让一、二行描边圆弧，下面两行填充路径。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs6&quot; width=&quot;150px&quot; height=&quot;195px&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw6() {
    var canvas = document.getElementById('cvs6');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');

      for(var i=0;i&lt;4;i++){
        for(var j=0;j&lt;3;j++){
          ctx.beginPath();
          var x              = 25+j*50;               // x 坐标值
          var y              = 25+i*50;               // y 坐标值
          var radius         = 20;                    // 圆弧半径
          var startAngle     = 0;                     // 开始点
          var endAngle       = Math.PI+(Math.PI*j)/2; // 结束点
          var anticlockwise  = i%2==0 ? false : true; // 顺时针或逆时针

          ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);

          if (i&gt;1){
            ctx.fill();
          } else {
            ctx.stroke();
          }
        }
      } 
    }
  }
  draw6();
&lt;/script&gt;

&lt;h4 id=&quot;326-贝塞尔bezier以及二次贝塞尔&quot;&gt;3.2.6 贝塞尔（bezier）以及二次贝塞尔&lt;/h4&gt;

&lt;p&gt;贝塞尔曲线在之前的svg介绍中也有提及，下面来看看canvas中的贝塞尔曲线。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;quadraticCurveTo(cp1x, cp1y, x, y)&lt;/p&gt;

    &lt;p&gt;绘制贝塞尔曲线，cp1x,cp1y为控制点，x,y为结束点。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)&lt;/p&gt;

    &lt;p&gt;绘制二次贝塞尔曲线，cp1x,cp1y为控制点一，cp2x,cp2y为控制点二，x,y为结束点。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面的图能够很好的描述两者的关系，贝塞尔曲线有一个开始、结束点（蓝色）以及一个控制点（红色），而二次贝塞尔曲线使用两个控制点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/canvas1/img2.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参数x、y在这两个方法中都是结束点坐标。cp1x,cp1y为坐标中的第一个控制点，cp2x,cp2y为坐标中的第二个控制点。&lt;/p&gt;

&lt;p&gt;下面来看两个个简单的例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 一次贝塞尔
  function draw7() {
    var canvas = document.getElementById('cvs7');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.moveTo(75,25);
      ctx.quadraticCurveTo(25,25,25,62.5);
      ctx.quadraticCurveTo(25,100,50,100);
      ctx.quadraticCurveTo(50,120,30,125);
      ctx.quadraticCurveTo(60,120,65,100);
      ctx.quadraticCurveTo(125,100,125,62.5);
      ctx.quadraticCurveTo(125,25,75,25);
      ctx.stroke();
    }
  }
  // 二次贝塞尔
  function draw8() {
    var canvas = document.getElementById('cvs8');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.moveTo(75,40);
      ctx.bezierCurveTo(75,37,70,25,50,25);
      ctx.bezierCurveTo(20,25,20,62.5,20,62.5);
      ctx.bezierCurveTo(20,80,40,102,75,120);
      ctx.bezierCurveTo(110,102,130,80,130,62.5);
      ctx.bezierCurveTo(130,62.5,130,25,100,25);
      ctx.bezierCurveTo(85,25,75,37,75,40);
      ctx.fill();    
    }
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs7&quot; width=&quot;200px&quot;&gt;&lt;/canvas&gt;
    &lt;canvas id=&quot;cvs8&quot; width=&quot;200px&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw7() {
    var canvas = document.getElementById('cvs7');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.moveTo(75,25);
      ctx.quadraticCurveTo(25,25,25,62.5);
      ctx.quadraticCurveTo(25,100,50,100);
      ctx.quadraticCurveTo(50,120,30,125);
      ctx.quadraticCurveTo(60,120,65,100);
      ctx.quadraticCurveTo(125,100,125,62.5);
      ctx.quadraticCurveTo(125,25,75,25);
      ctx.stroke();
    }
  }
  function draw8() {
    var canvas = document.getElementById('cvs8');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
      ctx.beginPath();
      ctx.moveTo(75,40);
      ctx.bezierCurveTo(75,37,70,25,50,25);
      ctx.bezierCurveTo(20,25,20,62.5,20,62.5);
      ctx.bezierCurveTo(20,80,40,102,75,120);
      ctx.bezierCurveTo(110,102,130,80,130,62.5);
      ctx.bezierCurveTo(130,62.5,130,25,100,25);
      ctx.bezierCurveTo(85,25,75,37,75,40);
      ctx.fill();    
    }
  }
  draw7();
  draw8();
&lt;/script&gt;

&lt;p&gt;使用一次以及二次贝塞尔曲线是有一定的难度的，因为不同于像Adobe Illustrators这样的矢量软件，canvas所绘制的曲线没有直接的视觉反馈。这让绘制复杂的图形十分的困难。即使这样，只要有时间和耐心，很多复杂的图形都可以绘制出来。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;part4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4组合使用&quot;&gt;4.组合使用&lt;/h2&gt;

&lt;p&gt;目前为止，每一个例子中的每个图形都只用到一种类型的函数，所以下面来看看将这些函数组合绘图的效果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; function draw9() {
    var canvas = document.getElementById('cvs9');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
	   ctx.beginPath();
        ctx.moveTo(150, 0);
        ctx.lineTo(75, 75);
        ctx.lineTo(150, 150);
        ctx.lineTo(225, 75);
        ctx.lineTo(150, 0);
        ctx.stroke();
        ctx.closePath();

        ctx.strokeRect(75,0, 150, 150);

        ctx.beginPath();
        ctx.arc(150, 75, 52, Math.PI / 2, Math.PI * 3 / 2);
        ctx.stroke();
        ctx.closePath();


        ctx.beginPath();
        ctx.moveTo(150,23);
        ctx.bezierCurveTo(190,30,190,70,150,75);
        ctx.bezierCurveTo(110,82,110,122,150,127);
        ctx.bezierCurveTo(220,127,220,23,150,23);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(150, 49, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(150, 101, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill(); 
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面例子中的fillStyle属性可以用来设置fill填充颜色，颜色与样式的内容会在下一章介绍。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs9&quot; width=&quot;300px&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw9() {
    var canvas = document.getElementById('cvs9');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
	   ctx.beginPath();
        ctx.moveTo(150, 0);
        ctx.lineTo(75, 75);
        ctx.lineTo(150, 150);
        ctx.lineTo(225, 75);
        ctx.lineTo(150, 0);
        ctx.stroke();
        ctx.closePath();

        ctx.strokeRect(75,0, 150, 150);

        ctx.beginPath();
        ctx.arc(150, 75, 52, Math.PI / 2, Math.PI * 3 / 2);
        ctx.stroke();
        ctx.closePath();


        ctx.beginPath();
        ctx.moveTo(150,23);
        ctx.bezierCurveTo(190,30,190,70,150,75);
        ctx.bezierCurveTo(110,82,110,122,150,127);
        ctx.bezierCurveTo(220,127,220,23,150,23);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(150, 49, 5, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(150, 101, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill(); 
    }
  }
  draw9();
&lt;/script&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function draw10() {
	var canvas = document.getElementById('cvs10');
	var ctx = canvas.getContext('2d');
	if (canvas.getContext) {
		var ctx = canvas.getContext('2d');
		roundedRect(ctx,12,12,150,150,15);
		roundedRect(ctx,19,19,150,150,9);
		roundedRect(ctx,53,53,49,33,10);
		roundedRect(ctx,53,119,49,16,6);
		roundedRect(ctx,135,53,49,33,10);
		roundedRect(ctx,135,119,25,49,10);
		
		ctx.beginPath();
		ctx.arc(37,37,13,Math.PI/7,-Math.PI/7,false);
		ctx.lineTo(31,37);
		ctx.fill();
		
		for(var i=0;i&amp;lt;8;i++){
			ctx.fillRect(51+i*16,35,4,4);
		}
		
		for(i=0;i&amp;lt;6;i++){
			ctx.fillRect(115,51+i*16,4,4);
		}
		
		for(i=0;i&amp;lt;8;i++){
			ctx.fillRect(51+i*16,99,4,4);
		}
		
		ctx.beginPath();
		ctx.moveTo(83,116);
		ctx.lineTo(83,102);
		ctx.bezierCurveTo(83,94,89,88,97,88);
		ctx.bezierCurveTo(105,88,111,94,111,102);
		ctx.lineTo(111,116);
		ctx.lineTo(106.333,111.333);
		ctx.lineTo(101.666,116);
		ctx.lineTo(97,111.333);
		ctx.lineTo(92.333,116);
		ctx.lineTo(87.666,111.333);
		ctx.lineTo(83,116);
		ctx.fill();
		
		ctx.fillStyle = &quot;white&quot;;
		ctx.beginPath();
		ctx.moveTo(91,96);
		ctx.bezierCurveTo(88,96,87,99,87,101);
		ctx.bezierCurveTo(87,103,88,106,91,106);
		ctx.bezierCurveTo(94,106,95,103,95,101);
		ctx.bezierCurveTo(95,99,94,96,91,96);
		ctx.moveTo(103,96);
		ctx.bezierCurveTo(100,96,99,99,99,101);
		ctx.bezierCurveTo(99,103,100,106,103,106);
		ctx.bezierCurveTo(106,106,107,103,107,101);
		ctx.bezierCurveTo(107,99,106,96,103,96);
		ctx.fill();
		
		ctx.fillStyle = &quot;black&quot;;
		ctx.beginPath();
		ctx.arc(101,102,2,0,Math.PI*2,true);
		ctx.fill();
		
		ctx.beginPath();
		ctx.arc(89,102,2,0,Math.PI*2,true);
		ctx.fill();
	}
}

function roundedRect(ctx,x,y,width,height,radius){
  ctx.beginPath();
  ctx.moveTo(x,y+radius);
  ctx.lineTo(x,y+height-radius);
  ctx.quadraticCurveTo(x,y+height,x+radius,y+height);
  ctx.lineTo(x+width-radius,y+height);
  ctx.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);
  ctx.lineTo(x+width,y+radius);
  ctx.quadraticCurveTo(x+width,y,x+width-radius,y);
  ctx.lineTo(x+radius,y);
  ctx.quadraticCurveTo(x,y,x,y+radius);
  ctx.stroke();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个例子是MDN上的一个例子，这个例子看着复杂，只要耐下性子看看，其实很容易理解，这里就不详细说明。&lt;/p&gt;

&lt;p&gt;重要的一点是绘制上下文中使用到了fillStyle属性，以及封装函数（例子中的 roundedRect()）。&lt;/p&gt;

&lt;p&gt;fillStyle属性会在下次介绍，而使用封装函数对于减少代码量以及复杂度十分有用，在canvas的使用中，有效的封装函数才是重中之重。&lt;/p&gt;

&lt;div style=&quot;text-align: center&quot;&gt;
    &lt;canvas id=&quot;cvs10&quot; width=&quot;300px&quot; height=&quot;300&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;
&lt;script&gt;
  function draw10() {
    var canvas = document.getElementById('cvs10');
    var ctx = canvas.getContext('2d');
    if (canvas.getContext) {
      var ctx = canvas.getContext('2d');
	   roundedRect(ctx,12,12,150,150,15);
      roundedRect(ctx,19,19,150,150,9);
    roundedRect(ctx,53,53,49,33,10);
    roundedRect(ctx,53,119,49,16,6);
    roundedRect(ctx,135,53,49,33,10);
    roundedRect(ctx,135,119,25,49,10);

    ctx.beginPath();
    ctx.arc(37,37,13,Math.PI/7,-Math.PI/7,false);
    ctx.lineTo(31,37);
    ctx.fill();

    for(var i=0;i&lt;8;i++){
      ctx.fillRect(51+i*16,35,4,4);
    }

    for(i=0;i&lt;6;i++){
      ctx.fillRect(115,51+i*16,4,4);
    }

    for(i=0;i&lt;8;i++){
      ctx.fillRect(51+i*16,99,4,4);
    }

    ctx.beginPath();
    ctx.moveTo(83,116);
    ctx.lineTo(83,102);
    ctx.bezierCurveTo(83,94,89,88,97,88);
    ctx.bezierCurveTo(105,88,111,94,111,102);
    ctx.lineTo(111,116);
    ctx.lineTo(106.333,111.333);
    ctx.lineTo(101.666,116);
    ctx.lineTo(97,111.333);
    ctx.lineTo(92.333,116);
    ctx.lineTo(87.666,111.333);
    ctx.lineTo(83,116);
    ctx.fill();

    ctx.fillStyle = &quot;white&quot;;
    ctx.beginPath();
    ctx.moveTo(91,96);
    ctx.bezierCurveTo(88,96,87,99,87,101);
    ctx.bezierCurveTo(87,103,88,106,91,106);
    ctx.bezierCurveTo(94,106,95,103,95,101);
    ctx.bezierCurveTo(95,99,94,96,91,96);
    ctx.moveTo(103,96);
    ctx.bezierCurveTo(100,96,99,99,99,101);
    ctx.bezierCurveTo(99,103,100,106,103,106);
    ctx.bezierCurveTo(106,106,107,103,107,101);
    ctx.bezierCurveTo(107,99,106,96,103,96);
    ctx.fill();

    ctx.fillStyle = &quot;black&quot;;
    ctx.beginPath();
    ctx.arc(101,102,2,0,Math.PI*2,true);
    ctx.fill();

    ctx.beginPath();
    ctx.arc(89,102,2,0,Math.PI*2,true);
    ctx.fill();
    }
  }
  function roundedRect(ctx,x,y,width,height,radius){
  ctx.beginPath();
  ctx.moveTo(x,y+radius);
  ctx.lineTo(x,y+height-radius);
  ctx.quadraticCurveTo(x,y+height,x+radius,y+height);
  ctx.lineTo(x+width-radius,y+height);
  ctx.quadraticCurveTo(x+width,y+height,x+width,y+height-radius);
  ctx.lineTo(x+width,y+radius);
  ctx.quadraticCurveTo(x+width,y,x+width-radius,y);
  ctx.lineTo(x+radius,y);
  ctx.quadraticCurveTo(x,y,x,y+radius);
  ctx.stroke();
}
  draw10();
&lt;/script&gt;

</content>
 </entry>
 
 <entry>
   <title>zabbix安装部署</title>
   <link href="http://www.blogways.net/blog/2016/12/17/zabbix-intro.html"/>
   <updated>2016-12-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/17/zabbix-intro</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part1&quot;&gt;zabbix简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part2&quot;&gt;搭建依赖环境&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part3&quot;&gt;zabbix安装配置&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#part4&quot;&gt;问题汇总&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;part1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1-zabbix简介&quot;&gt;1. zabbix简介&lt;/h2&gt;

&lt;h3 id=&quot;11-zabbix自述&quot;&gt;1.1 zabbix自述&lt;/h3&gt;

&lt;p&gt;Zabbix是一个企业级的、开源的、分布式的监控套件；&lt;/p&gt;

&lt;p&gt;Zabbix 可以监控网络和服务的运行状况。 Zabbix 利用灵活的告警机制，允许用户对事件发送基于 Email 的告警。&lt;/p&gt;

&lt;p&gt;Zabbix利用存储数据提供杰出的报告及图表，这一特性将帮助用户完成配置规划；&lt;/p&gt;

&lt;p&gt;Zabbix支持polling和trapping两种方式. 所有的Zabbix报告都可以通过配置参数在WEB前端进行访问。Web 前端将帮助你在任何区域都能够迅速获得你的网络及服务状况。&lt;/p&gt;

&lt;h3 id=&quot;12-功能特点&quot;&gt;1.2 功能特点&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;分布式监控，天生具有的功能，适合于构建分布式监控系统，具有node，proxy2种分布式模式;&lt;/li&gt;
  &lt;li&gt;自动化功能，自动发现，自动注册主机，自动添加模板，自动添加分组，是适应于自动化运维利器的首选;&lt;/li&gt;
  &lt;li&gt;自定义监控比较方便，自定义监控项非常简单，支持变量;&lt;/li&gt;
  &lt;li&gt;支持多种监控方式，agentd，snmp，ipmi，jmx;&lt;/li&gt;
  &lt;li&gt;提供api功能，二次开发方便，可以进行二次深度开发。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;13-进程构成&quot;&gt;1.3 进程构成&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;zabbix_server：
zabbix 服务端守护进程，获取的主机数据最终都是提交到 server（server可主动访问agentd获取数据，也可配置agentd主动推送数据至server）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zabbix_agentd：
客户端守护进程，此进程收集客户端数据，例如 cpu 负载、内存、硬盘使用情况等。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zabbix_get：
zabbix 工具，单独使用的命令，通常在 server 或者 proxy 端执行获取远程客户端信息的命令，排查客户端与服务端是否连接故障。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zabbix_sender：
zabbix 工具，用于发送数据给 server 或者 proxy，通常用于耗时比较长的检查。很多检查非常耗时间，导致zabbix 超时。可在脚本执行完毕之后，使用 sender 主动提交数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zabbix_proxy：
zabbix 代理守护进程。功能类似 server，唯一不同的是它只是一个中转站，它需要把收集到的数据提交（或被提交)到 server 里。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zabbix_java_gateway：
Java 网关，类似 agentd，但是只用于 Java 方面。它只能主动去获取数据，而不能被动获取数据。它的数据最终会给到 server 或者 proxy。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14-操作系统支持&quot;&gt;1.4 操作系统支持&lt;/h3&gt;

&lt;p&gt;以下操作系统支持所有进程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linux&lt;/li&gt;
  &lt;li&gt;IBM AIX&lt;/li&gt;
  &lt;li&gt;FreeBSD&lt;/li&gt;
  &lt;li&gt;NetBSD&lt;/li&gt;
  &lt;li&gt;OpenBSD&lt;/li&gt;
  &lt;li&gt;HP-UX&lt;/li&gt;
  &lt;li&gt;Mac OSX&lt;/li&gt;
  &lt;li&gt;Solaris&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以下操作系统仅支持客户端agentd：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows 2000&lt;/li&gt;
  &lt;li&gt;Windows Server 2003&lt;/li&gt;
  &lt;li&gt;Windows Server 2008&lt;/li&gt;
  &lt;li&gt;Windows Server 2012&lt;/li&gt;
  &lt;li&gt;Windows XP&lt;/li&gt;
  &lt;li&gt;Windows Vista&lt;/li&gt;
  &lt;li&gt;Windows 7&lt;/li&gt;
  &lt;li&gt;Windows 8&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;15-磁盘占用量计算&quot;&gt;1.5 磁盘占用量计算&lt;/h3&gt;

&lt;p&gt;zabbix的数据有以下几种数据构成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;配置数据：zabbix的配置文件等，一般固定大小在10MB以下；&lt;/li&gt;
  &lt;li&gt;历史数据：zabbix会保存一定时间内监控数据，记录时间段内的主机运行情况；&lt;/li&gt;
  &lt;li&gt;趋势数据：即监控指标的最大值、最小值、平均值、计数等此类数据；&lt;/li&gt;
  &lt;li&gt;时间记录：当监控项指标超过某阀值时zabbix会产生事件提示运维人员，zabbix会保存此事件的数据直至被删除。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;####场景：&lt;/p&gt;

&lt;p&gt;假设要监控100台服务器，每台30个监控项，每个监控项60秒刷新一次，即每秒会有50(30*100/60)条数据入库。&lt;/p&gt;

&lt;h4 id=&quot;配置数据大小&quot;&gt;配置数据大小：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zabbix配置数据:	固定大小，一般&amp;lt;10MB。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;历史数据大小&quot;&gt;历史数据大小：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;历史数据（保留30天，一条历史数据约50字节）：
    30天*24小时*3600秒*50条数据*50字节 ≈ 6.5G 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;趋势数据大小&quot;&gt;趋势数据大小：&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;趋势数据（保留5年，当查看一周或一个月的图表，其中的MAX/MIN/AVG/COUNT取自趋势数据，一条趋势数据约128字节）：
    5年*365天*24小时*3000个监控项*128字节 ≈ 16.8G
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;事件数据大小&quot;&gt;事件数据大小：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;事件记录（一个事件约占130个字节，每秒产生一个事件，保留1年）：
    1年*365天*24小时*3600秒*130字节 ≈ 4.1G
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;结论&quot;&gt;结论：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;此场景下需要的数据库硬盘容量 ≈ 27.41G 。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;part2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2-搭建依赖环境&quot;&gt;2. 搭建依赖环境&lt;/h2&gt;

&lt;h3 id=&quot;21-zabbix依赖环境&quot;&gt;2.1 zabbix依赖环境&lt;/h3&gt;

&lt;p&gt;zabbix后端程序是用c语言写的，前台web页面是用php语言写的，需要数据库的支持。&lt;/p&gt;

&lt;p&gt;操作系统前面已介绍，此处不再赘述。&lt;/p&gt;

&lt;p&gt;zabbix可使用以下数据库：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;MySQL  5.0.3  及以上，推荐使用InnoDB引擎&lt;/li&gt;
  &lt;li&gt;Oracle  10g  及以上&lt;/li&gt;
  &lt;li&gt;PostgreSQL  8.1  及以上&lt;/li&gt;
  &lt;li&gt;SQLite  3.3.5  及以上&lt;/li&gt;
  &lt;li&gt;IBM DB2  9.7  及以上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;web环境依赖如下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Apache HTTP Server 1.3.12  及以上&lt;/li&gt;
  &lt;li&gt;PHP  5.3.0  及以上&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本例操作系统为Mac OS 10.12.1，数据库采用MySQL 5.7.16，此处主要介绍Apache HTTP Server 和 PHP 的安装。&lt;/p&gt;

&lt;h3 id=&quot;22-安装-apache-http-server&quot;&gt;2.2 安装 Apache HTTP Server&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;下载源码包&lt;code class=&quot;highlighter-rouge&quot;&gt;httpd-2.4.23.tar.gz&lt;/code&gt;至&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/src&lt;/code&gt;目录并解压，的到&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/src/httpd-2.4.23&lt;/code&gt;目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd httpd-2.4.23&lt;/code&gt;，执行命令&lt;code class=&quot;highlighter-rouge&quot;&gt;./configure --prefix=/usr/local/httpd&lt;/code&gt;，配置完毕后执行&lt;code class=&quot;highlighter-rouge&quot;&gt;make &amp;amp;&amp;amp; make install&lt;/code&gt;，无报错即安装成功。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cp /usr/local/httpd/bin/apachectl  /usr/sbin&lt;/code&gt;，之后可通过命令：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		    sudo apachectl start -- 启动服务
		    
		    sudo apachectl stop -- 停止服务
		    
		    sudo apachectl status -- 查看状态
		    
		    sudo apachectl restart -- 重启服务
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;来管理服务的启停。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/httpd/conf/httpd.conf&lt;/code&gt; 修改配置项：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.去掉
	#LoadModule php5_module        modules/libphp5.so 
 此行的注释
 
2.&amp;lt;Directory /&amp;gt;标签内部内容做如下修改：
	&amp;lt;Directory /&amp;gt;
	    Options Includes ExecCGI FollowSymLinks
	    AllowOverride All
	    Order deny,allow
	    Deny from all
	&amp;lt;/Directory&amp;gt;

3.修改DocumentRoot内容为：
	DocumentRoot &quot;/usr/local/httpd/htdocs&quot;

4.将&amp;lt;Directory &quot;/usr/local/httpd/htdocs&quot;&amp;gt;标签内容修改为：
	&amp;lt;Directory &quot;/usr/local/httpd/htdocs&quot;&amp;gt;
	    Options FollowSymLinks
	    AllowOverride None
	    Order allow,deny
	    Allow from all
	    Require all granted
	&amp;lt;/Directory&amp;gt;

5. 将&amp;lt;IfModule dir_module&amp;gt;标签内容修改为：
	&amp;lt;IfModule dir_module&amp;gt;
    	DirectoryIndex index.html index.php
	&amp;lt;/IfModule&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上修改主要是添加对php的支持，至此Apache HTTP Server安装完毕。&lt;/p&gt;

&lt;h3 id=&quot;23-安装php&quot;&gt;2.3 安装PHP&lt;/h3&gt;

&lt;p&gt;php的安装会比较麻烦，因为php有很多扩展需要额外配置安装，zabbix所需要的php扩展支持如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;bcmath&lt;/li&gt;
  &lt;li&gt;socket&lt;/li&gt;
  &lt;li&gt;mbstring&lt;/li&gt;
  &lt;li&gt;gettext&lt;/li&gt;
  &lt;li&gt;snmp&lt;/li&gt;
  &lt;li&gt;libxml&lt;/li&gt;
  &lt;li&gt;gd（gd扩展最为麻烦，除gd本身以外，还需要向gd添加png、jpeg、freetype三种支持）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;bcmath&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;mbstring&lt;/code&gt;只需要在configure的时候加上&lt;code class=&quot;highlighter-rouge&quot;&gt;--enable-xxx&lt;/code&gt;的参数就能在编译安装的同时添加。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;gettext&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;snmp &lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libxml&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;gd&lt;/code&gt;则需要在configure时指定这些扩展的目录路径，也就是说在本机要先安装这些扩展，配置php时指定路径才能给php添加上所需扩展。&lt;/p&gt;

&lt;p&gt;所以此时先不急着安装php，而应先安装php扩展的依赖扩展。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;snmp &lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;gettext&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;libxml&lt;/code&gt;的安装比较简单，下载源码包编译安装即可，这里简单介绍相对比较麻烦的&lt;code class=&quot;highlighter-rouge&quot;&gt;gd&lt;/code&gt;扩展的安装。&lt;/p&gt;

&lt;p&gt;libgd是一个开源的图像处理的库程序，全称是GD Graphics Library，php开发中对于图像的处理会使用到。libgd可在官网下载源码安装，但是各种图片类型的支持需要额外添加，zabbix必须的图片支持有&lt;code class=&quot;highlighter-rouge&quot;&gt;libjpeg&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libpng&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;freetype&lt;/code&gt;三种。&lt;/p&gt;

&lt;p&gt;所以整个php的安装顺序应是：&lt;/p&gt;

&lt;p&gt;1、安装&lt;code class=&quot;highlighter-rouge&quot;&gt;libjpeg&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libpng&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;freetype&lt;/code&gt;三种gd库需要的支持；
2、安装&lt;code class=&quot;highlighter-rouge&quot;&gt;gd&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;gettext&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;snmp &lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;libxml&lt;/code&gt;四个php需要指定路径的扩展；
3、安装&lt;code class=&quot;highlighter-rouge&quot;&gt;php&lt;/code&gt;，在配置阶段把所需扩展添加上。&lt;/p&gt;

&lt;p&gt;以上扩展的安装此处不赘述，可自行查阅其他资料进行安装，本文只介绍php的安装。&lt;/p&gt;

&lt;p&gt;最终，php的configure命令应是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure \
--prefix=/usr/local/php \
--with-apxs2=/usr/local/httpd/bin/apxs \
--enable-bcmath \
--enable-socket \ 
--with-mysql=/Users/mysql/mysql \
--with-mysqli=/Users/mysql/mysql/bin/mysql_config \
--with-mysql-sock=/tmp/mysql.sock \
--with-libxml-dir=libxml安装目录 \
--with-snmp=libsnmp安装目录 \
--with-gettext=libgettext安装目录 \
--with-gd=libgd安装目录;

make &amp;amp;&amp;amp; make test;
make install;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;php安装完毕后，拷贝源码包内的&lt;code class=&quot;highlighter-rouge&quot;&gt;php.ini-production&lt;/code&gt;至安装目录的&lt;code class=&quot;highlighter-rouge&quot;&gt;lib&lt;/code&gt;目录下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp /usr/local/src/php-5.6.28/php.ini-production  /usr/local/php/lib/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并根据zabbix的需要编辑修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;max_execution_time = 300
max_input_time = 300
memory_limit = 128M
post_max_size = 32M
date.timezone = Asia/Shanghai
mbstring.func_overload=2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;至此，php安装完毕。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;part3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3-安装zabbix&quot;&gt;3. 安装zabbix&lt;/h2&gt;

&lt;p&gt;下载源码包&lt;code class=&quot;highlighter-rouge&quot;&gt;zabbix-3.2.1.tar.gz&lt;/code&gt;至&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/zabbix/src&lt;/code&gt;并解压。&lt;/p&gt;

&lt;h3 id=&quot;31-数据库初始化&quot;&gt;3.1 数据库初始化&lt;/h3&gt;

&lt;p&gt;连接mysql并创建名为zabbix的database。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd /Users/zabbix/src/zabbix-3.2.1/database/mysql&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在此目录下有三个sql脚本文件&lt;code class=&quot;highlighter-rouge&quot;&gt;schema.sql、images.sql、data.sql&lt;/code&gt;，将这三个文件导入zabbix database即完成了初始化：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql -uzabbix -p123456 -hlocalhost zabbix &amp;lt; /usr/local/src/zabbix-3.2.0/database/mysql/schema.sql

mysql -uzabbix -p123456 -hlocalhost zabbix &amp;lt; /usr/local/src/zabbix-3.2.0/database/mysql/images.sql

mysql -uzabbix -p123456 -hlocalhost zabbix &amp;lt; /usr/local/src/zabbix-3.2.0/database/mysql/data.sql
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意导入顺序，需要按照此顺序导入，否则失败。&lt;/p&gt;

&lt;h3 id=&quot;32-安装zabbix&quot;&gt;3.2 安装zabbix&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#配置
./configure \ 
--prefix=/Users/zabbix/zabbix \
--enable-server \ # 安装server进程服务
--enable-agent \  # 安装agentd进程服务
--with-net-snmp \  # 安装net-snmp监控接口
--with-libcurl \		
--with-mysql=/usr/bin/mysql_config  # mysql数据库配置

#编译
make 

#安装
make install 

#添加系统软连接
ln -s /Users/zabbix/zabbix/sbin/* /usr/local/sbin/ 

#添加系统软连接
ln -s /Users/zabbix/zabbix/bin/* /usr/local/bin/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在配置时候不需要的组件可以不进行配置，如只想在主机上安装agentd进程，只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;./configure --enable-agent&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;33-修改配置&quot;&gt;3.3 修改配置&lt;/h3&gt;

&lt;p&gt;编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/services&lt;/code&gt; 在最后一行添加：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zabbix-agent 10050/tcp # Zabbix Agent
zabbix-agent 10050/udp # Zabbix Agent
zabbix-trapper 10051/tcp # Zabbix Trapper
zabbix-trapper 10051/udp # Zabbix Trapper
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于安装了server和agentd两个进程，所以在&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/zabbix/zabbix/etc&lt;/code&gt;目录下有&lt;code class=&quot;highlighter-rouge&quot;&gt;zabbix_server.conf、zabbix_agentd.conf&lt;/code&gt;对应两个进程的配置文件，下面就要修改这两个文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi zabbix_server.conf

DBName=zabbix #数据库名称

DBUser=zabbix #数据库用户名

DBPassword=123456 #数据库密码

ListenIP=127.0.0.1 #数据库ip地址

AlertScriptsPath=/Users/zabbix/zabbix/share/zabbix/alertscripts #zabbix运行脚本存放目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi zabbix_agentd.conf

Server=127.0.0.1  #服务端Server的IP，配置此项agentd会被动等待服务端拉去监控数据

ListenIP=127.0.0.1 #客户端agentd的IP

ServerActive=127.0.0.1	#服务端Server的IP，配置此项agentd会主动向服务端推送监控数据

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加系统软连接&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ln -s /Users/zabbix/zabbix/sbin/* /usr/sbin/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;34-配置web&quot;&gt;3.4 配置Web&lt;/h3&gt;

&lt;p&gt;在zabbix源码包的&lt;code class=&quot;highlighter-rouge&quot;&gt;frontends&lt;/code&gt;目录下存放zabbix的前端php文件，此时需将这些文件复制到Apache HTTP Server服务维护的目录。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp -r /User/zabbix/src/	zabbix-3.2.1/frontends/php /usr/local/httpd/htdocs/zabbix
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后启动服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apachectl start;	# 启动Apache HTTP Server服务
sudo zabbix_server;		# 启动zabbix server服务
sudo zabbix_agentd;		# 启动zabbix agentd服务
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时，可在浏览器访问&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost/zabbix&lt;/code&gt;进行Web配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/zabbix/img1.png&quot; alt=&quot;img1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;访问可看到上面的欢迎页面，点击下一步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/zabbix/img2.png&quot; alt=&quot;img2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从欢迎页面来的上面的页面，此页面展示zabbix检测必要配置的结果，主要检测PHP对于zabbix的各项支持，当所有必要项都检测通过(即最后字段显示OK)，方可进行下一步，否则需要重新配置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/zabbix/img3.png&quot; alt=&quot;img3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;配置检查通过点击下一步来到第三个页面，此处主要是配置数据库连接，填写上mysql数据库的信息后点击下一步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/zabbix/img4.png&quot; alt=&quot;img4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此处主要填写server的IP、端口和名称。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/zabbix/img5.png&quot; alt=&quot;img5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;来到最后一个配置页面，这里是zabbix自动生成的php页面配置文件，下载此文件放置在zabbix页面目录下的conf目录下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/wanghui/zabbix/img6.png&quot; alt=&quot;img6&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击finish后，跳转至登录页面，默认账号/密码是&lt;code class=&quot;highlighter-rouge&quot;&gt;admin/zabbix&lt;/code&gt;，至此，zabbix安装完毕。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;part4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4-问题汇总&quot;&gt;4. 问题汇总&lt;/h2&gt;

&lt;p&gt;在这里列举了几个安装过程中遇到的问题和解决办法，以便以后查阅。&lt;/p&gt;

&lt;h3 id=&quot;41-mysql-lib-缺失&quot;&gt;4.1 mysql lib 缺失&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error while loading shared libraries: libmysql.so.20: cannot open shared object file: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在mac os中，mysql的安装目录中的lib目录下有&lt;code class=&quot;highlighter-rouge&quot;&gt;libmysqlclient.20.dylib&lt;/code&gt;，可将此文件复制到&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/sbin&lt;/code&gt;中，创建软链接解决。&lt;/p&gt;

&lt;h3 id=&quot;42-libjpeg相关问题&quot;&gt;4.2 libjpeg相关问题&lt;/h3&gt;

&lt;h4 id=&quot;421-configure时报错&quot;&gt;4.2.1 configure时报错&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-bash: ./configure: /bin/sh^M:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此问题是系统编码不同而引起的，libjpeg貌似是在windows系统下开发的，configure文件的系统编码是dos，此时在mac下执行需要改为unix。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi configure 			# vi 编辑configure文件

:set ff=unix			# 修改系统编码

:wq						# 保存退出
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;422-目录不存在&quot;&gt;4.2.2 目录不存在&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-c -m 644 ./cjpeg.1 　/usr/local/man/man1/cjpeg.1　　/usr/bin/install: cannot create regular file 　　`/usr/local/man/man1/cjpeg.1': No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此问题是安装目录未创建导致，与大多数库不同，libjpeg不会自动创建安装目录，需要自己手动创建。&lt;/p&gt;

&lt;h4 id=&quot;423-libtool库缺失&quot;&gt;4.2.3 libtool库缺失&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./libtool --mode=compile mipsel-linux-gcc -O2  -I. -c ./jcapimin.c  \ make: ./libtool: Command not found \make: *** [jcapimin.lo] Error 127
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;缺少&lt;code class=&quot;highlighter-rouge&quot;&gt;libtool&lt;/code&gt;库，需要自行安装。&lt;/p&gt;

&lt;p&gt;安装&lt;code class=&quot;highlighter-rouge&quot;&gt;libtool&lt;/code&gt;后，需要复制&lt;code class=&quot;highlighter-rouge&quot;&gt;libtool&lt;/code&gt;的配置文件覆盖到&lt;code class=&quot;highlighter-rouge&quot;&gt;libjpeg&lt;/code&gt;目录下的，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp /usr/local/share/libtool/config.sub /usr/local/src/jpeg-6b/
cp /usr/local/share/libtool/config.guess /usr/local/src/jpeg-6b/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;之后才可安装&lt;code class=&quot;highlighter-rouge&quot;&gt;libjpeg&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;43-动态安装php扩展&quot;&gt;4.3 动态安装php扩展&lt;/h3&gt;

&lt;p&gt;有时安装了php后，发现忘记安装某项扩展，此时可使用&lt;code class=&quot;highlighter-rouge&quot;&gt;phpize&lt;/code&gt;命令进行动态安装，避免重新整体安装php。&lt;/p&gt;

&lt;p&gt;在php的源码包的&lt;code class=&quot;highlighter-rouge&quot;&gt;ext&lt;/code&gt;目录下存放着大部分扩展的源文件，本机是在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/src/php-5.6.28/ext&lt;/code&gt;目录中，例如此时要动态安装&lt;code class=&quot;highlighter-rouge&quot;&gt;gd&lt;/code&gt;库。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/src/php-5.6.28/ext/gd;		# 进入gd扩展源码目录

/usr/local/php/bin/phpize;					# 使用phpize命令建立外挂模块

# 配置
./configure \
--with-php-config=/usr/local/php/bin/php-config \ # 指定php-config目录
--with-jpeg-dir=/usr/local/jpeg/ \	# 添加jpeg支持
--with-freetype-dir=/usr/local/freetype/ \    # 添加freetype支持
--with-png-dir=/usr/local/png/；    # 添加png支持

make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装完毕后要在&lt;code class=&quot;highlighter-rouge&quot;&gt;php.ini&lt;/code&gt;配置文件中加入扩展模块的信息：&lt;code class=&quot;highlighter-rouge&quot;&gt;extension = “memcache.so”&lt;/code&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Google地图入门</title>
   <link href="http://www.blogways.net/blog/2016/12/16/Google-Map-introduction.html"/>
   <updated>2016-12-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/16/Google-Map-introduction</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link1&quot;&gt;Google地图简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link2&quot;&gt;创建一个简单的 Google 地图&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;总结与心得&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一google地图简介&quot;&gt;一.Google地图简介&lt;/h2&gt;

&lt;p&gt;GoogleMapsAPI除了帮助开发者将地图嵌入到Web应用中之外，还允许开发者利用JavaScript脚本进行应用开发拓展，给地图添加标注和路径及其他图层覆盖物，或者响应用户的点击动作，并显示包含内容信息在内的气泡提示窗口。&lt;/p&gt;

&lt;p&gt;通过GoogleMaps为开发者提供的地图API，可以开发出各种各样有趣的地图Mash-up应用，还可以将不同地图图层加载到应用中，如卫星影像、根据海拔高度绘制的高山和植被地形图、街道视图等，从而帮助开发者打造个性化的地图应用站点。&lt;/p&gt;

&lt;p&gt;Google 地图 API 是一种通过 JavaScript 将 Google 地图嵌入到您的网页的 API。该 API 提供了大量实用工具用以处理地图,并通过各种服务向地图添加内容，从而使您能够在您的网站上创建功能全面的地图应用程序。&lt;/p&gt;

&lt;p&gt;地图 API 是一项免费的服务，任何非盈利性网站均可使用。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二创建一个简单的-google-地图&quot;&gt;二.创建一个简单的 Google 地图&lt;/h2&gt;

&lt;p&gt;我们通过引入插件的方式创建Google地图&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://maps.googleapis.com/maps/api/js?key=AIzaSyDY0kkJiTPVd2U7aTOAwhc9ySH6oHxOIYM&amp;amp;sensor=false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;mapProp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;center&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;maps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;LatLng&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;51.508742&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.120850&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;zoom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;mapTypeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;maps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;MapTypeId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ROADMAP&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;maps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementById&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;googleMap&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mapProp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;google&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;maps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addDomListener&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'load'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;googleMap&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;style=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width:500px;height:380px;&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1应用为什么要声明-html5&quot;&gt;1.应用为什么要声明 HTML5?&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;&lt;/code&gt;大多数浏览器使用 “标准模式” 的 HTML5 文档渲染页面，这就意味着你的应用是兼容各大浏览器的。&lt;/p&gt;

&lt;p&gt;另外，如果没有DOCTYPE标签，浏览器则使用混杂模式 (quirks mode)进行渲染页面内容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;： 应该注意的是一些”混杂模式 “中的CSS并不能使用与标准模式中。在具体的应用中，所有基于百分比的大小都必须从父块元素继承 。如果在父模块中没有指定大小，默认值为 0 x 0 像素。如果你想使用百分比，可以在&lt;style&gt; 标签中声明，如下所示：&lt;/style&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;style type=&quot;text/css&quot;&amp;gt;
html {height:100%}
body {height:100%;margin:0;padding:0}
#googleMap {height:100%}
&amp;lt;/style&amp;gt; 这个样式声明表明地图模块的（GoogleMap）应 HTML高度为100%。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2添加-google-地图-api-key&quot;&gt;2.添加 Google 地图 API Key&lt;/h3&gt;

&lt;p&gt;在以下实例中第一个&lt;script&gt; 标签中必须包含 Google 地图 API：&lt;/script&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;http://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;amp;sensor=TRUE_OR_FALSE&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将google生成的 API key 放置于 key 参数中(key=YOUR_API_KEY)。
&lt;strong&gt;sensor&lt;/strong&gt;
这个参数是必须的，该参数用于指明应用程序是否使用一个传感器 (类似 GPS 导航) 来定位用户的位置。参数值可以设置为 true 或者 false。
&lt;strong&gt;HTTPS&lt;/strong&gt;
如果你的应用是安全的HTTP(HTTPS:HTTP Secure)应用,你可以使用 HTTPS 来加载 Google 地图 API：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&amp;amp;sensor=TRUE_OR_FALSE&quot;&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3异步加载&quot;&gt;3.异步加载&lt;/h3&gt;

&lt;p&gt;同样我们也可以在页面完全载入后再加载 Google 地图 API。
以下实例使用了 window.onload 来实现页面完全载入后加载 Google 地图 。 loadScript() 函数创建了加载 Google 地图 API     &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签。此外在标签的末尾添加了 callback=initialize 参数， initialize()作为回调函数会在API完全载入后执行：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实例&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function loadScript()
{
var script = document.createElement(&quot;script&quot;);
script.src = &quot;http://maps.googleapis.com/maps/api/js?      key=AIzaSyDY0kkJiTPVd2U7aTOAwhc9ySH6oHxOIYM&amp;amp;sensor=false&amp;amp;callback=initialize&quot;; document.body.appendChild(script);
}

window.onload = loadScript;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4定义地图属性&quot;&gt;4.定义地图属性&lt;/h3&gt;
&lt;p&gt;在初始化地图前，我们需要先创建一个 Map 属性对象来定义一些地图的属性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var mapProp = {
  center:new google.maps.LatLng(51.508742,-0.120850),
  zoom:7,
  mapTypeId: google.maps.MapTypeId.ROADMAP
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;center（中心点）&lt;/strong&gt;
中心属性指定了地图的中心，该中心通过坐标（纬度，经度）在地图上创建一个中心点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Zoom（缩放级数）&lt;/strong&gt;
zoom 属性指定了地图的 缩放级数。zoom: 0
显示了整个地球地图的完全缩放。&lt;/p&gt;

&lt;p&gt;MapTypeId（地图的初始类型）&lt;/p&gt;

&lt;p&gt;mapTypeId 属性指定了地图的初始类型。&lt;/p&gt;

&lt;p&gt;mapTypeId包括如下四种类型：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;google.maps.MapTypeId.HYBRID：显示卫星图像的主要街道透明层&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;google.maps.MapTypeId.ROADMAP：显示普通的街道地图&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;google.maps.MapTypeId.SATELLITE：显示卫星图像&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;google.maps.MapTypeId.TERRAIN：显示带有自然特征（如地形和植被）的地图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;在哪里显示 Google 地图&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通常 Google 地图使用于&lt;code class=&quot;highlighter-rouge&quot;&gt; &amp;lt;div&amp;gt;&lt;/code&gt; 元素中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;googleMap&quot; style=&quot;width:500px;height:380px;&quot;&amp;gt;
&amp;lt;/div&amp;gt; &amp;gt;注意： 地图将以div中设置的大小来显示地图的大小，所以我们可以在   `&amp;lt;div&amp;gt;`元素中设置地图的大小。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5创建一个-map-对象&quot;&gt;5.创建一个 Map 对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map=new google.maps.Map(document.getElementById(&quot;googleMap&quot;)
,mapProp); 以上代码使用参数(mapProp)在&amp;lt;div&amp;gt; 元素 (id为googleMap) 创建了一个新的地图。 &amp;gt;提示：如果想在页面中创建多个地图，你只需要添加新的地图对象即可。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下实例定义了四个地图实例 (四个地图使用了不同的地图类型):
实例:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var map = new google.maps.Map(document.getElementById(&quot;googleMap&quot;),mapProp);
var map2 = new google.maps.Map(document.getElementById(&quot;googleMap2&quot;),mapProp2);
var map3 = new google.maps.Map(document.getElementById(&quot;googleMap3&quot;),mapProp3);
var map4 = new google.maps.Map(document.getElementById(&quot;googleMap4&quot;),mapProp4);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6加载地图&quot;&gt;6.加载地图&lt;/h3&gt;
&lt;p&gt;窗口载入后通过执行 initialize() 函数来初始化 Map 对象，这样可以确保在页面完全载入后再加载 Google 地图：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;google.maps.event.addDomListener(window, 'load', initialize);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;link3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;三总结与心得&quot;&gt;三.总结与心得&lt;/h3&gt;

&lt;p&gt;最近在做凤来的临柜时长，涉及了山西地图等问题，用的是echart地图来画，偶然看到了Google地图API插件，做出来的效果不错，如果有兴趣大家可以深入的了解一下。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>新设计趋势观察</title>
   <link href="http://www.blogways.net/blog/2016/12/14/Design-Trends.html"/>
   <updated>2016-12-14T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/14/Design-Trends</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#intro&quot;&gt;概述&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#names&quot;&gt;卡片式设计&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#replace1&quot;&gt;微交互将会大量主导产品设计细节&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#replace2&quot;&gt;颜色，字体和质感将成为设计师追捧利器&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#replace3&quot;&gt;The internet of everything 人的距离将会无限被拉近&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;概述--&quot;&gt;概述  &lt;a id=&quot;intro&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;用户体验已经迎来了它的“黄金时代”。在未来，当对微小细节的关注渗入用户体验设计的每一寸土壤；当对像素级完美的追求成为设计的基本要求；当将简单便捷的设计理念融入用户的日常生活，那么我们就能够帮助用户体验全新的生活。&lt;/p&gt;

&lt;h2 id=&quot;一卡片式设计-&quot;&gt;一、卡片式设计 &lt;a id=&quot;names&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;卡片式设计在所有的媒介和设备上，已经成为设计常用的一种方式，卡片设计的应用不仅仅只是一种趋势。有数据显示2014年，移动端使用率远远高于桌面端，网页设计都能很好的适应小屏幕。这个结论就是：简单的界面风格，比如：扁平化设计，极简设计，尤其是卡片设计比往年都要流行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. UI卡片在移动端和响应式设计中的应用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;卡片为响应式框架提供了出色的兼容性，有人把它称为“网页的未来”。这种设计能够在移动端随意很好的转换。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/2.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先，它能够自己扩展或者收缩去适应任何屏幕的尺寸。设计师可以很灵活的控制卡片的比例，还可以设计固定的宽度和一致的间距来适应可变动的高度，几组卡片能够更好的适应彼此。下面的移动端截图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/3.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;他们两个的文本信息、图像和颜色的风格都是一致的。卡片设计让用户在不同的设备上有一致性的体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 卡片设计的未来&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;卡片设计模式不断适应新的挑战，而响应式和移动端也许会受最大的影响。这种设计流行是未来发展趋势。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/4.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.1 &lt;strong&gt;技术&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;卡片不可能永远是静态的，随着网络性能的提高，也能够支持更丰富的多媒体内容。可能会看到更多细节的元素，比如自动更新内容但是不会影响整个用户体验。视频能更换图片也许会变得很流行，更具有创意，一些GIF动画功能让整个页面体验非常愉悦。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/5.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/6.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2.2 &lt;strong&gt;尺寸&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;图片并列的布局趋势，也让卡片更好的使用大尺寸屏幕。大卡片上能布局更多的细节和复杂的字体，它从视觉上让用户感觉很舒服。大小卡片交替的时候，大卡片在视觉上更让人感觉舒服。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/7.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有些卡片有链接，有些卡片是静态的信息。大小不同的卡片呈现方式，让整个页面更有呼吸感。&lt;/p&gt;

&lt;p&gt;2.3 &lt;strong&gt;“年龄响应式”设计&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据不同消费者群体的兴趣差异来“定制”内容。网页广告已经在这方面试水了一段时间，是时候轮到网站内容本身了：一个8岁的孩子和一位80岁的老人显然不会对同一本书、同一块表感兴趣，也不太会看同一栏电视节目，那么为什么要让他们拥有完全一致的上网体验呢？网站应该告别一成不变的“成衣”，走向“私人订制”。&lt;/p&gt;

&lt;p&gt;到2017年，大量的元数据将成为“年龄响应式网站”的基本特征：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;导航目录的长短可以根据用户的理解能力进行伸缩；那些接收大量信息相对困难的人将会看到简约的交互界面，从而更方便地从有限但更为熟悉的信息入手。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;网站字体、字号与间距能够为了照顾老年人的视力而自然变大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配色方案也会调整：年轻人会体验到饱和度更高的色彩；而老年人则会看到相对柔和的颜色。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二微交互将会大量主导产品设计细节-&quot;&gt;二、微交互将会大量主导产品设计细节 &lt;a id=&quot;replace1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;微交互这个概念其实早在2013年底就被提出了。 Designing for details－微交互，不是只在小范围收到空间时间概念限制的交互，而是细微的，细节的，有人性化的交互，通过细节对于用户进行引导。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/1.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/2.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三颜色字体和质感将成为设计师追捧的视觉利器-&quot;&gt;三、颜色、字体和质感将成为设计师追捧的视觉利器 &lt;a id=&quot;replace2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Gradients(渐变色)，火了去年整整一年了。但是仅仅是渐变，不能满足设计的要求。这一年里，层出不穷更是各样的文章表示现在是终结纯扁平化的时候了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现下很多视觉方案，已经在努力突破扁平的桎梏，向着更有意思的趋势发展起来了。比如大字体，强对比，新的iOS 10阴影等等。毕竟，审美会疲劳，而用户面对如此大的信息量，这是对于视觉设计，排版，字体研究等的真正考验。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/3.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四the-internet-of-everything-人的距离将会无限被拉近-&quot;&gt;四、The internet of everything 人的距离将会无限被拉近 &lt;a id=&quot;replace3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;物联网，智能家居，人工智能，O2O都不是新词汇了，但现实中我们还不会在短时间之内真正做到普及，但是在这个概念先行设计紧随其后的时代，应该快速的适应现在的技术并延伸到生活的方方面面，我们今后的设计不会再简单的是个登录页面，而是你连接实体和虚无的高复杂度抽象交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;作为设计师的我们，应该感谢无数工程师的努力，技术的革新，使得我们的很多设计理想都成为了现实，那么下一个即将实现的梦想，就是人和人之间的距离。靠更稳定的沟通桥梁技术，和我们在设计中引入情感化设计元素并加以思考，将人与人之间的距离缩短。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/Design-Trends/10.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>移动APP导航设计的选择及利弊对比</title>
   <link href="http://www.blogways.net/blog/2016/12/13/app-navigation.html"/>
   <updated>2016-12-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/13/app-navigation</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter&quot;&gt;概述&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter1&quot;&gt;标签式导航（tab式导航）&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter2&quot;&gt;抽屉式导航&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter3&quot;&gt;列表式导航&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter4&quot;&gt;平铺式导航&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter5&quot;&gt;宫格式导航&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter6&quot;&gt;悬浮icon导航&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter7&quot;&gt;更多自由导航&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#chapter8&quot;&gt;最后总结&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;概述&quot;&gt;概述&lt;a id=&quot;chapter&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;不同的产品需求和商业目标决定了不同的导航框架的设计模式。当确定了移动APP的设计需求和APP产品设计流程之后，就开始着手设计APP界面UI或是APP原型图。这个时候要面临的第一个问题就是如何将信息以最优的方式组合起来，使之逐渐丰富血肉。从我们一些常用的产品去分析和了解APP导航设计是非常必要的。适合的导航模式，是产品设计中的关键一环，对整个app的核心体验起到关键作用。&lt;/p&gt;

&lt;p&gt;首先，要给组织信息分层，要做好信息层级的扁平化，不能把所有的组织信息都铺出来，这样做只会让用户心烦意乱找不到想要的重要操作，也不能把层级做的很深，用户没有那么多耐心跟你玩躲猫猫。要将做核心、最稳固、最根本的功能要素放在第一层页面，其他得内容收在第二层、第三层、甚至更深。&lt;/p&gt;

&lt;p&gt;移动端的导航模式一般分为以下几种（很多优秀的app都是基于这些模式做了一些创新的优化方案），以下总结了目前通用且流行的模式，及模式适用的场景，以方便设计师更快的作出较合理的信息组织决策。&lt;/p&gt;

&lt;h2 id=&quot;一标签式导航tab式导航-&quot;&gt;一、标签式导航（tab式导航） &lt;a id=&quot;chapter1&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;tab式导航分为底部tab式导航和顶部tab式导航，是移动应用中最普遍、最常用的导航模式，观察一下自己手机中常用的APP你就会发现QQ、微信、淘宝、微博、美团、京东等全部都是tab式导航。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/1.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;tab式导航设计之所以这么设计是由我们操作手机的习惯决定的，我们单手拿手机的时候，拇指的可控范围有限，缺乏灵活度。尤其是在如今的大屏手机上，拇指的可控范围还不到整个屏幕的三分之一——主要集中在屏幕底部、与拇指相对的另外一边。如拇指的热区如上图图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;tab模式导航在iOS和Android上一直是最安全的一种导航模式，它不怎么出彩，但是绝对不会犯错。在大屏幕时代，底部Tab模式的导航更能适应，也更好设计。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;适用于：入口分类数目不多，可以控制在5个以内，且用户需要在入口间频繁切换来执行多个任务&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意：结构太过复杂而且不稳定的应用不适合标签式导航。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二抽屉式导航-&quot;&gt;二、抽屉式导航 &lt;a id=&quot;chapter2&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;经常和底部tab式导航结合使用的抽屉式导航，称之为优雅的隐喻。抽屉式导航将部分信息内容进行隐藏，突出了应用的核心功能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但是，抽屉栏式导航有两大缺陷：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在大屏幕手机上，单手持握时处于操作盲区，难以点击；&lt;/li&gt;
  &lt;li&gt;抽屉式导航可能会降低你产品一半的用户参与度；
到底什么时候适合用侧导航呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果应用主要的功能和内容都在一个页面里面。只是一些用户设置这类低频操作内容需要显示在其他页面里。为了让主页面看上去干净美观，可以把这些辅助功能放在抽屉栏里。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果应用有不同的视图，且他们是平级的，需要用户同等地对待，抽屉栏将会浪费掉大多数的用户对于侧边栏中入口的潜在参与度和交互程度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在大屏时代使用抽屉栏，手势操作显得尤为重要，从屏幕边缘唤出抽屉栏是个不错的选择。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三列表式导航-&quot;&gt;三、列表式导航 &lt;a id=&quot;chapter3&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;列表式导航结构简单清晰、易于理解、冷静高效，能够帮助用户快速定位到对应内容。&lt;/p&gt;

&lt;p&gt;列表式导航在APP中的应用也分为两种:&lt;/p&gt;

&lt;h3 id=&quot;1-作为主导航使用&quot;&gt;1. 作为主导航使用&lt;/h3&gt;
&lt;p&gt;如果这款APP主要表达的信息层级较为单一，且并不会在入口间频繁且反复跳转，那么将列表式导航作为主导航是一种不错的选择。例如杂志Elle，作为一个杂志APP，他以文字、图片表达为主，层级浅且内容评级，用列表式导航作为主导航来构架内容，简单而直接。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-作为辅助导航来展示二级甚至更深层级的内容&quot;&gt;2. 作为辅助导航来展示二级甚至更深层级的内容&lt;/h3&gt;
&lt;p&gt;几乎在所以APP中都能看到它的应用，作为信息梳理条目，列表数量尽量保持在一屏以内，超过一屏最好再分一级，而且按照人一次只能记住4项事物的心理法则最重要的内容归纳在前4个列表更容易被人们记住。如果不同种类的内容放在同一页面，那么要注意为这些内容分类，比如微信的设置页面，用留白的方式来区分内容的不同。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;列表式导航大多作为辅助导航来展示二级甚至更深层次的内容，若要作为主导航，必须满足层级浅且内容平级的条件&lt;/p&gt;

&lt;p&gt;需要注意的是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;列表式导航的数量保持在一屏以内，超过一屏最好再分一级，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将最终要的内容归纳在前4个列表更容易被人们记住&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;要注意为列表内容分类。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四平铺式导航-&quot;&gt;四、平铺式导航 &lt;a id=&quot;chapter4&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;当信息足够扁平，可以尝试平铺式导航。这种导航方式很容易带来高大上的视觉体验，最大程度的保证了页面的简洁性和内容的完整性，且一般都会结合滑动切换的手势，操作起来也非常方便。PChouse是一个家居杂志的APP，杂志休闲随意的特质，非常适合平铺式导航，最大限度的保持了图片的完整性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;但缺点是用户只能切换的相邻页面，很难跳转到非相邻的页面，很容易迷失位置，因此平铺式导航都会添加几个小点来指示当前位置。如墨迹天气中切换城市的操作就运用了平铺式导航，优点是可以在一个页面完整展示当前城市的情况，快速切换到其他城市。但如果你设置的城市比较多，就很难快速定位到某个城市，但所幸手势操作切换方便，且正常情况下，用户最多只会设置2-3个页面，不会造成太大的负担。&lt;/p&gt;

&lt;p&gt;淘宝中的店铺推荐也使用了平铺式导航，推荐店铺虽然有40个之多，但用数字表达出了明确位置的同时，也加入了手势切换，增加了易用性和趣味性。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/10.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;轮播式导航比较适用于足够扁平化的内容和随意浏览的阅读模式&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的是：无法跳转至费相邻页面，如果入口间需要反复跳转，则不适合这种模式&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五宫格式导航-&quot;&gt;五、宫格式导航 &lt;a id=&quot;chapter5&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;这种导航模式非常常见，但是却不常用。
常见是因为，无论你用的是Android还是iOS，每天一打开手机就是宫格式导航。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/11.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每一个APP都是一个宫格，这些宫格聚集在中心页面，用户只能在中心页面进入其中一个宫格，如果想要进入另一个宫格，必须要先回到中心页面，再进入另一个宫格。每个宫格相互独立，它们的信息间也没有任何交集，无法跳转互通。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;APP的主导航用了宫格式导航只能找到一个最常用的-美图秀秀。美图秀秀给我的体验是这样的:进入美图秀秀-打开一张图片-进入人像美容-祛斑祛痘、放大眼睛、瘦个脸-保存图片-再进入美化图片-加个特效-再次保存。这样做的结果是流程复杂，而且需要多存了一张没用的照片，还要到照片里进行删除。&lt;/p&gt;

&lt;p&gt;这就是宫格式导航的缺陷，信息互斥，无法相互通达，只能给用户带来了更多的操作步骤。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;宫格式导航适合入口相互独立互斥，且不需要交叉使用的信息归类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一旦入口需要有所交集，必然导致更多的操作负累，这个时候只能根据产品特性做出权衡，如果不适合，建议果断拒绝这种方式。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;六悬浮icon导航-&quot;&gt;六、悬浮icon导航 &lt;a id=&quot;chapter6&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;悬浮icon导航，是将导航页面分层，无论你到达APP的哪个页面，悬浮icon永远悬浮在上面，你依靠悬浮层随时可以去想要去的地方，同时，为了让悬浮icon不遮挡某个页面的操作，通常悬浮的icon都可以在屏幕边缘自由移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/13.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;iOS系统就运用了这种导航模式-Assistive Touch，悬浮icon在大屏幕时代发挥的作用，当你单手持握手机，拇指在手机中部浏览，你想回到主屏幕，但是手指却难以到达屏幕底部，悬浮方块在这个时候就能为你提供快捷操作。&lt;/p&gt;

&lt;p&gt;在Android的Material Design中，同样提出了悬浮icon的设计概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/app-navigation/14.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;悬浮式icon是一个非常便捷的操作入口，也适应大屏幕时代。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要注意的是：悬浮式icon会遮挡某些页面的操作，在设计的时候应该考虑进去，比如无论在那个页面永远为悬浮icon留有位置。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某些信息层级繁多且复杂的APP，让用户自主决定是否需要调出悬浮式icon，或者让用户自定义菜单会更加符合用户的心理预期。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;七更多自由-&quot;&gt;七、更多自由 &lt;a id=&quot;chapter7&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;总结的导航其实只有6种，但大家一定不能被现有的导航模式所束缚，未来会有新的导航模式，新的操作手势…设计的心应该是自由的，可突破规则，甚至建立自己的规则。&lt;/p&gt;

&lt;h2 id=&quot;最后总结-&quot;&gt;最后总结 &lt;a id=&quot;chapter8&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;总结的导航其实只有6种，但大家一定不能被现有的导航模式所束缚，未来会有新的导航模式，新的操作手势…设计的心应该是自由的，可突破规则，甚至建立自己的规则。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;标签式导航&lt;/strong&gt;：最常用、最不易出错，请第一时间考虑它；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;抽屉式导航&lt;/strong&gt;：如果你的信息层级繁多，可以考虑将辅助类内容放在抽屉中；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;列表式导航&lt;/strong&gt;：作为辅助导航来展示二级甚至更深层级的内容，每个APP必不可少，但请注意数量与分类；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;平铺式导航&lt;/strong&gt;：如果你的内容是随意浏览，无需来回跳转的，可以考虑它；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;宫格式导航&lt;/strong&gt;：不建议在APP中作为主导航使用，如果非使用不可，请增加跳转的关联性；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;悬浮式导航&lt;/strong&gt;：更适应大屏的导航模式，不妨试一试，但注意不要让它遮挡住某些页面的操作；&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Vert.x-web</title>
   <link href="http://www.blogways.net/blog/2016/12/12/vert.x-web.html"/>
   <updated>2016-12-12T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/12/vert.x-web</id>
   <content type="html">&lt;h2 id=&quot;一vertx-web介绍&quot;&gt;一、Vert.x-web介绍&lt;/h2&gt;
&lt;p&gt;1、Vert.x-web基于Vert.x core，可以非常简单的构建web应用程序的功能集；&lt;/p&gt;

&lt;p&gt;2、Yoke从Node.js中的Express框架和Ruby世界中的Sinatra获得灵感出来的一个基于Vert.x 2.x框架；&lt;/p&gt;

&lt;p&gt;3、Vertx-web并不是容器，Vert.x-Web强在设计，内部功能并不是完全嵌入，你只需构建应用时只需使用你所需要的；&lt;/p&gt;

&lt;p&gt;4、Vert.x-web可以创建经典的服务器侧Web应用程序、RESTfulweb应用程序、实时(服务器推送)Web应用,或者其他你要实现的某种web应用，应用的类型完全由你决定；&lt;/p&gt;

&lt;p&gt;5、Vert.x-Web非常适合编写RESTful HTTP微服务，但是Vert.x不强制你这样编写应用程序&lt;/p&gt;

&lt;h2 id=&quot;二vertx-web包含的功能&quot;&gt;二、Vert.x-web包含的功能&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;路由(基于方法【get,post】,路径，等)&lt;/li&gt;
  &lt;li&gt;路径的正则表达式匹配&lt;/li&gt;
  &lt;li&gt;从路径中抽取参数&lt;/li&gt;
  &lt;li&gt;内容协商&lt;/li&gt;
  &lt;li&gt;请求体处理&lt;/li&gt;
  &lt;li&gt;请求和响应体大小限制&lt;/li&gt;
  &lt;li&gt;Cookie解析与处理&lt;/li&gt;
  &lt;li&gt;多部分表单（指有表单域和上传的表单）&lt;/li&gt;
  &lt;li&gt;多部分文件上传&lt;/li&gt;
  &lt;li&gt;子路由器&lt;/li&gt;
  &lt;li&gt;会话支持——包括本地（粘滞会话）和集群（非粘滞）&lt;/li&gt;
  &lt;li&gt;CORS（跨区域资源共享）支持&lt;/li&gt;
  &lt;li&gt;错误页处理&lt;/li&gt;
  &lt;li&gt;Basic认证&lt;/li&gt;
  &lt;li&gt;基于认证的重定向&lt;/li&gt;
  &lt;li&gt;JWt (Java Web Toolkit) 基本认证&lt;/li&gt;
  &lt;li&gt;用户/角色/权限认证&lt;/li&gt;
  &lt;li&gt;favicon（指浏览器页面上的图标）处理&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模板支持服务端渲染，支持下列模板引擎&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Handlebars
  Jade
  MVEL
  Thymelea
  Apache FreeMarker
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;响应时间处理器&lt;/li&gt;
  &lt;li&gt;静态文件提供，包括缓存逻辑和目录列表&lt;/li&gt;
  &lt;li&gt;请求超时处理&lt;/li&gt;
  &lt;li&gt;SockJS支持&lt;/li&gt;
  &lt;li&gt;事件总线桥&lt;/li&gt;
  &lt;li&gt;CSRF虚拟跨站请求&lt;/li&gt;
  &lt;li&gt;虚拟主机&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Vert.x-web的大多数特性被实现成处理器，所以要以自己编写。随着时间推移，会在vert.x-web中添加更多内容。我们将在此手册中讨认所有这些特性&lt;/p&gt;

&lt;h2 id=&quot;三vertx-web使用情况调查&quot;&gt;三、Vert.x-web使用情况调查&lt;/h2&gt;

&lt;p&gt;下图为来自网络调查所得web框架排行榜：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/vert-web.png&quot; alt=&quot;vert-web&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看出Vert.x是仅次于spring MVC排名在第二位的框架，可见Vert.x的活跃程度已经很高了。&lt;/p&gt;

&lt;h2 id=&quot;四vertx-web简单例子&quot;&gt;四、Vert.x-web简单例子&lt;/h2&gt;
&lt;p&gt;Vert.x-web本身包含功能很多，这里的例子只是通过Vert.x-web 基于java8（还有ruby、groovy、JavaScript等）实现简单的功能,详细例子可见：https://github.com/vert-x3/vertx-examples/tree/master/web-examples&lt;/p&gt;

&lt;h3 id=&quot;简单hello-word&quot;&gt;简单Hello Word&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class Server extends AbstractVerticle {
	  public static void main(String[] args) {
	    Runner.runExample(Server.class);
	  }
	
	  @Override
	  public void start() throws Exception {
	    Router router = Router.router(vertx);
	    router.route().handler(routingContext -&amp;gt; {
	      routingContext.response().putHeader(&quot;content-type&quot;, &quot;text/html&quot;).end(&quot;Hello World!&quot;);
	    });
	    vertx.createHttpServer().requestHandler(router::accept).listen(8080);
	  }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;页面展现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/vert-http.png&quot; alt=&quot;vert-http&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;简单rest微服务&quot;&gt;简单rest微服务&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public class SimpleREST extends AbstractVerticle {
		  public static void main(String[] args) {
		    Runner.runExample(SimpleREST.class);
		  }		
		  private Map&amp;lt;String, JsonObject&amp;gt; products = new HashMap&amp;lt;&amp;gt;();
		
		  @Override
		  public void start() {			
		    setUpInitialData();			
		    Router router = Router.router(vertx);
		    router.route().handler(BodyHandler.create());
		    router.get(&quot;/products/:productID&quot;).handler(this::handleGetProduct);
		    router.put(&quot;/products/:productID&quot;).handler(this::handleAddProduct);
		    router.get(&quot;/products&quot;).handler(this::handleListProducts);
		    vertx.createHttpServer().requestHandler(router::accept).listen(8080);
		  }
		
		  private void handleGetProduct(RoutingContext routingContext) {
		    String productID = routingContext.request().getParam(&quot;productID&quot;);
		    HttpServerResponse response = routingContext.response();
		    if (productID == null) {
		      sendError(400, response);
		    } else {
		      JsonObject product = products.get(productID);
		      if (product == null) {
		        sendError(404, response);
		      } else {
		        response.putHeader(&quot;content-type&quot;, &quot;application/json&quot;).end(product.encodePrettily());
		      }
		    }
		  }
		
		  private void handleAddProduct(RoutingContext routingContext) {
		    String productID = routingContext.request().getParam(&quot;productID&quot;);
		    HttpServerResponse response = routingContext.response();
		    if (productID == null) {
		      sendError(400, response);
		    } else {
		      JsonObject product = routingContext.getBodyAsJson();
		      if (product == null) {
		        sendError(400, response);
		      } else {
		        products.put(productID, product);
		        response.end();
		      }
		    }
		  }
		
		  private void handleListProducts(RoutingContext routingContext) {
		    JsonArray arr = new JsonArray();
		    products.forEach((k, v) -&amp;gt; arr.add(v));
		    routingContext.response().putHeader(&quot;content-type&quot;, &quot;application/json&quot;).end(arr.encodePrettily());
		  }
		
		  private void sendError(int statusCode, HttpServerResponse response) {
		    response.setStatusCode(statusCode).end();
		  }
		
		  private void setUpInitialData() {
		    addProduct(new JsonObject().put(&quot;id&quot;, &quot;prod3568&quot;).put(&quot;name&quot;, &quot;Egg Whisk&quot;).put(&quot;price&quot;, 3.99).put(&quot;weight&quot;, 150));
		    addProduct(new JsonObject().put(&quot;id&quot;, &quot;prod7340&quot;).put(&quot;name&quot;, &quot;Tea Cosy&quot;).put(&quot;price&quot;, 5.99).put(&quot;weight&quot;, 100));
		    addProduct(new JsonObject().put(&quot;id&quot;, &quot;prod8643&quot;).put(&quot;name&quot;, &quot;Spatula&quot;).put(&quot;price&quot;, 1.00).put(&quot;weight&quot;, 80));
		  }
		
		  private void addProduct(JsonObject product) {
		    products.put(product.getString(&quot;id&quot;), product);
        }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;页面展现：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/vert-rest.png&quot; alt=&quot;vert-rest&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>微信小程序</title>
   <link href="http://www.blogways.net/blog/2016/12/11/wchart-introduction.html"/>
   <updated>2016-12-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/11/wchart-introduction</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link1&quot;&gt;微信小程序简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link2&quot;&gt;工具安装&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;基本介绍&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link4&quot;&gt;代码编写&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link5&quot;&gt;demo&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一微信小程序介绍&quot;&gt;一.微信小程序介绍&lt;/h2&gt;

&lt;p&gt;微信应用号是一个APP应用推广平台，微信应用号目前暂定名为“小程序”，使用微信应用号平台，用户关注一个应用号就如同安装一个App一样，而微信应用号就相当于另一个App Store，主要功能就是应用推广。用户关注一个应用号就如同安装一个App一样，而微信应用号就相当于另一个App Store，主要功能就是应用推广。微信的目的似乎很简单，就是希望把用户使用App的动作都集中在微信上。应用号有两大特色：首先APP功能可以直接通过关注应用号来实现，所以用户就省去了安装下载卸载等等一系列动作，对那些使用频率不高的软件来说，你完全可以用“应用号”代替;另外，用户也免去了不定时下载软件更新包的困扰。&lt;/p&gt;

&lt;p&gt;然而微信应用号要能获取足够多的用户，还得要开发者的支持。毫无疑问，开发者将是微信应用号的最大获益群体。对于开发者而言，应用号可以节省开发成本，并且可以提升研发效率，开发人员只需要研发出一款适用于浏览器应用的产品，就可满足不同操作系统的使用需求。另外，入驻应用号的APP营销推广工作也能取到事半功倍的效果。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二工具安装&quot;&gt;二.工具安装&lt;/h2&gt;

&lt;p&gt;点击https://mp.weixin.qq.com，点击微信小程序，点击工具下载，选择对应的版本，即可安装，这是官方提供编辑工具&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三-基本介绍&quot;&gt;三. 基本介绍&lt;/h2&gt;

&lt;p&gt;开发者工具安装完成后，打开并使用微信扫码登录。选择创建“项目”，填入上文获取到的 AppID ，设置一个本地项目的名称（非小程序名称），比如“我的第一个项目”，并选择一个本地的文件夹作为代码存储的目录，点击“新建项目”就可以了。&lt;/p&gt;

&lt;p&gt;为方便初学者了解微信小程序的基本代码结构，在创建过程中，如果选择的本地文件夹是个空文件夹，开发者工具会提示，是否需要创建一个 quick start 项目。选择“是”，开发者工具会帮助我们在开发目录里生成一个简单的 demo。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/wchart1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;项目创建成功后，我们就可以点击该项目，进入并看到完整的开发者工具界面，点击左侧导航，在“编辑”里可以查看和编辑我们的代码，在“调试”里可以测试代码并模拟小程序在微信客户端效果，在“项目”里可以发送到手机里预览实际效果。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四代码编写&quot;&gt;四.代码编写&lt;/h2&gt;

&lt;h4 id=&quot;创建小程序实例&quot;&gt;创建小程序实例&lt;/h4&gt;

&lt;p&gt;点击开发者工具左侧导航的“编辑”，我们可以看到这个项目，已经初始化并包含了一些简单的代码文件。最关键也是必不可少的，是 app.js、app.json、app.wxss 这三个。其中，.js后缀的是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件。微信小程序会读取这些文件，并生成小程序实例。&lt;/p&gt;

&lt;p&gt;下面我们简单了解这三个文件的功能，方便修改以及从头开发自己的微信小程序。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;app.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;app.js是小程序的脚本代码。我们可以在这个文件中监听并处理小程序的生命周期函数、声明全局变量。调用框架提供的丰富的API，如本例的同步存储及同步读取本地数据。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;App({
  onLaunch: function () {
    //调用API从本地缓存中获取数据
    var logs = wx.getStorageSync('logs') || []
    logs.unshift(Date.now())
    wx.setStorageSync('logs', logs)
  },
  getUserInfo:function(cb){
    var that = this;
    if(this.globalData.userInfo){
      typeof cb == &quot;function&quot; &amp;amp;&amp;amp; cb(this.globalData.userInfo)
    }else{
      //调用登录接口
      wx.login({
        success: function () {
          wx.getUserInfo({
            success: function (res) {
              that.globalData.userInfo = res.userInfo;
              typeof cb == &quot;function&quot; &amp;amp;&amp;amp; cb(that.globalData.userInfo)
            }
          })
        }
      });
    }
  },
  globalData:{
    userInfo:null
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;app.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;app.json 是对整个小程序的全局配置。我们可以在这个文件中配置小程序是由哪些页面组成，配置小程序的窗口背景色，配置导航条样式，配置默认标题。注意该文件不可添加任何注释。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;pages&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pages/index/index&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pages/logs/logs&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;window&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;backgroundTextStyle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;light&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;navigationBarBackgroundColor&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;#fff&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;navigationBarTitleText&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;WeChat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;navigationBarTextStyle&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;black&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;app.wxss&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;app.wxss 是整个小程序的公共样式表。如同web编写的CSS一样，我们可以在页面组件的 class 属性上直接使用 app.wxss中声明的样式规则。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  padding: 200rpx 0;
  box-sizing: border-box;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;基本写作规则和css一样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;创建页面&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这个教程里，我们有两个页面，index 页面和 logs 页面，即欢迎页和小程序启动日志的展示页，他们都在 pages 目录下。微信小程序中的每一个页面的【路径+页面名】都需要写在 app.json 的 pages 中，且 pages 中的第一个页面是小程序的首页。&lt;/p&gt;

&lt;p&gt;每一个小程序页面是由同路径下同名的四个不同后缀文件的组成，如：index.js、index.wxml、index.wxss、index.json。.js后缀的文件是脚本文件，.json后缀的文件是配置文件，.wxss后缀的是样式表文件，.wxml后缀的文件是页面结构文件。&lt;/p&gt;

&lt;p&gt;index.wxml 是页面的结构文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--index.wxml--&amp;gt;
&amp;lt;view class=&quot;container&quot;&amp;gt;
  &amp;lt;view  bindtap=&quot;bindViewTap&quot; class=&quot;userinfo&quot;&amp;gt;
    &amp;lt;image class=&quot;userinfo-avatar&quot; src=&quot;&quot; background-size=&quot;cover&quot;&amp;gt;&amp;lt;/image&amp;gt;
    &amp;lt;text class=&quot;userinfo-nickname&quot;&amp;gt;&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;
  &amp;lt;view class=&quot;usermotto&quot;&amp;gt;
    &amp;lt;text class=&quot;user-motto&quot;&amp;gt;&amp;lt;/text&amp;gt;
  &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt; 本例中使用了 `&amp;lt;view/&amp;gt;`、`&amp;lt;image/&amp;gt;`、`&amp;lt;text/&amp;gt;`来搭建页面结构，绑定数据和交互处理函数。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;index.js&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;index.js 是页面的脚本文件，在这个文件中我们可以监听并处理页面的生命周期函数、获取小程序实例，声明并处理数据，响应页面交互事件等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//index.js
//获取应用实例
var app = getApp()
Page({
  data: {
    motto: 'Hello World',
    userInfo: {}
  },
  //事件处理函数
  bindViewTap: function() {
    wx.navigateTo({
      url: '../logs/logs'
    })
  },
  onLoad: function () {
    console.log('onLoad')
    var that = this
    //调用应用实例的方法获取全局数据
    app.getUserInfo(function(userInfo){
      //更新数据
      that.setData({
        userInfo:userInfo
      })
    })
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;index.wxss&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;index.wxss 是页面的样式表：
​  &lt;br /&gt;
    /&lt;strong&gt;index.wxss&lt;/strong&gt;/
    .userinfo {
      display: flex;
      flex-direction: column;
      align-items: center;
    }&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.userinfo-avatar {
  width: 128rpx;
  height: 128rpx;
  margin: 20rpx;
  border-radius: 50%;
}

.userinfo-nickname {
  color: #aaa;
}

.usermotto {
  margin-top: 200px;
} 页面的样式表是非必要的。当有页面样式表时，页面的样式表中的样式规则会层叠覆盖 app.wxss 中的样式规则。如果不指定页面的样式表，也可以在页面的结构文件中直接使用 app.wxss 中指定的样式规则。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;index.json&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;index.json 是页面的配置文件：&lt;/p&gt;

&lt;p&gt;页面的配置文件是非必要的。当有页面的配置文件时，配置项在该页面会覆盖 app.json 的 window 中相同的配置项。如果没有指定的页面配置文件，则在该页面直接使用 app.json 中的默认配置。&lt;/p&gt;

&lt;p&gt;logs 的页面结构&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--logs.wxml--&amp;gt;
&amp;lt;view class=&quot;container log-list&quot;&amp;gt;
  &amp;lt;block wx:for=&quot;&quot; wx:for-item=&quot;log&quot;&amp;gt;
    &amp;lt;text class=&quot;log-item&quot;&amp;gt;. &amp;lt;/text&amp;gt;
  &amp;lt;/block&amp;gt;
&amp;lt;/view&amp;gt; logs 页面使用  `&amp;lt;block/&amp;gt;` 控制标签来组织代码，在 `&amp;lt;block/&amp;gt;` 上使用 wx:for 绑定 logs 数据，并将 logs 数据循环展开节点

//logs.js
var util = require('../../utils/util.js')
Page({
  data: {
    logs: []
  },
  onLoad: function () {
    this.setData({
      logs: (wx.getStorageSync('logs') || []).map(function (log) {
        return util.formatTime(new Date(log))
      })
    })
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;link5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;五demo编写&quot;&gt;五.demo编写&lt;/h2&gt;

&lt;p&gt;我在网上找了个比较简单上手的小例子，一个读书的demo&lt;/p&gt;

&lt;p&gt;先上个效果图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/wchart2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先我们先要在最下面添加导航,即在app.json中添加tabBar的配置&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &quot;tabBar&quot;: {
     &quot;color&quot;: &quot;#dddddd&quot;,
     &quot;selectedColor&quot;: &quot;#d92121&quot;,
     &quot;borderStyle&quot;: &quot;white&quot;,
     &quot;backgroundColor&quot;: &quot;#fff&quot;,
     &quot;list&quot;: [{
       &quot;pagePath&quot;: &quot;pages/index&quot;,
       &quot;iconPath&quot;: &quot;images/main.png&quot;,
       &quot;selectedIconPath&quot;: &quot;images/main-s.png&quot;,
       &quot;text&quot;: &quot;主页&quot;
     },{
       &quot;pagePath&quot;: &quot;pages/layout/hot&quot;,
       &quot;iconPath&quot;: &quot;images/hot.png&quot;,
       &quot;selectedIconPath&quot;: &quot;images/hot-s.png&quot;,
       &quot;text&quot;: &quot;最热&quot;
     },{
       &quot;pagePath&quot;: &quot;pages/layout/new&quot;,
       &quot;iconPath&quot;: &quot;images/new.png&quot;,
       &quot;selectedIconPath&quot;: &quot;images/new-s.png&quot;,
       &quot;text&quot;: &quot;最新&quot;
     }]
   }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;pagePath，就是此tabBar对应的页面链接&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;然后开始我们的主要工作，即制作主页&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;先看下目录结构，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/wchart3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;即在pages下写我们的js，html和样式表&lt;/p&gt;

&lt;p&gt;我们打开首页index页面&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = getApp();
Page({
  data: {
    indexList:app.getBoookList()
  },
  onLoad: function(options) {
    // Do some initialize when page load.
  },
  onReady: function() {
    // Do something when page ready.
  },
  onShow: function() {
    // Do something when page show.
  },
  onHide: function() {
    // Do something when page hide.
  },
  onUnload: function() {
    // Do something when page close.
  },
  // Event handler.
  viewTap: function() {
    this.setData({
      text: 'Set some data for updating view.'
    })
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到上面的页面生命周期，我们可以在事件中写我们自己要处理的事件。&lt;/p&gt;

&lt;p&gt;其中getApp();方法获取全局实例。&lt;/p&gt;

&lt;p&gt;我们打开视图页面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;view class=&quot;banner&quot;&amp;gt;
  &amp;lt;image src=&quot;../images/banner.jpg&quot; /&amp;gt;
&amp;lt;/view&amp;gt;

&amp;lt;view class=&quot;list clearfix&quot;&amp;gt;
    &amp;lt;view class=&quot;list-item&quot; wx:for=&quot;&quot;&amp;gt;
      &amp;lt;navigator url=&quot;bookList/bookDetails?title=&amp;amp;id=&quot; hover-class=&quot;navigator-hover&quot;&amp;gt; &amp;lt;image src=&quot;&quot; /&amp;gt;&amp;lt;/navigator&amp;gt;
      &amp;lt;view class=&quot;book-name&quot;&amp;gt;
         &amp;lt;navigator url=&quot;bookList/bookDetails?title=&amp;amp;id=&quot; hover-class=&quot;navigator-hover&quot;&amp;gt; &amp;lt;/navigator&amp;gt;
     &amp;lt;/view&amp;gt;
    &amp;lt;/view&amp;gt;

    &amp;lt;view class=&quot;menus&quot;&amp;gt;
      &amp;lt;image src=&quot;../images/menu.png&quot; class=&quot;menu-btn&quot; /&amp;gt;
      &amp;lt;!--&amp;lt;view class=&quot;menu-list&quot; id=&quot;menu-list&quot;&amp;gt;
        &amp;lt;view&amp;gt;本机书架&amp;lt;/view&amp;gt;
        &amp;lt;view&amp;gt;wifi传书&amp;lt;/view&amp;gt;
        &amp;lt;view&amp;gt;云书架&amp;lt;/view&amp;gt;        
      &amp;lt;/view&amp;gt;--&amp;gt;
    &amp;lt;/view&amp;gt;
&amp;lt;/view&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里看到箭头指向的 wx：for=“”，这个是一个出来数组或列表对象的循环方法，而item是默认（又是默认）的单个列表元素。用不不想用item也可以起别名。&lt;/p&gt;

&lt;p&gt;navigator就是导航标签了，这里，类似于html中的&lt;a&gt;标签，就不在说了。点击navigator的内容页面跳转对应页面，同样是用url传递数据。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;打开index.wxss&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.list{
    width: 100%;
    background: #fff;
}
.list-item{
    width: 33.333333%;
    height: 370rpx;
    text-align: center;
    padding-top: 5px;
    float: left;
}
.list-item image {
    width: 80%;
    height: 300rpx;
}
.book-name{
    font-size: 28rpx;
    color: #000;
}
.menus{
    position: fixed;
    bottom: 5px;
    right: 5px;
    border-radius:100%;
    background-color: rgba(0, 0, 0, 0.5);
    text-align: center;
}
.menus image{
    width: 64rpx;
    height: 64rpx;
    vertical-align: middle
}
.banner image {
    width:750rpx;
    height: auto;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看下后台代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = getApp();
Page({
  onLoad: function(options) {
    this.setData({
      title: options.title,
      id:options.id,
      bookDetails:app.getOneBook(options.id)
    })
  }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数据可以通过url传递，目标页面通过onLoad方法中的参数（ 对象）获取。这里还可以看到书的详情是通过全局getApp获取全局实例，获取数据。这个数据就是在全局app.js里面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;App( {
    getBanner:function(){
        var bannerUrl=[&quot;../images/banner.jpg&quot;];
        return bannerUrl;
    },
    getOneBook:function(id){
        var abook;
      var books =  [
                    {   id:&quot;1&quot;,
                        bookUrl:&quot;../images/img1.jpg&quot;,
                        bookName:&quot;西方哲学史&quot;,
                        bookInfor:&quot;关于哲学&quot;
                    }
                    ];
                for(i=0;i&amp;lt;books.length;i++){
                    if(books[i].id == id){
                        abook = books[i];  
                    }
                }
                 return abook;
  },
    getBoookList:function(){
        var indexList = [
                    {   id:&quot;1&quot;,
                        bookUrl:&quot;../images/img1.jpg&quot;,
                        bookName:&quot;西方哲学史&quot;,
                        bookInfor:&quot;关于哲学&quot;
                    }
                    ];

                     return indexList;
                }


})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>vert.x介绍</title>
   <link href="http://www.blogways.net/blog/2016/12/11/vert.x-01.html"/>
   <updated>2016-12-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/11/vert.x-01</id>
   <content type="html">&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;在传统J2EE开发中，用户对生产系统的部署都需依赖昂贵的服务器中间件（如WebLogic、WebSphere，当然也有免费的tomcat等），这些服务器上面部署了大型的程序包，它们运行缓慢，消耗大量的内存，运维人员也需要对服务器有足够了解。随着异步非阻塞、微服务等概念的出现，近年来也涌现了很多不依赖传统容器的服务框架。2009年，Node.js项目启动，它支持异步非阻塞的、基于事件驱动的I/O。如果服务器的线程使用得当，Node.js可以极大地提升响应速度，单个服务器的吞吐量可以媲美一个Java EE服务器集群。同时基于JAVA NIO、AIO（jdk1.7后）原理，也涌现出了一批如Netty、mina等优秀网络框架。其中vert.x、undertow等就是基于这些优秀框架（undertow基于XNIO）诞生的异步无阻塞的网络框架，&lt;/p&gt;

&lt;h2 id=&quot;二vertx-简介&quot;&gt;二、vert.x 简介&lt;/h2&gt;
&lt;p&gt;vert.x，是一个JVM下、轻量级、高性能的应用平台，非常适用于最新的移动端后台、互联网、企业应用，基于Netty实现的异步无阻塞的网络框架，诞生于2011年，当时叫node.x，不过后来因为某些原因改名位Vert.x。经过5年多的发展，现在已经到了3.3.3版本。&lt;/p&gt;

&lt;p&gt;Vert.x是一个异步无阻塞的网络框架，其参照物是node.js。基本上node.js能干的事情，Vert.x都能干。而且Vert.x还支持分布式，与多核利用。通过Hazelcast管理各个Vert.x节点的信息，然后通过EventBus在节点之间互相发消息，于此同时Vert.x还能支持应用的高可用。&lt;/p&gt;

&lt;h3 id=&quot;vertx体系架构&quot;&gt;vert.x体系架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/tangsz/vert-frame.jpg&quot; alt=&quot;vert-frame&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们的业务逻辑其实都是基于verticle来实现的，然后Vert.x框架会将你的verticle绑定到相关的线程模型上，这里verticle1,verticle2是I/O密集型项目，所有的逻辑都会跑在NIO Worker上。而Verticle3会有一些同步的耗时的请求，则会被绑定到Worker线程模型上。另外两个Vert.x节点则通过EventBus互相通信，而EventBus通过HazelCast来获取整个集群里的节点信息。注意这里每一个verticle其实都是一个线程(启动的时候指定实例数目参数即可)，这样可以充分的利用多核。而node.js其实只能通过Cluster来提升多核利用&lt;/p&gt;

&lt;p&gt;一个典型的Vert.x部署场景:
&lt;img src=&quot;/images/tangsz/vert-deploy.jpg&quot; alt=&quot;vert-deploy&quot; /&gt;&lt;/p&gt;

&lt;p&gt;图中业务逻辑被拆成很多小的verticle。这里你可以把这些小的verticle看成是微服务，然后水平扩展这些服务，同时也可以把自己的业务按CPU密集与I/O密集型拆分。服务与服务之间可以通过EventBus互相调用，另外Vert.x的EventBus调用目标verticle的时候会按RoundRobin算法来做balance&lt;/p&gt;

&lt;h2 id=&quot;三vertx中基本概念&quot;&gt;三、vert.x中基本概念&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;/images/tangsz/vert-module.png&quot; alt=&quot;vert-module&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;verticle&quot;&gt;Verticle&lt;/h3&gt;

&lt;p&gt;Vert.x的代码执行包，它可以用JS、Ruby等多语言来编写，在同一个Vert.x实例中可以同时执行多个Verticle，一个应用可能由多个Verticle组成，他们被部署到不同的网络节点上，彼此之间通过在Vert.x的事件总线(event bus)上交换信息来通信。对于具体的verticle可以直接从命令行启动，但是通常会将它打包成modules&lt;/p&gt;

&lt;h3 id=&quot;module&quot;&gt;Module&lt;/h3&gt;
&lt;p&gt;Vert.x应用由一个或多个modules来实现.一个模块由多个verticles来实现.你可以把module想象出一个个Java package.里面可能是特定业务的实现,或者公共的服务实现(那些可以重用的服务).Vert.x编写好的module,可以发布到maven的仓库里.以zip包装成二进制格式.或者发布到vert.x module 注册中心.实际上这种以模块方式的开发,支撑着整个Vert.x生态系统&lt;/p&gt;

&lt;h3 id=&quot;vertx-实例&quot;&gt;Vert.x 实例&lt;/h3&gt;
&lt;p&gt;Verticles 其实是跑在 Vert.x实例上的.所谓Vert.x实例其实就是一个运行在某一个JVM上的Vert.x对象实例.可以将多个Verticles运行在一个Vert.x实例上,而vert.x实例可以跑在单个JVM上,也可以跑在其他JVM上,通过分布式event bus来维持通信.注意vert.x实例其实是由vertx命令行启动的.你可以指定实例数目在单个JVM上&lt;/p&gt;

&lt;h3 id=&quot;event-loop-vertical&quot;&gt;Event Loop Vertical&lt;/h3&gt;
&lt;p&gt;事件的业务处理线程，存在于Event Loop中，用于处理非阻塞短任务&lt;/p&gt;

&lt;h3 id=&quot;event-bus&quot;&gt;Event Bus&lt;/h3&gt;
&lt;p&gt;它是Vert.X的核心，在集群中容器之间的通信，各个Verticle之间的通讯都是经过Event Bus来实现的&lt;/p&gt;

&lt;h3 id=&quot;shared-data共享数据&quot;&gt;Shared Data（共享数据）&lt;/h3&gt;
&lt;p&gt;它是Vert.X提供的一个简单共享Map和Set，用来解决各个Verticle之间的数据共享。&lt;/p&gt;

&lt;h3 id=&quot;worker-vertical-阻塞处理&quot;&gt;Worker Vertical （阻塞处理）&lt;/h3&gt;
&lt;p&gt;事件的业务处理线程，用于处理长任务阻塞任务。
事件处理之外肯定会发生其长时间数据处理请求.比如处理一个图片上传,然后转存到磁盘上等.或者一次长时间的排序计算等.&lt;/p&gt;

&lt;p&gt;在Verticle类型里,有一种特别的verticle叫做Worker.不同于标准的verticle,他不使用event loop.而是采用vert.x内部的另一个线程池叫做worker pool.其区别在于,worker verticles不会并行的执行Handler.而是阻塞式的,等待上一个Handler处理完了,才会再执行后面的请求.你可以想象出队列的方式执行某些请求.所以为了支持标准的与阻塞式的worker verticles, Vert.x提供了一种混合线程模型,你可以选择适当的模型用于你的应用.&lt;/p&gt;

&lt;h2 id=&quot;四vertx特性&quot;&gt;四、vert.x特性&lt;/h2&gt;

&lt;h3 id=&quot;多语言支持&quot;&gt;多语言支持&lt;/h3&gt;
&lt;p&gt;能在JVM上运行的常见语言，都可以直接编写基于Vert.X的应用，目前官方支持的有 Java, JavaScript, CoffeeScript, Ruby, Python or Groovy&lt;/p&gt;

&lt;h3 id=&quot;多服务器客户端支持&quot;&gt;多服务器客户端支持&lt;/h3&gt;
&lt;p&gt;支持编写TCP、UDP客户端和服务器，HTTP客户端和服务器和Websocket支持，Vert.x-Web模块能够实现基于http的微服务框架&lt;/p&gt;

&lt;h3 id=&quot;支持多异步客户端&quot;&gt;支持多异步客户端&lt;/h3&gt;
&lt;p&gt;Vert.x提供了不同的异步客户端，用于从应用程序访问各种数据存储。 当然Vert.x也没有限制你必须用vert.x的客户端，你也可以到下载各软件自己的客户端（如mongoDB自己的），不过vert.x的异步API，提供多了多种语言支持Java、JavaScript、Groovy、Ruby等多语言的支持。从目前官网列出的异步API有：MongoDB client、JDBC client、SQL common、Redis client、MySQL / PostgreSQL client 等。&lt;/p&gt;

&lt;p&gt;除了数据访问层API支持，Vert.x还实现了Mail Client、STOMP Client &amp;amp; Server、TCP 客户端A等PI，同时vert.x也对Eventbus、apache Camel、RabbitMQ等桥接集成了实现，的并支持Java、JavaScript、Groovy、Ruby等多语言。&lt;/p&gt;

&lt;h3 id=&quot;认证和授权&quot;&gt;认证和授权&lt;/h3&gt;
&lt;p&gt;Vert.x目前已经支持Auth common、JDBC auth、JWT auth、Shiro auth、MongoDB auth、OAuth 2等多种认证和授权API，并支持Java、JavaScript、Groovy、Ruby等多语言。&lt;/p&gt;

&lt;h3 id=&quot;微服务支持&quot;&gt;微服务支持&lt;/h3&gt;
&lt;p&gt;在Vert.x3.3.0中，vert.x提供了两个微服务相关特性：服务发现和断路器。其中服务发现是在服务运行时发现，服务位置不要硬编码，可以使用Consul、Kubernetes、redis Docker links等扩展服务发现的支持；另外断路器&lt;/p&gt;

&lt;h3 id=&quot;集群支持&quot;&gt;集群支持&lt;/h3&gt;
&lt;p&gt;vert.x Verticle支持集群部署、支持Verticle的高可用和故障备份。在一个Verticle突然崩溃时，Verticle会被迁移到另外的vert.x实例上。&lt;/p&gt;

&lt;h2 id=&quot;五vertx的使用&quot;&gt;五、vert.x的使用&lt;/h2&gt;
&lt;p&gt;vert.x社区目前已经很活跃，在国内vert.x的用还很少见到，但是在国外已经有很多大公司将vert.x运用到自己的项目中了，以下为vert.x官网列出的部分公司：
&lt;img src=&quot;/images/tangsz/vert-company.png&quot; alt=&quot;vert-company&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>响应式设计学习</title>
   <link href="http://www.blogways.net/blog/2016/12/11/responsive-design.html"/>
   <updated>2016-12-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/11/responsive-design</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link1&quot;&gt;概述&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link2&quot;&gt;布局类型&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;布局实现&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link4&quot;&gt;布局响应&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;响应式设计作为近几年大热的设计趋势，已然是设计师的必备技能之一了。响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。&lt;/p&gt;

&lt;p&gt;响应式设计的发展趋势在2012年被提的比较多，但是响应式设计仍然在不断变化，不断创新。比如，新的设备不断出来(iPad Mini)，这让以前的设计想法土崩瓦解。而各种Web的响应式设计也获得了越来越多的注意，“让人们忘记设备尺寸”的理念将更快地驱动响应式设计，所以Web设计也将迎来更多的响应式设计元素。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二布局类型&quot;&gt;二、布局类型&lt;/h2&gt;

&lt;p&gt;在了解响应式布局前，先了解下网页设计中整体页面排版布局，常见的主要有如下几种类型：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三布局实现&quot;&gt;三、布局实现&lt;/h2&gt;

&lt;p&gt;采用不同方式实现布局设计，也有不同的方式，这里基于页面的实现单位而言，分为四种类型：固定布局、可切换的固定布局、弹性布局、混合布局。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;固定布局：以像素作为页面的基本单位，不管设备屏幕及浏览器宽度，只设计一套尺寸；&lt;/li&gt;
  &lt;li&gt;可切换的固定布局：同样以像素作为页面单位，参考主流设备尺寸，设计几套不同宽度的布局。通过设别的屏幕尺寸或浏览器宽度，选择最合适的那套宽度布局；&lt;/li&gt;
  &lt;li&gt;弹性布局：以百分比作为页面的基本单位，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；&lt;/li&gt;
  &lt;li&gt;混合布局：同弹性布局类似，可以适应一定范围内所有尺寸的设备屏幕及浏览器宽度，并能完美利用有效空间展现最佳效果；只是混合像素、和百分比两种单位作为页面单位。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可切换的固定布局、弹性布局、混合布局都是目前可被采用的响应式布局方式。&lt;/p&gt;

&lt;p&gt;其中可切换的固定布局的实现成本最低，但拓展性比较差；而弹性布局与混合布局效果具响应性，都是比较理想的响应式布局实现方式。&lt;/p&gt;

&lt;p&gt;只是对于不同类型的页面排版布局实现响应式设计，需要采用不用的实现方式。通栏、等分结构的适合采用弹性布局方式、而对于非等分的多栏结构往往需要采用混合布局的实现方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四布局响应&quot;&gt;四、布局响应&lt;/h2&gt;

&lt;p&gt;布局响应对页面进行响应式的设计实现，需要对相同内容进行不同宽度的布局设计，有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;桌面优先（从桌面端开始向下设计）；&lt;/li&gt;
  &lt;li&gt;移动优先（从移动端向上设计）；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;无论基于那种模式的设计，要兼容所有设备，布局响应时不可避免地需要对模块布局做一些变化（发生布局改变的临界点称之为断点，这里作为一个设计就只能为理解为一个区间了），数据员通过JS获取设备的屏幕宽度，来改变网页的布局，这一过程称之为布局响应屏幕。常见的主要有如下几种方式：&lt;/p&gt;

&lt;h3 id=&quot;41-布局不变&quot;&gt;4.1 布局不变&lt;/h3&gt;
&lt;p&gt;布局不变，即页面中整体模块布局不发生变化，主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;模块中内容：挤压－拉伸；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块中内容：换行－平铺；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块中内容：删减－增加；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42-布局改变&quot;&gt;4.2 布局改变&lt;/h3&gt;
&lt;p&gt;布局改变，即页面中的整体模块布局发生变化，主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;模块位置变换；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块展示方式改变：隐藏－展开；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-8.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块数量改变：删减－增加；&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/chenwt/responsive-design-9.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很多时候，单一方式的布局响应无法满足理想效果，需要结合多种组合方式，但原则上尽可能时保持简单轻巧，而且同一断点内保持统一逻辑。否则页面实现得太过复杂，也会影响整体体验。从设计布局方面了解的响应式设计还很片面浅显，希望以后可以跟同事们交流更深入了解响应式设计。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>色彩攻略</title>
   <link href="http://www.blogways.net/blog/2016/12/11/color-strategy.html"/>
   <updated>2016-12-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/11/color-strategy</id>
   <content type="html">&lt;p&gt;&lt;img src=&quot;/images/chenwt/color-strategy.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Esper复杂事件处理引擎 - 入门简介</title>
   <link href="http://www.blogways.net/blog/2016/12/10/esper-introduction.html"/>
   <updated>2016-12-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/10/esper-introduction</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link1&quot;&gt;Esper简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link2&quot;&gt;事件类型&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;处理模型&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link4&quot;&gt;未完待续…&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;style&gt;
.red { color: red; }
.blue { color: blue; }
&lt;/style&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一esper简介&quot;&gt;一、Esper简介&lt;/h2&gt;
&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;Espser&lt;/code&gt;之前，首先要讲&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;，是一种实时事件处理并从大量事件数据流中挖掘复杂模式的技术，全称为Complex Event Processing，即复杂事件处理。&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;是一种标准，&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;只是对这个标准的一种开源实现。&lt;/p&gt;

&lt;p&gt;听起来好像很复杂，实际上就是基于事件流进行数据处理，把要分析的数据抽象成事件，然后将数据发送到&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;引擎，引擎就会根据事件的输入和最初注册的处理模型，得到事件处理结果。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;的一个重要特点就是他是一个&lt;i class=&quot;red&quot;&gt;内存计算&lt;/i&gt;工具和&lt;i class=&quot;red&quot;&gt;类SQL&lt;/i&gt;语句。&lt;/p&gt;

&lt;p&gt;有朋友可能会想到目前很流行的一个实时计算框架——&lt;code class=&quot;highlighter-rouge&quot;&gt;Storm&lt;/code&gt;，但这两个完全不是一类东西。&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;的特点在于它的复杂处理逻辑可以用类SQL语句（EPL）开发，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Storm&lt;/code&gt;的特点在于&lt;strong&gt;&lt;em&gt;并行计算&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;快速恢复&lt;/em&gt;&lt;/strong&gt;，但是计算逻辑是需要自己用代码实现的。&lt;/p&gt;

&lt;p&gt;前面说了，&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;，是&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;的一个开源实现，它是一个Java的事件流处理和复杂事件处理的引擎（.NET为NEsper）。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;引擎可应用于如下等领域：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;网络入侵探测&lt;/li&gt;
  &lt;li&gt;SLA监测&lt;/li&gt;
  &lt;li&gt;RFID读取&lt;/li&gt;
  &lt;li&gt;航空运输调控&lt;/li&gt;
  &lt;li&gt;金融方面(风险管理，欺诈探测)等&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其特点是能够快速开发出复杂的实时计算策略，并且有着高吞吐量以及低延迟的特点，特别适合&lt;i class=&quot;red&quot;&gt;大量数据的实时计算&lt;/i&gt;。&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;后续所有测试例子中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Bean&lt;/code&gt;都没有写出&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;setter&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;toString&lt;/code&gt;，如有需要请自行添加。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;11-epl-简述&quot;&gt;1.1 EPL 简述&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EPL&lt;/code&gt;，即Event Proess Language，&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;的类SQL语句，可以理解为处理模型的定义与描述。&lt;/p&gt;

&lt;p&gt;这是运行在&lt;code class=&quot;highlighter-rouge&quot;&gt;CEP&lt;/code&gt;引擎中的特殊语句，之所以叫他类SQL，是因为它和SQL确实很像，除了&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;，而且也有&lt;code class=&quot;highlighter-rouge&quot;&gt;avg&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;count&lt;/code&gt;等函数。所以对于会SQL的人来说，他的语法结构大致还是能猜出一二的。&lt;/p&gt;

&lt;p&gt;工作模式有点类似于一个数据库的 &lt;i class=&quot;red&quot;&gt;&lt;strong&gt;倒置&lt;/strong&gt;&lt;/i&gt;，它允许应用程序存储查询并让数据通过，而不是存储数据并在存储的数据上运行查询语句（应用程序存储查询，并让数据运行通过）。当匹配查询的条件时，响应逻辑触发。&lt;/p&gt;

&lt;p&gt;数据库是先存储数据，通过编译解析SQL，完成已存储数据的查询，Esper则是先编译EPL语句，形成一个过滤（或处理）层（或者网），实时过来的数据，通过这个过滤层完成有效事件的筛选或形成有效事件。&lt;/p&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from Apple
select avg(price) from Apple.win:length_batch(3)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Created by wanzhou on 16/8/1.
 */
import com.espertech.esper.client.*;

class Apple
{
  private int id;
  private int price;
}

class AppleListener implements UpdateListener
{

  public void update(EventBean[] newEvents, EventBean[] oldEvents)
  {
    if (newEvents != null)
    {
//      Double avg = (Double) newEvents[0].get(&quot;avg(price)&quot;);
//      System.out.println(&quot;Apple's average price is &quot; + avg);
      for (int i = 0; i &amp;lt; newEvents.length; i++) {
        System.out.println(newEvents[i].getUnderlying());
      }
    }
  }

}

public class AverageTest {
  public static void main(String[] args) throws InterruptedException {
    EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();

    EPAdministrator admin = epService.getEPAdministrator();

    EPRuntime runtime = epService.getEPRuntime();

    String product = Apple.class.getName();
    String epl = &quot;select avg(price) from &quot; + product + &quot;.win:length_batch(2)&quot;;
	// String epl = &quot;select * from Apple.win:length_batch(2)&quot;;

    EPStatement state = admin.createEPL(epl);
    state.addListener(new AppleListener());


    Apple apple1 = new Apple();
    apple1.setId(1);
    apple1.setPrice(5);
    runtime.sendEvent(apple1);

    Apple apple2 = new Apple();
    apple2.setId(2);
    apple2.setPrice(2);
    runtime.sendEvent(apple2);

    Apple apple3 = new Apple();
    apple3.setId(3);
    apple3.setPrice(5);
    runtime.sendEvent(apple3);

    Apple apple4 = new Apple();
    apple4.setId(4);
    apple4.setPrice(6);
    runtime.sendEvent(apple4);

    Apple apple5 = new Apple();
    apple5.setId(5);
    apple5.setPrice(7);
    runtime.sendEvent(apple5);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;12-事件类型&quot;&gt;1.2 事件类型&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt; 对处理的数据结构有明确的要求，能处理的数据结构：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;POJO ( java.lang.Object )&lt;/li&gt;
  &lt;li&gt;java.util.Map&lt;/li&gt;
  &lt;li&gt;Object[]&lt;/li&gt;
  &lt;li&gt;XML&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;支持nested、indexed、mapped属性（嵌套没有层数限制）&lt;/li&gt;
  &lt;li&gt;需要告知引擎类型元数据，包括嵌套的数据。&lt;/li&gt;
  &lt;li&gt;能改变属性顺序，或抽取部分属性到一个新的事件。&lt;/li&gt;
  &lt;li&gt;Object、Map 和 Object[] 类型支持超类( Supertype )&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;13-事件属性&quot;&gt;1.3 事件属性&lt;/h3&gt;
&lt;p&gt;| &lt;strong&gt;&lt;em&gt;类型&lt;/em&gt;&lt;/strong&gt;|  &lt;strong&gt;&lt;em&gt;说明&lt;/em&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;em&gt;语法&lt;/em&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;em&gt;实例&lt;/em&gt;&lt;/strong&gt;|
| — | — | — | — |
| Simple | 只包含单个值得属性 | name | price |
| Indexed | 索引 | name[index] | price[0] |
| Mapped | map属性 | name[‘key’] | apple(‘price’) |
| nested | 属性嵌套 | name.nestedname | apple.price|&lt;/p&gt;

&lt;p&gt;组合上述所有的属性，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;person.address(‘home’).street[0]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;事件属性示例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class MyEventType {
  String myMapKey;
  int myIndexValue;
  int myInnerIndexValue;
  Map&amp;lt;String, InnerType&amp;gt; innerTypesMap; // mapped property
  InnerType[] innerTypesArray; // indexed property
  }
  public class InnerType {
  String name;
  int[] ids;
  }
	
  select innerTypesMap('somekey').ids[1],
  // innerTypesMap(myMapKey).getIds(myIndexValue),
  innerTypesArray[1].ids[2],
  // innerTypesArray(myIndexValue).getIds(myInnerIndexValue)
  from MyEventType
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14-动态事件属性&quot;&gt;1.4 动态事件属性&lt;/h3&gt;
&lt;p&gt;| &lt;strong&gt;&lt;em&gt;类型&lt;/em&gt;&lt;/strong&gt; | &lt;strong&gt;&lt;em&gt;语法&lt;/em&gt;&lt;/strong&gt; |
| — | — |
| Dynamic Simple | name? |
| Dynamic Indexed | name[index]? |
| Dynamic Mapped | name(‘key’)? |
| Dynamic Nested | name?.nestedname |&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select timestamp? from OrderEvent

select detail?.driection from OrderEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;OrderEvent&lt;/code&gt; 拥有多个接口类，其中某个或某些有&lt;code class=&quot;highlighter-rouge&quot;&gt;timestamp&lt;/code&gt;属性，则其动态属性&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select timestamp? from OrderEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果动态属性是嵌套属性，则&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select detail?.driection from OrderEvent 等价于

select detail?.direction? from OrderEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;示例&lt;/p&gt;

    &lt;p&gt;动态属性返回值总是 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt; 类型，在事件进程运行时，动态属性不存在，则返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;如：事件&lt;code class=&quot;highlighter-rouge&quot;&gt;OrderEvent&lt;/code&gt;拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;item&lt;/code&gt;属性，通过动态属性指定一个查询来取得&lt;code class=&quot;highlighter-rouge&quot;&gt;Service&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Product&lt;/code&gt;的价格，如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select item.price? from OrderEvent
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;OrderEvent&lt;/code&gt; 拥有多个接口类，其中某个或某些有&lt;code class=&quot;highlighter-rouge&quot;&gt;timestamp&lt;/code&gt;属性，则其动态属性：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select timestamp? from OrderEvent
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;如果动态属性是嵌套属性，则动态属性下的所有嵌套属性都为动态属性：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select detail?.driection from OrderEvent   等价于

  select detail?.direction? from OrderEvent
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试代码&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class OrderEvent {
    Object item;
  }
	
  class Serivce {
    String name;
    int price;
  }
	
  class Product {
    String name;
    int price;
    String info;
  }
	
  class DynamicListener implements UpdateListener
  {
	
    public void update(EventBean[] newEvents, EventBean[] oldEvents)
    {
      if (newEvents != null)
      {
  //      Double avg = (Double) newEvents[0].get(&quot;item.price?&quot;);
  //      System.out.println(&quot;Apple's average price is &quot; + avg);
        for (int i = 0; i &amp;lt; newEvents.length; i++) {
          System.out.println(newEvents[i].getUnderlying());
        }
      }
    }
	
  }
	
  public class DynamicProps {
    public static void main(String[] args) throws InterruptedException {
      EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
	
      EPAdministrator admin = epService.getEPAdministrator();
	
      String epl = &quot;select item.info? from OrderEvent&quot;;
	
      EPStatement state = admin.createEPL(epl);
      state.addListener(new AppleListener());
	
      EPRuntime runtime = epService.getEPRuntime();
	
      Product product = new Product();
      product.setName(&quot;pdt1&quot;);
      product.setPrice(5);
      product.setInfo(&quot;Product Info.&quot;);
	
      OrderEvent oe1 = new OrderEvent();
      oe1.setItem(product);
      runtime.sendEvent(oe1);
	
      Serivce svr = new Serivce();
      svr.setName(&quot;svr&quot;);
      svr.setPrice(10);
	
      OrderEvent oe2 = new OrderEvent();
      oe2.setItem(svr);
      runtime.sendEvent(oe2);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;link2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二事件类型&quot;&gt;二、事件类型&lt;/h2&gt;

&lt;h3 id=&quot;21-pojojavalangobject&quot;&gt;2.1 POJO（&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.Object&lt;/code&gt;）&lt;/h3&gt;

&lt;p&gt;对于POJO，&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;要求对每一个私有属性要有&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法。&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;允许不必按照&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaBean&lt;/code&gt;规定的格式，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;方法是必须的。又或者可以在配置文件中配置可访问的方法来代替&lt;code class=&quot;highlighter-rouge&quot;&gt;getter&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Person  
{  
    String name;  
    int age;  
    public String getName()  
    {  
        return name;  
    }  
    public int getAge()  
    {  
        return age;  
    }  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;对POJO的支持基本上就是上面所说的，另外他还支持实现了多个接口类或者抽象类的POJO，使用方法和普通的POJO没什么区别，这里就不列举了。&lt;/p&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的name属性为test时，得到对应的age,所有children和address.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select age,children,address from Person where name=&quot;test&quot;  当Person的name属性为test时，得到对应的第二个孩子,家里的电话和家庭住址在哪条路上  

select children[1], phones('home'), address.road from Person where name=&quot;test”
public Child getChildren(int index) { // 返回对应下标的children信息
	return children.get(index);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当&lt;code class=&quot;highlighter-rouge&quot;&gt;Person&lt;/code&gt;的name属性为test时，更新家里的电话&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update Person set phones('home') = 123456789 where name=&quot;test&quot; 
public void setPhones(String name, Integer number) {  
   phones.put(name, number); // 用于 phones 属性的更新
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;PojoPersonTest 测试示例：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class PojoPerson implements Serializable {
    String pname;
    int age;
    List&amp;lt;Child&amp;gt; children;
    Map&amp;lt;String, Integer&amp;gt; phones;
    Address address;
	
    public String getPname() {
      return pname;
    }
	
    public void setPname(String pname) {
      this.pname = pname;
    }
	
    public int getAge() {
      return age;
    }
	
    public void setAge(int age) {
      this.age = age;
    }
	
    public List&amp;lt;Child&amp;gt; getChildren() {
      return children;
    }
	
    public Child getChildren(int index) {
      return children.get(index);
    }
	
    public void setChildren(List&amp;lt;Child&amp;gt; children) {
      this.children = children;
    }
	
    public Map&amp;lt;String, Integer&amp;gt; getPhones() {
      return phones;
    }
	
    public void setPhones(Map&amp;lt;String, Integer&amp;gt; phones) {
      this.phones = phones;
    }
	
    public void setPhones(String name, Integer number) {
      System.out.println(&quot;=======&quot;);
      phones.put(name, number);
    }
	
    public Address getAddress() {
      return address;
    }
	
    public void setAddress(Address address) {
      this.address = address;
    }
	
    @Override
    public String toString() {
      return &quot;PojoPerson{&quot; +
          &quot;name='&quot; + pname + '\'' +
          &quot;, age=&quot; + age +
          &quot;, children=&quot; + children +
          &quot;, phones=&quot; + phones +
          &quot;, address=&quot; + address +
          '}';
    }
  }
	
  class Child
  {
    String cname;
    int gender;
	
    public String getCname() {
      return cname;
    }
	
    public void setCname(String cname) {
      this.cname = cname;
    }
	
    public int getGender() {
      return gender;
    }
	
    @Override
    public String toString() {
      return &quot;Child{&quot; +
          &quot;name='&quot; + cname + '\'' +
          &quot;, gender=&quot; + gender +
          '}';
    }
	
    public void setGender(int gender) {
      this.gender = gender;
    }
  }
	
  class Address
  {
    String road;
    String street;
    int houseNo;
	
    public String getRoad() {
      return road;
    }
	
    public void setRoad(String road) {
      this.road = road;
    }
	
    public String getStreet() {
      return street;
    }
	
    public void setStreet(String street) {
      this.street = street;
    }
	
    public int getHouseNo() {
      return houseNo;
    }
	
    public void setHouseNo(int houseNo) {
      this.houseNo = houseNo;
    }
	
    @Override
    public String toString() {
      return &quot;Address{&quot; +
          &quot;road='&quot; + road + '\'' +
          &quot;, street='&quot; + street + '\'' +
          &quot;, houseNo=&quot; + houseNo +
          '}';
    }
  }
	
	
  public class PojoPersonTest {
    public static void main(String[] args) {
	
      EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
      EPAdministrator admin = epService.getEPAdministrator();
      EPRuntime runtime = epService.getEPRuntime();
	
      String qry1 = &quot;select age,children,address from PojoPerson where pname = \&quot;张三\&quot;&quot;;
      String qry2 = &quot;select children[1], phones('home'), address.road from PojoPerson where pname=\&quot;李四\&quot;&quot;;
      String qry = &quot;select * from PojoPerson&quot;;
	
      EPStatement state1 = admin.createEPL(qry1);
      state1.addListener(new UpdateListener() {
        public void update(EventBean[] newEvents, EventBean[] oldEvents) {
          if (null != newEvents) {
            System.out.print(&quot;qry1=====  &quot;);
            System.out.println(newEvents[0].getUnderlying());
          }
        }
      });
	
      EPStatement state2 = admin.createEPL(qry2);
      state2.addListener(new UpdateListener() {
        public void update(EventBean[] newEvents, EventBean[] oldEvents) {
          if (null != newEvents) {
            System.out.print(&quot;qry2+++++  &quot;);
            System.out.println(newEvents[0].getUnderlying());
          }
        }
      });
	
	
      EPStatement state = admin.createEPL(qry);
      state.addListener(new UpdateListener() {
        public void update(EventBean[] newEvents, EventBean[] oldEvents) {
          if (null != newEvents) {
            System.out.print(&quot;qry----  &quot;);
            for (int i = 0; i &amp;lt; newEvents.length; i++) {
              System.out.println(newEvents[i].getUnderlying());
            }
          }
        }
      });
	
      PojoPerson pp1 = new PojoPerson();
      Address a1 = new Address();
      a1.setHouseNo(100);
      a1.setRoad(&quot;Address 1&quot;);
      a1.setStreet(&quot;Street 1&quot;);
      pp1.setAddress(a1);
      pp1.setPname(&quot;张三&quot;);
      pp1.setAge(30);
      Map&amp;lt;String, Integer&amp;gt; p1 = new HashMap&amp;lt;String, Integer&amp;gt;();
      p1.put(&quot;home&quot;, 1333333333);
      p1.put(&quot;work&quot;, 1333333334);
      pp1.setPhones(p1);
      List&amp;lt;Child&amp;gt; lc1 = new ArrayList&amp;lt;Child&amp;gt;();
      Child ch1 = new Child();
      ch1.setCname(&quot;张四&quot;);
      ch1.setGender(1);
      lc1.add(ch1);
      pp1.setChildren(lc1);
      runtime.sendEvent(pp1);
	
      PojoPerson pp2 = new PojoPerson();
      Address a2 = new Address();
      a2.setHouseNo(100);
      a2.setRoad(&quot;Address 1&quot;);
      a2.setStreet(&quot;Street 1&quot;);
      pp2.setAddress(a2);
      pp2.setPname(&quot;李四&quot;);
      pp2.setAge(30);
      Map&amp;lt;String, Integer&amp;gt; p2 = new HashMap&amp;lt;String, Integer&amp;gt;();
      p2.put(&quot;home&quot;, 1444444444);
      p2.put(&quot;work&quot;, 1444444445);
      pp2.setPhones(p2);
      List&amp;lt;Child&amp;gt; lc2 = new ArrayList&amp;lt;Child&amp;gt;();
      Child ch21 = new Child();
      ch21.setCname(&quot;李五&quot;);
      ch21.setGender(1);
      lc2.add(ch21);
      Child ch22 = new Child();
      ch22.setCname(&quot;李六&quot;);
      ch22.setGender(0);
      lc2.add(ch22);
      pp2.setChildren(lc2);
      runtime.sendEvent(pp2);
	
      PojoPerson pp3 = new PojoPerson();
      Address a3 = new Address();
      a3.setHouseNo(100);
      a3.setRoad(&quot;Address 1&quot;);
      a3.setStreet(&quot;Street 1&quot;);
      pp3.setAddress(a3);
      pp3.setPname(&quot;test&quot;);
      pp3.setAge(30);
      Map&amp;lt;String, Integer&amp;gt; p3 = new HashMap&amp;lt;String, Integer&amp;gt;();
      p3.put(&quot;home&quot;, 1555555555);
      p3.put(&quot;work&quot;, 1555555556);
      pp3.setPhones(p3);
      List&amp;lt;Child&amp;gt; lc3 = new ArrayList&amp;lt;Child&amp;gt;();
      Child ch31 = new Child();
      ch31.setCname(&quot;王六&quot;);
      ch31.setGender(1);
      lc3.add(ch31);
      pp3.setChildren(lc3);
	
      runtime.sendEvent(pp3);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UpdateTest 测试代码&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public class UpdateTest {
    public static void main(String[] args) {
	
      EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
      EPAdministrator admin = epService.getEPAdministrator();
      EPRuntime runtime = epService.getEPRuntime();
	
      String ctr = &quot;create window UPerson.win:keepall() as Person&quot;;
      String update = &quot;on Person as p1 update UPerson as p2 set p2.age = 40 where p2.name = 'test'&quot;;
  //    String update = &quot;update Person set age = 40 where name = 'test'&quot;;
      String qry = &quot;select * from Person&quot;;
	
	
      admin.createEPL(ctr);
      admin.createEPL(&quot;insert into UPerson select * from Person&quot;);
      EPStatement state3 = admin.createEPL(update);
      state3.addListener(new UpdateListener() {
        public void update(EventBean[] newEvents, EventBean[] oldEvents) {
          if (null != newEvents) {
            System.out.print(&quot;update==&amp;gt;  &quot;);
            for (int i = 0; i &amp;lt; newEvents.length; i++) {
              System.out.println(newEvents[i].getUnderlying());
            }
          }
        }
      });
	
      EPStatement state = admin.createEPL(qry);
      state.addListener(new UpdateListener() {
        public void update(EventBean[] newEvents, EventBean[] oldEvents) {
          if (null != newEvents) {
            System.out.print(&quot;qry==&amp;gt;  &quot;);
            for (int i = 0; i &amp;lt; newEvents.length; i++) {
              System.out.println(newEvents[i].getUnderlying());
            }
          }
        }
      });
	
      Person p1 = new Person();
      p1.setName(&quot;test&quot;);
      p1.setAge(22);
      runtime.sendEvent(p1);
	
      Person p2 = new Person();
      p2.setName(&quot;test2&quot;);
      p2.setAge(23);
      runtime.sendEvent(p2);
		
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-javautilmap&quot;&gt;2.2 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Map&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;支持原生&lt;code class=&quot;highlighter-rouge&quot;&gt;Java Map&lt;/code&gt;结构的事件。相对于POJO来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;的结构更利于事件类型的热加载，毕竟不是&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;，所以不需要重启JVM。&lt;/p&gt;

&lt;p&gt;所以如果系统对重启比较敏感，建议使用Map来定义事件的结构。&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;的结构很简单，主要分为事件定义名和事件属性列表。&lt;/p&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;sendEvent(Map map, String eventTypeName)&lt;/code&gt; 方法发送事件。&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;只支持增量更新，也就是说只能增加&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;中的属性定义，而不能修改或者删除某个属性。&lt;/p&gt;

&lt;p&gt;实际上属性增多并不影响其处理性能，所以没有删除在我看来也没什么。至于修改，也只能是先注销再注册了。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;定义&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Person定义  
  Map&amp;lt;String,Object&amp;gt; person = new HashMap&amp;lt;String,Object&amp;gt;();  
  person.put(&quot;name&quot;, String.class);  
  person.put(&quot;age&quot;, int.class);  
  person.put(&quot;children&quot;, List.class);  
  person.put(&quot;phones&quot;, Map.class);  
	          
  // 注册Person到Esper  
  admin.getConfiguration().addEventType(&quot;PersonEvent&quot;, person);
	
  select name, age, phones from PersonEvent.win:time(1 min) where age = 20 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Map&lt;/code&gt;发送&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Map&amp;lt;String, Object&amp;gt; p1 = new HashMap&amp;lt;String, Object&amp;gt;();
  p1.put(&quot;name&quot;, &quot;test&quot;);
  p1.put(&quot;age&quot;, 20);
  List&amp;lt;Person&amp;gt; child = new ArrayList&amp;lt;Person&amp;gt;();
  p1.put(&quot;children&quot;, child);
	
  Map&amp;lt;String, Object&amp;gt; phones = new HashMap&amp;lt;String, Object&amp;gt;();
  phones.put(&quot;home&quot;, &quot;051088744796&quot;);
  phones.put(&quot;self&quot;, &quot;15051818371&quot;);
  p1.put(&quot;phones&quot;, phones);
	
  epService.getEPRuntime().sendEvent(p1, &quot;PersonEvent&quot;);
	
  select name, age, phones from PersonEvent.win:time(1 min) where age = 20 

  {name=test, phones={self=15051818371, home=051088744796}, age=20}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PersonMap 示例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class Person implements Serializable
  {
    String name;
    int age;
	
    public String getName() {
      return name;
    }
	
    public void setName(String name) {
      this.name = name;
    }
	
    public int getAge() {
      return age;
    }
	
    public void setAge(int age) {
      this.age = age;
    }
	
    @Override
    public String toString() {
      return &quot;Person{&quot; +
          &quot;name='&quot; + name + '\'' +
          &quot;, age=&quot; + age +
          '}';
    }
  }
	
  class PersonMapListener implements UpdateListener
  {
	
    public void update(EventBean[] newEvents, EventBean[] oldEvents)
    {
      if (newEvents != null)
      {
        for (int i = 0; i &amp;lt; newEvents.length; i++) {
          System.out.println(newEvents[i].getUnderlying());
        }
      }
    }
	
  }
	
  public class PersonMap {
    public static void main(String[] args) throws InterruptedException {
      EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
	
      EPAdministrator admin = epService.getEPAdministrator();
	
      // Person 定义
      Map&amp;lt;String, Object&amp;gt; person = new HashMap&amp;lt;String, Object&amp;gt;();
      person.put(&quot;name&quot;, String.class);
      person.put(&quot;age&quot;, int.class);
      person.put(&quot;children&quot;, List.class);
      person.put(&quot;phones&quot;, Map.class);
	
      // 注册Person到Esper
      admin.getConfiguration().addEventType(&quot;PersonEvent&quot;, person);
	
      String epl = &quot;select name, age, phones from PersonEvent.win:time(1 min) where age = 20&quot;;
      EPStatement state = admin.createEPL(epl);
      state.addListener(new PersonMapListener());
	
      EPRuntime runtime = epService.getEPRuntime();
	
      Map&amp;lt;String, Object&amp;gt; p1 = new HashMap&amp;lt;String, Object&amp;gt;();
      p1.put(&quot;name&quot;, &quot;test&quot;);
      p1.put(&quot;age&quot;, 20);
	
      List&amp;lt;Person&amp;gt; child = new ArrayList&amp;lt;Person&amp;gt;();
      Person pc1 = new Person();
      pc1.setName(&quot;Child1&quot;);
      pc1.setAge(20);
      child.add(pc1);
      p1.put(&quot;children&quot;, child);
	
      Map&amp;lt;String, Object&amp;gt; phones = new HashMap&amp;lt;String, Object&amp;gt;();
      phones.put(&quot;home&quot;, &quot;051088744796&quot;);
      phones.put(&quot;self&quot;, &quot;15051818371&quot;);
      p1.put(&quot;phones&quot;, phones);
	
      runtime.sendEvent(p1, &quot;PersonEvent&quot;);
	
      // 新增一个gender属性
  //    person.put(&quot;gender&quot;, int.class);
  //    admin.getConfiguration().updateMapEventType(&quot;PersonEvent&quot;, person);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;221-javautilmap超类supertype&quot;&gt;2.2.1 &lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Map&lt;/code&gt;超类(Supertype)&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;epService.getEPAdministrator().getConfiguration().addEventType(
	&quot;AccountUpdate&quot;, accountUpdateDef, new String[] {&quot;BaseUpdate&quot;}
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当继承之后，对超类进行&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;时，不管是子类、或超类事件到达，都会进行查询输出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from BaseUpdate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每个Map 事件可以有多个超类！&lt;/p&gt;

&lt;h4 id=&quot;222-map-嵌套&quot;&gt;2.2.2 Map 嵌套&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; updatedFieldDef = new HashMap&amp;lt;String, Object&amp;gt;();
updatedFieldDef.put(&quot;name&quot;, String.class);
updatedFieldDef.put(&quot;addressLine1&quot;, String.class);
updatedFieldDef.put(&quot;history&quot;, UpdateHistory.class);
epService.getEPAdministrator().getConfiguration().
addEventType(&quot;UpdatedFieldType&quot;, updatedFieldDef);

Map&amp;lt;String, Object&amp;gt; accountUpdateDef = new HashMap&amp;lt;String, Object&amp;gt;();
accountUpdateDef.put(&quot;accountId&quot;, long.class);
accountUpdateDef.put(&quot;fields&quot;, &quot;UpdatedFieldType&quot;);	
// the latter can also be:  accountUpdateDef.put(&quot;fields&quot;, updatedFieldDef);

epService.getEPAdministrator().getConfiguration().
addEventType(&quot;AccountUpdate&quot;, accountUpdateDef);

Map&amp;lt;String, Object&amp;gt; updatedField = new HashMap&amp;lt;String, Object&amp;gt;();
updatedField.put(&quot;name&quot;, &quot;Joe Doe&quot;);
updatedField.put(&quot;addressLine1&quot;, &quot;40 Popular Street&quot;);
updatedField.put(&quot;history&quot;, new UpdateHistory());

Map&amp;lt;String, Object&amp;gt; accountUpdate = new HashMap&amp;lt;String, Object&amp;gt;();
accountUpdate.put(&quot;accountId&quot;, 10009901);
accountUpdate.put(&quot;fields&quot;, updatedField);

epService.getEPRuntime().sendEvent(accountUpdate, &quot;AccountUpdate&quot;);


select accountId, fields.name, fields.addressLine1, fields.history.lastUpdate
from AccountUpdate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;223-map-数组&quot;&gt;2.2.3 Map 数组&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Map&amp;lt;String, Object&amp;gt; sale = new HashMap&amp;lt;String, Object&amp;gt;();
sale.put(&quot;userids&quot;, int[].class);
sale.put(&quot;salesPersons&quot;, SalesPerson[].class);
sale.put(&quot;items&quot;, &quot;OrderItem[]&quot;);	 // The property type is the name itself appended by []

epService.getEPAdministrator().getConfiguration().
    addEventType(&quot;SaleEvent&quot;, sale);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查询语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select userids[0], salesPersons[1].name, 
items[1], items[1].price.amount from SaleEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;23-object-array&quot;&gt;2.3 Object Array&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt; 数组跟&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;类似，只是定义的方式有些区别，同时也只支持增量更新。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String[] propertyNames = {&quot;carId&quot;, &quot;direction&quot;};   // order is important
Object[] propertyTypes = {String.class, int.class};  // type order matches name order

epService.getEPAdministrator().getConfiguration().
  addEventType(&quot;CarLocUpdateEvent&quot;, propertyNames, propertyTypes);

epRuntime.sendEvent(new Object[]{carId, direction}, “CarLocUpdateEvent”);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;查询语句：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select carId from CarLocUpdateEvent .win:time(1 min) where direction = 1
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增量更新：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  admin.getConfiguration().updateObjectArrayEventType(&quot;Person&quot;, new String[] { &quot;gender&quot; }, new Object[] { int.class });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ObjectArray 实例：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class CommonUpdateListener implements UpdateListener {
	
    public void update(EventBean[] newEvents, EventBean[] oldEvents) {
      if (null != newEvents) {
        System.out.print(&quot;common update method:  &quot;);
        for (int i = 0; i &amp;lt; newEvents.length; i++) {
          System.out.println(newEvents[i].getUnderlying());
        }
      }
    }
  }
	
  public class ObjectArray {
	
    /**
     * @param args
     */
    public static void main(String[] args)
    {
      EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
      EPAdministrator admin = epService.getEPAdministrator();
      EPRuntime runtime = epService.getEPRuntime();
	
      // Address定义
      String[] addressPropNames = { &quot;road&quot;, &quot;street&quot;, &quot;houseNo&quot; };
      Object[] addressPropTypes = { String.class, String.class, int.class };
	
      // Child定义
      String[] childPropNames = { &quot;name&quot;, &quot;age&quot; };
      Object[] childPropTypes = { String.class, int.class };
	
      // Person定义
      String[] personPropNames = { &quot;name&quot;, &quot;age&quot;, &quot;children&quot;, &quot;phones&quot;, &quot;address&quot; };
      Object[] personPropTypes = { String.class, int.class, &quot;Child[]&quot;, Map.class, &quot;Address&quot; };
	
      // 注册Address到Esper
      admin.getConfiguration().addEventType(&quot;Address&quot;, addressPropNames, addressPropTypes);
      // 注册Child到Esper
      admin.getConfiguration().addEventType(&quot;Child&quot;, childPropNames, childPropTypes);
      // 注册Person到Esper
      admin.getConfiguration().addEventType(&quot;Person&quot;, personPropNames, personPropTypes);
	
      // 新增一个gender属性
      admin.getConfiguration().updateObjectArrayEventType(&quot;Person&quot;, new String[] { &quot;gender&quot; }, new Object[] { int.class });
	
      /** 输出结果：
       * Person props: [name, age, children, phones, address, gender]
       */
      EventType event = admin.getConfiguration().getEventType(&quot;Person&quot;);
      System.out.println(&quot;Person props: &quot; + Arrays.asList(event.getPropertyNames()));
	
      String epl = &quot;select name, age, phones, address.road, address.street, address.houseNo, children[0].name from Person&quot;;
      EPStatement state = admin.createEPL(epl);
      state.addListener(new CommonUpdateListener());
	
      Object[] addr = {&quot;road1&quot;, &quot;street1&quot;, 1};
      Object[][] child = child;
	
      Map&amp;lt;String, Object&amp;gt; phones = new HashMap&amp;lt;String, Object&amp;gt;();
      phones.put(&quot;home&quot;, &quot;051088744796&quot;);
      phones.put(&quot;self&quot;, &quot;15051818371&quot;);
	
      Object[] person = {&quot;person&quot;, 30, child, phones, addr};
	
      runtime.sendEvent(person, &quot;Person&quot;);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;231-object-array-超类supertype&quot;&gt;2.3.1 Object Array 超类（Supertype）&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object[]&lt;/code&gt; 可以在引擎初始化、或运行时通过administrator接口，定义一个超类。&lt;/p&gt;

&lt;p&gt;超类必须也是&lt;code class=&quot;highlighter-rouge&quot;&gt;Object[]&lt;/code&gt; 事件，且所有的属性会对子类可见，同名属性将会被覆盖。定义于超类上的EPL查询语法，子类亦会触发。&lt;/p&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;create objectarray schema SuperType (p0 String)
create objectarray schema SubType (p1 String, p2 String) inherits SuperType
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发送：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;epRuntime.sendEvent(new Object[] {&quot;p0_value&quot;, &quot;p1_value&quot;}, &quot;SubType&quot;);
epRuntime.sendEvent(new Object[] {&quot;p0_value&quot;}, &quot;SuperType&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;232-object-array嵌套属性&quot;&gt;2.3.2 Object Array（嵌套属性）&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String[] propertyNamesUpdField = {&quot;name&quot;, &quot;addressLine1&quot;, &quot;history&quot;};
Object[] propertyTypesUpdField = {String.class, String.class, UpdateHistory.class};
epService.getEPAdministrator().getConfiguration().
addEventType(&quot;UpdatedFieldType&quot;, propertyNamesUpdField, propertyTypesUpdField);

String[] propertyNamesAccountUpdate = {&quot;accountId&quot;, &quot;fields&quot;};
Object[] propertyTypesAccountUpdate = {long.class, &quot;UpdatedFieldType&quot;};
epService.getEPAdministrator().getConfiguration().
addEventType(&quot;AccountUpdate&quot;, propertyNamesAccountUpdate, propertyTypesAccountUpdate);

Object[] updatedField = {&quot;Joe Doe&quot;, &quot;40 Popular Street&quot;, new UpdateHistory()};
Object[] accountUpdate = {10009901, updatedField};
epService.getEPRuntime().sendEvent(accountUpdate, &quot;AccountUpdate&quot;);

select accountId, fields.name, fields.addressLine1, fields.history.lastUpdate
from AccountUpdate
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;233-object-array一对多属性&quot;&gt;2.3.3 Object Array（一对多属性）&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String[] propertyNames = {&quot;userids&quot;, &quot;salesPersons&quot;, &quot;items&quot;};
Object[] propertyTypes = {int[].class, SalesPerson[].class, &quot;OrderItem[]&quot;);

epService.getEPAdministrator().getConfiguration().addEventType(&quot;SaleEvent&quot;, propertyNames, propertyTypes);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查询语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select userids[0], salesPersons[1].name, 
	items[1], items[1].price.amount from SaleEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;24-xml&quot;&gt;2.4 XML&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ParseXmlSchema 示例&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  class ParseXMLListener implements UpdateListener
  {
	
    public void update(EventBean[] newEvents, EventBean[] oldEvents)
    {
      if (newEvents != null)
      {
        for (int i = 0; i &amp;lt; newEvents.length; i++) {
          System.out.println(newEvents[i].getUnderlying());
        }
      }
    }
	
  }
	
  public class ParseXmlSchema {
    public static void main(String[] args) throws InterruptedException, IOException, ParserConfigurationException, SAXException {
      String xml = &quot;&amp;lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&amp;gt;&quot; +
          &quot;&amp;lt;Sensor xmlns=\&quot;SensorSchema\&quot;&amp;gt;&quot; +
          &quot;  &amp;lt;ID&amp;gt;urn:epc:1:4.16.36&amp;lt;/ID&amp;gt;&quot; +
          &quot;  &amp;lt;Observation Command=\&quot;READ_PALLET_TAGS_ONLY\&quot;&amp;gt;&quot; +
          &quot;    &amp;lt;ID&amp;gt;00000001&amp;lt;/ID&amp;gt;&quot; +
          &quot;    &amp;lt;Tag&amp;gt;&quot; +
          &quot;      &amp;lt;ID&amp;gt;urn:epc:1:2.24.400&amp;lt;/ID&amp;gt;&quot; +
          &quot;    &amp;lt;/Tag&amp;gt;&quot; +
          &quot;    &amp;lt;Tag&amp;gt;&quot; +
          &quot;      &amp;lt;ID&amp;gt;urn:epc:1:2.24.401&amp;lt;/ID&amp;gt;&quot; +
          &quot;    &amp;lt;/Tag&amp;gt;&quot; +
          &quot;  &amp;lt;/Observation&amp;gt;&quot; +
          &quot;&amp;lt;/Sensor&amp;gt;&quot;;
      URL schemaURL = ParseXmlSchema.class.getResource(&quot;sensor.xsd&quot;);
      EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();
	
      EPAdministrator admin = epService.getEPAdministrator();
      epService = EPServiceProviderManager.getDefaultProvider();
      ConfigurationEventTypeXMLDOM sensorcfg = new ConfigurationEventTypeXMLDOM();
      sensorcfg.setRootElementName(&quot;Sensor&quot;);
      sensorcfg.setSchemaResource(schemaURL.toString());
      epService.getEPAdministrator().getConfiguration()
          .addEventType(&quot;SensorEvent&quot;, sensorcfg);
	
      String epl = &quot;select ID, Observation.Command, Observation.ID, Observation.Tag[0].ID, Observation.Tag[1].ID from SensorEvent&quot;;
      EPStatement state = admin.createEPL(epl);
      state.addListener(new ParseXMLListener());
	
      InputSource source = new InputSource(new StringReader(xml));
      DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
      builderFactory.setNamespaceAware(true);
      Document doc = builderFactory.newDocumentBuilder().parse(source);
	
      epService.getEPRuntime().sendEvent(doc);
    }
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;schema&lt;/code&gt;文件&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
  &amp;lt;xs:schema xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;&amp;gt;
	
    &amp;lt;xs:element name=&quot;Sensor&quot;&amp;gt;
      &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:sequence&amp;gt;
          &amp;lt;xs:element name=&quot;ID&quot; type=&quot;xs:string&quot;/&amp;gt;
          &amp;lt;xs:element ref=&quot;Observation&quot; /&amp;gt;
        &amp;lt;/xs:sequence&amp;gt;
      &amp;lt;/xs:complexType&amp;gt;
    &amp;lt;/xs:element&amp;gt;
	
    &amp;lt;xs:element name=&quot;Observation&quot;&amp;gt;
      &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:sequence&amp;gt;
          &amp;lt;xs:element name=&quot;ID&quot; type=&quot;xs:string&quot;/&amp;gt;
          &amp;lt;xs:element ref=&quot;Tag&quot; maxOccurs=&quot;unbounded&quot; /&amp;gt;
        &amp;lt;/xs:sequence&amp;gt;
        &amp;lt;xs:attribute name=&quot;Command&quot; type=&quot;xs:string&quot; use=&quot;required&quot; /&amp;gt;
      &amp;lt;/xs:complexType&amp;gt;
    &amp;lt;/xs:element&amp;gt;
	
    &amp;lt;xs:element name=&quot;Tag&quot;&amp;gt;
      &amp;lt;xs:complexType&amp;gt;
        &amp;lt;xs:sequence&amp;gt;
          &amp;lt;xs:element name=&quot;ID&quot; type=&quot;xs:string&quot;/&amp;gt;
        &amp;lt;/xs:sequence&amp;gt;
      &amp;lt;/xs:complexType&amp;gt;
    &amp;lt;/xs:element&amp;gt;
  &amp;lt;/xs:schema&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;25-事件类型对比&quot;&gt;2.5 事件类型对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/images/esper/compare.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link3&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三处理模型&quot;&gt;三、处理模型&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt; 进程模型是连续不间断的：根据&lt;code class=&quot;highlighter-rouge&quot;&gt;event stream&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;filters&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;output rates&lt;/code&gt;的语句选择范围，&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UpdaterListener&lt;/code&gt;是Esper提供的一个接口，用于监听某个EPL在引擎中的运行情况，即事件进入并产生结果后会通知&lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateListener&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.espertech.esper.client;  
  
import com.espertech.esper.client.EventBean;  
  
public interface UpdateListener  
{  
    public void update(EventBean[] newEvents, EventBean[] oldEvents);  
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;是怎么处理事件的，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Esper&lt;/code&gt;的进程模型。&lt;/p&gt;

&lt;p&gt;一个update方法，其中包括两个EventBean数组。EventBean中有一个最常用的get方法，是用来得到EPL中某个字段的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select name from User  
//假设newEvents长度为一  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents[0].get(&quot;name&quot;)&lt;/code&gt;能得到进入的User事件的name属性值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select count(*) from User.win:time(5 sec)  
//假设newEvents长度为一  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents[0].get(&quot;count(*))&lt;/code&gt;能得到5秒内进入引擎的User事件数量有多少。&lt;/p&gt;

&lt;h3 id=&quot;31-insert-and-remove-stream&quot;&gt;3.1 Insert And Remove Stream&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;IR Stream&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/esper/irstream.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;从此图可以看出，随着时间推移，每个进入到引擎的&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;事件都是&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents&lt;/code&gt;，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert Stream&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;W&lt;/code&gt;后括号里的值为属性值，可忽略。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Insert&lt;/code&gt;表示事件进入引擎，&lt;code class=&quot;highlighter-rouge&quot;&gt;Remove Stream&lt;/code&gt;表示移出引擎，对应于&lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateListener&lt;/code&gt;中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;oldEvents&lt;/code&gt;。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select * from Withdrawal
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;每当引擎处理一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Withdrawal&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;Withdrawal&lt;/code&gt; 子类型的事件时，会触发对应所有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;update listener&lt;/code&gt;，并将该事件传递给每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;EPL&lt;/code&gt; 语句的监听器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Window Length&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;队列窗口(length window)告知引擎只保留最新的 &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; 个事件，如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select * from Withdrawal.win:length(5)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;开放了一个大小为 5 的空间，可同时存放 5 个事件。&lt;/p&gt;

    &lt;p&gt;引擎将所有接收到的事件，让入到一个长度为 5 的空间中，当空间满了之后，最老的事件将会置换出队列，新到的事件即为&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvent&lt;/code&gt;，置换出去的即为&lt;code class=&quot;highlighter-rouge&quot;&gt;oldEvent&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/esper/irstream-win-length.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;实际上这个EPL触发监听器都只能看到&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents&lt;/code&gt;，看不到&lt;code class=&quot;highlighter-rouge&quot;&gt;oldEvents&lt;/code&gt;。如果想看到&lt;code class=&quot;highlighter-rouge&quot;&gt;oldEvents&lt;/code&gt;，EPL要改写一下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select irstream * from Withdrawal.win:length(5)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;默认情况下，Esper认为你只想让&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents&lt;/code&gt;触发监听器，即&lt;code class=&quot;highlighter-rouge&quot;&gt;istream&lt;/code&gt;(insert stream)。如果想让&lt;code class=&quot;highlighter-rouge&quot;&gt;oldEvents&lt;/code&gt;触发监听器，那么为&lt;code class=&quot;highlighter-rouge&quot;&gt;rstream&lt;/code&gt;(remove stream)。如果两个都想，那么为&lt;code class=&quot;highlighter-rouge&quot;&gt;irstream&lt;/code&gt;。当然这个默认情况是可以配置的，以后会说到这个问题。&lt;/p&gt;

    &lt;p&gt;当只用&lt;code class=&quot;highlighter-rouge&quot;&gt;rstream&lt;/code&gt;时，过期的&lt;code class=&quot;highlighter-rouge&quot;&gt;oldEvents&lt;/code&gt;是放松到&lt;code class=&quot;highlighter-rouge&quot;&gt;newEvents&lt;/code&gt;中的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;32-filter-and-where-causes&quot;&gt;3.2 Filter And Where-causes&lt;/h3&gt;
&lt;p&gt;EPL有两种过滤事件的方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;过滤事件进入view（可以把view理解为一个窗口），即Filter。&lt;/li&gt;
  &lt;li&gt;让事件都进入view，但不触发UpdateListener，即Where子句。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;Filter：&lt;/strong&gt;&lt;/i&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from Withdrawal(amount&amp;gt;=200).win:length(5)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有&lt;code class=&quot;highlighter-rouge&quot;&gt;Withdrawal&lt;/code&gt;事件中，只有&lt;code class=&quot;highlighter-rouge&quot;&gt;amount&lt;/code&gt;属性值 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;= 200&lt;/code&gt;的才可以进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;win:length&lt;/code&gt;，且&lt;code class=&quot;highlighter-rouge&quot;&gt;win:length&lt;/code&gt;大小为 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/esper/irstream-filter-where.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;Where-causes：&lt;/strong&gt;&lt;/i&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select * from Withdrawal.win:length(5) where amount &amp;gt;= 200
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有&lt;code class=&quot;highlighter-rouge&quot;&gt;Withdrawal&lt;/code&gt;事件中，都可以进入 &lt;code class=&quot;highlighter-rouge&quot;&gt;win:length&lt;/code&gt;，且&lt;code class=&quot;highlighter-rouge&quot;&gt;win:length&lt;/code&gt;大小为 5，只有&lt;code class=&quot;highlighter-rouge&quot;&gt;amount&lt;/code&gt;属性 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;= 200&lt;/code&gt; 的才可以触发 &lt;code class=&quot;highlighter-rouge&quot;&gt;UpdateListener&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/esper/irstream-where.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;33-time-windows&quot;&gt;3.3 Time Windows&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Time Windows&lt;/p&gt;

    &lt;p&gt;Time Window 是基于过去系统时间上的，一个移动的指定时间间隔的窗口，Time Window 能够限制一次查询中事件的个数，类似于length window。&lt;/p&gt;

    &lt;p&gt;例如，要查询所有过去4秒的account中，amount大于1000的withdrawal的平均值，&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select account, avg(amount)
  from Withdrawal.win:time(4 sec)
  group by account
  having amount &amp;gt; 1000

  select * from Withdrawal.win:time(4 sec)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;img src=&quot;/images/esper/time-window.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;t+4 秒，W1到达并进入window，引擎将之反馈给 update listeners&lt;/li&gt;
      &lt;li&gt;t+5 秒，W2到达并进入window，引擎将之反馈给 update listeners&lt;/li&gt;
      &lt;li&gt;t+6.5 秒，W3到达并进入window，引擎将之反馈给 update listeners&lt;/li&gt;
      &lt;li&gt;t+8 秒，W1离开time window，引擎将之作为一个old event 告知update listeners&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Time Batch&lt;/p&gt;

    &lt;p&gt;Time Batch视图缓存事件，并在每个指定的时间间隔更新时释放它们，可以理解为批、批处理。length batch也类似。&lt;/p&gt;

    &lt;p&gt;例如，&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select * from Withdrawal.win:time_batch(4 sec)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;上述EPL语句可以理解为通过时间分批查询，每一批为4秒钟。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/esper/time-batch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;在 t + 1秒，W1 到达并进入batch，不触发调用 update listeners&lt;/li&gt;
      &lt;li&gt;在 t + 3秒，W2 到达并进入batch，不触发调用 update listeners&lt;/li&gt;
      &lt;li&gt;在 t + 4秒，引擎处理batch事件，并开始一个新的batch，引擎触发W1和W2给update listeners&lt;/li&gt;
      &lt;li&gt;在 t + 6.5秒，W3 引擎处理batch事件，并开始一个新的batch，引擎触发W1和W2给update listeners&lt;/li&gt;
      &lt;li&gt;在 t + 8秒，引擎处理batch事件，并开始一个新的batch，引擎触发W3给update listeners,并将W1和W2作为old data（前一个batch）发给update listeners&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;收集1秒钟之内到达的Withdrawal事件，并在1秒钟结束之后，将之作为new events（insert stream）发送给引擎的每个listener，将上1秒的作为old events（remove stream）发送给每个listener&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select account, amount from Withdrawal.win:time_batch(1 sec)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;1秒内所有Withdrawal时间的amount属性和&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select sum(amount) as mysum from Withdrawal.win:time_batch(1 sec)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;34-分组聚合&quot;&gt;3.4 分组聚合&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;IStream&lt;/p&gt;

    &lt;p&gt;当聚合属性值发生改变的时候，聚合事件语句，能够通过聚合函数传递(post)remove steam（即聚合函数值也能作为触发update listener的条件）。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select count(*) as mycount from Withdrawal having count(*) = 2   当接收到 2 个Withdrawal事件时，输出。

  select istream count(*) as mycount form Withdrawal having count(*) = 2
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;istream&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;rstream&lt;/code&gt;关键字能被用来指定传递（post） &lt;code class=&quot;highlighter-rouge&quot;&gt;new events&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;old events&lt;/code&gt; 给&lt;code class=&quot;highlighter-rouge&quot;&gt;update listeners&lt;/code&gt;。上述语句，表示当且仅当第二个&lt;code class=&quot;highlighter-rouge&quot;&gt;Withdrawal&lt;/code&gt;事件到达时，引擎才会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;；若&lt;code class=&quot;highlighter-rouge&quot;&gt;istream&lt;/code&gt;改为&lt;code class=&quot;highlighter-rouge&quot;&gt;rstream&lt;/code&gt;，则仅当第三个&lt;code class=&quot;highlighter-rouge&quot;&gt;Withdrawal&lt;/code&gt;事件到达时，引擎才会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;listener&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IR Stream&lt;/p&gt;

    &lt;p&gt;监听器有两个参数 newEvents 和 oldEvents，newEvents 表示通常的计算结果，oldEvents 可以理解为上一次计算结果。默认情况下，newEvents 有值，oldEvnets 为null。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select rstream * from Withdrawal   上述结果会将上一次的计算结果放入到 newEvents，而不是 oldEvents，且无法获取当前计算结果！

  select irstream * from Withdrawal   会将当前计算结果放入 newEvents，上次计算结果放入到 oldEvents。

  select istream * from Withdrawal
  select * from Withdrawal   会将当前计算结果放入newEvents，且无法得到上次计算结果，默认设置。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Aggregate and Group&lt;/p&gt;

    &lt;p&gt;不聚合、不分组&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  select * from Withdrawal.win:time_batch(1 sec)   只有聚合，没有分组

  select sum(amount)
  from Withdrawal.win:time_batch(1 sec)   非聚合属性、聚合属性，当不分组

  select account, sum(amount)
  from Withdrawlal.win:time_batch(1 sec)   查询语句中的聚合属性、所有非聚合属性，都被group by语句列出。

  select account, sum(amount)
  from Withdrawal.win:time_batch(1 sec)
  group by account   查询 非聚合属性和聚合属性，仅用group by分组了部分属性。

  select account, accountName, sum(amount) 
  from Withdrawal.win:time_batch(1 sec) 
  group by account
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;link4&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;未完待续&quot;&gt;未完待续…&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>Docker 入门简介</title>
   <link href="http://www.blogways.net/blog/2016/12/10/docker-introduction.html"/>
   <updated>2016-12-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/10/docker-introduction</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link1&quot;&gt;Docker简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link2&quot;&gt;Docker安装&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link3&quot;&gt;端口映射、网络&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link4&quot;&gt;自定义容器&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link5&quot;&gt;容器数据卷管理&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#link6&quot;&gt;其它&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;link1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;style&gt;
.red { color: red; }
.blue { color: blue; }
&lt;/style&gt;

&lt;h2 id=&quot;一docker简介&quot;&gt;一、Docker简介&lt;/h2&gt;

&lt;p&gt;Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Windows&lt;/code&gt;机器上，也可以实现虚拟化。&lt;/p&gt;

&lt;h3 id=&quot;11-什么是-docker&quot;&gt;1.1 什么是 Docker&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;使用&lt;strong&gt;客户端-服务器&lt;/strong&gt; (C/S) 架构模式。&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker客户端&lt;/code&gt;会与&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker守护进程&lt;/code&gt;进行通信。&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;容器。&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;客户端和守护进程可以运行在同一个系统上，当然你也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;客户端去连接一个远程的&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;守护进程。&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;客户端和守护进程之间通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;socket&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;RESTful API&lt;/code&gt; 进行通信。&lt;/p&gt;

&lt;p&gt;首先，&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器的启动可以在 &lt;span class=&quot;red&quot;&gt;&lt;strong&gt;&lt;em&gt;秒级&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt; 实现，这相比传统的虚拟机方式要快得多。 其次，&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 对系统资源的&lt;span class=&quot;red&quot;&gt;&lt;strong&gt;&lt;em&gt;利用率很高&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;，一台主机上可以同时运行数千个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器。
容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 只需要启动 10 个隔离的应用即可。&lt;/p&gt;

&lt;h3 id=&quot;12-与传统虚拟化的差异&quot;&gt;1.2 与传统虚拟化的差异&lt;/h3&gt;
&lt;p&gt;容器是在 &lt;strong&gt;&lt;em&gt;操作系统层面&lt;/em&gt;&lt;/strong&gt; 上实现虚拟化，直接&lt;span class=&quot;red&quot;&gt;&lt;strong&gt;&lt;em&gt;复用&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;本地主机的操作系统，而传统方式则是在&lt;span class=&quot;red&quot;&gt;&lt;strong&gt;&lt;em&gt;硬件层面&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;实现。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/vm-arch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于传统的虚拟机来说，每个虚拟的应用包括不仅仅一个应用程序（可能只有数十&lt;code class=&quot;highlighter-rouge&quot;&gt;MB&lt;/code&gt;），还需要&lt;code class=&quot;highlighter-rouge&quot;&gt;bins&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;libs&lt;/code&gt;，但是一个完整的操作系统可能有数十&lt;code class=&quot;highlighter-rouge&quot;&gt;GB&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/docker-arch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker Engine&lt;/code&gt;仅包括应用程序和它的依赖。在宿主机操作系统上，用户空间，独立的运行，和其它容器分享内核。但是有更高的可移植性和高效性。&lt;/p&gt;

&lt;h3 id=&quot;13-为什么使用docker&quot;&gt;1.3 为什么使用Docker&lt;/h3&gt;
&lt;p&gt;前面简单介绍了下&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;，说了很多&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;的相关概念，可是为什么我们要使用它呢？它给我们带来了什么具体的好处呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，前面也说了&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器的启动可以在&lt;strong&gt;&lt;em&gt;秒级&lt;/em&gt;&lt;/strong&gt;实现，这相比传统的虚拟机方式要快得多。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行 &lt;strong class=&quot;red&quot;&gt;数千个&lt;/strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器。&lt;/p&gt;

    &lt;p&gt;容器除了运行其中应用外，&lt;strong class=&quot;red&quot;&gt;基本不消耗&lt;/strong&gt; 额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 只需要启动 10 个隔离的应用即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速交付和部署&lt;/p&gt;

    &lt;p&gt;对开发和运维人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。&lt;/p&gt;

    &lt;p&gt;开发者可以使用一个标准镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 可以快速创建容器，&lt;strong&gt;&lt;em&gt;快速迭代&lt;/em&gt;&lt;/strong&gt;应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器很轻很快！容器的启动时间是秒级的，&lt;strong&gt;&lt;em&gt;大量&lt;/em&gt;&lt;/strong&gt; 地节约开发、测试、部署的时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;高效虚拟化、迁移、扩展&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器的运行不需要额外的 &lt;code class=&quot;highlighter-rouge&quot;&gt;hypervisor&lt;/code&gt; 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。&lt;/p&gt;

    &lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对比传统虚拟机&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/docker/compare.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14-docker-镜像&quot;&gt;1.4 Docker 镜像&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器运行时的&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;只读模板&lt;/strong&gt;&lt;/i&gt;，每一个镜像由一系列的层 (layers) 组成，最底层是&lt;code class=&quot;highlighter-rouge&quot;&gt;bootfs&lt;/code&gt;，接着是&lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;UnionFS&lt;/code&gt; 来将这些层联合到单独的镜像中。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UnionFS&lt;/code&gt; 允许独立文件系统中的文件和文件夹(称之为分支)被&lt;strong&gt;&lt;em&gt;透明覆盖&lt;/em&gt;&lt;/strong&gt;，形成一个单独连贯的文件系统。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/docker-images-fs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bootfs&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;镜像最底层的 &lt;strong&gt;&lt;em&gt;引导文件&lt;/em&gt;&lt;/strong&gt;　系统，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;bootloader&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;操作系统的内核&lt;/code&gt;。在容器启动完毕之后，为了节省内存空间，&lt;code class=&quot;highlighter-rouge&quot;&gt;bootfs&lt;/code&gt;会被卸载。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt;位于&lt;code class=&quot;highlighter-rouge&quot;&gt;bootfs&lt;/code&gt;之上，是&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;容器启动时内部进程课件的文件系统，即&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;容器的根目录。通常包含一个操作系统运行所需的文件系统。如&lt;code class=&quot;highlighter-rouge&quot;&gt;/dev&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/lib&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp&lt;/code&gt; 等。&lt;/p&gt;

&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt;设为只读模式，在挂载完成之后，利用&lt;code class=&quot;highlighter-rouge&quot;&gt;UnionFS&lt;/code&gt;，在&lt;code class=&quot;highlighter-rouge&quot;&gt;rootfs&lt;/code&gt;上方创建一个&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;读写层&lt;/strong&gt;&lt;/i&gt;，只有在&lt;code class=&quot;highlighter-rouge&quot;&gt;Docke&lt;/code&gt;容器运行过程中文件系统发生改变，才会把变化的文件内容写到可读可写层，并隐藏只读成的老版本文件（写时复制）。&lt;/p&gt;

&lt;p&gt;当修改镜像内的某个文件时，只对处于最上方的 &lt;strong&gt;&lt;em&gt;读写层&lt;/em&gt;&lt;/strong&gt; 进行了变动，不覆盖下层已有的文件系统的内容，已有文件在只读层的原始版本仍然存在，但会被读写层的新版本文件隐藏，当&lt;code class=&quot;highlighter-rouge&quot;&gt;docker commit&lt;/code&gt;这个修改过的容器文件系统为一个新的镜像时，保存的内容仅为上层读写文件系统中被更新过的文件。&lt;/p&gt;

&lt;h3 id=&quot;15-docker-仓库容器&quot;&gt;1.5 Docker 仓库、容器&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 仓库用来保存镜像，可以理解为代码控制中的代码仓库。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 仓库有公有和私有的概念。公有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 仓库名字是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker Hub&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。&lt;/p&gt;

&lt;p&gt;可以把容器看做是一个 &lt;i class=&quot;red&quot;&gt;&lt;strong&gt;简易版&lt;/strong&gt;&lt;/i&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt; 环境（包括&lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。&lt;/p&gt;

&lt;h3 id=&quot;16-命名空间&quot;&gt;1.6 命名空间&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;通过以下 &lt;strong&gt;&lt;em&gt;6&lt;/em&gt;&lt;/strong&gt; 种 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 从进程、网络、IPC、文件系统、UTS 和用户角度的隔离，一个 container 就可以对外展现出一个独立计算机的能力，并且不同 container 从 OS 层面实现了隔离。 然而不同 namespace 之间资源还是相互竞争的，仍然需要类似 ulimit 来管理每个 container 所能使用的资源 - &lt;code class=&quot;highlighter-rouge&quot;&gt;cgroup&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;161-pid-namespace&quot;&gt;1.6.1 pid namespace&lt;/h4&gt;
&lt;p&gt;不同用户的进程就是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;pid namespace&lt;/code&gt; 隔离开的，且不同 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中可以有相同 PID。具有以下特征:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中的 pid 是有各自的 pid=1 的进程(类似 &lt;code class=&quot;highlighter-rouge&quot;&gt;/sbin/init&lt;/code&gt; 进程)&lt;/li&gt;
  &lt;li&gt;每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中的进程只能影响自己的同一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 或子 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中的进程&lt;/li&gt;
  &lt;li&gt;因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 包含正在运行的进程，因此在 &lt;code class=&quot;highlighter-rouge&quot;&gt;container&lt;/code&gt; 中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;pseudo-filesystem&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc&lt;/code&gt; 目录只能看到自己 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中的进程&lt;/li&gt;
  &lt;li&gt;因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 允许嵌套，父 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 可以影响子 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 的进程，所以子 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 的进程可以在父 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中看到，但是具有不同的 pid&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;162-mnt-namespace&quot;&gt;1.6.2 mnt namespace&lt;/h4&gt;
&lt;p&gt;类似&lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt;，将一个进程放到一个特定的目录执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mnt namespace&lt;/code&gt; 允许不同 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt;的进程看到的文件结构不同，这样每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt;中的进程说看到的文件目录就被隔离开了。&lt;/p&gt;

&lt;p&gt;同&lt;code class=&quot;highlighter-rouge&quot;&gt;chroot&lt;/code&gt;不同，每个 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 中的容器在&lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/mounts&lt;/code&gt; 的信息只包含所在 &lt;code class=&quot;highlighter-rouge&quot;&gt;namespace&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;mount point&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;163-net-namespace&quot;&gt;1.6.3 net namespace&lt;/h4&gt;
&lt;p&gt;网络隔离是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;net namespace&lt;/code&gt; 实现的，内有&lt;code class=&quot;highlighter-rouge&quot;&gt;net namespace&lt;/code&gt; 有独立的network devices，IP addresses，IP routeing tables， &lt;code class=&quot;highlighter-rouge&quot;&gt;/proc/net&lt;/code&gt; 目录，这样每个容器的网络就能隔离开来。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 默认采用&lt;code class=&quot;highlighter-rouge&quot;&gt;veth&lt;/code&gt; 的方式将容器中的虚拟网卡同 宿主机host 上的一个&lt;code class=&quot;highlighter-rouge&quot;&gt;docker bridge&lt;/code&gt; 连接在一起。&lt;/p&gt;

&lt;h4 id=&quot;164-utsipc-namespace&quot;&gt;1.6.4 uts/ipc namespace&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;UTS(&quot;Unix Time-sharding System&quot;) namespace&lt;/code&gt; 允许每个 container 拥有独立的 &lt;code class=&quot;highlighter-rouge&quot;&gt;hostname&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;domain name&lt;/code&gt;，使其在网络上可以被视作一个独立的节点，而非宿主机上的一个进程。&lt;/p&gt;

&lt;p&gt;container 中进程交互采用 &lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt; 常见的进程间交互方法 (interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而同 VM 不同，container 的进程间交互实际上还是宿主机上具有相同 pid namespace 中的进程间交互，因此需要在IPC资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32bit ID。&lt;/p&gt;

&lt;h4 id=&quot;165-user-namespace&quot;&gt;1.6.5 user namespace&lt;/h4&gt;
&lt;p&gt;每个 container 可以有不同的 user 和 group id, 也就是说可以以 container 内部的用户在 container 内部执行程序而非 Host 上的用户。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link2&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二docker-安装&quot;&gt;二、Docker 安装&lt;/h2&gt;
&lt;h3 id=&quot;21-centos--red-hat-enterprice-linux&quot;&gt;2.1 CentOS / Red Hat Enterprice Linux&lt;/h3&gt;
&lt;p&gt;要求是&lt;code class=&quot;highlighter-rouge&quot;&gt;64&lt;/code&gt;位操作系统，内核版本&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;=3.0&lt;/code&gt;。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;yum&lt;/code&gt;源：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo tee /etc/yum.repos.d/docker.repo &amp;lt;&amp;lt;-'EOF'
  [dockerrepo]
  name=Docker Repository
  baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/
  enabled=1
  gpgcheck=1
  gpgkey=https://yum.dockerproject.org/gpg
  EOF 具体可以参考：

  https://docs.docker.com/engine/installation/linux/centos/
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装命令：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  yum install docker-engine -y
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置开机启动：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  systemctl enable docker
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动配置文件路径&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  /usr/lib/systemd/system/docker.service
	
  [Unit]
  Description=Docker Application Container Engine
  Documentation=https://docs.docker.com
  After=network.target docker.socket
  Requires=docker.socket

  [Service]
  Type=notify
  ExecStart=/usr/bin/docker daemon -H 0.0.0.0:2375 -H unix:///var/run/docker.sock
  MountFlags=slave
  LimitNOFILE=1048576
  LimitNPROC=1048576
  LimitCORE=infinity
  TimeoutStartSec=0

  [Install]
  WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;加载&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;免 &lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;(没权限访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/run/docker.sock&lt;/code&gt;)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  sudo groupadd docker
  sudo gpasswd -a ${USER} docker
  sudo service docker restart
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在安装的过程中，可能会提示有一个已安装的包冲突，先把冲突的卸载，&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  yum remove lvm-2.02
  yum install docker-engine –y
  yum install lvm-2.02 -y
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-mac-osx--windows&quot;&gt;2.2 Mac OSX / Windows&lt;/h3&gt;
&lt;p&gt;下载安装即可，或者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;docker-machine&lt;/code&gt;安装，后续会有介绍，下载链接：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://www.docker.com/products/docker-toolbox 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;23-centos--red-hat-enterprice-linux-测试&quot;&gt;2.3 CentOS / Red Hat Enterprice Linux 测试&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;运行&lt;code class=&quot;highlighter-rouge&quot;&gt;hello-world&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run hello-world
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker search centos
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # [:tag]指定pull的版本，不指定默认为latest
  docker pull centos[:7]
  # 查看当前本地镜像列表
  docker images
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;交互式运行容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run --name test -i -t -d centos /bin/bash
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看当前运行的程序&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker ps
  # 查看所有容器
  docker ps -a
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;连接到运行的容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker exec -it test /bin/bash
  # or
  docker attach test
  # 或容器的container id，退出 Ctrl +P,Ctrl +Q（exit或Ctrl+D退出容器） ### 2.4 常用命令介绍
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看所有&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;命令&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看启动&lt;code class=&quot;highlighter-rouge&quot;&gt;docker server&lt;/code&gt;的参数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker daemon --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看某个具体命令的介绍&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker &amp;lt;command&amp;gt; --help
  如： docker search --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pull 拉取镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker pull --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;push 推送指定镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker push --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;查看所有镜像列表&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker images --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移除一个或多个镜像&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker rmi --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker run --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker create --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker start --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;停止容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker stop --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;kill 容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker kill --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;删除容器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  docker rm --help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;link3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三端口映射网络&quot;&gt;三、端口映射、网络&lt;/h2&gt;
&lt;p&gt;顾名思义，就是将容器内部服务的端口，映射到宿主机上，以便在宿主机、外部网络能访问容器内部发布的服务。映射的方式有两种：自动映射和绑定映射端口。&lt;/p&gt;

&lt;p&gt;自动映射：在容器启动的时候，通过指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt; 参数( &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -P&lt;/code&gt; )，自动绑定所有对外提供服务的容器端口，映射的端口会在没有使用的端口池中（&lt;code class=&quot;highlighter-rouge&quot;&gt;49000-49900&lt;/code&gt;）自动选择。&lt;/p&gt;

&lt;p&gt;绑定映射：跟自动映射的区别在于，可以指定映射到宿主主机上的端口号，其基本语法如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -p [([&amp;lt;host_interface&amp;gt;:[host_port]])|(&amp;lt;host_port&amp;gt;):]&amp;lt;container_port&amp;gt;[/udp] &amp;lt;image&amp;gt; &amp;lt;cmd&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认不指定绑定ip，则监听所有网络端口。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt; 使用时需要指定&lt;code class=&quot;highlighter-rouge&quot;&gt;--expose&lt;/code&gt; 选项，用于指定需要对外监听的端口。&lt;/li&gt;
  &lt;li&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;docker inspect &amp;lt;contain id&amp;gt;&lt;/code&gt; 或&lt;code class=&quot;highlighter-rouge&quot;&gt;docker port &amp;lt;contain id&amp;gt; &amp;lt;port&amp;gt;&lt;/code&gt;等确定绑定信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;31-四种网络模式&quot;&gt;3.1 四种网络模式&lt;/h3&gt;
&lt;p&gt;在通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 命令创建并启动一个容器的时候，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net&lt;/code&gt; 选项指定容器的网络模式，可选网络模式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;模式，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=host&lt;/code&gt; 指定。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;container&lt;/code&gt;模式，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=container:name or id&lt;/code&gt;指定。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;none&lt;/code&gt;模式，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=none&lt;/code&gt; 指定。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bridge&lt;/code&gt;模式，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--net=bridge&lt;/code&gt; 指定。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不指定，默认使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;bridge&lt;/code&gt;模式（桥接）。&lt;/p&gt;

&lt;h4 id=&quot;311-host-模式&quot;&gt;3.1.1 host 模式&lt;/h4&gt;
&lt;p&gt;如果容器启动的时候指定了 &lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt; 模式，那么容器不会获取一个独立的 &lt;code class=&quot;highlighter-rouge&quot;&gt;network namespace&lt;/code&gt;，而是和宿主机 &lt;i class=&quot;red&quot;&gt;&lt;strong&gt;共用&lt;/strong&gt;&lt;/i&gt; 一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;network namespace&lt;/code&gt;。且不会虚拟自己的网卡、ip等，而是使用宿主机的 ip 和端口。&lt;/p&gt;

&lt;p&gt;形象一点描述，在 &lt;code class=&quot;highlighter-rouge&quot;&gt;10.211.55.2/24&lt;/code&gt; 主机上用 host 模式启动了一个容器，对外监听 &lt;code class=&quot;highlighter-rouge&quot;&gt;27017&lt;/code&gt; 端口。此时若在容器中用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ifconfig&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ip addr&lt;/code&gt; 等查看网络信息的命令查看，看到的是宿主机的网络信息。而外界可以直接通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;10.211.55.2:27017&lt;/code&gt;访问即可，不用进行任何 &lt;code class=&quot;highlighter-rouge&quot;&gt;NAT&lt;/code&gt; 转换，对于其他应用或人而言，就像一个 &lt;strong&gt;&lt;em&gt;直接运行在宿主机上的进程&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;相对的，容器的文件系统，进程等还是跟宿主机 &lt;strong&gt;&lt;em&gt;隔离&lt;/em&gt;&lt;/strong&gt; 的。&lt;/p&gt;

&lt;h4 id=&quot;312-container-模式&quot;&gt;3.1.2 container 模式&lt;/h4&gt;
&lt;p&gt;指定此模式创建启动容器，则新创建的容器会和指定的容器共享同一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;network namespace&lt;/code&gt;，新创建的容器不会配置自己的网络环境、ip端口等，而是和指定的容器共享同一套ip、端口池等。&lt;/p&gt;

&lt;p&gt;跟host模式一样，两个容器的文件系统、进程列表等还是相互 &lt;strong&gt;&lt;em&gt;隔离&lt;/em&gt;&lt;/strong&gt; 的，两个进程和通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;lo&lt;/code&gt; 网卡进行通信，&lt;code class=&quot;highlighter-rouge&quot;&gt;127.0.0.1&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;0.0.0.0&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;313-none-模式&quot;&gt;3.1.3 none 模式&lt;/h4&gt;
&lt;p&gt;此种模式下，容器拥有自己独立的 &lt;code class=&quot;highlighter-rouge&quot;&gt;network namespace&lt;/code&gt;，但是并不会创建任何网络配置，也就是说该容器并没有网卡、ip、路由等。&lt;/p&gt;

&lt;p&gt;也就是说，如果有网络配置要求，需要 &lt;i class=&quot;red&quot;&gt;&lt;strong&gt;人为&lt;/strong&gt;&lt;/i&gt; 去进行配置。&lt;/p&gt;

&lt;h4 id=&quot;314-bridge-模式&quot;&gt;3.1.4 bridge 模式&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt; 默认的网络模式，此模式为每个容器分配&lt;code class=&quot;highlighter-rouge&quot;&gt;network namespace&lt;/code&gt;、设置ip等，并将所有的容器通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;veth&lt;/code&gt; 连接到宿主机的虚拟网桥上 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt; 启动时，会自动创建该网桥）。&lt;/p&gt;

&lt;p&gt;虚拟网桥的工作方式跟物理交换机类似，这样所有宿主机上的容器都通过交换机连接在一个二层网络中。&lt;/p&gt;

&lt;p&gt;在创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 网桥时，会自动为其分配一个和宿主机不同的ip地址和子网，连接到 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt; 的容器就从其子网内选择一个未被使用的ip分配给容器。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt; 一般会使用&lt;code class=&quot;highlighter-rouge&quot;&gt;172.17.0.0/16&lt;/code&gt;这个网段，并将&lt;code class=&quot;highlighter-rouge&quot;&gt;172.17.42.1/16&lt;/code&gt;分配给&lt;code class=&quot;highlighter-rouge&quot;&gt;docker0&lt;/code&gt;网桥。也可以自己创建一个网桥，为其分配指定的网段，然后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt; 参数指定为&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;默认的网桥。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/bridge.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;32-跨主机容器互联&quot;&gt;3.2 跨主机容器互联&lt;/h3&gt;
&lt;p&gt;可行的方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kubernetes&lt;/code&gt; 集群&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm&lt;/code&gt; 集群 + &lt;code class=&quot;highlighter-rouge&quot;&gt;overlay&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接路由 – 要求所有主机&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四自定义容器&quot;&gt;四、自定义容器&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 的内容来自动构建镜像，&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt;是一个包含创建镜像所有命令的 &lt;strong&gt;&lt;em&gt;文本文件&lt;/em&gt;&lt;/strong&gt;，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker build&lt;/code&gt; 可以根据编写的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 来构建镜像。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 的指令选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FROM&lt;/li&gt;
  &lt;li&gt;MAINTAINER&lt;/li&gt;
  &lt;li&gt;RUN&lt;/li&gt;
  &lt;li&gt;CMD&lt;/li&gt;
  &lt;li&gt;EXPOSE&lt;/li&gt;
  &lt;li&gt;ENV&lt;/li&gt;
  &lt;li&gt;ADD&lt;/li&gt;
  &lt;li&gt;COPY&lt;/li&gt;
  &lt;li&gt;ENTRYPOINT&lt;/li&gt;
  &lt;li&gt;VOLUME&lt;/li&gt;
  &lt;li&gt;USER&lt;/li&gt;
  &lt;li&gt;WORKDIR&lt;/li&gt;
  &lt;li&gt;ONBUILD&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;41-from&quot;&gt;4.1 FROM&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM &amp;lt;image&amp;gt;[:tag] &amp;lt;i class='blue'&amp;gt;说明：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;指定构建镜像的基础镜像，一般来说就是提供运行环境的基础镜像（&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;环境、&lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt;运行环境等），若本地不存在，这自动去共有仓库&lt;code class=&quot;highlighter-rouge&quot;&gt;pull&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt; 必须是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 中非注释的第一个命令，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 中&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt; 开始。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FROM&lt;/code&gt; 可以出现多次，比如说需要构建多个镜像。&lt;/li&gt;
  &lt;li&gt;如果没有指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;[tag]&lt;/code&gt;，则默认使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;latest&lt;/code&gt;作为&lt;code class=&quot;highlighter-rouge&quot;&gt;tag&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;42-maintainer&quot;&gt;4.2 MAINTAINER&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MAINTAINER &amp;lt;name&amp;gt; &amp;lt;i class='blue'&amp;gt;说明：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;指定创建镜像的用户。&lt;/p&gt;

&lt;h3 id=&quot;43-run&quot;&gt;4.3 RUN&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUN &amp;lt;cmd&amp;gt;     命令会在一个shell中运行 /bin/sh -c
RUN [&quot;cmd&quot;, &quot;param1&quot;, &quot;param2&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;每条命令会在当前镜像上执行，并提交为新的镜像，后续的RUN 会在前面 RUN 提交的镜像为基础，镜像是分层的（UnionFS）。&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;第二种方式会被解析为一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;JSON&lt;/code&gt; 数组，必须使用双引号，且不会调用一个命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;，所以也就不会继承相应的变量，&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  RUN [&quot;echo&quot;, &quot;$HOME&quot;] 上述命令不会输出 `HOME` 变量，正确的应该，

  RUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot;]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt; 命令产生的缓存在下一次构建时并不会失效，会被重用，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--no-cache&lt;/code&gt; 禁用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;44-cmd&quot;&gt;4.4 CMD&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]  优先选择
CMD [&quot;param1&quot;, &quot;param2&quot;]  作为 ENTRYPOINT 的参数
CMD command param1 param2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;为在容器启动的时候，提供一个默认的命令执行选项。如果用户启动容器的时候指定了运行的命令，这会覆盖 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt; 指定的命令。&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt; 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 中能使用一次，如果使用多个，只有最后一个生效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;的差异：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;会在容器启动的时候执行，在容器构建的时候不执行，而RUN在容器构建时运行，待容器构建完成之后，后续的所有操作均与&lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;无关。&lt;/p&gt;

&lt;h3 id=&quot;45-expose&quot;&gt;4.5 EXPOSE&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt; …] &amp;lt;i class='blue'&amp;gt;说明：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;告诉 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 服务端容器对外映射的端口号，需要在容器运行的时候，通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run -p&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;-P&lt;/code&gt; 对外映射生效。&lt;/p&gt;

&lt;h3 id=&quot;46-env&quot;&gt;4.6 ENV&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;   # 只能设置一个变量
ENV &amp;lt;key&amp;gt;=&amp;lt;value&amp;gt; …   # 可以设置多个变量 &amp;lt;i class='blue'&amp;gt;说明：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;指定一个或多个环境变量，会被后续的 &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt; 命令所使用，并在容器运行时保留。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENV env1=test1 env2=test2
等同于
ENV env1 test1
ENV env2 test2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;47-add&quot;&gt;4.7 ADD&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ADD &amp;lt;src&amp;gt; … &amp;lt;dest&amp;gt; &amp;lt;i class='blue'&amp;gt;说明：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;复制本地主机文件、目录或者远程文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;URLS&lt;/code&gt; 从 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 并且添加到容器指定路径中 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 支持通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;GO&lt;/code&gt; 的正则模糊匹配，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ADD hom* /mydir/
ADD hom?.txt /mydir/ &amp;lt;i class='red'&amp;gt;注意：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 路径必须是绝对路径，如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;dest&amp;gt;&lt;/code&gt; 不存在，会自动创建对应目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 路径必须是 &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 所在路径的相对路径&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;src&amp;gt;&lt;/code&gt; 如果是一个目录，只会复制目录下的内容，而目录本身则不会被复制&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;48-copy&quot;&gt;4.8 COPY&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;COPY &amp;lt;src&amp;gt; … &amp;lt;dest&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt; 复制新文件或者目录从 &lt;src&gt; 添加到容器指定路径中 &lt;dest&gt;。&lt;/dest&gt;&lt;/src&gt;&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;用法同 &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt;，与 &lt;code class=&quot;highlighter-rouge&quot;&gt;ADD&lt;/code&gt; 的区别是，&lt;code class=&quot;highlighter-rouge&quot;&gt;COPY&lt;/code&gt; 不能指定远程文件。&lt;/p&gt;

&lt;h3 id=&quot;49-entrypoint&quot;&gt;4.9 ENTRYPOINT&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]
ENTRYPOINT command param1 param2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;创建容器启动后执行的命令，并且不可以被 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt;提供的参数覆盖，如需替换，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run --entrypoint&lt;/code&gt;选项。&lt;/p&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 只能有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt;，如指定多个，只有最后一个生效。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM centos:7
ENTRYPOINT [“top”, “-b”]
CMD [“-c”] 使用 `exec form`来指定默认启动命令，通过`CMD`添加默认启动命令之外，经常被更改的参数项。

FROM centos:7
ENTRYPOINT exec top -b
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/sh -c&lt;/code&gt; 中执行，会忽略任何 &lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker run&lt;/code&gt; 命令行选项，为了确保 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker stop&lt;/code&gt; 能够停止长时间运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt; 的容器，确保执行的时候使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; 选项.&lt;/p&gt;

&lt;h3 id=&quot;410-volume&quot;&gt;4.10 VOLUME&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VOLUME [“/data”]
VOLUME /data/db /data/logs &amp;lt;i class='blue'&amp;gt;说明：&amp;lt;/i&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建一个可以从本地主机或其他容器挂载的挂载点&lt;/p&gt;

&lt;h3 id=&quot;411-user&quot;&gt;4.11 USER&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;USER daemon
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;指定运行容器时的用户名或 UID，后续的 &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt; 也会使用指定用户。&lt;/p&gt;

&lt;h3 id=&quot;412-workdir&quot;&gt;4.12 WORKDIR&lt;/h3&gt;
&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WORKDIR /path/to/your/dir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;为后续的 &lt;code class=&quot;highlighter-rouge&quot;&gt;RUN&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;CMD&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;ENTRYPOINT&lt;/code&gt; 指令配置工作目录。可以使用多个 &lt;code class=&quot;highlighter-rouge&quot;&gt;WORKDIR&lt;/code&gt; 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WORKDIR /a
WORKDIR b
WORKDIR c

最后的路径为 /a/b/c ### 4.13 ONBUILD 用法：

ONBUILD [INSTRUCTION]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;blue&quot;&gt;说明：&lt;/i&gt;&lt;/p&gt;

&lt;p&gt;配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。&lt;/p&gt;

&lt;h3 id=&quot;414-mongodb实例&quot;&gt;4.14 mongodb实例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM centos:7

RUN mkdir -p /data/db /data/logs /keys /config

ADD source/mongodb-bin.tar.gz /usr/local/bin
COPY source/mongod.conf /config/
COPY source/mongodb-keyfile /keys/
COPY source/authAdmin.ms /config/

RUN chmod 600 /keys/mongodb-keyfile \
	&amp;amp;&amp;amp; ls -l /keys \
	&amp;amp;&amp;amp; mongo --version
COPY docker-entrypoint.sh /entrypoint.sh
ENTRYPOINT [&quot;/entrypoint.sh&quot;]

EXPOSE 27017

WORKDIR /config
CMD [&quot;mongod&quot;, &quot;-f&quot;, &quot;mongod.conf&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;link5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;五容器数据卷管理&quot;&gt;五、容器数据卷管理&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 镜像 &amp;lt;==&amp;gt; 只读层，虽然提高了镜像构建、存储和分发效率，但是也有如下的缺点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;容器文件在宿主机上保存形式复杂，不易在宿主机上进行访问。&lt;/li&gt;
  &lt;li&gt;多个容器间数据无法共享。&lt;/li&gt;
  &lt;li&gt;删除容器时，容器产生的数据会丢失。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因而，&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 引入了数据卷（&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;）机制，存在于一个或多个容器中的特定文件或文件夹，能独立于联合文件系统的形式存在于宿主机中，并能为多个容器所共享。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在容器创建时初始化，容器运行时就可以使用其中的文件。&lt;/li&gt;
  &lt;li&gt;能在不同容器之间共享和重用。&lt;/li&gt;
  &lt;li&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;中数据的操作会马上生效。&lt;/li&gt;
  &lt;li&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;的操作不会影响到镜像本身。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;的生命周期独立于容器的生存周期。（即使删除容器，&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;仍然存在，没有任何容器使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;也不会被&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt;删除）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;51-添加数据卷&quot;&gt;5.1 添加数据卷&lt;/h3&gt;
&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 选项添加一个数据卷，或者可以使用多次 &lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt; 选项为一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt; 容器运行挂载多个数据卷。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name test -v /data -i -t -d centos /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建的数据卷可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker inspect&lt;/code&gt; 获取宿主机对应路径。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker inspect test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者直接通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;--format&lt;/code&gt; 只显示需要的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker inspect --format=“” data
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;此种方式添加的数据卷，数据默认保存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/volumes&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;52-挂载宿主机目录&quot;&gt;5.2 挂载宿主机目录&lt;/h3&gt;
&lt;p&gt;除了直接挂载一个数据卷到容器之外，还可以将宿主机中的一个文件或目录挂载到容器当中。格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name mongod -itd -p 27017:27017 -v /data/db:/data phoenix-mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认挂载是读写的，可以在挂载的时候指定只读。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name mongod -itd -p 27017:27017 -v /data/db:/data:ro phoenix-mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是实际在运用过程中，会遇到一些问题，即挂载之后在容器中没有权限读取挂载的目录，只要将上述的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ro&lt;/code&gt; 指定为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; 即可，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -name mongod -itd -p 27017:27017 -v /data/db:/data:Z phoenix-mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stackoverflow&lt;/code&gt;上关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Z&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;z&lt;/code&gt; 的说明:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://stackoverflow.com/questions/24288616/permission-denied-on-accessing-host-directory-in-docker
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;53-数据卷容器&quot;&gt;5.3 数据卷容器&lt;/h3&gt;
&lt;p&gt;如果需要在容器（或非持久性容器）间共享一些持久性数据，最好的办法是创建一个数据卷容器，然后从此容器上挂载数据。&lt;/p&gt;

&lt;p&gt;创建数据卷容器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -itd -v /data/test:/test:Z --name data centos echo hello
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--volume-from&lt;/code&gt; 选项在另一个容器上挂载 &lt;code class=&quot;highlighter-rouge&quot;&gt;/test&lt;/code&gt; 卷，不管 &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; 容器是否运行，其它容器都可以挂载该容器数据卷，若只是一个单独的数据卷（容器中没有任何服务逻辑）是不需要创建容器的，直接通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker volume create&lt;/code&gt; 创建即可。&lt;/p&gt;

&lt;p&gt;使用容器数据卷：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name test1 -itd --volume-form data centos /bin/bash
docker run --name test2 -itd --volume-form data centos /bin/bash 也可以继承其它挂载 `/test` 卷的容器，

docker run --name test3 -itd --volume-form test2 centos /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建为按成之后的结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/container-volume.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;删除数据卷&lt;code class=&quot;highlighter-rouge&quot;&gt;volume&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker rm -v，删除容器时指定 -v 参数。
docker run --rm ，启动容器的时候指定 --rm 参数。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;若不像上述方式，在删除容器的时候删除其数据卷的话，会在 &lt;code class=&quot;highlighter-rouge&quot;&gt;/var/lib/docker/volumes&lt;/code&gt; 目录下遗留很多文件及目录。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;link6&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;六其它&quot;&gt;六、其它&lt;/h2&gt;
&lt;p&gt;很多部署&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 服务的时候，会遇到容器间需要交互的情况，如展示WEB服务、数据库容器之间。&lt;/p&gt;

&lt;p&gt;容器见的交互，是在&lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt; 启动参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;--icc&lt;/code&gt; 控制，特殊情况为了保证容器及宿主机的安全，&lt;code class=&quot;highlighter-rouge&quot;&gt;--icc&lt;/code&gt; 通常设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，即容器间不能进行交互。如果直接向外映射端口，虽然可以达到交互的条件，但是也可能不能满足安全性的要求。&lt;/p&gt;

&lt;p&gt;链接就是为了解决这一问题的，&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 的连接系统可以在两个容器间建立一个安全的通道，斯特接收容器可以通过此通道访问源容器指定的相关服务信息（数据库访问等）。&lt;/p&gt;

&lt;p&gt;用法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;--link &amp;lt;name or id&amp;gt;:alias
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;61-示例&quot;&gt;6.1 示例&lt;/h3&gt;
&lt;p&gt;现有两个容器 &lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;db&lt;/code&gt;，分别提供展示和数据库服务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run --name db -itd phoenix-mongo
docker run --name web --link db:webdb phoenix-web
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如此一个&lt;code class=&quot;highlighter-rouge&quot;&gt;link&lt;/code&gt;就创建完成了，&lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;容器可以从&lt;code class=&quot;highlighter-rouge&quot;&gt;db&lt;/code&gt;容器中获取数据，&lt;code class=&quot;highlighter-rouge&quot;&gt;web&lt;/code&gt;容器叫作接收容器或父容器，&lt;code class=&quot;highlighter-rouge&quot;&gt;db&lt;/code&gt;容器叫作源容器或子容器。链接的具体实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置接收容器的环境变量。&lt;/li&gt;
  &lt;li&gt;更新接收容器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt; 文件。&lt;/li&gt;
  &lt;li&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;iptables&lt;/code&gt;规则，使容器链接的两个容器可以通讯。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;i class=&quot;red&quot;&gt;注意：&lt;/i&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;一个接收容器可以设置多个源容器，一个源容器也可以有多个接收容器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;62-swarm-集群介绍&quot;&gt;6.2 swarm 集群介绍&lt;/h3&gt;
&lt;p&gt;将一系列 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 宿主机变为一个集群，对外而言就像一个单一的宿主机一样。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm&lt;/code&gt;由一个&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm manager&lt;/code&gt;和若干个&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm node&lt;/code&gt; 组成，&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm manager&lt;/code&gt;上运行&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm daemon&lt;/code&gt;，用户跟&lt;code class=&quot;highlighter-rouge&quot;&gt;manager&lt;/code&gt;通信，&lt;code class=&quot;highlighter-rouge&quot;&gt;manager&lt;/code&gt;将操作转发到对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;node&lt;/code&gt;上。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm daemon&lt;/code&gt;只是一个调度器（&lt;code class=&quot;highlighter-rouge&quot;&gt;scheduler&lt;/code&gt;）和路由器（&lt;code class=&quot;highlighter-rouge&quot;&gt;router&lt;/code&gt;）的组合，其本身并不会运行任何 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 容器，它只是接受 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 客户端发来的请求，调度合适的 &lt;code class=&quot;highlighter-rouge&quot;&gt;swarm node&lt;/code&gt; 来运行&lt;code class=&quot;highlighter-rouge&quot;&gt;container&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;若&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm daemon&lt;/code&gt;意外挂掉了，已经运行的容器不会受到任何影响。其架构如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/swarm-arch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;三个独立的主机，分别装了&lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/single-docker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;swarm&lt;/code&gt;创建集群：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/docker/swarm-cluster.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;63-docker-compose-简介&quot;&gt;6.3 docker-compose 简介&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; 重现一个容器，&lt;code class=&quot;highlighter-rouge&quot;&gt;Compose&lt;/code&gt;重现容器的配置和集群。&lt;/p&gt;

&lt;p&gt;编排&lt;code class=&quot;highlighter-rouge&quot;&gt;Orchestration&lt;/code&gt;，定义被部署对象的各个组成部分之间的耦合关系，部署流程中各个动作的执行顺序，部署过程说需要的依赖文件，被部署文件的存储位置和获取方式，以及如何验证部署成功。&lt;/p&gt;

&lt;p&gt;部署&lt;code class=&quot;highlighter-rouge&quot;&gt;Deployment&lt;/code&gt;，安装编排指定的内容和流程，在目标主机上执行编排指定的环境初始化，存放指定的依赖和文件，运行指定的部署动作，最终安装编排的规则确认部署成功与否。&lt;/p&gt;

&lt;p&gt;说的简单点，就是安装一个特定的顺序，完成其指定的容器启动顺序，并校验部署的成功与否。&lt;/p&gt;

&lt;h4 id=&quot;631-示例&quot;&gt;6.3.1 示例&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-- docker-compose.yml
web:
images: phoenix-web
ports:
- “3000:3000”
links:
- db
db:
images: phoenix-mongo
volumes:
- /data/db:/data:Z
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose up
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;64-docker-machine-简介&quot;&gt;6.4 docker-machine 简介&lt;/h3&gt;
&lt;p&gt;对于 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 集群而言，需要每台宿主机有安装并启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt; 进程，而安装启动&lt;code class=&quot;highlighter-rouge&quot;&gt;docker&lt;/code&gt;进程的过程是重复，&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker Machine&lt;/code&gt;把用户搭建&lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 环境的各种方案汇集在一起，简化了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 环境搭建过程，让用户和把时间花在开发上。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Machine&lt;/code&gt; 主要帮助用户在不同的云主机等上，创建并管理虚拟机，并在虚拟机中安装Docker，而 Docker本身就是客户端程序与守护进程之间的交互，启动了&lt;code class=&quot;highlighter-rouge&quot;&gt;docker daemon&lt;/code&gt;即搭建了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Docker&lt;/code&gt; 运行环境。&lt;/p&gt;

&lt;p&gt;目前已经支持十余种运品台和虚拟机软件，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;Amazon Web Services&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Google Compute Engine&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;OpenStack&lt;/code&gt;等。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Machine&lt;/code&gt; 支持多种虚拟机软件和众多主流的&lt;code class=&quot;highlighter-rouge&quot;&gt;IaaS&lt;/code&gt;平台，支持的虚拟机软件有&lt;code class=&quot;highlighter-rouge&quot;&gt;VirtualBox&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Vmware Fusion&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Hyper-V&lt;/code&gt;，涵盖了&lt;code class=&quot;highlighter-rouge&quot;&gt;Linux&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Mac&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Windows&lt;/code&gt;三大平台。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Zen Coding：快速编写HTML</title>
   <link href="http://www.blogways.net/blog/2016/12/08/zen-coding.html"/>
   <updated>2016-12-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/08/zen-coding</id>
   <content type="html">&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;HTML 语言很简单，但是却比较难写。各种标签、符号实在是太多了，标签又包含很多属性、class、id。想写出一个好看的静态页面确实是非常耗时而且麻烦。&lt;/p&gt;

&lt;p&gt;下面要介绍的 Zen Coding 是一种借助 CSS 选择器的方式帮你快速编写 HTML 代码的方法。它能用很短的语句写出很长的 HTML 代码。&lt;/p&gt;

&lt;p&gt;让我们来见识一下它的威力。&lt;/p&gt;

&lt;h2 id=&quot;二实例介绍&quot;&gt;二、实例介绍&lt;/h2&gt;
&lt;p&gt;在开始使用 Zen Coding 之前，介绍一下它支持的 CSS 选择器：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;E：
元素名称(div, p);&lt;/li&gt;
  &lt;li&gt;E#id：
使用id的元素(div#content, p#intro, span#error);&lt;/li&gt;
  &lt;li&gt;E.class：
使用类的元素(div.header, p.error.critial). 你也可以联合使用class和idID: div#content.column.width;&lt;/li&gt;
  &lt;li&gt;E&amp;gt;N：
子代元素(div&amp;gt;p, div#footer&amp;gt;p&amp;gt;span);&lt;/li&gt;
  &lt;li&gt;E+N：
兄弟元素(h1+p, div#header+div#content+div#footer);&lt;/li&gt;
  &lt;li&gt;E&lt;em&gt;N：
元素倍增(ul#nav&amp;gt;li&lt;/em&gt;5&amp;gt;a);&lt;/li&gt;
  &lt;li&gt;E$&lt;em&gt;N：
条目编号 (ul#nav&amp;gt;li.item-$&lt;/em&gt;5);&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Zen Coding 其实就是基于这样的语法来快速生成 HTML 的。&lt;/p&gt;

&lt;h3 id=&quot;编辑器&quot;&gt;编辑器&lt;/h3&gt;
&lt;p&gt;下面所做的演示全部都来自 &lt;em&gt;Atom&lt;/em&gt;，&lt;em&gt;Brackets&lt;/em&gt; 同样也支持 Zen Coding。&lt;/p&gt;

&lt;h3 id=&quot;实例一&quot;&gt;实例一&lt;/h3&gt;
&lt;p&gt;在编辑器中输入：
&lt;code class=&quot;highlighter-rouge&quot;&gt;！&lt;/code&gt;
然后按&lt;em&gt;tab&lt;/em&gt;键。
最后生成的结果是：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/example1.png&quot; alt=&quot;example1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;没错就是这么&lt;em&gt;神奇&lt;/em&gt;。&lt;/p&gt;

&lt;h3 id=&quot;实例二&quot;&gt;实例二&lt;/h3&gt;
&lt;p&gt;在页面中添加一个 class 为 &lt;em&gt;col-sm-6&lt;/em&gt; 的 div 标签，只需要输入
&lt;code class=&quot;highlighter-rouge&quot;&gt;div.col-sm-6&lt;/code&gt;，然后按 tab 键。&lt;/p&gt;

&lt;p&gt;如果想添加12个 class 为 &lt;em&gt;col-sm-1&lt;/em&gt; 的 div 标签呢？&lt;/p&gt;

&lt;p&gt;只需要输入&lt;code class=&quot;highlighter-rouge&quot;&gt;div.col-sm-1*12&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;同理，如果想要输出 id 为 test 的 div 标签只需要把&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;换成&lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt;就行了。&lt;/p&gt;

&lt;h3 id=&quot;实例四&quot;&gt;实例四&lt;/h3&gt;
&lt;p&gt;在页面中添加&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/example2.png&quot; alt=&quot;example2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code class=&quot;highlighter-rouge&quot;&gt;h1+p&lt;/code&gt;即可。&lt;/p&gt;

&lt;h3 id=&quot;实例五&quot;&gt;实例五&lt;/h3&gt;
&lt;p&gt;想要下面这种效果？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/example3.png&quot; alt=&quot;example3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;输入&lt;code class=&quot;highlighter-rouge&quot;&gt;div.item$*3&lt;/code&gt;！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>nodejs的异步流程控制</title>
   <link href="http://www.blogways.net/blog/2016/12/07/nodejs-async.html"/>
   <updated>2016-12-07T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/07/nodejs-async</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#begin&quot;&gt;为什么使用异步流程控制&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;Async的介绍和安装&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;Async的函数介绍&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3rd&quot;&gt;使用案例&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;总结与心得&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;begin&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1为什么使用异步流程控制&quot;&gt;1.为什么使用异步流程控制&lt;/h2&gt;

&lt;p&gt;“流程控制”本来是件比较简单的事，但是由于Nodejs的异步架构的实现方法，对于需要同步的业务逻辑，实现起来就比较麻烦。嵌套3-4层，代码就会变得的支离破碎了！
如何让代码看起来简介，而且过程可控，这里我们就需要引入异步流程控制。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2async的介绍和安装&quot;&gt;2.Async的介绍和安装&lt;/h2&gt;

&lt;p&gt;Async是一个流程控制工具包，提供了直接而强大的异步功能。基于Javascript为Node.js设计，同时也可以直接在浏览器中使用。&lt;/p&gt;

&lt;p&gt;Async提供了大约20个函数，包括常用的 map, reduce, filter, forEach 等，异步流程控制模式包括，串行(series)，并行(parallel)，瀑布(waterfall)等。&lt;/p&gt;

&lt;p&gt;(1). 安装环境&lt;/p&gt;

&lt;p&gt;Npm:1.2.19&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;nodejs&lt;/p&gt;

&lt;p&gt;(2) 安装方式&lt;/p&gt;

&lt;p&gt;npm install async&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3async的函数介绍&quot;&gt;3.Async的函数介绍&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;async主要实现了三个部分的流程控制功能：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;集合: Collections&lt;/li&gt;
&lt;li&gt;流程控制: Control Flow&lt;/li&gt;
&lt;li&gt;工具类: Utils&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;1). 集合: Collections&lt;/p&gt;

&lt;p&gt;each: 如果想对同一个集合中的所有元素都执行同一个异步操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;: 对集合中的每一个元素，执行某个异步操作，得到结果。所有的结果将汇总到最终的callback里。与each的区别是，each只关心操作不管最后的值，而map关心的最后产生的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;filter&lt;/strong&gt;: 使用异步操作对集合中的元素进行筛选, 需要注意的是，iterator的callback只有一个参数，只能接收true或false。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;reject&lt;/strong&gt;: reject跟filter正好相反，当测试为true时则抛弃&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;reduce&lt;/strong&gt;: 可以让我们给定一个初始值，用它与集合中的每一个元素做运算，最后得到一个值。reduce从左向右来遍历元素，如果想从右向左，可使用reduceRight。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;detect&lt;/strong&gt;: 用于取得集合中满足条件的第一个元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sortBy&lt;/strong&gt;: 对集合内的元素进行排序，依据每个元素进行某异步操作后产生的值，从小到大排序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;some&lt;/strong&gt;: 当集合中是否有至少一个元素满足条件时，最终callback得到的值为true，否则为false。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;every&lt;/strong&gt;: 如果集合里每一个元素都满足条件，则传给最终回调的result为true，否则为false。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;concat&lt;/strong&gt;: 将多个异步操作的结果合并为一个数组。&lt;/p&gt;

&lt;p&gt;2). 流程控制: Control Flow&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;series&lt;/strong&gt;: 串行执行，一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;parallel&lt;/strong&gt;: 并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;whilst&lt;/strong&gt;: 相当于while，但其中的异步调用将在完成后才会进行下一次循环。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;doWhilst&lt;/strong&gt;: 相当于do…while, doWhilst交换了fn,test的参数位置，先执行一次循环，再做test判断。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;until&lt;/strong&gt;: until与whilst正好相反，当test为false时循环，与true时跳出。其它特性一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;doUntil&lt;/strong&gt;: doUntil与doWhilst正好相反，当test为false时循环，与true时跳出。其它特性一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;forever&lt;/strong&gt;: 无论条件循环执行，如果不出错，callback永远不被执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;waterfall&lt;/strong&gt;: 按顺序依次执行一组函数。每个函数产生的值，都将传给下一个。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;compose&lt;/strong&gt;: 创建一个包括一组异步函数的函数集合，每个函数会消费上一次函数的返回值。把f(),g(),h()异步函数，组合成f(g(h()))的形式，通过callback得到返回值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;applyEach&lt;/strong&gt;: 实现给一数组中每个函数传相同参数，通过callback返回。如果只传第一个参数，将返回一个函数对象，我可以传参调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;queue&lt;/strong&gt;: 是一个串行的消息队列，通过限制了worker数量，不再一次性全部执行。当worker数量不够用时，新加入的任务将会排队等候，直到有新的worker可用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;cargo&lt;/strong&gt;: 一个串行的消息队列，类似于queue，通过限制了worker数量，不再一次性全部执行。不同之处在于，cargo每次会加载满额的任务做为任务单元，只有任务单元中全部执行完成后，才会加载新的任务单元。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;auto&lt;/strong&gt;: 用来处理有依赖关系的多个任务的执行。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;iterator&lt;/strong&gt;: 将一组函数包装成为一个iterator，初次调用此iterator时，会执行定义中的第一个函数并返回第二个函数以供调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;apply&lt;/strong&gt;: 可以让我们给一个函数预绑定多个参数并生成一个可直接调用的新函数，简化代码。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nextTick&lt;/strong&gt;: 与nodejs的nextTick一样，再最后调用函数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;times&lt;/strong&gt;: 异步运行,times可以指定调用几次，并把结果合并到数组中返回。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;timesSeries&lt;/strong&gt;: 与time类似，唯一不同的是同步执行&lt;/p&gt;

&lt;p&gt;3). 工具类: Utils&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;memoize&lt;/strong&gt;: 让某一个函数在内存中缓存它的计算结果。对于相同的参数，只计算一次，下次就直接拿到之前算好的结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;unmemoize&lt;/strong&gt;: 让已经被缓存的函数，返回不缓存的函数引用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;log&lt;/strong&gt;: 执行某异步函数，并记录它的返回值，日志输出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;dir&lt;/strong&gt;: 与log类似，不同之处在于，会调用浏览器的console.dir()函数，显示为DOM视图。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;noConflict&lt;/strong&gt;: 如果之前已经在全局域中定义了async变量，当导入本async.js时，会先把之前的async变量保存起来，然后覆盖它。仅仅用于浏览器端，在nodejs中没用，这里无法演示。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;3rd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3async的使用案例&quot;&gt;3.Async的使用案例&lt;/h2&gt;

&lt;h3 id=&quot;1-seriestasks-callback-多个函数依次执行之间没有数据交换&quot;&gt;1. series(tasks, [callback]) （多个函数依次执行，之间没有数据交换）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var async = require('async')
    async.series([
       step1, step2, step3
    ], function(err, values) {
       // do somethig with the err or values v1/v2/v3
    });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（1）依次执行一个函数数组中的每个函数，每一个函数执行完成之后才能执行下一个函数。&lt;/p&gt;

&lt;p&gt;（2）如果任何一个函数向它的回调函数中传了一个error，则后面的函数都不会被执行，并且将会立刻会将该error以及已经执行了的函数的结果，传给series中最后那个callback。&lt;/p&gt;

&lt;p&gt;（3）当所有的函数执行完后（没有出错），则会把每个函数传给其回调函数的结果合并为一个数组，传给series最后的那个callback。&lt;/p&gt;

&lt;p&gt;（4）还可以json的形式来提供tasks。每一个属性都会被当作函数来执行，并且结果也会以json形式传给series最后的那个callback。这种方式可读性更高一些。&lt;/p&gt;

&lt;h3 id=&quot;2-paralleltasks-callback-多个函数并行执行&quot;&gt;2. parallel(tasks, [callback]) （多个函数并行执行）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async.parallel([
    function(cb) { t.fire('a400', cb, 400) },
    function(cb) { t.fire('a200', cb, 200) },
    function(cb) { t.fire('a300', cb, 300) }
], function (err, results) {
    log('1.1 err: ', err); // -&amp;gt; undefined
    log('1.1 results: ', results); // -&amp;gt;[ 'a400', 'a200', 'a300' ]
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（1）并行执行多个函数，每个函数都是立即执行，不需要等待其它函数先执行。传给最终callback的数组中的数据按照tasks中声明的顺序，而不是执行完成的顺序。&lt;/p&gt;

&lt;p&gt;（2）如果某个函数出错，则立刻将err和已经执行完的函数的结果值传给parallel最终的callback。其它未执行完的函数的值不会传到最终数据，但要占个位置。&lt;/p&gt;

&lt;p&gt;（3）同时支持json形式的tasks，其最终callback的结果也为json形式&lt;/p&gt;

&lt;h3 id=&quot;3-waterfalltasks-callback-多个函数依次执行且前一个的输出为后一个的输入&quot;&gt;3. waterfall(tasks, [callback]) （多个函数依次执行，且前一个的输出为后一个的输入）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async.waterfall([
    function(cb) { log('1.1.1: ', 'start'); cb(null, 3); },
    function(n, cb) { log('1.1.2: ',n); t.inc(n, cb); },
    function(n, cb) { log('1.1.3: ',n); t.fire(n*n, cb); }
], function (err, result) {
    log('1.1 err: ', err); // -&amp;gt; null
    log('1.1 result: ', result); // -&amp;gt; 16
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（1）与seires相似，按顺序依次执行多个函数。不同之处，每一个函数产生的值，都将传给下一个函数。如果中途出错，后面的函数将不会被执行。错误信息以及之前产生的结果，将传给waterfall最终的callback。&lt;/p&gt;

&lt;p&gt;（2）这个函数名为waterfall(瀑布)，可以想像瀑布从上到下，中途冲过一层层突起的石头。注意，该函数不支持json格式的tasks。&lt;/p&gt;

&lt;h3 id=&quot;4autotasks-callback-多个函数有依赖关系有的并行执行有的依次执行&quot;&gt;4.auto(tasks, [callback]) （多个函数有依赖关系，有的并行执行，有的依次执行）&lt;/h3&gt;

&lt;p&gt;这里假设我要写一个程序，它要完成以下几件事：
从某处取得数据&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在硬盘上建立一个新的目录&lt;/li&gt;

&lt;li&gt;将数据写入到目录下某文件&lt;/li&gt;

&lt;li&gt;发送邮件，将文件以附件形式发送给其它人&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析该任务，可以知道1与2可以并行执行，3需要等1和2完成，4要等3完成。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;async.auto({
    getData: function (callback) {
        setTimeout(function(){
            console.log('1.1: got data');
            callback();
        }, 300);
    },
    makeFolder: function (callback) {
        setTimeout(function(){
            console.log('1.1: made folder');
            callback();
        }, 200);
    },
    writeFile: ['getData', 'makeFolder', function(callback) {
        setTimeout(function(){
            console.log('1.1: wrote file');
            callback(null, 'myfile');
        }, 300);
    }],
    emailFiles: ['writeFile', function(callback, results) {
        log('1.1: emailed file: ', results.writeFile); // -&amp;gt; myfile
        callback(null, results.writeFile);
    }]
}, function(err, results) {
    log('1.1: err: ', err); // -&amp;gt; null
    log('1.1: results: ', results); // -&amp;gt; { makeFolder: undefined,
                                    //      getData: undefined,
                                    //      writeFile: 'myfile',
                                    //      emailFiles: 'myfile' }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（1）用来处理有依赖关系的多个任务的执行。比如某些任务之间彼此独立，可以并行执行；但某些任务依赖于其它某些任务，只能等那些任务完成后才能执行。&lt;/p&gt;

&lt;p&gt;（2）虽然我们可以使用async.parallel和async.series结合起来实现该功能，但如果任务之间关系复杂，则代码会相当复杂，以后如果想添加一个新任务，也会很麻烦。这时使用async.auto，则会事半功倍。&lt;/p&gt;

&lt;p&gt;（3）如果有任务中途出错，则会把该错误传给最终callback，所有任务（包括已经执行完的）产生的数据将被忽略。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;5总结与心得&quot;&gt;5.总结与心得&lt;/h2&gt;

&lt;p&gt;在凤来平台开发过程，对于数据库连续操作，由于nodejs异步的原因，我们不好对结果出现的顺序进行控制，或者回调函数使用过多，维护起来十分麻烦，使用异步操作可以很方便的解决开发过程中出现的一系列问题。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>apache tiles布局框架的简单使用</title>
   <link href="http://www.blogways.net/blog/2016/12/06/apache-apacheTiles.html"/>
   <updated>2016-12-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/06/apache-apacheTiles</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;apache tiles简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2st&quot;&gt;apache tiles的优势&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3st&quot;&gt;apache tiles的简单使用&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一apache-tiles的简介&quot;&gt;一、apache tiles的简介&lt;/h2&gt;

&lt;h3 id=&quot;apache-tiles是一个javaee应用的页面布局框架tiles框架提供了一种模板机制可以为某一类页面定义一个通用的模板该模板定义了页面的整体布局布局由可以复用的多个块组成每个页面可以有选择性的重新定义块而达到组件的复用&quot;&gt;Apache Tiles是一个JavaEE应用的页面布局框架。Tiles框架提供了一种模板机制，可以为某一类页面定义一个通用的模板，该模板定义了页面的整体布局。布局由可以复用的多个块组成，每个页面可以有选择性的重新定义块而达到组件的复用。&lt;/h3&gt;

&lt;h3 id=&quot;apache-tiles一开始是apache-struts框架的组件之一后来才被apache独立为一个独立项目&quot;&gt;apache tiles一开始是apache Struts框架的组件之一，后来才被apache独立为一个独立项目。&lt;/h3&gt;

&lt;h3 id=&quot;tiles主要有以下几个特点&quot;&gt;tiles主要有以下几个特点：&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;1.模板机制的页面布局功能。&lt;/li&gt;
  &lt;li&gt;2.页面布局的重构机制，使用模板的页面，可以直接在JSP里使用Tiles提供的标签重新定义块元素，也可以使用类似tiles.xml等配置文件定义。&lt;/li&gt;
  &lt;li&gt;3.易于与Struts，Spring，SpringMVC，Shale，JSF等框架集成 。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二apache-tiles的优势&quot;&gt;二、apache tiles的优势&lt;/h2&gt;

&lt;h3 id=&quot;大家都知道在web开发中我们可以通过include标签来动态的插入其它的jsp页面这样能够让多个jsp页面共用一个jsp界面的内容这个功能能够让我们在开发中节省很多时间并且实用&quot;&gt;大家都知道，在web开发中、我们可以通过include标签来动态的插入其它的jsp页面，这样能够让多个jsp页面共用一个jsp界面的内容，这个功能能够让我们在开发中节省很多时间，并且实用。&lt;/h3&gt;

&lt;h3 id=&quot;如果有一天我们需要把这个界面删除掉的话或者说添加修改一个界面需要在每个jsp的引入位置把引入删除掉添加修改一个jsp界面当然这个处理听起来比较方便但是如果有几百几千个界面估计人就想吐了当然时间久了还是可以把他实现&quot;&gt;如果有一天、我们需要把这个界面删除掉的话（或者说添加/修改一个界面），需要在每个jsp的引入位置把引入删除掉（添加/修改一个jsp界面），当然、这个处理听起来比较方便，但是如果有几百，几千个界面，估计人就想吐了，当然时间久了还是可以把他实现，&lt;/h3&gt;

&lt;h3 id=&quot;而tiles则很方便的就可以让我们去实现这个操作下面就一起来去看看这个tiles怎么去简单的实现&quot;&gt;而tiles则很方便的就可以让我们去实现这个操作，下面就一起来去看看这个tiles怎么去简单的实现，&lt;/h3&gt;

&lt;h2 id=&quot;二apache-tiles的简单使用&quot;&gt;二、apache tiles的简单使用&lt;/h2&gt;

&lt;h3 id=&quot;在这里我使用的是springmvctileseclipsemaven&quot;&gt;在这里我使用的是SpringMVC+Tiles+Eclipse+Maven;&lt;/h3&gt;

&lt;h3 id=&quot;非maven环境需要手动导入tiles和springmvc的互相依赖的包&quot;&gt;非maven环境需要手动导入tiles和springmvc的互相依赖的包&lt;/h3&gt;

&lt;h3 id=&quot;首先新建一个maven工程并且使用pomxml导入包&quot;&gt;首先新建一个maven工程并且使用pom.xml导入包&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
 	 &amp;lt;groupId&amp;gt;org.apache.tiles&amp;lt;/groupId&amp;gt;
 	 &amp;lt;artifactId&amp;gt;tiles-extras&amp;lt;/artifactId&amp;gt;
 	 &amp;lt;version&amp;gt;3.0.5&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;'

SpringMVC

&amp;lt;dependency&amp;gt;
 	 &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  	 &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
 	 &amp;lt;version&amp;gt;4.3.3.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;webxml配置文件&quot;&gt;web.xml配置文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;web-app&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2.5&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet&amp;gt;&lt;/span&gt;
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;tile&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-class&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-class&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
  		&lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&lt;/span&gt;classpath:main.xml&lt;span class=&quot;nt&quot;&gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;load-on-startup&amp;gt;&lt;/span&gt;1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/load-on-startup&amp;gt;&lt;/span&gt;
 	 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-mapping&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;servlet-name&amp;gt;&lt;/span&gt;tile&lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-name&amp;gt;&lt;/span&gt;
  	&lt;span class=&quot;nt&quot;&gt;&amp;lt;url-pattern&amp;gt;&lt;/span&gt;*.do&lt;span class=&quot;nt&quot;&gt;&amp;lt;/url-pattern&amp;gt;&lt;/span&gt;
 	 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/servlet-mapping&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/web-app&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;spring配置文件&quot;&gt;Spring配置文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 配置组件扫描 --&amp;gt;
	&amp;lt;context:component-scan base-package=&quot;main&quot;/&amp;gt;
	&amp;lt;!-- 配置mvc扫描 --&amp;gt;
	&amp;lt;mvc:annotation-driven/&amp;gt;
	&amp;lt;!-- 配置视图解析器 --&amp;gt; 
	&amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
		&amp;lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/&quot;/&amp;gt;
		&amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&amp;gt;
	&amp;lt;/bean&amp;gt;
	&amp;lt;bean id=&quot;tilesViewResolver&quot; class=&quot;org.springframework.web.servlet.view.tiles3.TilesViewResolver&quot;&amp;gt;
	&amp;lt;!--视图解析器的优先级--&amp;gt; 		
 &amp;lt;property name=&quot;order&quot; value=&quot;1&quot; /&amp;gt;
 		&amp;lt;/bean&amp;gt;
	&amp;lt;!--加载tiles配置文件--&amp;gt;
	&amp;lt;bean id=&quot;tilesConfigurer&quot; class=&quot;org.springframework.web.servlet.view.tiles3.TilesConfigurer&quot;&amp;gt;
    &amp;lt;property name=&quot;definitions&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;classpath:layout.xml&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;/beans&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;tiles配置文件layoutxml&quot;&gt;tiles配置文件layout.xml&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE tiles-definitions PUBLIC
   &quot;-//Apache Software Foundation//DTD Tiles Configuration 3.0//EN&quot;
   &quot;http://tiles.apache.org/dtds/tiles-config_3_0.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;tiles-definitions&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 主布局 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;definition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;layout&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;template=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mainLayout.jsp&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/definition&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 主布局 --&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 项目 --&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;definition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;myView&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;extends=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;layout&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
 	&lt;span class=&quot;nt&quot;&gt;&amp;lt;put-attribute&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;a&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/a.jsp&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;put-attribute&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;b&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/b.jsp&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/definition&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;&amp;lt;!--项目--&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/tiles-definitions&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;配置文件做完之后java代码处理&quot;&gt;配置文件做完之后java代码处理&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RequestMapping(&quot;/test.do&quot;)
	protected String method(){
	return &quot;myView&quot;;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;在webapp写上jsp页面当然也可以在其他文件下面写上jsp界面相应的配置文件的路径需要处理&quot;&gt;在webapp写上jsp页面（当然也可以在其他文件下面写上jsp界面，相应的配置文件的路径需要处理）&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mainLayout.jsp

&amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://tiles.apache.org/tags-tiles&quot; prefix=&quot;tiles&quot; %&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://tiles.apache.org/tags-tiles-extras&quot; prefix=&quot;tilesx&quot; %&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;tiles:insertAttribute name=&quot;a&quot; /&amp;gt;
  &amp;lt;tiles:insertAttribute name=&quot;b&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;另外写上ajsp--bjsp文件这是我们需要引入的两个jsp文件其中内容可以随便写&quot;&gt;另外写上a.jsp  b.jsp文件，这是我们需要引入的两个jsp文件，其中内容可以随便写&lt;/h3&gt;

&lt;h3 id=&quot;最后部署到tomcat服务器之上访问相应的路径这里我的路径是httplocalhost8080tilestestdo就可以看到组合的成的网页了这是我自己组成的简单的界面&quot;&gt;最后部署到tomcat服务器之上，访问相应的路径（这里我的路径是http://localhost:8080/tiles/test.do），就可以看到组合的成的网页了！这是我自己组成的简单的界面&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhshyong/111.png&quot; alt=&quot;111&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;当然这是死的界面如果要灵活应用则需要修改下配置文件&quot;&gt;当然、这是死的界面、如果要灵活应用、则需要修改下配置文件&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 主布局 --&amp;gt;
&amp;lt;!-- 项目 --&amp;gt;
  &amp;lt;definition name=&quot;myView&quot; extends=&quot;layout&quot;&amp;gt;
 	&amp;lt;put-attribute name=&quot;a&quot; value=&quot;/a.jsp&quot; /&amp;gt;
&amp;lt;!--${item}.jsp  item为传递过来的参数--!&amp;gt;
	&amp;lt;put-attribute name=&quot;item&quot; expression=&quot;/${item}.jsp&quot; /&amp;gt;
&amp;lt;/definition&amp;gt;
&amp;lt;!--项目--&amp;gt;
&amp;lt;/tiles-definitions&amp;gt; ###  组合界面mainLayout.jsp文件也需要修改一下

&amp;lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;utf-8&quot;%&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://tiles.apache.org/tags-tiles&quot; prefix=&quot;tiles&quot; %&amp;gt;
&amp;lt;%@ taglib uri=&quot;http://tiles.apache.org/tags-tiles-extras&quot; prefix=&quot;tilesx&quot; %&amp;gt;
&amp;lt;div&amp;gt;
  &amp;lt;tiles:insertAttribute name=&quot;a&quot; /&amp;gt;
  &amp;lt;tiles:insertAttribute name=&quot;item&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;请求也需要修改一下&quot;&gt;请求也需要修改一下&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RequestMapping(&quot;/test1.do&quot;)
protected String ee(Model model){
	//传递的参数tigger则是对应的jsp文件的名称
	//也只需要修改这个位置就可以达到组合成其他的页面
	//不需要修改其它位置以及文件
	model.addAttribute(&quot;item&quot;, &quot;tigger&quot;);
	return &quot;myView&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;这样再访问一次路径httplocalhost8080tilestest1do&quot;&gt;这样再访问一次路径（http://localhost:8080/tiles/test1.do）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhshyong/222.png&quot; alt=&quot;222&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;当修改参数&quot;&gt;当修改参数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RequestMapping(&quot;/test1.do&quot;)
protected String ee(Model model){
	//传递的参数tigger则是对应的jsp文件的名称
	//也只需要修改这个位置就可以达到组合成其他的页面
	//不需要修改其它位置以及文件
	model.addAttribute(&quot;item&quot;, &quot;rabbit&quot;);
	return &quot;myView&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;再次访问httplocalhost8080tilestest1do时候就有下图&quot;&gt;再次访问http://localhost:8080/tiles/test1.do时候就有下图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhshyong/333.png&quot; alt=&quot;333&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;这样拼成的界面会比较方便而且修改起来也特别方便以前干很久的事现在几分钟就可以做完了&quot;&gt;这样拼成的界面会比较方便，而且修改起来也特别方便！以前干很久的事，现在几分钟就可以做完了。&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>UI设计中下拉刷新有什么讲究？</title>
   <link href="http://www.blogways.net/blog/2016/12/06/UI-appDesign-05.html"/>
   <updated>2016-12-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/06/UI-appDesign-05</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;UI设计中下拉刷新有什么讲究&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;最早的下拉刷新设计源自于tweetie-这款应用的设计设计师loren-brichter-是这种令人欲罢不能的交互的缔造者现在下拉刷新的交互几乎无处不在但即便如此也让人无法轻易忽视它带来的快感从twitter-到-gmail从qq到新浪微博它几乎存在于你触手可及的每一个应用当中&quot;&gt;最早的下拉刷新设计源自于Tweetie 这款应用的设计，设计师Loren Brichter 是这种令人欲罢不能的交互的缔造者。现在，下拉刷新的交互几乎无处不在，但即便如此也让人无法轻易忽视它带来的快感。从Twitter 到 Gmail，从QQ到新浪微博，它几乎存在于你触手可及的每一个应用当中。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902176.gif&quot; alt=&quot;902176&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;下拉刷新是怎么运行的&quot;&gt;下拉刷新是怎么运行的&lt;/h4&gt;
&lt;p&gt;简而言之，下拉刷新是刷新指示器于下拉手势想结合的产物，同时借助下拉动效完善整个交互。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902206.gif&quot; alt=&quot;902206&quot; /&gt;&lt;/p&gt;

&lt;p&gt;下拉刷新本质上是一种特定的手动刷新交互，和其他的同类操作不同的地方在于它采用了更加直觉的下拉操作。它的交互足够清晰明显，不过有的时候设计师依然会使用刷新指示器来显示自动更新的内容。不过，由于自动刷新的机制不需要用户进行任何操作，是因此自动刷新最好还是不要使用刷新指示器了。&lt;/p&gt;

&lt;h4 id=&quot;什么时候使用下拉刷新&quot;&gt;什么时候使用下拉刷新&lt;/h4&gt;

&lt;p&gt;滑动刷新(包括下拉刷新)非常适合于列表、栅格列表和卡片集合之类界面(按照时间降序排列)。这类界面通常会随着时间推移，优先展示最新的内容，并且通常不会采用自动更新来刷新内容。不采用自动刷新的机制的原因很简单，当你滚动到顶部的时候，如果采用自动刷新，内容会不断自动下载显示，对于用户而言，这样的自动显示的机制并不可控。而下拉刷新则很好的解决了这个问题，只有在你使用下拉手势的时候，触发刷新指示器，再行更新，这样也给了用户选择和退出的机会。常见的下拉刷新用例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902209.jpg&quot; alt=&quot;902209&quot; /&gt;&lt;/p&gt;

&lt;p&gt;内容流(Twitter，微博，RSS)
收件箱(电子邮件，短信)
以Twitter 为例，推文是按照时间顺序排列，最新的推文在顶部，当用户下拉刷新之后，能够看到最新更新的推文。
####什么时候不适合下拉刷新
下拉刷新并非万能的，它有不适宜使用的场景：
屏幕小插件。这类小插件是需要自动更新的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902211.png&quot; alt=&quot;902211&quot; /&gt;&lt;/p&gt;

&lt;p&gt;地图应用。地图上的内容通常不会以时序排列，也没有明确的方向和内容来源，用户也无法直觉推断出下拉刷新的含义。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902213.png&quot; alt=&quot;902213&quot; /&gt;&lt;/p&gt;

&lt;p&gt;无序列表。有序列表通常能够给用户以下拉更新的期望，而无序列表在这方便则不明显，也无法直观地让用户看出其中的更新。
低更新率的内容。如果列表中的内容并不经常更新，下拉刷新的手势几乎没有存在的意义，因为用户去刷新列表的机率很低，也没有太大的必要。
按照时间先后顺序排列的内容。按照时间先后顺序排列的列表中，最新更新的内容排在最后，用户下拉刷新之后无法立刻看到最新更新的内容，这样列表使用下拉刷新就相当尴尬了。
特殊类型的内容。许多需要实时更新的内容会在短短一分钟甚至更短的时间内失去时效，诸如股票、服务器后台进程之类的信息，最好使用实时自动更新。&lt;/p&gt;

&lt;p&gt;####如何设计刷新指示器的过渡效果
下拉刷新前后两种状态需要借助过渡动效连接到一起，让用户了解界面到底发生了什么改变。刷新指示器在两种状态过渡过程中一直存在，它一直保持可见，直到刷新完成，新的内容更新出来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902214.gif&quot; alt=&quot;902214&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，在刷新过程中，哪怕用户针对界面有所操作，刷新指示器也不能隐藏，否则它作为指示器的作用就失去意义了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902217.gif&quot; alt=&quot;902217&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####自然或改变&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902293.jpg&quot; alt=&quot;902293&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####下拉刷新 vs. 刷新按钮
许多设计师和开发者将下拉刷新视作为一种节省屏幕空间的方法，毕竟它无需像刷新按钮一样占据一个固定按钮的空间。但是它的问题也同样很明显，下拉刷新没有刷新按钮那么明显直观，实现起来也更加麻烦。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902219.png&quot; alt=&quot;902219&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####刷新时长
当用户手指在屏幕上向下滑动，手势触发刷新指示器，以此为视觉反馈告知用户系统已经收到请求了。下拉刷新的交互设计很大程度上是想让用户明白发生了什么，并确保程序能够正常运行。当用户熟悉下拉刷新的操作和交互的结果之后，会逐步信任这种交互。刷新指示器会持续旋转，直到数据完全更新至可用，这样可以防止混乱。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902222.jpg&quot; alt=&quot;902222&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####可用的动效
下拉刷新的过渡动效是一个非常适合发挥创意的地方。由于它是连接两个不同状态的中间态，过渡动效可用帮助用户理解屏幕上发生了什么，精准地理解两个不同UI状态之间的差别。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902243.gif&quot; alt=&quot;902243&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>如何在你的UI设计项目中叠加色彩</title>
   <link href="http://www.blogways.net/blog/2016/12/06/UI-appDesign-04.html"/>
   <updated>2016-12-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/06/UI-appDesign-04</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;如何在你的UI设计项目中叠加色彩&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;在任何设计中颜色都是一个非常重要的组成部分无论你是喜欢明亮大胆的色彩或者是喜欢简约的黑白色调你如何使用颜色如何进行颜色搭配都会对你的整体的设计有很大的影响&quot;&gt;在任何设计中，颜色都是一个非常重要的组成部分。无论你是喜欢明亮大胆的色彩，或者是喜欢简约的黑白色调，你如何使用颜色，如何进行颜色搭配，都会对你的整体的设计有很大的影响。&lt;/h4&gt;
&lt;p&gt;在设计中使用色彩的方法很多，现在最常见的是，在设计项目中运用一个颜色叠加。这意味着你所覆盖的图像或视频，有着一个透明的色块，类似于一个半透明的彩色盒子，这种效果可以强化设计的形象含义，提升设计氛围，让观看者增强一种艺术选择感。
今天，我们所要探讨的就是，如何在在你的设计项目中灵活应用色彩叠加。&lt;/p&gt;

&lt;p&gt;####尝试渐变&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902272.jpg&quot; alt=&quot;902272&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;渐变再一次的回归了&quot;&gt;渐变再一次的回归了!&lt;/h4&gt;
&lt;p&gt;当你想使用色彩叠加时，它们是一个极佳的方式，你可以轻易的创建一种引人注目的(醒目)的色彩效果。
渐变有什么好处?你可以使用几种不同的颜色，把它们搭配在一起，形成渐变色彩(品牌用色更常见)。或者你也可以使用一种颜色，通过颜色上的明亮对比，创建视觉焦点。明亮的色彩搭配，可以帮助你更轻易的吸引用户，为你的设计和图像加分。
Spotify 在播放列表中，使用了韵味十足的渐变和双色调(点击可跳转链接)效果，开始引领了这种设计趋势，赋予图片一种新的生命，让用户看到更有艺术效果的音乐家图片。
这虽然是一个设计概念，但也是容易复制的。
选择一张照片
使用渐变颜色叠加
完成
纯色基调&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902277.jpg&quot; alt=&quot;902277&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;单独的纯色叠加照样可以跟渐变叠加一样引人注目但纯色叠加其选择的颜色往往更具有独特的意义比如说创建一个深褐色纯色叠加它会呈现一种回忆往事和历史的感觉厚重感十足&quot;&gt;单独的纯色叠加，照样可以跟渐变叠加一样引人注目，但纯色叠加其选择的颜色，往往更具有独特的意义。比如说，创建一个深褐色纯色叠加，它会呈现一种回忆往事和历史的感觉，厚重感十足。&lt;/h4&gt;
&lt;p&gt;一样的道理，你选择一个时髦的颜色(流行色)，效果也是一样的。通过使用一种明亮、艳美的颜色，结合扁平化设计，或者与之相对应的材料设计，可以为你的设计增添一种现代主义或时尚的感觉。
当使用一种单一颜色叠加时，我们应当认真的考虑一下颜色的饱和度和透明度，因为这些因素都是有其本身的意义的。颜色的饱和度和透明度，对你的设计有很大的影响。当叠加的颜色透明度低或饱和度高时，观看者将更容易被色彩本身所吸引，当叠加的颜色透明度高或饱和度低时，观看者会更容易被图像本身所吸引，而不是叠加的颜色本身。&lt;/p&gt;

&lt;p&gt;####考虑明暗&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902279.jpg&quot; alt=&quot;902279&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####你不要总是使用颜色来创建一个叠加，有时它可以是黑色，白色或灰色。使用这些颜色和色调，有时候真的可以改变一个设计项目的情绪。
正如你所期望的，一个偏暗的色彩叠加，可以营造出一个喜怒无常的环境氛围，反之，一个偏亮的色彩叠加，往往会显得更轻松与俏皮。
上面的图片是一个叫 Call me lsh 的网站，它使用了一个白色叠加，帮助网站把重点聚焦到屏幕上的黑白照片上的单词上。但是请注意，摄影师脸上的表情：他咧嘴微笑。颜色和照片的组合显得非常有趣，会不会让你想要与摄影师一起互动，甚至有雇佣他工作的可能?&lt;/p&gt;

&lt;p&gt;####选择高对比度的图像&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902283.jpg&quot; alt=&quot;902283&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902288.jpg&quot; alt=&quot;902288&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####当你计划在一个设计项目上使用色彩叠加时，你选择的图像(或视频)是很重要的。一张淡而无味的图像，会导致你的设计出现一个乏味的颜色叠加的结果。你想要得到最好的结果，那么从你刚开始选择照片时开始，注意图像本身的质量，选择高对比的图像。
如果你的图像没有足够的对比度，那么可以考虑用软件(比如PS)强化对比，或者直接选择另一张图像。否则，色彩叠加的可能会不好，导致你的设计失败。
还有一个特别简单的技巧，那就是使用黑白图像。尤其对于初学者来说，它可以更容易的控制黑白图像，增强对比度。上面的 Just Actions 网站，提供了一个很好的示例，一个使用色彩叠加的黑白图像。(它没有鲜艳的色彩对比，但依旧是一个很酷的效果)&lt;/p&gt;

&lt;p&gt;####自然或改变&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902293.jpg&quot; alt=&quot;902293&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####当涉及到使用色彩叠加时，你有两种选择：
1、图片看起来应该仍然自然。颜色、明暗和阴影，都应该出现在一个自然的位置。叠加应该尽量微妙，比如 Abednego Coffee。(上图)
2、图片看起来完全改变了。不需要猜颜，一看就知道是使用了色彩叠加。(本文的示例基本都是这样)
这个没有“中立”的选择，如果图片不落入其中一个“极端”，用户可能会更专注于你的色彩选择，而不是专注于网站的内容。如果你不想因为使用了色彩叠加，而导致用户的注意力分散，那么，你应该加强你的整体设计。&lt;/p&gt;

&lt;p&gt;####部分叠加&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902294.jpg&quot; alt=&quot;902294&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/902295.jpg&quot; alt=&quot;902295&quot; /&gt;&lt;/p&gt;

&lt;p&gt;####前面的例子展示了如何使用大范围的色彩叠加，但这并不是唯一的方法，尝试部分的叠加，色彩效应依旧可以很好。
上面的两个例子，利用部分的色彩叠加，有效地实现了设计目的。
Knot Clothing 网站，顶部导航栏使用了部分色彩叠加，它使用了一个明亮的绿色，降低了透明度，它进一步凸显了上面的线条，帮助维持品牌的颜色影响，同时在整个设计项目中，展示其它的颜色。效果很简单，但效果非常好。
Nuts and Woods 网站使用的是另一种方法。它在网站的设计上，使用了一个色彩叠加的悬停效果，告诉你关于具体项目的更多信息。任何被红色覆盖的元素也是一个可点击的元素。这个设计值得注意的是，色彩叠加作为给用户的视觉提示，它提供了一个路径链接，告诉用户他们想知道的相关内容。&lt;/p&gt;

&lt;p&gt;####结语
色彩叠加只是一种技术，并不是所有设计项目都适合。大多数的设计师发现他们只能侥幸的在一个或两个设计项目上取得成功。(这就是为什么，部分色彩叠加可能是一个更好的选择)
对于任何设计技术，应当确保在正确的设计理念的引导下去使用。你不应该仅仅因为你的灵感来自于另外一个使用了色彩叠加的项目，就决定使用色彩叠加。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>关于登录界面的设计观点</title>
   <link href="http://www.blogways.net/blog/2016/12/06/UI-appDesign-03.html"/>
   <updated>2016-12-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/06/UI-appDesign-03</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;关于登录界面的设计观点&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;关键字路径清晰主次分明专注眼前分场景&quot;&gt;关键字：路径清晰，主次分明，专注眼前，分场景。&lt;/h4&gt;

&lt;h4 id=&quot;路径清晰&quot;&gt;路径清晰&lt;/h4&gt;
&lt;p&gt;登录页面通常包含多个入口：注册、登录方式A、登录方式B、第三方账号登录等，我们无法准确预测用户会究竟要选择哪一个，因此，各个路径必须一目了然。以google、大众点评和美团为例：Google较简洁（因为它不支持第三方账号登录），功能说明和输入区域挤在同一区域，上半部屏幕直接浪费掉，也没有区分清楚登录和注册两个路径；大众点评和美团虽然界面信息更多，但比起google登录和注册路径区分更明确。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/917115.jpg&quot; alt=&quot;917115&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;主次分明&quot;&gt;主次分明&lt;/h4&gt;
&lt;p&gt;贪心是全人类的通病，设计师要压制好自己和产品经理的欲望。手机号快速登录逐渐成为主流，但某些产品依然不愿放弃传统登录，鱼与熊掌不可兼得，取舍不够决绝会导致功能主次不分。设计之前请选好一种主推的登录方式，哪种是当前最急需的？哪种是符合业务长远利益的？分清优先级的同时也要在界面上体现。对比大众点评和美团：大众点评已经把账密登录方式弱化成一个二级入口，而美团依然想保持两种登录方式直接切换的便利性（也许是数据上暂时没有明显的偏向，产品经理无法拍板)。突出一种登录方式，其他该弱化的弱化，该抛弃的抛弃。&lt;/p&gt;

&lt;h4 id=&quot;专注眼前&quot;&gt;专注眼前&lt;/h4&gt;
&lt;p&gt;既然做了选择，就不要三心二意。用户选择了一种登录方式后，其他的方式可以大胆放一边去了。然而某些设计师（或PM）一直把用户当成是购物中的选择困难症女性，“登录方式要切换方便，万一用户要更换。。。万一用户选错怎么办？”。也许有5%的用户会选错，为此就要降低剩下95%的用户的体验？假如遵循好上述的两个观点，所谓的万一会更加少。美团在这一点做的比较好，调起键盘输入并隐去第三方账号登录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/917127.jpg&quot; alt=&quot;917127&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;输出&quot;&gt;输出&lt;/h4&gt;
&lt;p&gt;综合上述观点，默认登录界面仅保留登录入口、切换登录方式、注册入口和第三方账号登录，尽可能保持路径清晰。账密登录仅作为次要登录方式弱化成跳转入口，主次分明。调起键盘后（确认登录方式）才显示验证码、登录按钮等控件，同时第三方账号登录下滑隐去，专注当前任务。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/917130.png&quot; alt=&quot;917130&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/917129.gif&quot; alt=&quot;917129&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ps分场景&quot;&gt;PS：分场景&lt;/h4&gt;
&lt;p&gt;登录及注册界面，其流程该是一次性展现还是按任线性务流一步步展现？线性任务流的好处是：分别对每个提交的信息检测并反馈，用户理解起来清晰安全，属于“can’t go wrong” 的设计，但其一步步的跳转容易给用户一种漫长的感觉。对比之下大众点评及美团拿任务流清晰度换取了便捷性。&lt;/p&gt;

&lt;h4 id=&quot;取舍&quot;&gt;取舍&lt;/h4&gt;
&lt;p&gt;线性任务流和集成任务究竟如何取舍，取决设计师如何平衡清晰度和便捷性。我的理解是：登录是留给老用户的，用户对应用有一定的熟悉度，另外结合场景分析，无论是主动触发或是在购买商品时被动触发登录，用户总是不耐烦的希望尽快结束此流程，因此登录流程约简短越好，选用集成任务；注册面对的是新用户，用户此刻更需要的是安全感，明确的说明和清晰的步骤比操作便捷更重要，因此选用线性任务流。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>APP界面设计（下）</title>
   <link href="http://www.blogways.net/blog/2016/12/06/UI-appDesign-02.html"/>
   <updated>2016-12-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/06/UI-appDesign-02</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;IOS字体规范与多屏幕适配&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20161205img01.jpg&quot; alt=&quot;20161205img01&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mui前端APP之四－android签名机制介绍及Hbuilder打包</title>
   <link href="http://www.blogways.net/blog/2016/12/05/web-mui-04.html"/>
   <updated>2016-12-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/05/web-mui-04</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;签名文件的作用&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2st&quot;&gt;生成及查看签名证书&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3st&quot;&gt;使用Hbuider云打包&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一签名文件keystore的作用&quot;&gt;一、签名文件（*.keystore）的作用&lt;/h2&gt;

&lt;h4 id=&quot;开发android的人这么多完全有可能大家都把类名包名起成了一个同样的名字这时候如何区分签名这时候就是起区分作用的&quot;&gt;开发Android的人这么多，完全有可能大家都把类名，包名起成了一个同样的名字，这时候如何区分？签名这时候就是起区分作用的。&lt;/h4&gt;

&lt;h4 id=&quot;由于开发商可能通过使用相同的package-name来混淆替换已经安装的程序签名可以保证相当名字但是签名不同的包不被替换&quot;&gt;由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证相当名字，但是签名不同的包不被替换。&lt;/h4&gt;

&lt;h4 id=&quot;apk如果使用一个key签名发布时另一个key签名的文件将无法安装或覆盖老的版本这样可以防止你已安装的应用被恶意的第三方覆盖或替换掉&quot;&gt;APK如果使用一个key签名，发布时另一个key签名的文件将无法安装或覆盖老的版本，这样可以防止你已安装的应用被恶意的第三方覆盖或替换掉。&lt;/h4&gt;

&lt;h4 id=&quot;这样签名其实也是开发者的身份标识交易中抵赖等事情发生时签名可以防止抵赖的发生&quot;&gt;这样签名其实也是开发者的身份标识。交易中抵赖等事情发生时，签名可以防止抵赖的发生。&lt;/h4&gt;

&lt;h3 id=&quot;签名的注意事项&quot;&gt;签名的注意事项&lt;/h3&gt;

&lt;h4 id=&quot;android系统要求所有的程序经过数字签名才能安装如果没有可用的数字签名系统将不许安装运行此程序不管是模拟器还是真实手机因此在设备或者是模拟器上运行调试程序之前必须为应用程序设置数字签名&quot;&gt;Android系统要求所有的程序经过数字签名才能安装，如果没有可用的数字签名，系统将不许安装运行此程序。不管是模拟器还是真实手机。因此，在设备或者是模拟器上运行调试程序之前，必须为应用程序设置数字签名；&lt;/h4&gt;

&lt;h4 id=&quot;android签名的数字证书不需要权威机构来认证是开发者自己产生的数字证书即所谓的自签名数字证书用来标识应用程序的作者和在应用程序之间建立信任关系而不是用来决定最终用户可以安装哪些应用程序&quot;&gt;Android签名的数字证书不需要权威机构来认证，是开发者自己产生的数字证书，即所谓的自签名。数字证书用来标识应用程序的作者和在应用程序之间建立信任关系，而不是用来决定最终用户可以安装哪些应用程序&lt;/h4&gt;

&lt;h4 id=&quot;系统仅仅会在安装的时候测试签名证书的有效期如果应用程序的签名是在安装之后才到期那么应用程序仍然可以正常启用&quot;&gt;系统仅仅会在安装的时候测试签名证书的有效期，如果应用程序的签名是在安装之后才到期，那么应用程序仍然可以正常启用&lt;/h4&gt;

&lt;h4 id=&quot;可以使用标准工具-keytool-and-jarsigner-生成密钥来签名应用程序的apk文件&quot;&gt;可以使用标准工具-Keytool and Jarsigner-生成密钥，来签名应用程序的.apk文件&lt;/h4&gt;

&lt;h4 id=&quot;正式发布一个android应用时必须使用一个合适的私钥生成的数字证书来给程序签名不能使用adt插件或者ant工具生成的调试证书来发布&quot;&gt;正式发布一个Android应用时，必须使用一个合适的私钥生成的数字证书来给程序签名，不能使用ADT插件或者ANT工具生成的调试证书来发布&lt;/h4&gt;

&lt;h2 id=&quot;二生成及查看签名证书&quot;&gt;二、生成及查看签名证书&lt;/h2&gt;

&lt;h3 id=&quot;1-生成keystore&quot;&gt;1. 生成keystore&lt;/h3&gt;

&lt;h4 id=&quot;创建keystore需要用到keytoolexe-位于jdk_xxjrebin目录下具体做法如下mac在终端下可直接敲入keytool&quot;&gt;创建keystore，需要用到keytool.exe (位于jdk_xx\jre\bin目录下)，具体做法如下,mac在终端下可直接敲入keytool&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keytool -genkey -alias mykey -keyalg RSA -validity 40000 -keystore demo.keystore
#说明：
#    -genkey 产生密钥
#    -alias mykey 别名 mykey
#    -keyalg RSA 使用RSA算法对签名加密
#    -validity 40000 有效期限4000天
#    -keystore demo.keystore

然后按回车键
按回车后首先会提示你输入的密码：这个在签名时要用的，要记住
然后会再确认你的密码。
之后会依次叫你输入姓名、组织单位、组织名称、城市区域、省份名称、国家代码（CN）等

Keytool的详细参数请参考

http://www.android123.com.cn/androidkaifa/173.html

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2查看签名信息&quot;&gt;2.查看签名信息&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keytool -list -keystore demo.keystore -alias mykey -v

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3查看keystore的公钥证书信息&quot;&gt;3.查看keystore的公钥证书信息&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;keytool -list -keystore demo.keystore -alias mykey -rfc

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三使用hbuider云打包&quot;&gt;三、使用Hbuider云打包&lt;/h2&gt;

&lt;h4 id=&quot;前面我们得到了keystore签名文件即可使用hbuilder来进行apk的签名如下图&quot;&gt;前面我们得到了keystore签名文件，即可使用Hbuilder来进行apk的签名,如下图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161205img01.png&quot; alt=&quot;20161205img01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1android包名可自己定义&quot;&gt;1.Android包名：可自己定义；&lt;/h4&gt;
&lt;h4 id=&quot;2证书别名生成keystore时的-alias后面部分即-mykey&quot;&gt;2.证书别名：生成keystore时的-alias后面部分，即 “mykey”&lt;/h4&gt;
&lt;h4 id=&quot;3私钥密码生成时输入的密码&quot;&gt;3.私钥密码：生成时输入的密码&lt;/h4&gt;
&lt;h4 id=&quot;4证书文件keystore的文件位置&quot;&gt;4.证书文件：keystore的文件位置&lt;/h4&gt;

&lt;h4 id=&quot;点击打包即可进行云端打包&quot;&gt;点击打包即可进行云端打包&lt;/h4&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;本章主要结合android的签名文件来进行了整过程的描述能够对android如何进行打包有个详细的了解&quot;&gt;本章主要结合Android的签名文件来进行了整过程的描述，能够对android如何进行打包有个详细的了解；&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>Django入门</title>
   <link href="http://www.blogways.net/blog/2016/12/05/Django-introduction.html"/>
   <updated>2016-12-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/05/Django-introduction</id>
   <content type="html">&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/Django_logo.png&quot; alt=&quot;Django_logo.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.djangoproject.com/&quot;&gt;Django&lt;/a&gt;是一个开放源代码的Web应用框架，由Python写成，本身是专门用作开发新闻管理系统的。采用了MVC的软件设计模式，即模型M，视图V和控制器C。&lt;/p&gt;

&lt;p&gt;Django框架的核心包括：一个面向对象的&lt;em&gt;映射器&lt;/em&gt;，用作数据模型（以Python类的形式定义）和关系性数据库间的媒介；一个基于正则表达式的&lt;em&gt;URL分发器&lt;/em&gt;；一个用于处理请求的&lt;em&gt;视图系统&lt;/em&gt;；以及一个&lt;em&gt;模板系统&lt;/em&gt;。&lt;/p&gt;

&lt;h2 id=&quot;二环境要求&quot;&gt;二、环境要求&lt;/h2&gt;
&lt;p&gt;从 &lt;a href=&quot;https://www.python.org/&quot;&gt;Python&lt;/a&gt; 官网下载安装适合机器系统的版本，Python &amp;gt;= 2.7。
用 Python 的 pip 命令安装 Django：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ pip install Django==1.10.4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装完成之后运行命令查看是否安装成功：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/Django_version.png&quot; alt=&quot;Django_version.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三一个实例&quot;&gt;三、一个实例&lt;/h2&gt;
&lt;h3 id=&quot;1-新建项目&quot;&gt;(1) 新建项目&lt;/h3&gt;
&lt;p&gt;用&lt;em&gt;django-admin&lt;/em&gt;命令新建一个项目：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ django-admin startproject mysite&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;会得到如下的目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysite/
    manage.py
    mysite/
        __init__.py
        settings.py
        urls.py
        wsgi.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;manage.py：是一个命令行工具，它允许你用多种方式和 Django 项目交互。&lt;/li&gt;
  &lt;li&gt;mysite/settings.y：包含项目的基本设置，如数据库，静态文件目录等。&lt;/li&gt;
  &lt;li&gt;mysite/urls.py：项目的 URL 的分发器。&lt;/li&gt;
  &lt;li&gt;mysite/wsgi.py：WSGI 服务器入口。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行命令启动项目：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ python manage.py runserver&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;打开浏览器输入：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看项目是否正确创建，如果项目创建成功，能看到成功页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/startpage.png&quot; alt=&quot;startpage.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-新建-app&quot;&gt;(2) 新建 app&lt;/h3&gt;
&lt;p&gt;进入 &lt;em&gt;mysite&lt;/em&gt; 目录，运行命令：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ python manage.py startapp polls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在&lt;em&gt;mysite&lt;/em&gt;项目下会生成一个目录&lt;em&gt;polls&lt;/em&gt;，我们所有的代码都是基于这个 app。
我们再往文件夹里加一些文件夹，最终目录结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;polls/
    __init__.py
    admin.py
    apps.py
    migrations/
        __init__.py
    static/
    templates/
        admin/
        polls/
    models.py
    tests.py
    urls.py
    views.py
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;admin.py：修改 admin 页面。&lt;/li&gt;
  &lt;li&gt;apps.py：注册 app，如这里的&lt;em&gt;polls&lt;/em&gt;。&lt;/li&gt;
  &lt;li&gt;static/：静态文件目录，如 css，JavaScript 文件。&lt;/li&gt;
  &lt;li&gt;templates/：模板文件目录。&lt;/li&gt;
  &lt;li&gt;models.py：所有数据模型。&lt;/li&gt;
  &lt;li&gt;test.py：测试文件。&lt;/li&gt;
  &lt;li&gt;urls.py：URL分发器。&lt;/li&gt;
  &lt;li&gt;views.py：包含所有的视图。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;运行命令，创建管理员用户：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ python manage.py createsuperuser&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根据提示一步步创建。&lt;/p&gt;

&lt;h3 id=&quot;3-数据模型&quot;&gt;(3) 数据模型&lt;/h3&gt;
&lt;p&gt;Django 支持大部分主流数据库，为简单起见在这里使用 &lt;em&gt;sqlite&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;polls&lt;/em&gt;中的数据模型都定义在 polls/models.py中。这里定义了两个数据模型，Question 和 Choice：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Question(models.Model):
    question_text = models.CharField(max_length=200)
    pub_date = models.DateTimeField('date published')

    def was_published_recently(self):
        now = timezone.now()
        return now - datetime.timedelta(days=1) &amp;lt;= self.pub_date &amp;lt;= now

    def __str__(self):
        return self.question_text

class Choice(models.Model):
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    choice_text = models.CharField(max_length=200)
    votes = models.IntegerField(default=0)

    def __str__(self):
        return self.choice_text
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 mysite/settings.py 中注册项目：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;INSTALLED_APPS = [
    'polls.apps.PollsConfig', # 注册polls
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数据库迁移：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ python manage.py makemigrations polls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;根据数据模型在数据库中创建表：&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ python manage.py sqlmigrate polls 0001&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;保存项目之后在浏览器中打开&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8000/admin/&lt;/code&gt;，首先输入管理员的用户名密码，然后就进入了后台管理页面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/Admin_page.png&quot; alt=&quot;Admin_page.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到 Django 自动为我们生成了一个管理页面，它能对定义的数据模型进行 &lt;em&gt;CRUD&lt;/em&gt; 的操作，并且提供了一些&lt;em&gt;权限控制&lt;/em&gt;的功能，非常方便。&lt;/p&gt;

&lt;h3 id=&quot;4-自定义视图&quot;&gt;(4) 自定义视图&lt;/h3&gt;
&lt;p&gt;视图定义在 views.py 中，可以基于方法或者类。下面定义了一个简单的视图，它会返回全部问题的列表：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        return Question.objects.order_by('-pub_date')[:5]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在模板目录 templates 中的 polls，添加模板文件 index.html：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/index_page.png&quot; alt=&quot;index_page.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-url分发&quot;&gt;(5) URL分发&lt;/h3&gt;
&lt;p&gt;Django的URL分发基于正则表达式，访问这些页面时会去 templates 目录中去找相应的 template，这些定义在 urls.py中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;urlpatterns = [
    url(r'^$', views.IndexView.as_view(), name='index'),
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面定义了当 URL 中什么都没写的时候，直接访问 index 页面。&lt;/p&gt;

&lt;h3 id=&quot;6-自定义样式&quot;&gt;(6) 自定义样式&lt;/h3&gt;
&lt;p&gt;可以在 static 目录中存放 css、JavaScript 或者图片文件。在 template 首部使用：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/load_command.png&quot; alt=&quot;load_command.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;就可以引用这些文件。
如在 static 目录中添加文件 style.css，增加下面的样式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;li a {
    color: green;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 index.html 中引入这个样式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/load_example.png&quot; alt=&quot;load_example.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;index 页面下的所有超链接都会变成绿色：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/jyjsjd/Django_style.png&quot; alt=&quot;Django_style.png&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>mui前端APP之三－IOS证书申请</title>
   <link href="http://www.blogways.net/blog/2016/12/02/web-mui-03.html"/>
   <updated>2016-12-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/02/web-mui-03</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;证书是什么&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2st&quot;&gt;申请流程&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3st&quot;&gt;使用Hbuider云打包&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一证书是什么&quot;&gt;一、证书是什么&lt;/h2&gt;

&lt;h3 id=&quot;ios打包需要证书及描述文件可是证书是什么东西呢&quot;&gt;IOS打包需要证书及描述文件，可是证书是什么东西呢？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img01.jpeg&quot; alt=&quot;20161203img01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;上面这个就是我们申请好证书后下载到本地的cer文件也就是常说的开发证书与发布证书的样式这cer文件格式的证书是让开发者使用的设备也就是你的mac有真机调试发布app的权限&quot;&gt;上面这个就是我们申请好证书后，下载到本地的.cer文件，也就是常说的开发证书与发布证书的样式。这.cer文件格式的证书是让开发者使用的设备（也就是你的Mac）有真机调试，发布APP的权限；&lt;/h4&gt;

&lt;h4 id=&quot;但是hbuilder需要的是p12文件不是cer文件先别急我们一步一步的讲解你就能明白了&quot;&gt;但是Hbuilder需要的是p12文件，不是cer文件；先别急，我们一步一步的讲解你就能明白了&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img02.png&quot; alt=&quot;20161203img02&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;上面这个就是我们配置好证书后下载到本地的mobileprovision文件也就是配置文件的样式这mobileprovision文件格式的配置文件是让开发者的项目app能有真机调试发布的权限&quot;&gt;上面这个就是我们配置好证书后，下载到本地的.mobileprovision文件，也就是配置文件的样式。这.mobileprovision文件格式的配置文件是让开发者的项目（APP）能有真机调试，发布的权限。&lt;/h4&gt;

&lt;h2 id=&quot;二申请流程&quot;&gt;二、申请流程&lt;/h2&gt;

&lt;h3 id=&quot;1-申请钥匙串文件&quot;&gt;1. 申请钥匙串文件&lt;/h3&gt;

&lt;h4 id=&quot;进入launchpad找到钥匙串访问运行后再左上角如下图&quot;&gt;进入Launchpad，找到“钥匙串访问”，运行后再左上角，如下图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img03.png&quot; alt=&quot;20161203img03&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img04.png&quot; alt=&quot;20161203img04&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img05.png&quot; alt=&quot;20161203img05&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;存储在桌面就好了然后就完成退出钥匙串工具就可以了&quot;&gt;存储在桌面就好了，然后就完成退出钥匙串工具就可以了。&lt;/h4&gt;

&lt;h3 id=&quot;2申请开发证书发布证书&quot;&gt;2.申请开发证书，发布证书&lt;/h3&gt;

&lt;h4 id=&quot;打开苹果开发者中心httpsdeveloperapplecom&quot;&gt;打开苹果开发者中心（https://developer.apple.com）&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img06.png&quot; alt=&quot;20161203img06&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img07.png&quot; alt=&quot;20161203img07&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img08.png&quot; alt=&quot;20161203img08&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img09.png&quot; alt=&quot;20161203img09&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img10.png&quot; alt=&quot;20161203img10&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img11.png&quot; alt=&quot;20161203img11&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img12.png&quot; alt=&quot;20161203img12&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;此处下载的cer文件即为申请的证书文件请一定要区分开发证书和发布证书&quot;&gt;此处下载的cer文件即为申请的证书文件，请一定要区分“开发证书”和“发布证书”&lt;/h4&gt;

&lt;h4 id=&quot;开发证书仅能用于开发者设备的安装-发布证书可以上架到app-store&quot;&gt;“开发证书”，仅能用于开发者设备的安装； “发布证书”，可以上架到APP Store&lt;/h4&gt;

&lt;h3 id=&quot;3导出p12文件&quot;&gt;3.导出p12文件&lt;/h3&gt;

&lt;h4 id=&quot;双击下载的cer文件即导入了证书文件我们重新打开钥匙串访问如下图选择左侧的证书&quot;&gt;双击下载的cer文件，即导入了证书文件，我们重新打开“钥匙串访问”，如下图，选择左侧的“证书”&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img13.png&quot; alt=&quot;20161203img13&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img14.png&quot; alt=&quot;20161203img14&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img15.png&quot; alt=&quot;20161203img15&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img16.png&quot; alt=&quot;20161203img16&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;需要注意的是1p12文件可以给其他的开发者使用但是只有申请证书的mac才能导出p12其他mac双击cer看不见liuyw6也无法导出&quot;&gt;需要注意的是：1、p12文件可以给其他的开发者使用，但是只有申请证书的mac才能导出p12；其他mac双击cer看不见liuyw6，也无法导出&lt;/h4&gt;

&lt;h4 id=&quot;至此我们已经得到了ios打包需要的第一个文件-p12接下来我们来获得描述文件mobileversion&quot;&gt;至此我们已经得到了IOS打包需要的第一个文件 p12；接下来我们来获得描述文件mobileversion&lt;/h4&gt;

&lt;h3 id=&quot;3注册项目的bundle-id&quot;&gt;3.注册项目的Bundle ID&lt;/h3&gt;

&lt;h4 id=&quot;bundle-id为你app的唯一标示id不允许与其它的app重复申请如下&quot;&gt;Bundle ID为你APP的唯一标示ID，不允许与其它的APP重复，申请如下&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img17.png&quot; alt=&quot;20161203img17&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img18.png&quot; alt=&quot;20161203img18&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img19.png&quot; alt=&quot;20161203img19&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4添加测试设备&quot;&gt;4.添加测试设备&lt;/h3&gt;

&lt;h4 id=&quot;一个app开发者账户允许配置100台测试设备测试设备仅对开发者证书有用发布证书不需要设置测试设备&quot;&gt;一个APP开发者账户允许配置100台测试设备，测试设备仅对开发者证书有用；发布证书不需要设置测试设备&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img20.png&quot; alt=&quot;20161203img20&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img21.png&quot; alt=&quot;20161203img21&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;上图中填写有一个uuiduuid是iphoneipad等的唯一标示可以通过itunes查看如下图&quot;&gt;上图中填写有一个UUID，UUID是iphone、ipad等的唯一标示，可以通过iTunes查看，如下图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img22.png&quot; alt=&quot;20161203img22&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img23.png&quot; alt=&quot;20161203img23&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4配置证书即mobileversion描述文件&quot;&gt;4.配置证书（即mobileversion描述文件）&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img24.png&quot; alt=&quot;20161203img24&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img25.png&quot; alt=&quot;20161203img25&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img26.png&quot; alt=&quot;20161203img26&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img27.png&quot; alt=&quot;20161203img27&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;这里不用担心会选择错误你配置开发证书那这里就只有开发证书供你选择配置发布证书这里就只有发布证书供你选择&quot;&gt;这里不用担心会选择错误，你配置开发证书，那这里就只有开发证书供你选择。配置发布证书，这里就只有发布证书供你选择。&lt;/h4&gt;

&lt;h4 id=&quot;tips同一个开发者账户可以创建2个开发者证书3个发布证书如果是同一团队创建一个即可通用所有的产品&quot;&gt;TIPS：同一个开发者账户可以创建2个开发者证书、3个发布证书；如果是同一团队，创建一个即可通用所有的产品&lt;/h4&gt;

&lt;h4 id=&quot;如果是配置开发证书就还会需要你设置在这个项目中添加哪些设备作为真机调试的设备&quot;&gt;如果是配置开发证书，就还会需要你设置，在这个项目中添加哪些设备作为真机调试的设备&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img28.png&quot; alt=&quot;20161203img28&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161203img29.png&quot; alt=&quot;20161203img29&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三使用hbuider云打包&quot;&gt;三、使用Hbuider云打包&lt;/h2&gt;

&lt;h4 id=&quot;完成创建后下载下载下来的即为mobileversion文件至此我们已经得到了ios打包的2个文件接下来我们使用hbuilder进行打包&quot;&gt;完成创建后下载，下载下来的即为mobileversion文件，至此，我们已经得到了IOS打包的2个文件，接下来我们使用Hbuilder进行打包&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161203img30.png&quot; alt=&quot;20161203img30&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;1appid与bundle-id-保持一致即可&quot;&gt;1.AppID：与Bundle id 保持一致即可；&lt;/h4&gt;
&lt;h4 id=&quot;2私钥密码导出p12时设置的密码&quot;&gt;2.私钥密码：导出p12时设置的密码&lt;/h4&gt;
&lt;h4 id=&quot;3profile文件mobileversion&quot;&gt;3.profile文件：mobileversion&lt;/h4&gt;
&lt;h4 id=&quot;4私钥证书p12文件&quot;&gt;4.私钥证书：p12文件&lt;/h4&gt;

&lt;h4 id=&quot;点击打包即可进行云端打包&quot;&gt;点击打包即可进行云端打包&lt;/h4&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;本章主要结合ios的证书描述文件来进行了整过程的描述能够了解如何去下载相应的打包文件提示app开发人员需要交费开通个人开发者99年&quot;&gt;本章主要结合IOS的证书、描述文件来进行了整过程的描述，能够了解如何去下载相应的打包文件；提示：APP开发人员需要交费开通：个人开发者$99/年&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>mui前端APP开发实践－热点新闻</title>
   <link href="http://www.blogways.net/blog/2016/12/02/web-mui-02.html"/>
   <updated>2016-12-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/12/02/web-mui-02</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;热点新闻APP界面认识&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2st&quot;&gt;一步步搭建应用&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3st&quot;&gt;热点新闻内容代码详解&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#4st&quot;&gt;APP打包及真机查看&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一热点新闻app界面认识&quot;&gt;一、热点新闻APP界面认识&lt;/h2&gt;

&lt;h3 id=&quot;上一章我们大概了解了mui的概念以及他提供的强大的工具和框架这一章我们用一个简单的例子来快速构建我们的app应用&quot;&gt;上一章我们大概了解了mui的概念，以及他提供的强大的工具和框架，这一章我们用一个简单的例子来快速构建我们的APP应用&lt;/h3&gt;

&lt;h4 id=&quot;我们要构建的应用非常简单就是仿一个简单的新闻类的app其中包含了2个界面一个新闻列表页可以上拉加载更多下拉刷新一个新闻详情页界面如下&quot;&gt;我们要构建的应用非常简单，就是仿一个简单的新闻类的APP，其中包含了2个界面，一个新闻列表页（可以上拉加载更多、下拉刷新），一个新闻详情页，界面如下：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161202img01.png&quot; alt=&quot;20161202img01&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161202img02.png&quot; alt=&quot;20161202img02&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;我们已经知道了我们的目标接下来我们就要开始创建工程了&quot;&gt;我们已经知道了我们的目标，接下来我们就要开始创建工程了。&lt;/h4&gt;

&lt;h2 id=&quot;二一步步搭建应用&quot;&gt;二、一步步搭建应用&lt;/h2&gt;

&lt;h4 id=&quot;打开开发工具hbuilder在左侧工程栏中右键新建移动app项目输入应用名称news默认选择空模版点击完成如下图&quot;&gt;打开开发工具“HBuilder”，在左侧工程栏中“右键”－“新建”－“移动APP”项目，输入应用名称“News”，默认选择空模版，点击完成，如下图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161202img03.png&quot; alt=&quot;20161202img03&quot; /&gt;
&lt;img src=&quot;/images/liuyw6/20161202img04.png&quot; alt=&quot;20161202img04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;建好工程后，按照下图的方式创建好相应的目录，同时导入mui相关的js，css等，其中工程目录的一些说明如下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161202img05.png&quot; alt=&quot;20161202img05&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;ps此工程已经放置于gogs上有兴趣的同学可以去下载&quot;&gt;PS：此工程已经放置于gogs上，有兴趣的同学可以去下载&lt;/h4&gt;

&lt;h4 id=&quot;按照上图中的目录建设完成我们可以进行相应的界面内容开发&quot;&gt;按照上图中的目录建设完成，我们可以进行相应的界面内容开发&lt;/h4&gt;

&lt;h2 id=&quot;三app内容代码详解&quot;&gt;三、APP内容代码详解&lt;/h2&gt;

&lt;h3 id=&quot;a数据源&quot;&gt;A、数据源&lt;/h3&gt;

&lt;h4 id=&quot;百度api-store中有许多的新闻接口我们就选择使用百度的api接口如下code段&quot;&gt;百度API Store中有许多的新闻接口，我们就选择使用百度的API接口，如下code段：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.ajax({
	type: &quot;GET&quot;,
	url: &quot;http://apis.baidu.com/showapi_open_bus/channel_news/search_news?channelId=&quot; + selectedType + &quot;&amp;amp;page=&quot; + pageObj[selectedType],
	beforeSend: function(request) {
		request.setRequestHeader(&quot;apikey&quot;, &quot;7f6dfa583fe9406f73f2830a5c2fb99c&quot;);
	},
	success: function(d) {
		if(d.showapi_res_body.pagebean) {
			var newsArray = d.showapi_res_body.pagebean.contentlist;
			var singleModel = '&amp;lt;div class=&quot;news-item&quot;&amp;gt;' + $('.news-item-model-single').html() + '&amp;lt;/div&amp;gt;';
			var multiModel = '&amp;lt;div class=&quot;news-item&quot;&amp;gt;' + $('.news-item-model-multi').html() + '&amp;lt;/div&amp;gt;';
			var textModel = '&amp;lt;div class=&quot;news-item&quot;&amp;gt;' + $('.news-item-model-none').html() + '&amp;lt;/div&amp;gt;';
			for(var i = 0; i &amp;lt; newsArray.length; i++) {
				//判断新闻是否已经显示过
				if(refreshArt.indexOf(newsArray[i].title) == -1) {
					//设置当前新闻格式，无图片格式、单图片格式、多图片格式
					var model, type;
					if(!newsArray[i].havePic) {
						model = textModel;
						type = 'text';
					} else {
						if(newsArray[i].imageurls.length &amp;gt; 1) {
							model = multiModel;
							type = 'multi';
						} else {
							model = singleModel;
							type = 'single';
						}
					}
					refreshArt.push(newsArray[i].title);
					detailObj[selectedType].push(newsArray[i]);

					$('.' + newId).append(model);
					$('.' + newId).find('.news-item:last').attr('iden', preLength + i);
					$('.' + newId).find('.news-item:last').find('.news-title').html(newsArray[i].title);

					//设置图片
					if(type == 'single') {
						$('.' + newId).find('.news-item:last').find('.news-image img').attr('src', newsArray[i].imageurls[0].url);
					} else {
						for(var j = 0; j &amp;lt; (newsArray[i].imageurls.length &amp;gt; 3 ? 3 : newsArray[i].imageurls.length); j++) {
							$('.' + newId).find('.news-item:last').find('.news-image-multi').find('.flex-element-no-padding:eq(' + j + ')').html('&amp;lt;img src=&quot;' + newsArray[i].imageurls[j].url + '&quot;/&amp;gt;')
						}
					}

					$('.' + newId).find('.news-item:last').find('.author-name').html(newsArray[i].source);
					$('.' + newId).find('.news-item:last').find('.pub-date').html(newsArray[i].pubDate);
					//绑定新闻点击事件，点击后进入新闻详情页面
					$('.' + newId).find('.news-item:last').on('tap', function() {
						storage.setItem('newsContent', JSON.stringify(detailObj[selectedType][$(this).attr('iden')]));
						_tl.toUrl('newsDetail.html');
					})
				}
			}

		} else {
			mui.toast('加载失败，请稍后尝试');
		}
		//设置上拉、下拉结束标志
		mui('#pullrefresh').pullRefresh().endPulldownToRefresh(); //refresh completed
		mui('#pullrefresh').pullRefresh().endPullupToRefresh(false);
	}
});

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;这一段的作用则是从百度api中抓取数据展示至界面中&quot;&gt;这一段的作用则是从百度API中抓取数据展示至界面中&lt;/h4&gt;

&lt;h3 id=&quot;b-list界面由外部的框架页面和内部列表界面&quot;&gt;B. List界面由外部的框架页面和内部列表界面&lt;/h3&gt;

&lt;h4 id=&quot;外部框架页&quot;&gt;外部框架页&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;width=device-width, initial-scale=1,maximum-scale=1, user-scalable=no&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-capable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-status-bar-style&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#fc3434&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../css/mui.min.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../css/common/base.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;css/index.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/flexible/flexible.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/mui.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;.android-body&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.mui-pull-top-pocket&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;margin-top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1.1rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.2rem&lt;/span&gt; &lt;span class=&quot;cp&quot;&gt;!important&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;line-height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.2rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#f1f1f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
			&lt;span class=&quot;nc&quot;&gt;.android-body&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.mui-pull&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0.1rem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;}&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;header&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui-bar mui-bar-nav&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;title&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui-title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;热点新闻&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-types&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-types-wrap&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;storage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;window&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;localStorage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;selectType&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

			&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;loadChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getJSON&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'../data/chanel.json'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
					&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.news-types-wrap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
					&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;channelList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
						&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;channelList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
						&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.news-types-wrap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'&amp;lt;span type=&quot;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;channelId&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&quot;&amp;gt;'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&amp;lt;/span&amp;gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
					&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
					&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.news-types-wrap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'span:first'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'selected'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
					&lt;span class=&quot;nx&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'selectType'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.selected'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'type'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

					&lt;span class=&quot;c1&quot;&gt;//绑定点击事件&lt;/span&gt;
					&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.news-types span'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'tap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
						&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'.selected'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;removeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'selected'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
						&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'selected'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
						&lt;span class=&quot;nx&quot;&gt;storage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'selectType'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'type'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
					&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

			&lt;span class=&quot;nx&quot;&gt;mui&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
				&lt;span class=&quot;na&quot;&gt;statusBarBackground&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'#fc3434'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
				&lt;span class=&quot;na&quot;&gt;subpages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[{&lt;/span&gt;
					&lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'index.html'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
					&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'index'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
					&lt;span class=&quot;na&quot;&gt;styles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
						&lt;span class=&quot;na&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'html'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;css&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'font-size'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'px'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//mui标题栏默认高度为45px；&lt;/span&gt;
						&lt;span class=&quot;na&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'0px'&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//默认为0px，可不定义；&lt;/span&gt;
					&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

			&lt;span class=&quot;nx&quot;&gt;mui&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;plusReady&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;c1&quot;&gt;//仅支持竖屏显示&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;plus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;screen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;lockOrientation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;portrait-primary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;mui&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;android&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
					&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'body'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;addClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'android-body'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
				&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

			&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;loadChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;外部框架页定义了新闻的种类列表同时使用了muiinit定义了子页面indexhtml作为内容列表的提供页&quot;&gt;外部框架页定义了，新闻的种类列表，同时使用了mui.init，定义了子页面index.html作为内容列表的提供页&lt;/h4&gt;

&lt;h4 id=&quot;内容列表页indexhtml&quot;&gt;内容列表页index.html&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-capable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-status-bar-style&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#fc3434&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/swiper/css/swiper.min.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../css/mui.min.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;css/index.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/flexible/flexible.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/swiper/js/swiper.jquery.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/circle-progress.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/tools.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/mui.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/index.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-panel-content-full&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;c&quot;&gt;&amp;lt;!--下拉刷新容器--&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pullrefresh&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui-content mui-scroll-wrapper&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui-scroll&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;c&quot;&gt;&amp;lt;!--数据列表--&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui-table-view mui-table-view-chevron&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-item-model-single hide&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-div&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-title flex-element3-no-padding&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;当你最穷的时候，这样做，不成百万富翁至少也是土豪！&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-image flex-element-no-padding&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;img&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;img-01&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://05.imgmini.eastday.com/mobile/20161011/20161011123754_349328718cfee5b4d04cd614f1033e3a_1_mwpm_03200403.jpeg&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-other flex-div&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding author-name&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;中国企业家俱乐部&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding pub-date text-right&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;2016-10-11 12:37&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-item-model-multi hide&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;当你最穷的时候，这样做，不成百万富翁至少也是土豪！&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-image-multi flex-div&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-other flex-div&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding author-name&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;中国企业家俱乐部&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding pub-date text-right&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;2016-10-11 12:37&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-item-model-none hide&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;当你最穷的时候，这样做，不成百万富翁至少也是土豪！&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;news-other flex-div&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding author-name&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;中国企业家俱乐部&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;flex-element-no-padding pub-date text-right&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;2016-10-11 12:37&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;内容列表是一个常规的html5界面定义了一个上拉下拉刷新的容器我们来看看index的js定义&quot;&gt;内容列表是一个常规的html5界面，定义了一个上拉下拉刷新的容器，我们来看看index的js定义&lt;/h4&gt;

&lt;h4 id=&quot;indexjs&quot;&gt;index.js&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var storage = window.localStorage;
var _tl = getTLInstance();
var detailObj = {}, //新闻内容
	pageObj = {}, //每个模块的分页数
	transObj = {}; //每个模块的滚动条位置

var refreshArt = []; //存储新闻标题的临时数组，防止新闻重复出现

//初始化加载栏
mui.init({
	pullRefresh: {
		container: '#pullrefresh',
		up: {
			contentrefresh: '正在加载更多...',
			callback: doUpLoading
		},
		down: {
			contentrefresh: '正在刷新...',
			callback: doDownLoading
		}
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h4 id=&quot;这一部分定义了此页面拥有上拉和下拉的功能并且指定了相应的容器同时指定了上拉和下拉的回调函数douploadingdodownloading&quot;&gt;这一部分定义了此页面拥有上拉和下拉的功能，并且指定了相应的容器，同时指定了上拉和下拉的回调函数doUpLoading、doDownLoading&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
$(function() {
	//延迟加载，等待WebView初始化完成
	if(mui.os.plus) {
		mui.plusReady(function() {
			setTimeout(function() {
				triggerUp();
				tempSolution();
			}, 500);

		});
	} else {
		mui.ready(function() {
			setTimeout(function() {
				triggerUp();
				tempSolution();
			}, 100);
		});
	}
	//纪录每个模块的滚动条变化
	setTimeout(function() {
		if(mui.os.android) {
			//Android不识别webkitTransform，因此还是使用的滚动条
			$(window).scroll(function(e) {
				transObj[storage.getItem('selectType')] = document.body.scrollTop;
			})
		} else {
			//IOS、Html识别webkitTransform
			$('.mui-scroll').on('touchend touchcancel', function(e) {
				var str = document.querySelector('.mui-scroll').style.webkitTransform;
				transObj[storage.getItem('selectType')] = $.trim(str.substring(str.indexOf(',') + 1, str.lastIndexOf(',')));
				if(parseInt(transObj[storage.getItem('selectType')]) &amp;gt; 0) {
					transObj[storage.getItem('selectType')] = '0px';
				}
			})
		}
	}, 2100)
})

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;这一部分定义了页面初始化时要做的事情触发一个上拉刷新加载内容同时绑定滚动事件记录当前频道的阅读位置并且存储起来&quot;&gt;这一部分定义了页面初始化时要做的事情：触发一个上拉刷新加载内容、同时绑定滚动事件记录当前频道的阅读位置并且存储起来&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//触发下拉刷新事件
function triggerUp() {
	var selectedType = storage.getItem('selectType');
	pageObj[selectedType] = 1;
	var newId = 'news-list-' + selectedType;
	$('.news-list').hide();
	//模块初始化后保留上次的加载纪录，避免切换时再次刷新，提高友好度
	if(!$('.' + newId).html()) {
		$('.mui-table-view').append('&amp;lt;div class=&quot;news-list ' + newId + '&quot;&amp;gt;&amp;lt;div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;');
		mui('#pullrefresh').pullRefresh().pulldownLoading();
	} else {
		$('.' + newId).show();
		//自动定位到每个模块的滚动条位置
		if(mui.os.android) {
			document.body.scrollTop = transObj[selectedType];
		} else {
			mui('.mui-scroll-wrapper').scroll().scrollTo(0, parseInt(transObj[selectedType]), 100);
		}
	}
}

//下拉刷新操作
function doDownLoading() {
	pageObj[storage.getItem('selectType')] = 1;
	loadNews();
}

//上拉加载更多操作
function doUpLoading() {
	pageObj[storage.getItem('selectType')]++;
	loadNews();
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;这一段定义了函数上拉下拉要做的事情其中triggerup做了2件事情1当点击的频道为第一次加载时从服务端获取数据2当点击的频道为已加载时自动定位到上次阅读的位置其中loadnews为第一段ajax获取数据的部分&quot;&gt;这一段定义了函数上拉下拉要做的事情；其中triggerUp做了2件事情：1、当点击的频道为第一次加载时，从服务端获取数据；2、当点击的频道为已加载时，自动定位到上次阅读的位置，其中loadNews()为第一段ajax获取数据的部分&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//临时解决方案，定时扫描type值，如发生变化则执行刷新操作（IOS、Android无法调用iframe方法）
var lastType;

function tempSolution() {
	setInterval(function() {
		if(!lastType) {
			lastType = storage.getItem('selectType');
		} else {
			if(lastType != storage.getItem('selectType')) {
				lastType = storage.getItem('selectType');
				triggerUp();
			}
		}
	}, 300)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;c新闻详情页由于百度的接口返回的列表中包含了新闻的主体内容因此在点击新闻时直接将内容传入展示&quot;&gt;C、新闻详情页，由于百度的接口返回的列表中包含了新闻的主体内容，因此在点击新闻时，直接将内容传入展示&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;viewport&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-capable&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-status-bar-style&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#fc3434&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/swiper/css/swiper.min.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../css/mui.min.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;css/newsDetail.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/flexible/flexible.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/swiper/js/swiper.jquery.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/circle-progress.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/common/tools.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;../js/mui.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;js/newsDetail.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-panel-top&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-panel-top-left&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;onclick=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui.back()&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mui-icon mui-icon-back&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-panel-top-center&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-title-bar&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
					热点新闻
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-panel-top-right&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;x-panel-content&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;article&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;J_article&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;J-article article&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;article-title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
						&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;article-src-time&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
						&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;src&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
					&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;content&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;J-article-content article-content&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;data-pswp-uid=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

				&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;/article&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var storage = window.localStorage;
var _tl = getTLInstance();
var _plus;

mui.plusReady(function() {
	_plus = plus;
})

$(function() {
	var news = JSON.parse(storage.getItem('newsContent'));
	$('.title').html(news.title);
	$('.src').html(news.pubDate+'&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;&amp;amp;nbsp;来源：'+news.source);
	var newsContent = news.allList;
	for(var i=0;i&amp;lt;newsContent.length;i++){
		if(typeof(newsContent[i]) == 'string'){
			$('.article-content').append('&amp;lt;p class=&quot;section txt&quot;&amp;gt;'+newsContent[i]+'&amp;lt;/p&amp;gt;');
		}else{
			$('.article-content').append('&amp;lt;figure class=&quot;section img&quot;&amp;gt;&amp;lt;a class=&quot;img-wrap&quot;&amp;gt;&amp;lt;img src=&quot;'+newsContent[i].url+'&quot;&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/figure&amp;gt;');
		}
	}

})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四app打包及真机查看&quot;&gt;四、APP打包及真机查看&lt;/h2&gt;

&lt;h3 id=&quot;a-真机调试&quot;&gt;A 真机调试&lt;/h3&gt;

&lt;h4 id=&quot;mac电脑安装xcode后即可使用模拟器进行ios调试连接iphone后也可以进行真机运行&quot;&gt;mac电脑安装xcode后，即可使用模拟器进行IOS调试、连接iphone后也可以进行真机运行&lt;/h4&gt;

&lt;h4 id=&quot;mac电脑连接android手机也可以进行真机调试android手机务必打开开发人员选项usb调试&quot;&gt;mac电脑连接android手机也可以进行真机调试，android手机务必打开“开发人员选项”－“USB调试”&lt;/h4&gt;

&lt;h4 id=&quot;window电脑暂时不能使用ios模拟器可使用真机运行&quot;&gt;window电脑暂时不能使用IOS模拟器，可使用真机运行&lt;/h4&gt;

&lt;h3 id=&quot;b-打包应用&quot;&gt;B 打包应用&lt;/h3&gt;

&lt;h4 id=&quot;右键应用选择发行发行为原生安装包按操作要求进行即可需说明&quot;&gt;右键应用选择“发行”－“发行为原生安装包”按操作要求进行即可，需说明：&lt;/h4&gt;

&lt;h4 id=&quot;android打包需要定义keystore即签名文件&quot;&gt;Android打包需要定义keystore，即签名文件&lt;/h4&gt;

&lt;h4 id=&quot;ios打包需要从apple开发者平台下载证书和描述文件才能打包在下面的章节我会详细的说明如何下载苹果证书创建安卓签名文件&quot;&gt;IOS打包需要从apple开发者平台下载证书和描述文件才能打包，在下面的章节我会详细的说明如何下载苹果证书、创建安卓签名文件&lt;/h4&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;通过上面的例子结合实例和mui官网的介绍可以很快速的入门进行h5的app开发&quot;&gt;通过上面的例子、结合实例和mui官网的介绍，可以很快速的入门进行h5的APP开发&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>Storm(2)-Storm集群的搭建</title>
   <link href="http://www.blogways.net/blog/2016/11/20/storm-2.html"/>
   <updated>2016-11-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/11/20/storm-2</id>
   <content type="html">&lt;blockquote&gt;
  &lt;p&gt;安装Storm集群，需要依赖以下组件：&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Zookeeper
Python
Zeromq
Storm
JDK
JZMQ
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我准备了3台机器，并在每台机器上配置主机别名，$ vi /etc/hosts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img01.png&quot; alt=&quot;20161120img01&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1搭建zookeeper集群&quot;&gt;1.搭建Zookeeper集群&lt;/h2&gt;

&lt;h4 id=&quot;1安装zookeeper&quot;&gt;(1)安装zookeeper&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar zxvf zookeeper-3.4.6.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2修改zoocfg&quot;&gt;(2)修改zoo.cfg&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cp -rf conf/zoo_sample.cfg conf/zoo.cfg
$ vi zoo.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;内容：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tickTime=2000
dataDir=/usr/local/software/zookeeper-3.4.6/data
clientPort=2181
initLimit=5
syncLimit=2
server.1=host1:2888:3888
server.2=host2:2889:3889
server.3=host3:2890:3890
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3在datadir的目录中添加myid并且编辑内容分别对应server的序号分别是123&quot;&gt;(3)在”dataDir”的目录中添加myid，并且编辑内容分别对应server的序号，分别是1、2、3&lt;/h4&gt;

&lt;h4 id=&quot;4在三台机器上分别启动&quot;&gt;(4)在三台机器上分别启动&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./bin/zkServer.sh start ./conf/zoo.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;通过$ ./bin/zkServer.sh status 查看zookeeper的leader&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img02.png&quot; alt=&quot;20161120img02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img03.png&quot; alt=&quot;20161120img03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img04.png&quot; alt=&quot;20161120img04&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2安装jdk&quot;&gt;2.安装JDK&lt;/h2&gt;

&lt;h4 id=&quot;1-tar-zxvf-jdk-7u79-linux-x64targz&quot;&gt;(1) tar zxvf jdk-7u79-linux-x64.tar.gz&lt;/h4&gt;

&lt;h4 id=&quot;2-配置环境变量&quot;&gt;(2) 配置环境变量&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ vi /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img05.png&quot; alt=&quot;20161120img05&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;运行$ source /etc/profile，使配置环境生效&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;3查看java版本&quot;&gt;(3)查看java版本&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img06.png&quot; alt=&quot;20161120img06&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;3安装jzmq&quot;&gt;3.安装JZMQ&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone git://github.com/nathanmarz/jzmq.git
$ cd jzmq
$ ./autogen.sh
$ ./configure
$ make &amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;4安装zeromq&quot;&gt;4.安装Zeromq&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;安装ZeroMQ所需组件及工具：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ yum install gcc gcc-c++ make uuid-devel libuuid-devel libtool

$ tar zxvf zeromq-4.2.0.tar.gz
$ cd zeromq-4.2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;手动创建classdist_noinst.stamp空文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ touch src/classdist_noinst.stamp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;进入文件夹 jzmq/src/org/zeromq，手动编译Java代码 $ javac  *.java&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./configure
$ make &amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;5搭建storm集群&quot;&gt;5.搭建Storm集群&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;(1) 安装包&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ tar zxvf apache-storm-1.0.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;(2) 配置环境变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img07.png&quot; alt=&quot;20161120img07&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(3) 建立storm存储目录&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir /tmp/storm
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;(4) 把host1作为nimbus和ui的服务器。host1、host2、host3为supervisor服务器，修改配置文件/conf/storm.yaml, 如下配置：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;storm.zookeeper.servers:
 - &quot;host1&quot;
 - &quot;host2&quot;
 - &quot;host3&quot;
ui.port: 8081
nimbus.host: &quot;host1&quot;
storm.local.dir: &quot;/tmp/storm&quot;
supervisor.slots.ports:
  - 6700
  - 6701
  - 6702
  - 6703
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;其中，配置参数说明：&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;• storm.zookeeper.servers：Storm集群使用的Zookeeper集群地址，如果Zookeeper集群使用的不是默认端口，那么还需要storm.zookeeper.port选项。&lt;/p&gt;

  &lt;p&gt;• ui.port：Storm UI的服务端口&lt;/p&gt;

  &lt;p&gt;• storm.local.dir：Nimbus和Supervisor进程用于存储少量状态，如jars、confs等的本地磁盘目录&lt;/p&gt;

  &lt;p&gt;• nimbus.host: Storm集群Nimbus机器地址&lt;/p&gt;

  &lt;p&gt;• supervisor.slots.ports: 对于每个Supervisor工作节点，需要配置该工作节点可以运行的worker数量。每个worker占用一个单独的端口用于接收消息，该配置选项即用于定义哪些端口是可被worker使用的。默认情况下，每个节点上可运行4个workers，分别在6700、6701、6702和6703端口&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;6启动storm集群&quot;&gt;6.启动Storm集群&lt;/h2&gt;

&lt;h4 id=&quot;1-nimbus&quot;&gt;(1) Nimbus:&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Storm主控节点(本文中为host1)上运行”bin/storm nimbus &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;”启动Nimbus后台程序，并放到后台执行；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;2-supervisor&quot;&gt;(2) Supervisor:&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Storm各个工作节点(本文中为host1/host2/host3)上运行”bin/storm supervisor &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;”启动Supervisor后台程序，并放到后台执行；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;3-ui&quot;&gt;(3) UI:&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Storm主控节点(本文中为host1)上运行”bin/storm ui &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;”启动UI后台程序，并放到后台执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;7查看storm-ui&quot;&gt;7.查看Storm UI&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;请求 &lt;em&gt;http://192.168.137.131:8081/&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161120img08.png&quot; alt=&quot;20161120img08&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自此storm集群环境就搭建完毕了。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Storm(1)-Storm基本概念</title>
   <link href="http://www.blogways.net/blog/2016/11/19/storm-1.html"/>
   <updated>2016-11-19T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/11/19/storm-1</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;Storm简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;Storm集群的组成&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;Storm基本概念&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;Storm流分组&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一storm简介&quot;&gt;一、Storm简介&lt;/h2&gt;

&lt;h4 id=&quot;storm是什么&quot;&gt;&lt;strong&gt;Storm是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Storm是一个开源的分布式实时计算系统，它提供了一系列的基本元素用于进行计算:Topology(拓扑)、Stream、Spout、Bolt等等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;storm的解决的是什么&quot;&gt;&lt;strong&gt;Storm的解决的是什么？&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Storm之前,实时计算的实现用的是标准队列和worker的方法。比如, 我们向一个队列集合里面写入data, 再用worker从这个队列集合读取data并处理他们。 通常情况下这些worker需要通过另一个队列集合向另一个worker集合发送消息来进一步处理这些data。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;我们非常不满意这种处理方式，这种方法不稳定–我们必须要保证所有的队列和worker一直处于工作状态，并且在构建应用时它也显得很笨重。 应用的大部分逻辑都集中在从哪发送/获取信息和怎样序列化/反序列化这些消息等等。但是在实际的业务逻辑里面它只是代码库的一小部分。再加上一个应用的正确逻辑应该是可以跨多个worker,并且这些worker之间是可以独立部署的，一个应用的逻辑也应该是自我约束的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Storm通过对 之前需要处理的繁重工作－发送／接收消息，序列化，部署等 这些操作的抽象实现了自动化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二storm集群的组成&quot;&gt;二、Storm集群的组成&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Storm集群里有两种节点: 控制节点和工作节点。控制节点上运行一个叫Nimbus后台程序,Nimbus负责在集群里面分发代码，分配计算任务给机器和监控状态。工作节点上运行一个叫做Supervisor的进程,Supervisor监听分配到机器的任务，根据需要启动/关闭工作进程worker。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;每一个工作进程执行一个topology的一个子集，一个运行的topology由运行在很多机器上的很多工作进程worker组成。(一个supervisor里面有多个workder，可以配置worker的数量，对应的是conf/storm.yaml中的upervisor.slot的数量）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161119img01.png&quot; alt=&quot;20161119img01&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nimbus和Supervisor之间的所有协调工作都是通过Zookeeper集群完成，除此之外，Nimbus后台程序和Supervisor后台程序是快速失效和无状态的。所有的状态保持在Zookeeper中或者是本地磁盘中，这意味着你能关闭Nimbus或者Supervisor而他们将会再次启动就像什么事情都没有发生过一样，这个设计使得Storm异常的稳定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a id=&quot;3nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三storm基本概念&quot;&gt;三、Storm基本概念&lt;/h2&gt;

&lt;h4 id=&quot;数据流topology&quot;&gt;&lt;strong&gt;数据流Topology&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Storm中,一个实时应用的计算任务被打包作为Topology发布,Topology任务一旦提交后永远不会结束，除非你显示去停止任务。计算任务Topology是由不同的Spouts和Bolts，通过数据流（Stream）连接起来的图｡&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161119img02.png&quot; alt=&quot;20161119img02&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;其中包含有：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Spout：Storm中的消息源,用于为Topology生产消息(数据)，一般是从外部数据源(如Message Queue、RDBMS、NoSQL、Realtime Log ）不间断地读取数据并发送给Topology消息(tuple元组)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bolt：Storm中的消息处理者，用于为Topology进行消息的处理，Bolt可以执行过滤，聚合，查询数据库等操作，而且可以一级一级的进行处理。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;数据模型tuple&quot;&gt;&lt;strong&gt;数据模型Tuple&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;Storm使用tuple来作为它的数据模型，每个tuple是一堆有名字的值，每个值可以是任何类型，可以理解为一个tuple是一个java对象。如果使用自定义类型来作为值类型，需要对值类型进行序列化。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;一个Tuple代表数据流中的一个基本的处理单元，它可以包含多个Field，每个Field表示一个属性。如：三个字段（taskID：int； StreamID：String； ValueList： List）：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;worker上执行的task&quot;&gt;&lt;strong&gt;Worker上执行的Task&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;worker中每一个spout/bolt的线程称为一个task，同一个spout/bolt的task可能会共享一个物理线程，该线程称为executor。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;storm的记录级容错&quot;&gt;&lt;strong&gt;Storm的记录级容错&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;相比于其他实时计算系统，Storm最大的亮点在于其记录级容错和能够保证消息精确处理的事务功能。Storm中记录级容错的意思是，Storm会告知用户每一个消息单元是否在指定时间内被完全处理了。如下图：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161119img03.png&quot; alt=&quot;20161119img03&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在Storm的topology中有一个系统级组件，叫做acker。这个acker的任务就是追踪从spout中流出来的每一个message id绑定的若干tuple的处理路径，如果在用户设置的最大超时时间内这些tuple没有被完全处理，那么acker就会告知spout该消息处理失败了，相反则会告知spout该消息处理成功了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;storm的事务拓扑&quot;&gt;&lt;strong&gt;Storm的事务拓扑&lt;/strong&gt;&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;事务拓扑简单来说就是将消息分为一个个的批(batch)，同一批内的消息以及批与批之间的消息可以并行处理，另一方面，用户可以设置某些bolt为committer，storm可以保证committer的finishBatch()操作是按严格不降序的顺序执行的。用户可以利用这个特性通过简单的编程技巧实现消息处理的精确。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;四storm流分组&quot;&gt;四、Storm流分组&lt;/h2&gt;
&lt;blockquote&gt;

  &lt;p&gt;Stream Grouping定义了一个流在Bolt任务间该如何被切分，就是哪个Task来处理哪些数据，按什么规则来分配。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Storm提供的6种类型：&lt;/strong&gt;&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;随机分组（Shuffle grouping）：随机分发tuple到Bolt的任务，保证每个任务获得相等数量的tuple。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;字段分组（Fields grouping）：根据指定字段分割数据流，并分组。例如，根据“color”字段，相同“color”的元组总是分发到同一个任务，不同“color”的元组可能分发到不同的任务。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;全部分组（All grouping）：tuple被复制到bolt的所有任务，广播方式。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;全局分组（Global grouping）：全部流都分配到bolt的同一个任务。明确地说，是分配给ID最小的那个task。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;无分组（None grouping）：你不需要关心流是如何分组。目前，无分组等效于随机分组。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;直接分组（Direct grouping）：这是一个特别的分组类型。元组生产者决定tuple由哪个元组处理者任务接收。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Mysql索引使用</title>
   <link href="http://www.blogways.net/blog/2016/11/11/mysql-index.html"/>
   <updated>2016-11-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/11/11/mysql-index</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;基本原理&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;索引类型&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;索引方式&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;注意事项&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一基本原理&quot;&gt;一、基本原理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。&lt;/p&gt;

  &lt;p&gt;当数据保存在磁盘类存储介质上时，它是作为数据块存放。这些数据块是被当作一个整体来访问的，这样可以保证操作的原子性。硬盘数据块存储结构类似于链表，都包含数据部分，以及一个指向下一个节点（或数据块）的指针，不需要连续存储。&lt;/p&gt;

  &lt;p&gt;记录集只能在某个关键字段上进行排序，所以如果需要在一个无序字段上进行搜索，就要执行一个线性搜索的过程，平均需要访问N/2的数据块，N是表所占据的数据块数目。如果这个字段是一个非主键字段（也就是说，不包含唯一的访问入口），那么需要在N个数据块上搜索整个表格空间。&lt;/p&gt;

  &lt;p&gt;但是对于一个有序字段，可以运用二分查找，这样只要访问log2(N)的数据块。这就是为什么性能能得到本质上的提高。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二索引类型&quot;&gt;二、索引类型&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Normal(普通索引)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;最基本的索引，没有任何限制。索引长度必须是固定的，MySQL所允许的最大索引长度是255个字符。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Unique(唯一索引)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;与普通索引的不同就是索引列的值必须唯一，但允许有空值。&lt;/p&gt;

  &lt;p&gt;（1）单列唯一索引。&lt;/p&gt;

  &lt;p&gt;（2）主键索引，是一种特殊的唯一索引，不允许有空值。&lt;/p&gt;

  &lt;p&gt;（3）组合索引，多列组合成一个索引，组合值必须唯一。&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Full Text(全文检索)&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;普通索引只能加快字段内容开头字符的检索，如果字段是多个单词构成 的较大段文字，普通索引就没什么作用。
这种检索往往以LIKE %word%的形式出现，如果需要处理的数据量很大，响应时间就会很长。
MySQL将把在文本中出现的所有单词创建为一份清单，查询操作将根据这份清单去检索有关的数据记录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a id=&quot;3nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三索引方式&quot;&gt;三、索引方式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;1.Hash方式&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Hash 索引就是把这一列进行哈希算法计算，得到哈希值，排序在哈希数组上，索引的检索可以一次定位。 其效
率很高，不像BTree 索引需要从根节点到枝节点，所以 Hash 索引的查询效率要远高于 BTree 索引。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161111img01.png&quot; alt=&quot;20161006img07&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;(1)不能使用hash索引排序。&lt;/p&gt;

  &lt;p&gt;(2)Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。&lt;/p&gt;

  &lt;p&gt;(3)Hash索引只支持等值比较查询，如：=,in(),&amp;lt;=精确查询。对于WHERE age&amp;gt;20并不能加速查询。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;2.BTree方式&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;Btree索引是以B+树为存储结构实现的，但是Btree索引的存储结构在Innodb和MyISAM中有很大区别。
MyISAM的索引方式也称为非聚集，Innodb的索引方式成为聚集索引。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161111img02.png&quot; alt=&quot;20161006img07&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;存储引擎-myisam和innodb的区别&quot;&gt;&lt;strong&gt;存储引擎-MyIsAM和InnoDB的区别&lt;/strong&gt;&lt;/h4&gt;
&lt;blockquote&gt;

  &lt;p&gt;(1)MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持。&lt;/p&gt;

  &lt;p&gt;(2)MyISAM是表级锁，而InnoDB是行级锁。&lt;/p&gt;

  &lt;p&gt;(3)InnoDB不支持FULLTEXT类型的索引，不保存表的具体行数。&lt;/p&gt;

  &lt;p&gt;(4)MyISAM表不支持外键&lt;/p&gt;

  &lt;p&gt;(5)对于自增长类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。&lt;/p&gt;

  &lt;p&gt;因此，当你的数据库有大量的写入、更新操作而查询比较少或者数据完整性要求比较高的时候就选择InnoDB表。当你的数据库主要以查询为主，相比较而言更新和写入比较少，并且业务方面数据完整性要求不那么严格，就选择MyISAM表。因为MyISAM表的查询操作效率和速度都比InnoDB要快。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四注意事项&quot;&gt;四、注意事项&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;数据库能同时使用多个索引&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;SELECT * FROM TB WHERE A=5 AND B=6&lt;/p&gt;

  &lt;p&gt;能分别使用索引(A) 和 (B)；&lt;/p&gt;

  &lt;p&gt;对于这个语句来说，创建组合索引(A,B) 更好；&lt;/p&gt;

  &lt;p&gt;最终是采用组合索引，还是两个单列索引？主要取决于应用系统中是否存在这类语句：&lt;/p&gt;

  &lt;p&gt;SELECT * FROM TB WHERE B=6&lt;/p&gt;

  &lt;p&gt;SELECT * FROM TB WHERE A=5 OR B=6&lt;/p&gt;

  &lt;p&gt;组合索引(A, B)不能用于此查询，很明显，分别创建索引(A) 和 (B)会更好；&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;删除无效的冗余索引&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;TB表有两个索引(A, B) 和 (A)，对应两种SQL语句：SELECT * FROM TB WHERE A=5 AND B=6 和 SELECT * FROM TB WHERE A=5&lt;/p&gt;

  &lt;p&gt;执行时，并不是WHERE A=5 就用 (A)； WHERE A=5 AND B=6  就用 (A, B)；&lt;/p&gt;

  &lt;p&gt;其查询优化器会使用其中一个以前常用索引，要么都用(A, B)， 要么都用 (A)。&lt;/p&gt;

  &lt;p&gt;所以应该删除索引(A)，它已经被(A, B)包含了，没有任何存在的必要。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;使用场景需要注意：&lt;/strong&gt;&lt;/p&gt;

  &lt;p&gt;(1) 频繁的作为查询条件的字段应该创建为索引。&lt;/p&gt;

  &lt;p&gt;(2) 唯一性很差的字段不适合做索引(如：性别)，因为就算建立了索引，二叉树也就只有一层，还是要大规模的进行表的扫描。&lt;/p&gt;

  &lt;p&gt;(3) 更新很频繁的字段不适合作为索引，因为每次操作的时候都会遍历，修改或者删除索引，这样会降低更新表的速度。&lt;/p&gt;

  &lt;p&gt;(4) 在列中有复合索引时，只要查询条件有使用最左边的列，索引一般就会被使用到。&lt;/p&gt;

  &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;复合索引:alter table dept add index my_index(dname,loc);//dname是左边的列。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/div&gt;

  &lt;p&gt;(5) 模糊查询 like ‘%a’（%为前缀）、not in、&amp;lt;&amp;gt;条件 不会用到索引，’a%’(%为后缀)会用到索引。&lt;/p&gt;

  &lt;p&gt;(6) 索引的数据类型越小越简单越好，整型数据比起字符，处理开销更小。&lt;/p&gt;

  &lt;p&gt;(7) 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。&lt;/p&gt;

  &lt;p&gt;(8) 不要在列上进行函数运算，如select * from users where YEAR(xxdate)&amp;lt;2007;应该写为：select * from users where xxdate&amp;lt;’2007-01-01’;&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>使用SourceTree进行gogs的操作</title>
   <link href="http://www.blogways.net/blog/2016/10/22/git-sourceTree.html"/>
   <updated>2016-10-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/10/22/git-sourceTree</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#begin&quot;&gt;什么是sourceTree&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;如何安装sourceTree&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;如何在gogs上创建仓库&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3rd&quot;&gt;如何克隆gogs上的工程&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#4ur&quot;&gt;如何在gogs仓库中添加目录和文件&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;如何新增或修改文件，并提交到gogs上去&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;begin&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1什么sourcetree&quot;&gt;1.什么sourceTree&lt;/h2&gt;

&lt;p&gt;SourceTree 是 Windows 和Mac OS X 下免费的 Git 和 Hg 客户端，拥有可视化界面，容易上手操作。同时它也是Mercurial和Subversion版本控制系统工具。支持创建、提交、clone、push、pull 和merge等操作。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2如何安装sourcetree&quot;&gt;2.如何安装sourceTree&lt;/h2&gt;

&lt;p&gt;（1） 点击连接&lt;a href=&quot;https://www.sourcetreeapp.com/&quot;&gt;sourceTree&lt;/a&gt;下载对应版本的sourceTree，官网里有Mac和win版本的，根据自己的电脑下载对应版本，下载之前确认电脑是否已经安装的git工具。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;若没有安装可以点击&lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;git下载&lt;/a&gt;，进行安装。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;（2）双击下载的.exe文件，可以看到下面界面
&lt;img src=&quot;/images/chenfan/sourceTree-install-1.png&quot; alt=&quot;sourceTree-install-1.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击Next，选择安装的本机路径，最后点击install即可&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-install-2.png&quot; alt=&quot;sourceTree-install-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-install-3.png&quot; alt=&quot;sourceTree-install-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（3）安装完成，会弹出如下对话框，你可以选择自动下载。我用的是git 直接选择跳过就可以了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-install-4.png&quot; alt=&quot;sourceTree-install-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;会显示正在下载文件&lt;/p&gt;

&lt;p&gt;（4）若没有在github进行注册，建议注册后使用github进行登陆，安装到此结束。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3如何在gogs上创建仓库&quot;&gt;3.如何在gogs上创建仓库&lt;/h2&gt;

&lt;p&gt;（1）首先在gogs上你的用户，联系gogs管理员为你分配权限&lt;/p&gt;

&lt;p&gt;（2）登陆gogs&lt;a href=&quot;http://10.20.16.78:3000&quot;&gt;http://10.20.16.78:3000&lt;/a&gt;,进入你的组织&lt;/p&gt;

&lt;p&gt;（3）点击&lt;img src=&quot;/images/chenfan/sourceTree-used-1.png&quot; alt=&quot;sourceTree-used-1.png&quot; /&gt;创建你自己的远程仓库&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;3rd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4如何克隆gogs上的工程&quot;&gt;4.如何克隆gogs上的工程&lt;/h2&gt;

&lt;p&gt;点击克隆/新建命令，弹出以下对话框&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-used-2.png&quot; alt=&quot;sourceTree-used-2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;源路径为要克隆的gogs工程的url，url地址可以登陆gogs进行查找&lt;/p&gt;

&lt;p&gt;目标路径为本机的工程存放路径，点击克隆即可&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;4ur&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;5如何在gogs仓库中添加目录和文件&quot;&gt;5.如何在gogs仓库中添加目录和文件&lt;/h2&gt;

&lt;p&gt;（1）点击配置选项，点击添加，添加远程仓库
&lt;img src=&quot;/images/chenfan/sourceTree-used-3.png&quot; alt=&quot;sourceTree-used-3.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;远程仓库指的是在gogs上创建的仓库，点击确定&lt;/p&gt;

&lt;p&gt;（2）方式1（远程仓库为空的情况）：&lt;/p&gt;

&lt;p&gt;1.点击克隆/新建，选择创建新仓库，
&lt;img src=&quot;/images/chenfan/sourceTree-used-4.png&quot; alt=&quot;sourceTree-used-4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;目标路径为你本地存放路径，在这个路径下你可以存放你要上传的文件目录等，点击创建，可以看到左侧出现，&lt;img src=&quot;/images/chenfan/sourceTree-used-6.png&quot; alt=&quot;sourceTree-used-6.png&quot; /&gt;，把要上传的工程放在此本机目录下，即为&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-used-7.png&quot; alt=&quot;sourceTree-used-7.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击未暂存文件，可以看到未暂存的文件已经存放到以暂存文件中&lt;/p&gt;

&lt;p&gt;2.点击&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-used-8.png&quot; alt=&quot;sourceTree-used-8.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;提交按钮，即出现&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-used-9.png&quot; alt=&quot;sourceTree-used-9.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击提交即可&lt;/p&gt;

&lt;p&gt;3.在最上面工具栏点击推送按钮，即
&lt;img src=&quot;/images/chenfan/sourceTree-used-10.png&quot; alt=&quot;sourceTree-used-10.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击确定，本地的要上传的东西提交到gogs远程仓库中，可以登陆gogs查看是否提交成功&lt;/p&gt;

&lt;p&gt;（3）方式2（克隆）&lt;/p&gt;

&lt;p&gt;1.点击克隆，克隆你在gogs创建的远程仓库，在本地该目录中存放你需要上传的东西&lt;/p&gt;

&lt;p&gt;2.点击未暂存文件，可以看到未暂存的文件已经存放到以暂存文件中，即重复方式1，点击提交，推送&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;6如何新增或修改文件并提交到gogs上去&quot;&gt;6.如何新增或修改文件，并提交到gogs上去&lt;/h2&gt;

&lt;p&gt;（1）克隆工程，在本地仓库中修改，添加文件，打开sourceTree&lt;/p&gt;

&lt;p&gt;会出现下图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-used-11.png&quot; alt=&quot;sourceTree-used-11.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chenfan/sourceTree-used-12.png&quot; alt=&quot;sourceTree-used-12.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;点击未暂存的文件，将其加入已暂存文件，重复5中的方式1，点击提交、推送，即将修改的文件工程添加到远程gogs中&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>初识APP混合应用开发框架 -- mui</title>
   <link href="http://www.blogways.net/blog/2016/10/09/web-mui-01.html"/>
   <updated>2016-10-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/10/09/web-mui-01</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;初识DCloud\HBuilder\5+\mui&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一什么是mui&quot;&gt;一、什么是mui&lt;/h2&gt;

&lt;h3 id=&quot;mui是dcloud推出的一款最接近原生app体验的高性能前端框架&quot;&gt;mui是DCloud推出的一款最接近原生APP体验的高性能前端框架&lt;/h3&gt;

&lt;h4 id=&quot;以下是dcloud官方的介绍&quot;&gt;以下是DCloud官方的介绍：&lt;/h4&gt;

&lt;h4 id=&quot;html5自出现以来几经风雨虽看似很有前途但实际使用问题太多dcloud为此踩了无数坑但我们从未放弃我们加入了w3c发起了html5中国产业联盟推出了hbuilderhtml5plus-runtimemui框架等产品直到我们终于可以使用html5开发出原生体验的app并且把这些技术公开给开发者&quot;&gt;HTML5自出现以来，几经风雨，虽看似很有前途，但实际使用问题太多，DCloud为此踩了无数坑。但我们从未放弃，我们加入了W3C，发起了HTML5中国产业联盟，推出了HBuilder、HTML5plus runtime、mui框架等产品，直到我们终于可以使用HTML5开发出原生体验的App，并且把这些技术公开给开发者。&lt;/h4&gt;

&lt;h4 id=&quot;html5过去被称为有性工能障碍即性能不如原生工具不如原生功能不如原生&quot;&gt;HTML5过去被称为有“性工能”障碍，即性能不如原生，工具不如原生、功能不如原生。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161009img01.png&quot; alt=&quot;20161009img01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;为了解决这些问题dcloud在以下方面做了升级优化hbuilder-和-html5plus-runtimemui框架等等下面我们就围绕性工能开始介绍&quot;&gt;为了解决这些问题，DCloud在以下方面做了升级优化：HBuilder 和 HTML5plus runtime、mui框架等等，下面我们就围绕“性工能”开始介绍&lt;/h4&gt;

&lt;h2 id=&quot;工具---hbuilder&quot;&gt;工具 - HBuilder&lt;/h2&gt;

&lt;h3 id=&quot;a起因&quot;&gt;A、起因&lt;/h3&gt;

&lt;h4 id=&quot;html最开始其实不是一个编程语言确实用不着什么ide&quot;&gt;HTML最开始其实不是一个编程语言，确实用不着什么ide。&lt;/h4&gt;

&lt;h4 id=&quot;但是发展到现在7w多个语法js越来越庞大真开发一个达到原生水准的app不是用以前的文本编辑器能搞定的&quot;&gt;但是发展到现在，7w多个语法，js越来越庞大，真开发一个达到原生水准的App，不是用以前的文本编辑器能搞定的。&lt;/h4&gt;

&lt;h4 id=&quot;目前竟然没有一个开发工具能把7w多html5语法提示齐全这不科学在原生开发里这是不可想象的xcode之于ioseclipse之于androidvs之于winphone在语法提示转到定义重构调试等方面都非常高效&quot;&gt;目前竟然没有一个开发工具能把7w多HTML5语法提示齐全，这不科学，在原生开发里这是不可想象的，xcode之于iOS，eclipse之于Android，vs之于winphone，在语法提示、转到定义、重构、调试等方面都非常高效。&lt;/h4&gt;

&lt;h4 id=&quot;作为同时熟悉原生和html5开发的我们我们在开发html5时明显感受到效率低下&quot;&gt;作为同时熟悉原生和HTML5开发的我们，我们在开发HTML5时明显感受到效率低下。&lt;/h4&gt;

&lt;h3 id=&quot;b强大的语法提示&quot;&gt;B、强大的语法提示&lt;/h3&gt;

&lt;h4 id=&quot;dcloud花费了很大心血建成了最全的html5及浏览器扩展前缀语法库也开发了强大的语法解析引擎然后推出了开发工具hbuilder使得开发者可以准确高效的编写html5代码而且全免费&quot;&gt;DCloud花费了很大心血建成了最全的HTML5及浏览器扩展前缀语法库，也开发了强大的语法解析引擎，然后推出了开发工具HBuilder，使得开发者可以准确、高效的编写HTML5代码。而且全免费&lt;/h4&gt;

&lt;h3 id=&quot;c最快的开发工具&quot;&gt;C、最快的开发工具&lt;/h3&gt;

&lt;h4 id=&quot;由于dcloud的极客特质hbuilder同时被打造成了最快的前端开发工具代码输入法的创新代码块的优化emmet的集成快捷键语法设计无鼠标操作hbuilder有句口号为极客为懒人为你&quot;&gt;由于DCloud的极客特质，HBuilder同时被打造成了最快的前端开发工具，代码输入法的创新、代码块的优化、emmet的集成、快捷键语法设计、无鼠标操作；HBuilder有句口号：为极客、为懒人、为你。&lt;/h4&gt;

&lt;h3 id=&quot;d环保健康的主题设计&quot;&gt;D、环保健康的主题设计&lt;/h3&gt;

&lt;h4 id=&quot;由于我们天天面对屏幕眼睛很受伤所以设计了绿柔主题以保护开发者的视力健康&quot;&gt;由于我们天天面对屏幕眼睛很受伤，所以设计了绿柔主题以保护开发者的视力健康&lt;/h4&gt;

&lt;h3 id=&quot;eapp开发及部署&quot;&gt;E、App开发及部署&lt;/h3&gt;

&lt;h4 id=&quot;当然移动app开发也是hbuilder的优势run-in-device真机调试打包发行这些功能并非普通的html4开发工具会涉及的如果只是做个网站html4就够了搞html5而不做app太糟蹋这个技术了以及云打包还能使得没有mac电脑的程序员可以开发ios应用&quot;&gt;当然移动App开发也是HBuilder的优势，Run in device真机调试、打包发行这些功能并非普通的HTML4开发工具会涉及的。如果只是做个网站，HTML4就够了，搞HTML5而不做App，太糟蹋这个技术了。以及云打包还能使得没有mac电脑的程序员可以开发iOS应用。&lt;/h4&gt;

&lt;h2 id=&quot;能力---html5plus-runtime&quot;&gt;能力 - HTML5plus Runtime&lt;/h2&gt;

&lt;h4 id=&quot;说完性工能里的工具再说说能力&quot;&gt;说完性工能里的工具，再说说能力。&lt;/h4&gt;

&lt;h4 id=&quot;html5plus-runtime简称5-runtime是运行于手机端的强化web引擎除了支持标准html5外还支持更多扩展的js-api使得js的能力不输于原生5-runtime内置于hbuilder在真机运行打包时自动挂载&quot;&gt;HTML5plus Runtime，简称5+ Runtime，是运行于手机端的强化web引擎，除了支持标准HTML5外，还支持更多扩展的js api，使得js的能力不输于原生。5+ Runtime内置于HBuilder，在真机运行、打包时自动挂载。&lt;/h4&gt;

&lt;h4 id=&quot;业内之前有phonegapcordova方案但是他们自带js-api太少了扩展api需要用原生语言开发更致命的是这类方案的性能不足&quot;&gt;业内之前有phonegap/Cordova方案，但是他们自带js api太少了，扩展api需要用原生语言开发，更致命的是这类方案的性能不足。&lt;/h4&gt;

&lt;h3 id=&quot;a常用的api--html5plus&quot;&gt;A、常用的API – HTML5plus&lt;/h3&gt;

&lt;h4 id=&quot;装成跨平台的html5plus规范并将规范公开于wwwhtml5plusorg不做厂商私有api包括二维码摇一摇语音输入地图支付分享文件系统通讯录等常用api可以方便简单的编写并且可跨平台&quot;&gt;装成跨平台的HTML5plus规范，并将规范公开于www.HTML5plus.org，不做厂商私有API。包括二维码、摇一摇、语音输入、地图、支付、分享、文件系统、通讯录等常用API，可以方便简单的编写，并且可跨平台。&lt;/h4&gt;

&lt;h3 id=&quot;b其他原生api--nativejs&quot;&gt;B、其他原生API – Native.js&lt;/h3&gt;

&lt;h4 id=&quot;原生api在ios和android上各自有40多万有些api并不常用而且不具有跨平台特性比如ios的game-center-api太多的api封装到html5plus里会过多增加runtime的体积但若有需求要使用这些api又很麻烦&quot;&gt;原生API在iOS和Android上各自有40多万，有些API并不常用，而且不具有跨平台特性，比如ios的game center api。太多的API封装到HTML5plus里，会过多增加runtime的体积，但若有需求要使用这些api又很麻烦。&lt;/h4&gt;

&lt;h4 id=&quot;dcloud使用突破性的技术解决上述烦恼nativejs一种把40w原生api映射为js-api的技术&quot;&gt;DCloud使用突破性的技术解决上述烦恼—Native.js，一种把40w原生API映射为JS API的技术。&lt;/h4&gt;

&lt;h4 id=&quot;如果说nodejs把js的战火烧到了服务器端那么nativejs把js战火烧到了原生应用战场但我们可以使用js直接调原生api语法是js语法api命名是原生命名&quot;&gt;如果说node.js把js的战火烧到了服务器端，那么Native.js把js战火烧到了原生应用战场。但我们可以使用js直接调原生API，语法是js语法，API命名是原生命名。&lt;/h4&gt;

&lt;h4 id=&quot;比如var-obj--plusandroidimport-androidosbundle--然后objxxx这个xxx属性就完全是原生对象的属性命名&quot;&gt;比如var obj = plus.android.import( “android.os.Bundle” ); 然后obj.xxx，这个xxx属性就完全是原生对象的属性命名。&lt;/h4&gt;

&lt;h4 id=&quot;对于jser他一下就有40w-api可以用瞬间感觉无所不能&quot;&gt;对于JSer，他一下就有40w API可以用，瞬间感觉无所不能&lt;/h4&gt;

&lt;h4 id=&quot;nativejs的教程详见httpaskdcloudnetcnarticle88&quot;&gt;Native.js的教程详见：http://ask.dcloud.net.cn/article/88&lt;/h4&gt;

&lt;h3 id=&quot;c更多原生sdk插件引入--5-runtime插件&quot;&gt;C、更多原生SDK插件引入 – 5+ Runtime插件&lt;/h3&gt;

&lt;h4 id=&quot;假使有一些原生的三方sdk想引入到5-runtime比如身份证扫描sdk可以通过5-runtime的插件机制进行扩展或者5-runtime预置的地图是百度地图开发者想换成高德地图也是类似的做法&quot;&gt;假使有一些原生的三方SDK想引入到5+ Runtime，比如身份证扫描SDK，可以通过5+ Runtime的插件机制进行扩展。或者5+ Runtime预置的地图是百度地图，开发者想换成高德地图，也是类似的做法。&lt;/h4&gt;

&lt;h4 id=&quot;dcloud也支持5-sdk把5-runtime作为一个sdk放入到其他原生app中用5-sdk替代webview可以得到更强大的功能和性能&quot;&gt;DCloud也支持5+ SDK，把5+ runtime作为一个SDK放入到其他原生App中，用5+ SDK替代webview可以得到更强大的功能和性能。&lt;/h4&gt;

&lt;h4 id=&quot;ios插件开发教程详见httpaskdcloudnetcnarticle67&quot;&gt;iOS插件开发教程详见：http://ask.dcloud.net.cn/article/67&lt;/h4&gt;
&lt;h4 id=&quot;android插件开发教程详见httpaskdcloudnetcnarticle66&quot;&gt;Android插件开发教程详见：http://ask.dcloud.net.cn/article/66&lt;/h4&gt;
&lt;h4 id=&quot;通过html5plus规范nativejs技术以及原生插件这3种机制使得5-runtime拥有完全不输于原生app的能力&quot;&gt;通过HTML5plus规范、Native.js技术以及原生插件，这3种机制使得5+ Runtime拥有完全不输于原生App的能力。&lt;/h4&gt;

&lt;h2 id=&quot;性能---html5plus-runtime和mui框架&quot;&gt;性能 - HTML5plus runtime和mui框架&lt;/h2&gt;

&lt;h4 id=&quot;性工能里最后的重头戏是性能在低端android手机上过去的html5无法商用切页白屏转场卡顿下拉刷新不流畅侧滑菜单不流畅众多问题逼迫开发者只能使用原生技术来做应用&quot;&gt;性工能里最后的重头戏是性能。在低端Android手机上，过去的HTML5无法商用，切页白屏、转场卡顿、下拉刷新不流畅、侧滑菜单不流畅。。。众多问题逼迫开发者只能使用原生技术来做应用。&lt;/h4&gt;
&lt;p&gt;HTML5 App的性能低下，有webview自身的性能问题，也有前端框架的性能问题。&lt;/p&gt;

&lt;h3 id=&quot;awebview性能问题&quot;&gt;A、Webview性能问题：&lt;/h3&gt;

&lt;h4 id=&quot;webview性能低主要体现在动画效果不流畅之前举例的转场动画下拉回弹动画侧滑动画均是此类既然js和css的动画不行我们就调用原生api换成原生动画dcloud设计了很多原生动画来解决之前的各种动画不流畅问题&quot;&gt;Webview性能低主要体现在动画效果不流畅，之前举例的转场动画、下拉回弹动画、侧滑动画均是此类。既然js和css的动画不行，我们就调用原生API换成原生动画。DCloud设计了很多原生动画，来解决之前的各种动画不流畅问题。&lt;/h4&gt;

&lt;h4 id=&quot;5-runtime还支持预载技术以加快页面的加载速度减少白屏和用户等待事实上原生语言都可以自己开发预载但html5标准api不足以完成此任务dcloud提供单独的preload-api同时支持对内存占用的管理协助开发者在低端手机上优化性能&quot;&gt;5+ Runtime还支持预载技术，以加快页面的加载速度，减少白屏和用户等待。事实上原生语言都可以自己开发预载，但HTML5标准API不足以完成此任务，DCloud提供单独的preload API。同时支持对内存占用的管理，协助开发者在低端手机上优化性能。&lt;/h4&gt;

&lt;h3 id=&quot;b前端框架问题&quot;&gt;B、前端框架问题：&lt;/h3&gt;

&lt;h4 id=&quot;由于html5的默认控件无法直视我们只能用css把按钮输入框修饰成原生样式以及html5的控件比原生控件少很多比如listtabmenuwaiting等常见控件以往都要写很多div和css拼装这引发了一个前端框架存在的市场但目前的前端框架性能都非常低在低端手机上很难达到商用要求更不用提pk原生效果&quot;&gt;由于HTML5的默认控件无法直视，我们只能用css把按钮、输入框修饰成原生样式，以及HTML5的控件比原生控件少很多，比如list、tab、menu、waiting等常见控件，以往都要写很多div和css拼装。这引发了一个前端框架存在的市场。但目前的前端框架性能都非常低，在低端手机上很难达到商用要求，更不用提pk原生效果。&lt;/h4&gt;

&lt;h4 id=&quot;jquery-mobile比较知名但有3个硬伤&quot;&gt;Jquery mobile比较知名，但有3个硬伤：&lt;/h4&gt;

&lt;h4 id=&quot;1-体积高达500k&quot;&gt;1. 体积高达500k；&lt;/h4&gt;

&lt;h4 id=&quot;2-data-的写法虽然写起来简单但在运行时需要js去解析html5标签并替换为新的dom结构这是非常消耗手机资源和影响加载速度的&quot;&gt;2. data-的写法虽然写起来简单，但在运行时需要js去解析HTML5标签并替换为新的dom结构，这是非常消耗手机资源和影响加载速度的；&lt;/h4&gt;

&lt;h4 id=&quot;3-样式风格自成一派不是用户所熟悉的原生样式&quot;&gt;3. 样式风格自成一派，不是用户所熟悉的原生样式。&lt;/h4&gt;

&lt;h4 id=&quot;基于这种情况dcloud推出了开源的mui框架httpdcloudiogithubiomui它是目前最高性能和最接近原生体验的手机端框架它的3个特点与jquery-mobile正好对应&quot;&gt;基于这种情况，DCloud推出了开源的mui框架（http://dcloudio.github.io/mui/），它是目前最高性能和最接近原生体验的手机端框架。它的3个特点与Jquery mobile正好对应：&lt;/h4&gt;

&lt;h4 id=&quot;1-体积小不到100k&quot;&gt;1. 体积小，不到100k；&lt;/h4&gt;

&lt;h4 id=&quot;2-直接使用class编写性能远高于data-方式又通过代码块的编写方式降低了开发者编码的复杂度在hbuilder里敲m会拉出一排控件mlistmbutton等选一个回车就会自动产生div和class&quot;&gt;2. 直接使用class编写，性能远高于data-方式，又通过代码块的编写方式降低了开发者编码的复杂度，在HBuilder里敲m，会拉出一排控件mList、mButton等，选一个回车，就会自动产生div和class；&lt;/h4&gt;

&lt;h4 id=&quot;3-mui的风格样式是最接近原生样式的如下图&quot;&gt;3. mui的风格样式是最接近原生样式的，如下图。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20161009img02.png&quot; alt=&quot;20161009img02&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;hbuilder5-runtimemui为前端开发人员提供了一个很好的工具框架能做到接近原生app的功能和体验同时为未来移动端应用带来巨大的变化&quot;&gt;HBuilder、5+ Runtime、mui为前端开发人员提供了一个很好的工具、框架，能做到接近原生App的功能和体验，同时为未来移动端应用带来巨大的变化&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>APP界面设计（上）</title>
   <link href="http://www.blogways.net/blog/2016/10/08/UI-appDesign-01.html"/>
   <updated>2016-10-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/10/08/UI-appDesign-01</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;APP界面设计&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20161008img01.jpg&quot; alt=&quot;20161008img01&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CAS单点登录</title>
   <link href="http://www.blogways.net/blog/2016/10/06/web-cas.html"/>
   <updated>2016-10-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/10/06/web-cas</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;CAS原理&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;cas-server配置&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;cas-client配置&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;客户端自定义登录界面&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一cas-原理&quot;&gt;一、CAS 原理&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;
      &lt;p&gt;访问服务： SSO 客户端发送请求访问应用系统提供的服务资源。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;定向认证： SSO 客户端会重定向用户请求到 SSO 服务器。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;用户认证：用户身份认证。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;发放票据： SSO 服务器会产生一个随机的 Service Ticket 。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;下面是 CAS 最基本的协议过程：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img05.jpg&quot; alt=&quot;20161006img05&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如上图： CAS Client 与受保护的客户端应用部署在一起，以Filter方式保护Web应用的受保护资源，过滤从客户端过来的每一个 Web 请求，同 时， CAS Client 会分析 HTTP 请求中是否包含请求 Service Ticket( ST 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的；于是 CAS Client 会重定向用户请求到 CAS Server （ Step 2 ），并传递 Service （要访问的目的资源地址）。 Step 3 是用户认证过程，如果用户提供了正确的 Credentials ， CAS Server 随机产生一个相当长度、唯一、不可伪造的 Service Ticket ，并缓存以待将来验证，并且重定向用户到 Service 所在地址（附带刚才产生的 Service Ticket ） , 并为客户端浏览器设置一个 Ticket Granted Cookie （ TGC ） ； CAS Client 在拿到 Service 和新产生的 Ticket 过后，在 Step 5 和 Step6 中与 CAS Server 进行身份核实，以确保 Service Ticket 的合法性。&lt;/p&gt;

  &lt;p&gt;在该协议中，所有与 CAS Server 的交互均采用 SSL 协议，以确保 ST 和 TGC 的安全性。协议工作过程中会有 2次重定向 的过程。但是 CAS Client 与 CAS Server 之间进行 Ticket 验证的过程对于用户是透明的（使用 HttpsURLConnection ）。&lt;/p&gt;

  &lt;p&gt;CAS 请求认证时序图如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img06.jpg&quot; alt=&quot;20161006img06&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二cas-server配置&quot;&gt;二、cas-server配置&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文所用测试地址说明：&lt;/p&gt;

  &lt;p&gt;cas-server地址：http://localhost:8080/cas&lt;/p&gt;

  &lt;p&gt;cas-client地址：http://localhost:7080/test_consumer&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;1下载cas包&quot;&gt;1.下载cas包&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/apereo/cas/releases/tag/v3.5.2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2cas-server-352-releasezip解压将modules下面的cas-server-webapp-352war部署到tomcat服务器重命名为caswar并解压&quot;&gt;2.cas-server-3.5.2-release.zip解压，将modules下面的cas-server-webapp-3.5.2.war部署到tomcat服务器，重命名为cas.war并解压。&lt;/h4&gt;

&lt;h4 id=&quot;3导入modules中的cas-server-support-jdbc-352jar包导入数据库驱动mysql-connector-java-5129jar包&quot;&gt;3.导入modules中的cas-server-support-jdbc-3.5.2.jar包，导入数据库驱动mysql-connector-java-5.1.29.jar包&lt;/h4&gt;

&lt;h4 id=&quot;4由于不采用https方式需要修改配置文件&quot;&gt;4.由于不采用https方式，需要修改配置文件&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;WEB-INF/DEPLOYERCONFIGCONTEXT.XML&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;增加参数 p:requireSecure=&quot;false&quot; ，是否需要安全验证，即 HTTPS ， false 为不采用 如下：
&amp;lt;bean class =  &quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref = &quot;httpClient&quot; p:requireSecure= &quot;false&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;WEB-INF/spring-configuration/ticketGrantingTicketCookieGenerator.xml 修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id = &quot;ticketGrantingTicketCookieGenerator&quot; class = &quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;
   p:cookieSecure = &quot; false &quot;
   p:cookieMaxAge = &quot;-1&quot;
   p:cookieName = &quot;CASTGC&quot;
   p:cookiePath = &quot;/cas&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;WEB-INF\spring-configuration\warnCookieGenerator.xml 修改&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id = &quot;warnCookieGenerator&quot; class = &quot;org.jasig.cas.web.support.CookieRetrievingCookieGenerator&quot;
   p:cookieSecure = &quot; false &quot;
   p:cookieMaxAge = &quot;-1&quot;
   p:cookieName = &quot;CASPRIVACY&quot;
   p:cookiePath = &quot;/cas&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;5自定义验证将原来的测试用验证注释掉然后添加查询数据库方式验证对于数据库表tb_user&quot;&gt;5.自定义验证，将原来的测试用验证注释掉，然后添加查询数据库方式验证，对于数据库表tb_user&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!--&amp;lt;bean class=&quot;org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler&quot;/&amp;gt;--&amp;gt;
			
&amp;lt;bean class=&quot;org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler&quot;&amp;gt;
	&amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&amp;gt;&amp;lt;/property&amp;gt;
	&amp;lt;property name=&quot;sql&quot; value=&quot;select password from tb_user where username=?&quot;&amp;gt;&amp;lt;/property&amp;gt;
	&amp;lt;property name=&quot;passwordEncoder&quot; ref=&quot;myPasswordEncoder&quot;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;6自定义md5验证&quot;&gt;6.自定义MD5验证&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id=&quot;myPasswordEncoder&quot; class=&quot;org.jasig.cas.authentication.handler.MyPasswordEncoder&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;自定义MD5 java代码如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package org.jasig.cas.authentication.handler;

import java.security.MessageDigest;

public class MyPasswordEncoder implements PasswordEncoder  
{

	public static void main(String[] args) {
		MyPasswordEncoder t = new MyPasswordEncoder();
		System.out.println(t.encode(&quot;123456&quot;));
	}

	public String encode(String content) {
		return md5(md5(content) + &quot;asiainfo&quot;);
	}
	
	public String md5(String content){
		if(content == null){
			return null;
		}
		StringBuffer sbReturn = new StringBuffer();
		try {
			MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
			md.update((content).getBytes(&quot;utf-8&quot;));
			for (byte b : md.digest()) {
				sbReturn.append(Integer.toString((b &amp;amp; 0xff) + 0x100, 16).substring(1));
			}
			return sbReturn.toString();
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;测试cas-server环境&quot;&gt;测试cas-server环境&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img01.jpg&quot; alt=&quot;20161006img01&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img02.jpg&quot; alt=&quot;20161006img02&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;3nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三cas-client配置&quot;&gt;三、cas-client配置&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;web.xml配置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- cas client begin --&amp;gt;
&amp;lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置--&amp;gt;  
&amp;lt;listener&amp;gt;  
    &amp;lt;listener-class&amp;gt;org.jasig.cas.client.session.SingleSignOutHttpSessionListener&amp;lt;/listener-class&amp;gt;  
&amp;lt;/listener&amp;gt;  
  
&amp;lt;!-- CAS Server 通知 CAS Client，删除session,注销登录信息  --&amp;gt;  
&amp;lt;filter&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS Single Sign Out Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;filter-class&amp;gt;org.jasig.cas.client.session.SingleSignOutFilter&amp;lt;/filter-class&amp;gt;  
&amp;lt;/filter&amp;gt;  
&amp;lt;filter-mapping&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS Single Sign Out Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/filter-mapping&amp;gt;  
  
&amp;lt;!-- 该过滤器负责用户的认证工作，必须启用它 --&amp;gt;  
&amp;lt;filter&amp;gt;  
    &amp;lt;filter-name&amp;gt;CASFilter&amp;lt;/filter-name&amp;gt;  

    &amp;lt;!-- 将AuthenticationFilter代码复制一份自定义为ClientAuthenticationFilter.java文件 --&amp;gt;
    &amp;lt;filter-class&amp;gt;org.jasig.cas.client.authentication.ClientAuthenticationFilter&amp;lt;/filter-class&amp;gt;    

    &amp;lt;init-param&amp;gt;  
        &amp;lt;param-name&amp;gt;casServerLoginUrl&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;http://localhost:8080/cas/login&amp;lt;/param-value&amp;gt;  
    &amp;lt;/init-param&amp;gt;

	&amp;lt;!-- 添加各客户端对应的登录界面 --&amp;gt;
    &amp;lt;init-param&amp;gt;  
        &amp;lt;param-name&amp;gt;login_from&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;http://localhost:7080/test_consumer/login.jsp&amp;lt;/param-value&amp;gt;  
    &amp;lt;/init-param&amp;gt;

    &amp;lt;init-param&amp;gt;  
        &amp;lt;!--这里的server是服务端的IP--&amp;gt;  
        &amp;lt;param-name&amp;gt;serverName&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;http://localhost:7080/&amp;lt;/param-value&amp;gt;  
    &amp;lt;/init-param&amp;gt;  
&amp;lt;/filter&amp;gt;  
&amp;lt;filter-mapping&amp;gt;  
    &amp;lt;filter-name&amp;gt;CASFilter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/filter-mapping&amp;gt;  
  
  
&amp;lt;!-- 该过滤器负责对Ticket的校验工作，必须启用它 --&amp;gt;  
&amp;lt;filter&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS Validation Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;filter-class&amp;gt;  
        org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter  
    &amp;lt;/filter-class&amp;gt;  
    &amp;lt;init-param&amp;gt;  
        &amp;lt;param-name&amp;gt;casServerUrlPrefix&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;http://localhost:8080/cas&amp;lt;/param-value&amp;gt;  
    &amp;lt;/init-param&amp;gt;  
    &amp;lt;init-param&amp;gt;  
        &amp;lt;param-name&amp;gt;serverName&amp;lt;/param-name&amp;gt;  
        &amp;lt;param-value&amp;gt;http://localhost:7080/&amp;lt;/param-value&amp;gt;  
    &amp;lt;/init-param&amp;gt;  
&amp;lt;/filter&amp;gt;  
&amp;lt;filter-mapping&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS Validation Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/filter-mapping&amp;gt;  
  
&amp;lt;!--  
    该过滤器负责实现HttpServletRequest请求的包裹，  
    比如允许开发者通过HttpServletRequest的getRemoteUser()方法获得SSO登录用户的登录名，可选配置。  
--&amp;gt;  
&amp;lt;filter&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS HttpServletRequest Wrapper Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;filter-class&amp;gt;org.jasig.cas.client.util.HttpServletRequestWrapperFilter&amp;lt;/filter-class&amp;gt;  
&amp;lt;/filter&amp;gt;  
&amp;lt;filter-mapping&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS HttpServletRequest Wrapper Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/filter-mapping&amp;gt;  
  
&amp;lt;!--  
    该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。  
    比如AssertionHolder.getAssertion().getPrincipal().getName()。  
--&amp;gt;  
&amp;lt;filter&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS Assertion Thread Local Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;filter-class&amp;gt;org.jasig.cas.client.util.AssertionThreadLocalFilter&amp;lt;/filter-class&amp;gt;  
&amp;lt;/filter&amp;gt;  
&amp;lt;filter-mapping&amp;gt;  
    &amp;lt;filter-name&amp;gt;CAS Assertion Thread Local Filter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/filter-mapping&amp;gt;  
&amp;lt;!-- cas client end --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;自定义ClientAuthenticationFilter.java文件添加：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private String login_from;
......
//initInternal方法中添加：
setCasServerLoginUrl(getPropertyFromInitParams(filterConfig, &quot;login_from&quot;, null));
log.trace(&quot;Loaded login_from parameter: &quot; + this.login_from);

//doFilter方法中添加：
//如果是登录界面则跳过
String loginUrl = request.getRequestURL().toString();
if(this.casServerLoginUrl.equals(loginUrl)){
	filterChain.doFilter(request, response);
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四客户端自定义登录界面&quot;&gt;四、客户端自定义登录界面&lt;/h2&gt;

&lt;h4 id=&quot;1自定义loginjsp登录界面&quot;&gt;1.自定义login.jsp登录界面&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;&lt;/span&gt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;自定义登录界面&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;http-equiv=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;content-type&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/html; charset=UTF-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;  
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;    
        &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getQueryStringByName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;    
             &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;location&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;RegExp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;[\?\&amp;amp;]&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;=([^\&amp;amp;]+)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;i&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;    
             &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;    
             &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    
         &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;    
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    
         &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;  
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getQueryStringByName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'info'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;error&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    
        &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;用户名密码错误!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    

	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;method=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;GET&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:8080/cas/login&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;    
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;用户名 : &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;username&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;    
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;密码 : &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;password&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;submit&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;登录&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;    
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;auto&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;    
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hidden&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;service&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&amp;lt;%=request.getParameter(&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;service&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&quot; /&amp;gt;  
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;    
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;  
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2定义相同的路径包orgjasigcaswebflow&quot;&gt;2.定义相同的路径包org.jasig.cas.web.flow&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;将cas-server-core-3.5.2中的AuthenticationViaFormAction.java复制到该包下就行改写，修改:
修改submit方法中
try {
        WebUtils.putTicketGrantingTicketInRequestScope(context, this.centralAuthenticationService.createTicketGrantingTicket(credentials));
        putWarnCookieIfRequestParameterPresent(context);
        return &quot;success&quot;;
    } catch (final TicketException e) {
    	//添加验证失败后的跳转页面 begin
    	String login_from = context.getRequestParameters().get(&quot;login_from&quot;);  
        if (login_from != null &amp;amp;&amp;amp; login_from.length() &amp;gt; 0) {  
            context.getRequestScope().put(&quot;redirectUrl&quot;, login_from + &quot;?info=error&quot;);  
            return &quot;customizedRedirect&quot;;  
        } 
        //添加验证失败后的跳转页面 end
    	
        populateErrorsInstance(e, messageContext);
        if (isCauseAuthenticationException(e))
            return getAuthenticationExceptionEventId(e);
        return &quot;error&quot;;
    }
将生成的AuthenticationViaFormAction.class替换cas-server-core-3.5.2.jar中的class文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3修改客户端过滤规则将loginjsp排除在外&quot;&gt;3.修改客户端过滤规则，将login.jsp排除在外&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;filter-mapping&amp;gt;  
    &amp;lt;filter-name&amp;gt;CASFilter&amp;lt;/filter-name&amp;gt;  
    &amp;lt;url-pattern&amp;gt;/jsp/*&amp;lt;/url-pattern&amp;gt;  
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4修改cas的默认登录页面-web-infviewjspdefaultuicasloginviewjsp&quot;&gt;4.修改cas的默认登录页面 WEB-INF/view/jsp/default/ui/casLoginView.jsp&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img07.jpg&quot; alt=&quot;20161006img07&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;5cas-server-webapp工程中修改web-inflogin-webflowxml&quot;&gt;5.cas-server-webapp工程中，修改WEB-INF/login-webflow.xml&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;action-state id=&quot;realSubmit&quot;&amp;gt;  
    ...... 
    &amp;lt;transition on=&quot;error&quot; to=&quot;generateLoginTicket&quot;/&amp;gt;  
    &amp;lt;!--加入下面这句话该transition , 当验证失败之后转到自定义页面 --&amp;gt;    
    &amp;lt;transition on=&quot;customizedRedirect&quot; to=&quot;customizedRedirectView&quot;/&amp;gt;  
    ......   
&amp;lt;/action-state&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;6添加客户端跳转页面&quot;&gt;6.添加客户端跳转页面&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;end-state id=&quot;customizedRedirectView&quot; view=&quot;externalRedirect:${requestScope.redirectUrl}&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;测试自定义登录界面&quot;&gt;测试自定义登录界面&lt;/h4&gt;

&lt;blockquote&gt;
  &lt;p&gt;在客户端浏览器中输入http://localhost:7080/test_consumer/jsp/home.jsp 回车，cas server验证失败
后重定向到客户端传过来的login_form地址&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img03.jpg&quot; alt=&quot;20161006img03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20161006img04.jpg&quot; alt=&quot;20161006img04&quot; /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Nginx+Mongodb 文件存储方案</title>
   <link href="http://www.blogways.net/blog/2016/09/16/nginx-grids.html"/>
   <updated>2016-09-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/09/16/nginx-grids</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;Nginx-gridfs和Nginx配置&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;应用示例&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;注意事项&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。是一个基于分布式文件存储的数据库，&lt;strong&gt;Gridfs适合存储海量大文件，特别是视频，音频，大型图片超过16MB大小的文件&lt;/strong&gt;。&lt;/p&gt;

  &lt;p&gt;Nginx-gridfs是一个 Nginx 的扩展模块，用于支持直接访问 MongoDB 的 GridFS 文件系统上的文件并提供 HTTP 访问，可理解为就是MongoDB的客户端。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GridFS实现原理
GridFS在数据库中，默认使用fs.chunks和fs.files来存储文件。
其中fs.files集合存放文件的信息，fs.chunks存放文件数据。

一个fs.files集合中的一条记录内容如下，即一个file的信息如下：
{
	&quot;_id&quot; : ObjectId(&quot;4f4608844f9b855c6c35e298&quot;),   //唯一id，可以是用户自定义的类型
	&quot;filename&quot; : &quot;CPU.txt&quot;,  //文件名
	&quot;length&quot; : 778,  //文件长度
	&quot;chunkSize&quot; : 262144,//chunk的大小
	&quot;uploadDate&quot; : ISODate(&quot;2012-02-23T09:36:04.593Z&quot;), //上传时间
	&quot;md5&quot; : &quot;e2c789b036cfb3b848ae39a24e795ca6&quot;,  //文件的md5值
	&quot;contentType&quot; : &quot;text/plain&quot; //文件的MIME类型
	&quot;meta&quot; : null//文件的其它信息，默认是没有”meta”这个key，用户可以自己定义为任意BSON对象
}

对应的fs.chunks中的chunk如下：
{
	&quot;_id&quot; : ObjectId(&quot;4f4608844f9b855c6c35e299&quot;),//chunk的id
	&quot;files_id&quot; : ObjectId(&quot;4f4608844f9b855c6c35e298&quot;),  //文件的id，对应fs.files中的对象，相当于fs.files集合的外键
	&quot;n&quot; : 0, //文件的第几个chunk块，如果文件大于chunksize的话，会被分割成多个chunk块
	&quot;data&quot; : BinData(0,&quot;QGV...&quot;) //文件的二进制数据，这里省略了具体内容
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二nginx-gridfs和nginx配置&quot;&gt;二、Nginx-gridfs和Nginx配置&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;进入目录 /usr/local/server/ 下
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安装依赖库工具&quot;&gt;安装依赖库、工具&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# yum -y install pcre-devel openssl-devel zlib-devel
# yum -y install gcc gcc-c++
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;下载nginx-gridfs源码&quot;&gt;下载nginx-gridfs源码&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# git clone https://github.com/mdirolf/nginx-gridfs.git
# cd nginx-gridfs
# git checkout v0.8
# git submodule init
# git submodule update
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;下载nginx源码编译安装&quot;&gt;下载nginx源码，编译安装&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# wget http://nginx.org/download/nginx-1.4.7.tar.gz
# tar zxvf nginx-1.4.7.tar.gz
# cd nginx-1.4.7
# ./configure --prefix=/usr/local/server/nginx --with-pcre=/usr/local/server/pcre-8.38 --with-http_ssl_module --with-http_stub_status_module --with-http_flv_module --with-http_gzip_static_module --add-module=/usr/local/server/nginx-gridfs --with-poll_module --without-select_module --with-http_realip_module --with-cc-opt=-Wno-error;
# make -j8 &amp;amp;&amp;amp; make install -j8
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;修改usrlocalnginxconfnginxconf配置文件&quot;&gt;修改/usr/local/nginx/conf/nginx.conf配置文件&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location /static/ {
    gridfs GridFS  # GridFS指的是mongodb的数据库名称
    field=filename  # [field]：查询字段，保证mongdb里有这个字段名，支持_id, filename, 可省略, 默认是_id
    type=string; # [type]：解释field的数据类型，支持objectid, int, string, 可省略, 默认是int
    mongo 127.0.0.1:27017;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;3nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三应用示例&quot;&gt;三、应用示例&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;要保证系统启动过程中，MongoDB比nginx先启动，否则nginx-gridfs初始化的时候不能正确链接MongoDB数据库。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;启动-mongodb&quot;&gt;启动 mongodb&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/local/server/mongodb/bin/mongod --dbpath=/usr/local/server/mongodb/data/db --logpath=/usr/local/server/mongodb/data/logs/mongodb.log &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;启动nginx服务&quot;&gt;启动nginx服务&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/local/server/nginx/sbin/nginx &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;java代码从本地上传一个图片到mongodb服务器&quot;&gt;Java代码从本地上传一个图片到mongodb服务器&lt;/h4&gt;

&lt;h4 id=&quot;1引入依赖的jar包&quot;&gt;（1）引入依赖的jar包&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.springframework.data&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;spring-data-mongodb&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.2.0.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2java代码实现&quot;&gt;（2）java代码实现&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; /**  
 * 存储文件  
 */  
 public static void saveFile() throws Exception{  
	  //连接服务器  
	  MongoClient mongoClient = new MongoClient(&quot;192.168.137.129&quot;, 27017);
	  // 连接到数据库.如果库不存在则创建
	  DB db = mongoClient.getDB(&quot;GridFS&quot;);
	   
	  //文件操作是在DB的基础上实现的，与表和文档没有关系  
	  GridFS gridFS = new GridFS(db);
	   
	  String fileName=&quot;asiainfo.jpg&quot;;  
	  File readFile=new File(&quot;e:/&quot;+fileName);  
	  GridFSInputFile  mongofile=gridFS.createFile(readFile);  
	  //可以再添加属性  
	  mongofile.put(&quot;path&quot;,&quot;e:/&quot;+fileName);  
	  mongofile.setFilename(fileName);
	  //保存  
	  mongofile.save();           
 }  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;使用客户端工具查看一下上传的结果&quot;&gt;使用客户端工具查看一下上传的结果&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160916img01.jpg&quot; alt=&quot;20160916img01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;测试图片&quot;&gt;测试图片&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160916img02.jpg&quot; alt=&quot;20160916img02&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;测试文件&quot;&gt;测试文件&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160916img03.jpg&quot; alt=&quot;20160916img03&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160916img04.jpg&quot; alt=&quot;20160916img04&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四注意事项&quot;&gt;四、注意事项&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;1）mongodb工作集
伴随数据库内容的GridFS文件会显著地搅动MongoDB的内存工作集。如果你不想让GridFS的文件影响到你的内存工作集，那么可以把GridFS的文件存储到不同的MongoDB服务器上。&lt;/p&gt;

  &lt;p&gt;2）nginx-gridfs的不足
没有实现http的range support，也就是断点续传，分片下载的功能。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Spring Boot 入门（一） -- 5分钟构建Spring Web Rest风格的Hello World</title>
   <link href="http://www.blogways.net/blog/2016/09/12/spring-boot-share01.html"/>
   <updated>2016-09-12T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/09/12/spring-boot-share01</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;什么是Spring Boot&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;快速搭建Spring Web&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;融合Swagger&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一什么是spring-boot&quot;&gt;一、什么是Spring Boot&lt;/h2&gt;

&lt;h4 id=&quot;spring-boot-的目的在于快速创建可以独立运行的-spring-应用通过-spring-boot-可以根据相应的模板快速创建应用并运行spring-boot-可以自动配置-spring-的各种组件并不依赖代码生成和-xml-配置文件spring-boot-可以大大提升使用-spring-框架时的开发效率&quot;&gt;Spring Boot 的目的在于快速创建可以独立运行的 Spring 应用。通过 Spring Boot 可以根据相应的模板快速创建应用并运行。Spring Boot 可以自动配置 Spring 的各种组件，并不依赖代码生成和 XML 配置文件。Spring Boot 可以大大提升使用 Spring 框架时的开发效率。&lt;/h4&gt;

&lt;h3 id=&quot;而spring-boot-包含的特性如下&quot;&gt;而Spring Boot 包含的特性如下：&lt;/h3&gt;

&lt;h4 id=&quot;1创建可以独立运行的-spring-应用&quot;&gt;1.创建可以独立运行的 Spring 应用。&lt;/h4&gt;

&lt;h4 id=&quot;2直接嵌入-tomcat-或-jetty-服务器不需要部署-war-文件&quot;&gt;2.直接嵌入 Tomcat 或 Jetty 服务器，不需要部署 WAR 文件。&lt;/h4&gt;

&lt;h4 id=&quot;3提供推荐的基础-pom-文件来简化-apache-maven-配置&quot;&gt;3.提供推荐的基础 POM 文件来简化 Apache Maven 配置。&lt;/h4&gt;

&lt;h4 id=&quot;4尽可能的根据项目依赖来自动配置-spring-框架&quot;&gt;4.尽可能的根据项目依赖来自动配置 Spring 框架。&lt;/h4&gt;

&lt;h4 id=&quot;5提供可以直接在生产环境中使用的功能如性能指标应用信息和应用健康检查&quot;&gt;5.提供可以直接在生产环境中使用的功能，如性能指标、应用信息和应用健康检查。&lt;/h4&gt;

&lt;h4 id=&quot;6没有代码生成也没有-xml-配置文件&quot;&gt;6.没有代码生成，也没有 XML 配置文件。&lt;/h4&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二快速搭建spring-web&quot;&gt;二、快速搭建Spring Web&lt;/h2&gt;

&lt;h4 id=&quot;第一节描述了spring-boot的作用此节将通过一个实例快速搭建spring-web&quot;&gt;第一节描述了Spring Boot的作用，此节将通过一个实例快速搭建Spring Web&lt;/h4&gt;

&lt;h3 id=&quot;首先通过maven新建一个工程并在pomxml中添加如下代码&quot;&gt;首先通过Maven新建一个工程，并在pom.xml中添加如下代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;project&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;modelVersion&amp;gt;&lt;/span&gt;4.0.0&lt;span class=&quot;nt&quot;&gt;&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;com.asiainfo.springboot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;com.asiainfo.springboot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;1.0-SNAPSHOT&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;packaging&amp;gt;&lt;/span&gt;jar&lt;span class=&quot;nt&quot;&gt;&amp;lt;/packaging&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;spring.boot.version&amp;gt;&lt;/span&gt;1.1.4.RELEASE&lt;span class=&quot;nt&quot;&gt;&amp;lt;/spring.boot.version&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.springfox&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;springfox-swagger-ui&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.2.2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;io.springfox&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;springfox-swagger2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;version&amp;gt;&lt;/span&gt;2.2.2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/version&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;groupId&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;nt&quot;&gt;&amp;lt;/groupId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;spring-boot-maven-plugin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;executions&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;execution&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;nt&quot;&gt;&amp;lt;goals&amp;gt;&lt;/span&gt;
                        &lt;span class=&quot;nt&quot;&gt;&amp;lt;goal&amp;gt;&lt;/span&gt;repackage&lt;span class=&quot;nt&quot;&gt;&amp;lt;/goal&amp;gt;&lt;/span&gt;
                    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/goals&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;/execution&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/executions&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;artifactId&amp;gt;&lt;/span&gt;maven-compiler-plugin&lt;span class=&quot;nt&quot;&gt;&amp;lt;/artifactId&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;source&amp;gt;&lt;/span&gt;1.7&lt;span class=&quot;nt&quot;&gt;&amp;lt;/source&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;target&amp;gt;&lt;/span&gt;1.7&lt;span class=&quot;nt&quot;&gt;&amp;lt;/target&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;1其中spring-boot-starter-web为web应用所需要的依赖相比与其它的应用简化了太多并不是声明了spring-boot-starter-web就不需要其它的包而是spring-boot自动做了关联打开工程的关联library即可查看到&quot;&gt;1.其中spring-boot-starter-web为Web应用所需要的依赖，相比与其它的应用简化了太多；并不是声明了spring-boot-starter-web就不需要其它的包，而是Spring boot自动做了关联；打开工程的关联library即可查看到&lt;/h4&gt;

&lt;h4 id=&quot;2springfox-swagger-uispringfox-swagger2-为swagger依赖包在下面的章节中会具体讲解&quot;&gt;2.springfox-swagger-ui\springfox-swagger2 为Swagger依赖包，在下面的章节中会具体讲解&lt;/h4&gt;

&lt;h3 id=&quot;配置好pomxml后开始创建程序主入口代码如下&quot;&gt;配置好pom.xml后，开始创建程序主入口，代码如下&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RestController
@EnableAutoConfiguration
public class Application {
 @RequestMapping(&quot;/&quot;)
 String home() {
 return &quot;Hello World!&quot;;
 }
 public static void main(String[] args) throws Exception {
 SpringApplication.run(Application.class, args);
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;通过运行application即可运行一个独立的-web-应用默认使用的tomcat服务器访问httplocalhost8080可以看到页面上显示hello-world也就是说只需要简单的-2-个文件就可以启动一个独立运行的-web-应用并不需要额外安装-tomcat-这样的应用服务器也不需要打包成-war-文件&quot;&gt;通过运行Application，即可运行一个独立的 Web 应用（默认使用的Tomcat服务器），访问“http://localhost:8080”可以看到页面上显示“Hello World!”，也就是说，只需要简单的 2 个文件就可以启动一个独立运行的 Web 应用。并不需要额外安装 Tomcat 这样的应用服务器，也不需要打包成 WAR 文件。&lt;/h4&gt;

&lt;h4 id=&quot;enableautoconfiguration注解的作用在于让-spring-boot-根据应用所声明的依赖来对-spring-框架进行自动配置&quot;&gt;“@EnableAutoConfiguration”注解的作用在于让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置&lt;/h4&gt;

&lt;h4 id=&quot;注解restcontroller和requestmapping由-spring-mvc-提供用来创建-rest-服务这两个注解和-spring-boot-本身并没有关系&quot;&gt;注解“@RestController”和”@RequestMapping”由 Spring MVC 提供，用来创建 REST 服务。这两个注解和 Spring Boot 本身并没有关系。&lt;/h4&gt;

&lt;h3 id=&quot;spring-boot-除了spring-boot-starter-web标签以外还有很多标签详细如下表格&quot;&gt;Spring Boot 除了spring-boot-starter-web标签以外，还有很多标签，详细如下表格&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;名称  说明
spring-boot-starter 核心 POM，包含自动配置支持、日志库和对 YAML 配置文件的支持。
spring-boot-starter-amqp    通过 spring-rabbit 支持 AMQP。
spring-boot-starter-aop 包含 spring-aop 和 AspectJ 来支持面向切面编程（AOP）。
spring-boot-starter-batch   支持 Spring Batch，包含 HSQLDB。
spring-boot-starter-data-jpa    包含 spring-data-jpa、spring-orm 和 Hibernate 来支持 JPA。
spring-boot-starter-data-mongodb    包含 spring-data-mongodb 来支持 MongoDB。
spring-boot-starter-data-rest   通过 spring-data-rest-webmvc 支持以 REST 方式暴露 Spring Data 仓库。
spring-boot-starter-jdbc    支持使用 JDBC 访问数据库。
spring-boot-starter-security    包含 spring-security。
spring-boot-starter-test    包含常用的测试所需的依赖，如 JUnit、Hamcrest、Mockito 和 spring-test 等。
spring-boot-starter-velocity    支持使用 Velocity 作为模板引擎。
spring-boot-starter-web 支持 Web 应用开发，包含 Tomcat 和 spring-mvc。
spring-boot-starter-websocket   支持使用 Tomcat 开发 WebSocket 应用。
spring-boot-starter-ws  支持 Spring Web Services。
spring-boot-starter-actuator    添加适用于生产环境的功能，如性能指标和监测等功能。
spring-boot-starter-remote-shell    添加远程 SSH 支持。
spring-boot-starter-jetty   使用 Jetty 而不是默认的 Tomcat 作为应用服务器。
spring-boot-starter-log4j   添加 Log4j 的支持。
spring-boot-starter-logging 使用 Spring Boot 默认的日志框架 Logback。
spring-boot-starter-tomcat  使用 Spring Boot 默认的 Tomcat 作为应用服务器。

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;其中每项功能的作用及demo会在后续的博文中继续完善&quot;&gt;其中每项功能的作用及Demo会在后续的博文中继续完善&lt;/h4&gt;

&lt;p&gt;&lt;a id=&quot;3nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三融合swagger实现api可视化&quot;&gt;三、融合Swagger实现API可视化&lt;/h2&gt;

&lt;h4 id=&quot;上一节谈到-pomxml中引入了springfox-swagger-uispringfox-swagger2-这两个包这2个包即为swagger基础依赖包引入后即可正常使用swagger相关的功能并且可以使用可视化界面&quot;&gt;上一节谈到 pom.xml中引入了springfox-swagger-ui\springfox-swagger2 这两个包，这2个包即为Swagger基础依赖包，引入后即可正常使用Swagger相关的功能，并且可以使用可视化界面&lt;/h4&gt;

&lt;h4 id=&quot;这里将通过一个例子了解如何添加api至swagger中首先先看工程结构图&quot;&gt;这里将通过一个例子，了解如何添加API至Swagger中，首先先看工程结构图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160912img01.png&quot; alt=&quot;20160912img01&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;创建一个user对象uservo&quot;&gt;创建一个User对象，UserVo&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.asiainfo.user.domain;

import io.swagger.annotations.ApiModelProperty;

/**
 * Created by liuyw on 16/9/7.
 */
public class UserVo{

    @ApiModelProperty(value=&quot;账户&quot;,required = true)
    private String account;
    @ApiModelProperty(value=&quot;姓名&quot;,required = true)
    private String name;
    @ApiModelProperty(value=&quot;昵称&quot;,required = true)
    private String nickName;

    public UserVo(String account,String name,String nickName){
        this.account = account;
        this.name = name;
        this.nickName = nickName;
    }

    public String getAccount() {
        return account;
    }

    public void setAccount(String account) {
        this.account = account;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getNickName() {
        return nickName;
    }

    public void setNickName(String nickName) {
        this.nickName = nickName;
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;apimodelpropertyvalue昵称required--true此语句为swagger提供给property的解释在可视化界面中用于属性注视&quot;&gt;@ApiModelProperty(value=”昵称”,required = true),此语句为Swagger提供给property的解释，在可视化界面中用于属性注视&lt;/h4&gt;

&lt;h3 id=&quot;创建一个controller暴露api接口并返回user对象&quot;&gt;创建一个Controller，暴露API接口，并返回User对象&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.asiainfo.user;

import com.asiainfo.user.domain.UserVo;
import io.swagger.annotations.*;
import org.springframework.web.bind.annotation.*;
import springfox.documentation.swagger2.annotations.EnableSwagger2;

import java.util.ArrayList;
import java.util.List;

/**
 * Created by liuyw on 16/9/7.
 */
@RestController
@RequestMapping(&quot;/user&quot;)
@Api(&quot;userController相关api&quot;)
@EnableSwagger2
public class UserController {


    @ApiOperation(&quot;获取用户信息&quot;)
    @ApiImplicitParams({
            @ApiImplicitParam(paramType = &quot;header&quot;, name = &quot;username&quot;, dataType = &quot;String&quot;, required = true, value = &quot;用户的姓名&quot;, defaultValue = &quot;zhaojigang&quot;),
            @ApiImplicitParam(paramType = &quot;query&quot;, name = &quot;password&quot;, dataType = &quot;String&quot;, required = true, value = &quot;用户的密码&quot;, defaultValue = &quot;wangna&quot;)
    })
    @ApiResponses({
            @ApiResponse(code = 400, message = &quot;请求参数没填好&quot;),
            @ApiResponse(code = 404, message = &quot;请求路径没有或页面跳转路径不对&quot;)
    })
    @RequestMapping(value = &quot;/getUser&quot;, method = RequestMethod.GET)
    public List&amp;lt;UserVo&amp;gt; getUser(@RequestHeader(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password) {
//        return userService.getUser(username,password);
        UserVo user1 = new UserVo(&quot;test01&quot;, &quot;测试账户一&quot;, &quot;真仙&quot;);
        UserVo user2 = new UserVo(&quot;test02&quot;, &quot;测试账户二&quot;, &quot;仙王&quot;);
        UserVo user3 = new UserVo(&quot;test03&quot;, &quot;测试账户三&quot;, &quot;仙帝&quot;);
        List&amp;lt;UserVo&amp;gt; list = new ArrayList&amp;lt;UserVo&amp;gt;();
        list.add(user1);
        list.add(user2);
        list.add(user3);
        return list;
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;usercontroller提供了getuser方法并对外暴露使用&quot;&gt;UserController提供了getUser方法，并对外暴露使用&lt;/h4&gt;

&lt;h4 id=&quot;apiusercontroller相关apiapioperationapiimplicitparamsapiresponses均为swagger语法用以注视接口的作用参数的传值说明以及异常返回的说明等&quot;&gt;@Api(“userController相关api”)、ApiOperation、ApiImplicitParams、ApiResponses均为Swagger语法，用以注视接口的作用，参数的传值说明，以及异常返回的说明等&lt;/h4&gt;

&lt;h4 id=&quot;enableswagger2-标记了此controller可以使用swagger若不填写在可视化视图中将无法正常查询使用&quot;&gt;@EnableSwagger2 标记了此Controller可以使用Swagger，若不填写，在可视化视图中将无法正常查询使用&lt;/h4&gt;

&lt;h3 id=&quot;创建运行主函数&quot;&gt;创建运行主函数&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.asiainfo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.context.annotation.ComponentScan;

/**
 * Created by liuyw on 16/9/7.
 */
@EnableAutoConfiguration
@ComponentScan
public class Application {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(Application.class, args);

    }


}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;运行application然后访问httplocalhost8080swagger-uihtml即可查看到usercontroller如下图&quot;&gt;运行Application,然后访问http://localhost:8080/swagger-ui.html,即可查看到UserController，如下图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160912img02.png&quot; alt=&quot;20160912img02&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;本文主要从最基本的spring-boot进行了描述其中涉及到深层次的内容如服务器部署集群数据库连接spring-boot其它的标签介绍等这些内容会在后续的博文中依次介绍谢谢&quot;&gt;本文主要从最基本的Spring Boot进行了描述，其中涉及到深层次的内容，如服务器部署、集群、数据库连接；spring boot其它的标签介绍等；这些内容会在后续的博文中依次介绍，谢谢&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>D3.js基本简介[2]--在D3中使用SVG和Canvas</title>
   <link href="http://www.blogways.net/blog/2016/09/10/web-d3-2.html"/>
   <updated>2016-09-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/09/10/web-d3-2</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;什么是画布&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;D3中使用Canvas&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3rd&quot;&gt;D3中使用SVG&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;小结&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;上节中，介绍了D3.js的基本概念，其中突出了一点其可视化功能十分强大，可以很方便与汪回介绍的SVG结合使用，本节将会重点讲解一些结合的例子。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1什么是画布&quot;&gt;1.什么是画布？&lt;/h2&gt;

&lt;p&gt;要绘图，首要需要的是一块绘图的“画布”。&lt;/p&gt;

&lt;p&gt;HTML 5 提供两种强有力的“画布”：SVG 和 Canvas。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2d3中使用canvas&quot;&gt;2.D3中使用Canvas&lt;/h2&gt;

&lt;p&gt;Canvas 是通过 JavaScript 来绘制 2D 图形，是 HTML 5 中新增的元素。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Canvas 有如下特点：&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;

&lt;li&gt;绘制的是位图，图像放大后会失真。&lt;/li&gt;

&lt;li&gt;不支持事件处理器。&lt;/li&gt;

&lt;li&gt;能够以 .png 或 .jpg 格式保存图像&lt;/li&gt;

&lt;li&gt;适合游戏应用&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;&lt;a id=&quot;3rd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3d3中使用svg&quot;&gt;3.D3中使用SVG&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;SVG 是什么&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;SVG，指可缩放矢量图形（Scalable Vector Graphics），是用于描述二维矢量图形的一种图形格式，是由万维网联盟制定的开放标准。 SVG 使用 XML 格式来定义图形，除了 IE8 之前的版本外，绝大部分浏览器都支持 SVG，可将 SVG 文本直接嵌入 HTML 中显示。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;SVG 有如下特点:&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;

&lt;li&gt;SVG 绘制的是矢量图，因此对图像进行放大不会失真。&lt;/li&gt;

&lt;li&gt;基于 XML，可以为每个元素添加 JavaScript 事件处理器。&lt;/li&gt;

&lt;li&gt;每个图形均视为对象，更改对象的属性，图形也会改变。&lt;/li&gt;

&lt;li&gt;不适合游戏应用。&lt;/li&gt;

&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;添加画布&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;D3 提供了很多的 SVG 图形的生成器，由于它们只支持 SVG 。所以，这里我建议使用 SVG 画布，但是并不是其他的不能用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var width = 300;  //画布的宽度
var height = 400;   //画布的高度

var svg = d3.select(&quot;#svgbody&quot;)     //选择文档中的id='svgbody'的div元素
    .append(&quot;svg&quot;)          //添加一个svg元素
    .attr(&quot;width&quot;, width)       //设定宽度
    .attr(&quot;height&quot;, height);    //设定高度
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们的画布就做好啦。接下来我们将在画布上画些东西了，简单起见，这里就介绍绘制矩形的基本方法，其他图形可以借鉴汪回写的SVG技术博客的内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;svg&amp;gt;
&amp;lt;rect&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;rect&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的 rect 里没有矩形的属性。矩形的属性，常用的有四个：&lt;/p&gt;

&lt;ul&gt;

&lt;li&gt;x：矩形左上角的 x 坐标&lt;/li&gt;

&lt;li&gt;y：矩形左上角的 y 坐标&lt;/li&gt;

&lt;li&gt;width：矩形的宽度&lt;/li&gt;

&lt;li&gt;height：矩形的高度&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;要注意，在 SVG 中，x 轴的正方向是水平向右，y 轴的正方向是垂直向下的。&lt;/p&gt;

&lt;p&gt;现在我们实现D3简介中的可视化数据。数据如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dataset = [ 250 , 210 , 170 , 130 , 90 ];  //数据（表示矩形的宽度）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为简单起见，我们直接用数值的大小来表示矩形的像素宽度&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var rectHeight = 25;   //每个矩形所占的像素高度(包括空白)

svg.selectAll(&quot;rect&quot;)
    .data(dataset)
    .enter()
    .append(&quot;rect&quot;)
    .attr(&quot;x&quot;,20)
    .attr(&quot;y&quot;,function(d,i){
         return i * rectHeight;
    })
    .attr(&quot;width&quot;,function(d){
         return d;
    })
    .attr(&quot;height&quot;,rectHeight-2)
    .attr(&quot;fill&quot;,&quot;blue&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段代码添加了与 dataset 数组的长度相同数量的矩形，所使用的语句是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;svg.selectAll(&quot;rect&quot;)   //选择svg内所有的矩形
    .data(dataset)  //绑定数组
    .enter()        //指定选择集的enter部分
    .append(&quot;rect&quot;) //添加足够数量的矩形元素  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;有数据，而没有足够图形元素的时候，使用此方法可以添加足够的元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;添加了元素之后，就需要分别给各元素的属性赋值。在这里用到了 function(d, i)，d 代表与当前元素绑定的数据，i 代表索引号。给属性赋值的时候，是需要用到被绑定的数据，以及索引号的。&lt;/p&gt;

&lt;p&gt;最后一行的&lt;code class=&quot;highlighter-rouge&quot;&gt;attr(&quot;fill&quot;,&quot;blue&quot;)&lt;/code&gt;用来给矩形添加颜色属性，一般来说我们可以写成css属性，方便查找和修改。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;4小结&quot;&gt;4.小结&lt;/h2&gt;

&lt;p&gt;本文主要介绍了在D3中如何使用SVG，并做了简单的举例。这里可以和汪回的SVG基本介绍结合使用，画出一些复杂的图形。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Swagger介绍及应用实例</title>
   <link href="http://www.blogways.net/blog/2016/09/08/web-swagger.html"/>
   <updated>2016-09-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/09/08/web-swagger</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;Swagger介绍&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;Swagger UI与SpringMVC的整合&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;应用实例&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;注意事项&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一swagger介绍&quot;&gt;一、Swagger介绍&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Swagger API框架用于管理项目中API接口，属当前最流行的API接口管理工具。Swagger是一个开源框架(Web框架)，是一个规范和完整的框架，用于生成、描述、调用和可视化RESTful风格的Web服务，方便的管理项目中API接口，功能强大，UI界面漂亮，并且支持在线测试等。&lt;/p&gt;

  &lt;p&gt;后端通过提供一套标准的RESTful API，让网站、移动端和第三方系统都可以基于API进行数据交互和对接，极大的提高系统的开发效率，也使得前后端分离架构成为可能。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二swagger-ui与springmvc的整合&quot;&gt;二、Swagger UI与SpringMVC的整合&lt;/h2&gt;

&lt;h3 id=&quot;1从githubhttpsgithubcomwordnikswagger-ui上下载swagger-ui&quot;&gt;1.从github(&lt;a href=&quot;https://github.com/wordnik/swagger-ui&quot;&gt;https://github.com/wordnik/swagger-ui&lt;/a&gt;)上下载Swagger-UI&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img01.jpg&quot; alt=&quot;20160908img01&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;修改dist目录下index.html文件，将url修改为应用服务url&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img07.jpg&quot; alt=&quot;20160908img07&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;把该项目dist目录的内容拷贝到项目的webapp的目录下，修改dist目录的名称(也可以不修改)，如改为“swagger”。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img02.jpg&quot; alt=&quot;20160908img02&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2与springmvc整合搭建&quot;&gt;2.与SpringMVC整合搭建&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Maven引入swagger所需的包，SpringMVC的配置这里不做说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.codehaus.jackson&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-mapper-asl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.13&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.codehaus.jackson&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-core-asl&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.13&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;com.mangofactory&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;swagger-springmvc&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.0.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;SpringMVC通过注解说明API接口的功能描述、参数含义以及校验等&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package home.action;

import home.model.CrmCar;
import home.service.CrmCarService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.ModelAndView;

import base.action.BaseAction;
import base.exception.BusinessException;

import com.wordnik.swagger.annotations.ApiOperation;
import com.wordnik.swagger.annotations.ApiParam;

@Controller
@RequestMapping(&quot;/crmCar/*&quot;)  // 父request请求url
public class CrmCarAction extends BaseAction {

	@Autowired
    private CrmCarService crmCarService; 

	@ApiOperation(value = &quot;车辆信息&quot;, notes = &quot;根据ID获取车辆对象信息,返回页面对象&quot;)  
	@RequestMapping(value = &quot;view/{carId}&quot;, method = RequestMethod.GET)
    public ModelAndView getCrmCarView(@ApiParam(value = &quot;填写车辆ID&quot;,allowableValues = &quot;range[1,5]&quot;,required = true) @PathVariable(&quot;carId&quot;) int carId){   
		ModelAndView mav = new ModelAndView(&quot;index&quot;); 
		CrmCar crmCar = crmCarService.getCrmCar(carId);
        mav.addObject(&quot;crmCar&quot;, crmCar); 
        return mav; 
    }
	
	@ApiOperation(value = &quot;车辆信息 GET&quot;, notes = &quot;根据ID获取车辆对象信息,返回JSON格式&quot;)  
	@ResponseBody
	@RequestMapping(value = &quot;get/{carId}&quot;, method = RequestMethod.GET)
    public CrmCar getCrmCarGet(@ApiParam(value = &quot;填写车辆ID&quot;,allowableValues = &quot;range[1,5]&quot;,required = true) @PathVariable(&quot;carId&quot;) int carId){   
		CrmCar crmCar = crmCarService.getCrmCar(carId);
        return crmCar;
    }
	
	@ApiOperation(value = &quot;车辆信息 POST&quot;, notes = &quot;根据ID获取车辆对象信息,返回JSON格式&quot;)  
	@ResponseBody
	@RequestMapping(value = &quot;post/{carId}&quot;, method = RequestMethod.POST)
    public CrmCar getCrmCarPost(@ApiParam(value = &quot;填写车辆ID&quot;,allowableValues = &quot;range[1,5]&quot;,required = true) @PathVariable(&quot;carId&quot;) int carId){   
		CrmCar crmCar = crmCarService.getCrmCar(carId);
        return crmCar;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;api相关注解参数说明如下&quot;&gt;API相关注解参数说明如下：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@ApiOperation(value = &quot;接口名称&quot;, notes = &quot;接口功能详细说明&quot;)  
@RequestMapping(value = &quot;接口请求URL&quot;, method = &quot;接口请求方式get/post&quot;)
@ApiParam(value = &quot;参数名称&quot;,allowableValues = &quot;参数约束&quot;,required = &quot;是否必须参数&quot;)
@PathVariable(&quot;绑定参数&quot;)
@ResponseBody注解一般在异步获取数据时使用，在springMVC框架时，使用@RequestMapping后，返回值通常解析为跳转路径，加上@ResponseBody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@ResponseBody后，会直接返回json数据。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;springswagger的配置有两种方式本文以第二种方式实现案例&quot;&gt;SpringSwagger的配置有两种方式，本文以第二种方式实现案例&lt;/h4&gt;

&lt;h4 id=&quot;1自定义配置类&quot;&gt;（1）自定义配置类&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package common;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.mangofactory.swagger.configuration.SpringSwaggerConfig;
import com.mangofactory.swagger.models.dto.ApiInfo;
import com.mangofactory.swagger.plugin.EnableSwagger;
import com.mangofactory.swagger.plugin.SwaggerSpringMvcPlugin;

@Configuration
@EnableSwagger
public class MySwaggerConfig
{
    private SpringSwaggerConfig springSwaggerConfig;

    /**
     * Required to autowire SpringSwaggerConfig
     */
    @Autowired
    public void setSpringSwaggerConfig(SpringSwaggerConfig springSwaggerConfig)
    {
        this.springSwaggerConfig = springSwaggerConfig;
    }

    /**
     * Every SwaggerSpringMvcPlugin bean is picked up by the swagger-mvc
     * framework - allowing for multiple swagger groups i.e. same code base
     * multiple swagger resource listings.
     */
    @Bean
    public SwaggerSpringMvcPlugin customImplementation()
    {
        return new SwaggerSpringMvcPlugin(this.springSwaggerConfig).apiInfo(apiInfo()).includePatterns(
                &quot;.*?&quot;);
    }

    private ApiInfo apiInfo()
    {
        ApiInfo apiInfo = new ApiInfo(
                &quot;My Apps API Title&quot;, 
                &quot;My Apps API Description&quot;,
                &quot;My Apps API terms of service&quot;, 
                &quot;My Apps API Contact Email&quot;, 
                &quot;My Apps API Licence Type&quot;,
                &quot;My Apps API License URL&quot;);
        return apiInfo;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;在-spring-配置文件中添加&quot;&gt;在 spring 配置文件中添加&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean class=&quot;common.MySwaggerConfig&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2自己不写配置类直接使用默认的实现类在spring的配置文件中配置&quot;&gt;（2）自己不写配置类，直接使用默认的实现类，在Spring的配置文件中配置&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;mvc:annotation-driven/&amp;gt;
&amp;lt;!-- Required so swagger-springmvc can access spring‘s RequestMappingHandlerMapping  --&amp;gt; 
&amp;lt;bean class=&quot;com.mangofactory.swagger.configuration.SpringSwaggerConfig&quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;3nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3启动服务如果swagger-ui是单独的工程需要保证swagger-ui和web-应用服务在同一个容器中否则不能显示具体原因在后面说明&quot;&gt;3.启动服务，如果swagger ui是单独的工程，需要保证swagger ui和web 应用服务在同一个容器中，否则不能显示，具体原因在后面说明。&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img06.jpg&quot; alt=&quot;20160908img06&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4查看web应用服务的api并进行测试&quot;&gt;4.查看web应用服务的API并进行测试&lt;/h3&gt;

&lt;h4 id=&quot;1接口列表&quot;&gt;（1）接口列表&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img08.jpg&quot; alt=&quot;20160908img08&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2接口说明及测试&quot;&gt;（2）接口说明及测试&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img09.jpg&quot; alt=&quot;20160908img09&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3测试结果&quot;&gt;（3）测试结果&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img10.jpg&quot; alt=&quot;20160908img10&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/zhaojiajun/20160908img11.jpg&quot; alt=&quot;20160908img11&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4注意事项&quot;&gt;4.注意事项&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;（1）swagger ui读取应用服务的接口描述是通过JSON方式传输，所以存在跨域问题，这就是上面提到需要放到同一个容器的原因。当然，不是说不能跨域就不能分离swagger ui，可以通过nginx代理URL，将swagger和应用服务保持在同一个域名下即可。&lt;/p&gt;

  &lt;p&gt;（2）swagger ui是纯静态的，可以不必放到服务容器中使用，可以使用nginx配置站点访问，后续再做讲解说明。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;本文主要就swagger ui和springmvc整合做了说明，除此swagger ui之外还有其他应用，
Swagger是一组开源项目，其中主要要项目如下：&lt;/p&gt;

  &lt;p&gt;Swagger-tools:提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。&lt;/p&gt;

  &lt;p&gt;Swagger-core: 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。&lt;/p&gt;

  &lt;p&gt;Swagger-js: 用于JavaScript的Swagger实现。&lt;/p&gt;

  &lt;p&gt;Swagger-node-express: Swagger模块，用于node.js的Express web应用框架。&lt;/p&gt;

  &lt;p&gt;Swagger-ui：一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。&lt;/p&gt;

  &lt;p&gt;可请各位一起研究探讨，谢谢！&lt;/p&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>D3.js基本简介[1]--概念与基本使用方法</title>
   <link href="http://www.blogways.net/blog/2016/09/03/web-d3-1.html"/>
   <updated>2016-09-03T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/09/03/web-d3-1</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;什么是D3.js&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;D3.js安装&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3rd&quot;&gt;第一个小程序&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;小结&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;近年来，可视化越来越流行，许多报刊杂志、门户网站、新闻、媒体都大量使用可视化技术，使得复杂的数据和文字变得十分容易理解，有一句谚语“一张图片价值于一千个字”，的确是名副其实。各种数据可视化工具也如井喷式地发展，D3 正是其中的佼佼者。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;1什么是d3js&quot;&gt;1.什么是D3.js&lt;/h2&gt;

&lt;p&gt;D3.js是一个JavaScript库，它可以通过数据来操作文档。D3可以通过使用HTML、SVG和CSS把数据鲜活形象地展现出来。D3严格遵循Web标准，因而可以让你的程序轻松兼容现代主流浏览器并避免对特定框架的依赖。同时，它提供了强大的可视化组件，可以让使用者以数据驱动的方式去操作DOM。&lt;/p&gt;

&lt;h4 id=&quot;为什么要数据可视化&quot;&gt;为什么要数据可视化&lt;/h4&gt;

&lt;p&gt;现在有一组数据， 【 4 ， 32 ， 15 ， 16 ， 42 ， 25 】 ，你能一眼看出它们的大小关系吗？当然这里的数据不算多，有那眼疾手快的家伙站出来说我能一眼看出来！但更直观的是用图形显示，如下图：
&lt;img src=&quot;/images/d3-1-1.png&quot; alt=&quot;d3-1-1.png&quot; title=&quot;d3-1-1&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;怎么学习d3&quot;&gt;怎么学习D3&lt;/h4&gt;

&lt;p&gt;以下是几个学习 D3 的站点：&lt;/p&gt;

&lt;p&gt;官方网站
http://d3js.org/&lt;/p&gt;

&lt;p&gt;包含有很多示例和 API，要想得心应手的使用 D3，熟悉 API 是避不开的。&lt;/p&gt;

&lt;p&gt;Mike Bostock 的博客和作品展示板
http://bost.ocks.org/mike/&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;2d3js的安装&quot;&gt;2.D3.js的安装&lt;/h2&gt;

&lt;p&gt;使用D3.js有两种方式，一种是官方下载D3.js文件，另外一种是直接使用网络连接&lt;/p&gt;

&lt;h4 id=&quot;1下载d3js文件&quot;&gt;（1）下载D3.js文件&lt;/h4&gt;

&lt;p&gt;https://github.com/mbostock/d3/releases/download/v3.4.8/d3.zip&lt;/p&gt;

&lt;h4 id=&quot;2直接包含网络的链接&quot;&gt;（2）直接包含网络的链接&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;http://d3js.org/d3.v3.min.js&quot; charset=&quot;utf-8&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a id=&quot;3rd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;3第一个小程序&quot;&gt;3.第一个小程序&lt;/h2&gt;

&lt;p&gt;学习一切语言的开头：Hello World！&lt;/p&gt;

&lt;h4 id=&quot;1使用html输出hello-world&quot;&gt;（1）使用HTML输出Hello World!&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;HelloWorld&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World 1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World 2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2使用js更改hello-world&quot;&gt;（2）使用JS更改Hello World&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;HelloWorld&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World 1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World 2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;paragraphs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getElementsByTagName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;p&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;paragraphs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;paragraph&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;paragraphs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;paragraph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;innerHTML&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;I want to say Hello world&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;          
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt; 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;会输出两行 Iwant to say Hello world!&lt;/p&gt;

&lt;h4 id=&quot;3使用d3js更改hello-world&quot;&gt;（3）使用D3.js更改Hello World&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;HelloWorld&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt; 
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt; 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt; 
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World 1&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World 2&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;d3.v3.js](&amp;lt;/script&amp;gt; 
        &amp;lt;script&amp;gt;  
        d3.select(&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;selectAll&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(&quot;&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;want&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;say&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;Hello&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;world&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&quot;);&lt;/span&gt;      
        &lt;span class=&quot;err&quot;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; 
    &amp;lt;/body&amp;gt; 
&amp;lt;/html&amp;gt; 从上述代码可以看出使用D3.js可以很方便的简化代码，这点有点类似于jQuery，语法结构是链式语法。
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;4使用d3js更改字体和颜色&quot;&gt;（4）使用D3.js更改字体和颜色&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;p.style(&quot;color&quot;,&quot;red&quot;)
 .style(&quot;font-size&quot;,&quot;72px&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;d3.select() 或 d3.selectAll() 选择元素后返回的对象，就是选择集。&lt;/p&gt;

&lt;h2 id=&quot;4小结&quot;&gt;4.小结&lt;/h2&gt;

&lt;p&gt;本文主要介绍了d3.js概念，安装方法和简单的小例子，它可以很方便简化JS语法，当然D3的功能不仅仅是这样，接下我会对D3选择器和在SVG画布中制作可视化图标进行讲解。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>8招教你玩转［视觉引导］</title>
   <link href="http://www.blogways.net/blog/2016/08/31/ued-design-share.html"/>
   <updated>2016-08-31T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/08/31/ued-design-share</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;第一招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;第二招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;第三招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#4nd&quot;&gt;第四招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#5nd&quot;&gt;第五招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#6nd&quot;&gt;第六招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#7nd&quot;&gt;第七招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#End&quot;&gt;第八招&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一先要有个视觉点靠这些点指引或者聚集视线&quot;&gt;一、先要有个视觉点，靠这些点指引或者聚集视线&lt;/h2&gt;
&lt;p&gt;点的形状并非都是圆，或者是某种具象的元素。&lt;/p&gt;

&lt;h4 id=&quot;比如在整张页面中出现的大小对比关系那么小的元素可以称之为点大的元素也可称之为点&quot;&gt;比如：在整张页面中出现的大小对比关系，那么小的元素可以称之为点。大的元素也可称之为点。&lt;/h4&gt;

&lt;h4 id=&quot;它是一种相对而言的说法其实在页面中出现一点时就-可以很快吸引住用户的眼球当再出现一点时此刻用户观察画面时的注意力就分散了&quot;&gt;它是一种相对而言的说法。其实，在页面中出现一点时，就 可以很快吸引住用户的眼球。当再出现一点时，此刻用户观察画面时的注意力就分散了。&lt;/h4&gt;

&lt;h4 id=&quot;当遇到大小不同的点同时出现时用户首先会关注较大的那个点再接着是-较小的点&quot;&gt;当遇到大小不同的点同时出现时，用户首先会关注较大的那个点，再接着是 较小的点。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02efef57c41f830000018c1ba882f2.jpg&quot; alt=&quot;02efef57c41f830000018c1ba882f2&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左上1视线会首先集中在右侧鲜红的草莓上1是因为颜色的对比2是因为面积的对比点在这里是相对的关系你可以把整体出现的元素都可以看做点但是首先会有一个焦点去吸引用户的视线&quot;&gt;左上1：视线会首先集中在右侧鲜红的草莓上，1是因为颜色的对比，2是因为面积的对比。点在这里是相对的关系，你可以把整体出现的元素都可以看做点。但是首先会有一个焦点去吸引用户的视线；&lt;/h4&gt;

&lt;h4 id=&quot;左上2点的焦中设计居中的位置使用户直接关注到正中的内容&quot;&gt;左上2：点的焦中设计，居中的位置使用户直接关注到正中的内容；&lt;/h4&gt;

&lt;h4 id=&quot;左下3这里的点甚至说是页面中的亮点就是右侧冲出画面的骑行者这种表现打破画面的平稳使用户最先关注到破格出画面的人物同时也体现出户外骑行的自然和冒险&quot;&gt;左下3：这里的点，甚至说是页面中的亮点。就是右侧冲出画面的骑行者，这种表现打破画面的平稳，使用户最先关注到破格出画面的人物，同时也体现出户外骑行的自然和冒险；&lt;/h4&gt;

&lt;h4 id=&quot;左下4点的集中设计中间的圆为点二边的餐具为线属于典型的居中构图&quot;&gt;左下4：点的集中设计，中间的圆为点，二边的餐具为线，属于典型的居中构图；&lt;/h4&gt;

&lt;h4 id=&quot;在实际应用中又可分为&quot;&gt;在实际应用中又可分为&lt;/h4&gt;

&lt;h4 id=&quot;焦点&quot;&gt;焦点&lt;/h4&gt;
&lt;h4 id=&quot;第一时间吸引人眼球的那个元素画面中的点有着明显的大小颜色形状的对比&quot;&gt;第一时间吸引人眼球的那个元素。画面中的点有着明显的大小、颜色、形状的对比。&lt;/h4&gt;

&lt;h4 id=&quot;亮点&quot;&gt;亮点&lt;/h4&gt;
&lt;h4 id=&quot;是指画面中点的形状或者细节区别于其他元素成为画面中的主视觉&quot;&gt;是指画面中点的形状或者细节区别于其他元素，成为画面中的主视觉。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0285ee57c41fd20000012e7ef20522.jpg&quot; alt=&quot;0285ee57c41fd20000012e7ef20522&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;当你在设计时&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1画面元素的对比不明显整体视觉很平均时&quot;&gt;1、画面元素的对比不明显，整体视觉很平均时：&lt;/h4&gt;
&lt;p&gt;你可以根据设计需要和活动目的，对设计元素调整大小、或者颜色等形式，使要突出的点对比更为突出。&lt;/p&gt;
&lt;h4 id=&quot;2当版式中的文字太多时用户不知道先看什么&quot;&gt;2、当版式中的文字太多时，用户不知道先看什么？&lt;/h4&gt;
&lt;p&gt;这时你可以尝试把主要文案的字形、颜色等进行处理，使用户视线有个聚焦点。亦或者你可以尝试对文字的层次进行调整，使该突出的突出，该弱化的弱化。&lt;/p&gt;

&lt;h2 id=&quot;二人物动作设计多手眼身脚都要使&quot;&gt;二、人物动作设计多，手眼身脚都要使！&lt;/h2&gt;
&lt;p&gt;动作，举止的指向性。&lt;/p&gt;

&lt;h4 id=&quot;这种指向可以通过模特摆出的各种姿势去体现也可以通过调整模特元素的方向位置和排版共同完成对指定内容的指向在做一些以模特类为主要元素的设计时可以好好利用下模特的一举一动&quot;&gt;这种指向可以通过模特摆出的各种姿势去体现，也可以通过调整模特元素的方向、位置、和排版共同完成对指定内容的指向。在做一些以模特类为主要元素的设计时，可以好好利用下模特的一举一动。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0262f857c420290000018c1be9f9de.jpg&quot; alt=&quot;0262f857c420290000018c1be9f9de&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;实际应用中&quot;&gt;实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;如在表现一些运动活动专题时动感活力是这类需求的主要切入点&quot;&gt;如在表现一些运动活动专题时：动感、活力是这类需求的主要切入点。&lt;/h4&gt;

&lt;h4 id=&quot;在人物动作的挑选上就尽量找一些动作幅度较大夸张的模特来完成对于动起来的基本诉求&quot;&gt;在人物动作的挑选上，就尽量找一些动作幅度较大、夸张的模特，来完成对于“动”起来的基本诉求。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02cc5057c420560000012e7efba633.jpg&quot; alt=&quot;02cc5057c420560000012e7efba633&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1模特人物展开双臂运动的动作中其中拿球的左手位置正好置于文字上加之文字颜色为白色使得用户第一时间去关注那部分内容其中右手所示的位置有一个扶地的动作而这个动作也正好巧妙的结合于推荐的商品上使用户的视觉顺着向下进行浏览关注&quot;&gt;左图1：模特人物展开双臂运动的动作中，其中拿球的左手位置正好置于文字上，加之文字颜色为白色，使得用户第一时间去关注那部分内容。其中右手所示的位置，有一个扶地的动作，而这个动作也正好巧妙的结合于推荐的商品上，使用户的视觉顺着向下进行浏览关注。&lt;/h4&gt;

&lt;h4 id=&quot;右图2第一屏图像中模特的动作有秀一下的暗示向用户展示出他的8块腹肌嘻嘻二是人物所展示的拳头指向也使用户的视觉焦点向画面左侧的文字靠拢第二屏模特眼神所示的方向正好指向了右侧内容&quot;&gt;右图2：第一屏，图像中模特的动作有“秀一下”的暗示，向用户展示出他的8块腹肌（嘻嘻）。二是人物所展示的拳头指向，也使用户的视觉焦点向画面左侧的文字靠拢。第二屏，模特眼神所示的方向正好指向了右侧内容。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-1&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1-选择大片模特时首先要考虑到使用模特做为主视觉元素时模特的动作是否要去结合文案需要构图需要等需求然后再去挑选或者去拍摄适合活动目的并带有指向的动作素材&quot;&gt;1､ 选择大片模特时，首先要考虑到使用模特做为主视觉元素时，模特的动作是否要去结合文案需要、构图需要等需求。然后再去挑选或者去拍摄适合活动目的并带有指向的动作素材；&lt;/h4&gt;

&lt;h4 id=&quot;2-在使用模特素材时充分利用好模特的动作表情和眼神的视觉指向按着浏览轨迹安排合适的贩内容到正确的位置上&quot;&gt;2､ 在使用模特素材时，充分利用好模特的动作、表情和眼神的视觉指向，按着浏览轨迹安排合适的贩内容到正确的位置上。&lt;/h4&gt;

&lt;h4 id=&quot;眼神&quot;&gt;眼神&lt;/h4&gt;
&lt;p&gt;眼神的作用，暗示出模特所指的具体内容中，它有着明确的方向指向。&lt;/p&gt;

&lt;h4 id=&quot;当你看我当我看你当你看它时随着人们注意视线的移动人们关注的焦点也会做出相应的调整&quot;&gt;当你看我、当我看你，当你看它时，随着人们注意视线的移动，人们关注的焦点也会做出相应的调整。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0273a557c420b80000012e7e7ef3a5.jpg&quot; alt=&quot;0273a557c420b80000012e7e7ef3a5&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在实际应用中&quot;&gt;在实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;当你用不同的眼神观察事物时其实你的眼神中就带有了指向目的的作用&quot;&gt;当你用不同的眼神观察事物时，其实你的眼神中，就带有了指向目的的作用。&lt;/h4&gt;

&lt;h4 id=&quot;人们会随着你的眼神所指朝你眼神所示的方向关注过去它会暗示用户的眼睛跟随模特或者元素的指引方向关注到指定的信息这是一种利用模特眼神引起用户关注的一个方法&quot;&gt;人们会随着你的眼神所指，朝你眼神所示的方向关注过去。它会暗示用户的眼睛，跟随模特或者元素的指引方向，关注到指定的信息。这是一种利用模特眼神，引起用户关注的一个方法。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02ae4357c420e50000018c1bbfb56b.jpg&quot; alt=&quot;02ae4357c420e50000018c1bbfb56b&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1人物向上的眼神引导用户先将视线聚焦在人物上身然后再跟随人物眼神向上移动关注人物顶端的四块信息&quot;&gt;左图1：人物向上的眼神引导用户先将视线聚焦在人物上身，然后再跟随人物眼神向上移动，关注人物顶端的四块信息。&lt;/h4&gt;

&lt;h4 id=&quot;左图2人物正面向上向右的眼神都把用户的眼神引导到相应的信息上&quot;&gt;左图2：人物正面、向上、向右的眼神，都把用户的眼神引导到相应的信息上。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-2&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1跟着模特脸的方向眼神所指的方向安排重要次要信息到相应的位置上这会暗示用户的眼球朝所示的方向看过去&quot;&gt;1､跟着模特脸的方向、眼神所指的方向，安排重要、次要信息到相应的位置上。这会暗示用户的眼球朝所示的方向看过去。&lt;/h4&gt;
&lt;h4 id=&quot;2不要忽略模特的表情哦它其实也很重要哦试想一下一个要表达天真无邪充满童趣的画面时你选的模特表情僵硬目光呆滞像欠了500工资一样是不是显得傻了一些呢&quot;&gt;2､不要忽略模特的表情哦，它其实也很重要哦。试想一下，一个要表达天真无邪，充满童趣的画面时，你选的模特表情僵硬、目光呆滞，像欠了500工资一样，是不是显得傻了一些呢？&lt;/h4&gt;

&lt;h2 id=&quot;03上下左右和中间前面后面和侧面&quot;&gt;03､上下左右和中间，前面后面和侧面！&lt;/h2&gt;
&lt;p&gt;方向，用于提示某种位置。&lt;/p&gt;

&lt;h4 id=&quot;箭头直线斜线都具有明确的指向性它们是引导用户视线的好元素它不仅有着明确的指向性而且还可以对画面进行分隔对信息进行层次的间隔&quot;&gt;箭头、直线、斜线都具有明确的指向性，它们是引导用户视线的好元素。它不仅有着明确的指向性，而且还可以对画面进行分隔，对信息进行层次的间隔。&lt;/h4&gt;

&lt;h4 id=&quot;在一些场景中指示方向最多的元素当属各式方向的箭头了它是提示用户并暗示行动的一种设计元素&quot;&gt;在一些场景中，指示方向最多的元素当属各式方向的箭头了。它是提示用户、并暗示行动的一种设计元素。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0274ec57c421210000012e7ed3fc21.jpg&quot; alt=&quot;0274ec57c421210000012e7ed3fc21&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在实际应用中-1&quot;&gt;在实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;如果要给用户点明要关注的内容最好的方法就是利用线箭头元素的指向可以很方便的对用户眼睛进行方向上的引导&quot;&gt;如果要给用户点明要关注的内容，最好的方法就是利用线、箭头元素的指向，可以很方便的对用户眼睛，进行方向上的引导。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0227b857c421470000012e7e187dc9.jpg&quot; alt=&quot;0227b857c421470000012e7e187dc9&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1线条具有明确的指向性节奏感直线具有男性的特征它有力度相对稳定曲线具有柔美流畅的印象&quot;&gt;左图1：线条具有明确的指向性、节奏感。直线具有男性的特征，它有力度、相对稳定。曲线具有柔美、流畅的印象；&lt;/h4&gt;

&lt;h4 id=&quot;左图2垂直的线有着明确的上下指向作用&quot;&gt;左图2：垂直的线，有着明确的上下指向作用。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-3&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1在做时尚类服装类的设计需求中灵活运用小短线元素可以帮你加强文字层次修饰画面细节和提示标重的地方中不同的线有着不同的视觉感觉例如粗线给人男人有力的印象曲线给人柔美飘逸的感受&quot;&gt;1､在做时尚类、服装类的设计需求中，灵活运用小短线元素可以帮你加强文字层次，修饰画面细节，和提示标重的地方中。不同的线，有着不同的视觉感觉。例如：粗线给人男人、有力的印象；曲线给人柔美、飘逸的感受；&lt;/h4&gt;

&lt;h4 id=&quot;2在使用线短线箭头元素时一定要加在要进行明确指向的目的上不要为了加而加&quot;&gt;2､在使用线、短线、箭头元素时，一定要加在要进行明确指向的目的上。不要为了加，而加。&lt;/h4&gt;

&lt;h2 id=&quot;04万柳丛中一点红诱导聚焦和突出&quot;&gt;04､万柳丛中一点红，诱导聚焦和突出&lt;/h2&gt;
&lt;p&gt;万柳丛中一点红，从这句话中折射出了色彩所具有的指向性。&lt;/p&gt;

&lt;h4 id=&quot;它的优点是直接让主体从万千元素干扰中非常突出并且马上抓住用户视觉&quot;&gt;它的优点是直接让主体从万千元素干扰中，非常突出并且马上抓住用户视觉。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02986857c4218c0000018c1b943180.jpg&quot; alt=&quot;02986857c4218c0000018c1b943180&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左上1人物向上慢慢撕开的红色内容成为用户关注的第一焦点面无表情人物给画面营造出一种诡异恐怖的感觉&quot;&gt;左上1：人物向上慢慢撕开的红色内容，成为用户关注的第一焦点，面无表情人物给画面营造出一种诡异、恐怖的感觉。&lt;/h4&gt;

&lt;h4 id=&quot;左上2科比的湖人黄色首先成为视觉焦点引导用户关注其经典的扣蓝动作中&quot;&gt;左上2：科比的湖人黄色首先成为视觉焦点，引导用户关注其经典的扣蓝动作中。&lt;/h4&gt;

&lt;h4 id=&quot;左下3红色的线条运用提示用户向下继续浏览分散的纤细短红色线条自由无序的摆放在页面的主要内容上使用户的视觉焦点集中在这些线条所指示的内容上&quot;&gt;左下3：红色的线条运用提示用户向下继续浏览，分散的纤细短红色线条自由无序的摆放在页面的主要内容上，使用户的视觉焦点，集中在这些线条所指示的内容上。&lt;/h4&gt;

&lt;h4 id=&quot;左下4红黑的对比使得人物左侧的红色更为明显&quot;&gt;左下4：红黑的对比，使得人物左侧的红色更为明显。&lt;/h4&gt;

&lt;h4 id=&quot;在实际应用可分为二种情况&quot;&gt;在实际应用可分为二种情况&lt;/h4&gt;

&lt;h4 id=&quot;诱导&quot;&gt;诱导&lt;/h4&gt;
&lt;p&gt;在面对大幅面文字、元素、图像信息时，人的眼睛是需要引导的，而色彩是最为直白的形式之一。&lt;/p&gt;

&lt;h4 id=&quot;通过对色彩的合理运用着重突出最主要的信息把色彩的反差最大化如果在色彩的引导上加配以元素的指向动作的指向那么色彩指向将会更加的具有冲击力&quot;&gt;通过对色彩的合理运用着重突出最主要的信息，把色彩的反差最大化。如果在色彩的引导上，加配以元素的指向、动作的指向，那么色彩指向将会更加的具有冲击力。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/022ddc57c421c30000012e7e1065a4.jpg&quot; alt=&quot;022ddc57c421c30000012e7e1065a4&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1是典型的绿红配整体色调的绿色化使得页面最底部的红瓶子显得格外醒目在用户按照从上到下的浏览习惯看完后视线就被定在了这个红色的元素上&quot;&gt;左图1：是典型的绿红配，整体色调的绿色化，使得页面最底部的红瓶子显得格外醒目。在用户按照从上到下的浏览习惯看完后，视线就被定在了这个红色的元素上。&lt;/h4&gt;

&lt;h4 id=&quot;左图2明快对比强烈的色块分别置于画面的左右侧让用户的视线跟着这些色块进行移动既活跃了画面又丰富了整体效果&quot;&gt;左图2：明快、对比强烈的色块分别置于画面的左右侧，让用户的视线跟着这些色块进行移动，既活跃了画面，又丰富了整体效果。&lt;/h4&gt;

&lt;h4 id=&quot;通过上面的例子说明色彩诱导的作用类似于色彩方案中的点睛色把你要做突出的内容用对比色互被色进行表现&quot;&gt;通过上面的例子说明，色彩诱导的作用类似于，色彩方案中的点睛色。把你要做突出的内容，用对比色、互被色进行表现。&lt;/h4&gt;

&lt;h4 id=&quot;聚集&quot;&gt;聚集&lt;/h4&gt;

&lt;h4 id=&quot;当画面出现多二种颜色时用户的眼神首先会聚焦在那些对比性强面积大的突出的颜色上然后再找另外一种颜色然后全部浏览完成&quot;&gt;当画面出现多二种颜色时，用户的眼神首先会聚焦在那些对比性强、面积大的突出的颜色上，然后再找另外一种颜色，然后全部浏览完成。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0208a457c421f40000012e7eb20817.jpg&quot; alt=&quot;0208a457c421f40000012e7eb20817&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;通过上面的例子说明色彩聚集的核心作用就是把你要突出的内容突出化对比化聚焦化让用户的视线停留于此阅读你想要传达给他们的信息&quot;&gt;通过上面的例子说明，色彩聚集的核心作用就是把你要突出的内容突出化、对比化、聚焦化，让用户的视线停留于此，阅读你想要传达给他们的信息。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-4&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1-用反差比较强烈的互补色去突出主要内容时这种聚焦的处理方法更有效&quot;&gt;1､ 用反差比较强烈的互补色去突出主要内容时，这种聚焦的处理方法更有效；&lt;/h4&gt;

&lt;h4 id=&quot;2-如果画面中的颜色较多时可以利用色彩的面积大小去给页面出现的所有信息进行重要层次的分级&quot;&gt;2､ 如果画面中的颜色较多时，可以利用色彩的面积大小，去给页面出现的所有信息进行重要层次的分级。&lt;/h4&gt;

&lt;h2 id=&quot;05留白设计空白多主角旁边面积大&quot;&gt;05、留白设计空白多，主角旁边面积大&lt;/h2&gt;
&lt;p&gt;留白，常见的逼格神器，突出主角的必备招数。&lt;/p&gt;

&lt;h4 id=&quot;如果说上述的几种方法是在做加法的设计那么留白其实是在做减法的设计当主角元素四周的留白很多时人眼的视线首先会从整页复杂的环境中优先发现那个没有任何障碍物的设计元素&quot;&gt;如果说上述的几种方法是在做加法的设计，那么留白其实是在做减法的设计。当主角元素四周的留白很多时，人眼的视线首先会从整页复杂的环境中，优先发现那个没有任何障碍物的设计元素。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02c4e857c423d90000018c1b7dc800.jpg&quot; alt=&quot;02c4e857c423d90000018c1b7dc800.jpg&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在实际应用中-2&quot;&gt;在实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;留白就是留出主角空白层次逼格的一种简洁的设计方法&quot;&gt;留白就是留出主角、空白、层次、逼格的一种简洁的设计方法。&lt;/h4&gt;

&lt;h4 id=&quot;留白的白指的不是颜色的白而是空白的白留白指的是某一区域无多余元素四周处于大面积空白的状态&quot;&gt;留白的”白”指的不是颜色的”白”，而是空白的”白”，留白指的是某一区域无多余元素、四周处于大面积空白的状态。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02437057c424040000012e7ec8d361.jpg&quot; alt=&quot;02437057c424040000012e7ec8d361&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1以产品为主的专题且只有的少量信息页面产品四周大面积的留白处理使产品的形态细节更加的聚焦同时留白的处理也提升品牌的品质感和气质&quot;&gt;左图1：以产品为主的专题且只有的少量信息页面，产品四周大面积的留白处理，使产品的形态，细节更加的聚焦。同时留白的处理，也提升品牌的品质感和气质。&lt;/h4&gt;

&lt;h4 id=&quot;右图2整体页面非常多的留白除了一些扁平的设计元素外主画面以外多是以白的形式出现的&quot;&gt;右图2：整体页面非常多的留白，除了一些扁平的设计元素外，主画面以外多是以“白”的形式出现的。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-5&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1有效的留白可以提升画面的逼格而且可以使要突出的主角更突出&quot;&gt;1、有效的留白可以提升画面的逼格，而且可以使要突出的主角更突出；&lt;/h4&gt;

&lt;h4 id=&quot;2敢留白大量留白会使页面有空间感不会因为页面内容密密麻麻而产生厌恶&quot;&gt;2、敢留白：大量留白会使页面有空间感，不会因为页面内容密密麻麻而产生厌恶。&lt;/h4&gt;

&lt;h4 id=&quot;3使用最精简的元素不添加无谓的设计元素给用户带去视觉干扰只保留核心和必要的关键关素并且对关键元素进行细节的刻画&quot;&gt;3、使用最精简的元素：不添加无谓的设计元素，给用户带去视觉干扰，只保留核心和必要的关键关素，并且对关键元素进行细节的刻画。&lt;/h4&gt;

&lt;h2 id=&quot;06一二三四五六七7654321&quot;&gt;06、一二三四五六七，7654321&lt;/h2&gt;
&lt;p&gt;数字指向，顺序的指向性。&lt;/p&gt;

&lt;h4 id=&quot;一般人都会有这样的体验当看到数字1时就要去寻找数字2有些需求里在需要用视觉牵引用户眼睛时把数字当标头使用户视线在页面中合理跳跃&quot;&gt;一般人都会有这样的体验，当看到数字1时，就要去寻找数字2。有些需求里，在需要用视觉牵引用户眼睛时，把数字当标头，使用户视线在页面中合理跳跃。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02fe9957c4244e0000018c1b1e74b5.jpg&quot; alt=&quot;02fe9957c4244e0000018c1b1e74b5&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在实际应用中-3&quot;&gt;在实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;数字元素的运用往往出现在以目录页发展历程或者产品排列展示中&quot;&gt;数字元素的运用往往出现在以目录页、发展历程、或者产品排列展示中。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/028caf57c424710000012e7eac0185.jpg&quot; alt=&quot;028caf57c424710000012e7eac0185&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1鲁尼踢球的动作和方向正好指向了右侧的内容区以数字为代表的标头又指示用户逐个阅读或者分散阅读&quot;&gt;左图1：鲁尼踢球的动作和方向正好指向了右侧的内容区，以数字为代表的标头又指示用户逐个阅读或者分散阅读。&lt;/h4&gt;

&lt;h4 id=&quot;右图1数字的作用就是用来指示用户继续向下阅读黄色与黑色的强烈火对比&quot;&gt;右图1：数字的作用就是用来指示用户继续向下阅读，黄色与黑色的强烈火对比。&lt;/h4&gt;

&lt;h4 id=&quot;左图2产品周围大面积的留白使得主角先被人关注到右侧泛白的标题数字起到了突出产品折扣的目的&quot;&gt;左图2：产品周围大面积的留白，使得主角先被人关注到。右侧泛白的标题数字，起到了突出产品折扣的目的。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-6&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1做时尚搭配的需求时可以用数字去引导产品的顺序&quot;&gt;1、做时尚搭配的需求时，可以用数字去引导产品的顺序；&lt;/h4&gt;

&lt;h4 id=&quot;2以用运数字为元素时对数字的大小和字形要进行整体的把控切不可让数字影响主体内容当然如果是以数字为主的就要尽量突出数字的视觉性&quot;&gt;2、以用运数字为元素时，对数字的大小和字形要进行整体的把控。切不可让数字影响主体内容，当然如果是以数字为主的，就要尽量突出数字的视觉性。&lt;/h4&gt;

&lt;h2 id=&quot;07动的太大显得闹静的太死显得闷&quot;&gt;07、动的太大显得闹，静的太死显得闷&lt;/h2&gt;
&lt;p&gt;动静，就是画面的静与动。&lt;/p&gt;

&lt;h4 id=&quot;动的元素在整体静态的页面中更能吸引用户的眼球当然这其中包括页面中有gif图视觉元素的动感表现等&quot;&gt;动的元素在整体静态的页面中更能吸引用户的眼球。当然这其中包括页面中有gif图、视觉元素的动感表现等。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/0242c857c424bb0000018c1b9ef21d.jpg&quot; alt=&quot;0242c857c424bb0000018c1b9ef21d&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在实际应用中-4&quot;&gt;在实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;动的表现可以用人物的动作产品的动作gif图来完成对动的执行但是画面中同一屏的页面中同时动的元素最好不要超过3处或更多因为每动一处都会引起人们视觉的噪动如果动的太多势必会分散用户的注意力使主要内容的传达弱化&quot;&gt;动的表现可以用人物的动作、产品的动作、gif图来完成对动的执行。但是画面中同一屏的页面中，同时动的元素最好不要超过3处或更多，因为每动一处都会引起人们视觉的噪动，如果动的太多，势必会分散用户的注意力。使主要内容的传达，弱化。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02fb5657c424dd0000012e7e3074d1.gif&quot; alt=&quot;02fb5657c424dd0000012e7e3074d1&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;大家注意细节手的动作&quot;&gt;大家注意细节：手的动作。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-7&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1---瞬间让元素有动感的处理方法给元素增加动感模糊给画面增加飞着的元素如五彩纸屑红包倾斜着的线等&quot;&gt;1､   瞬间让元素有动感的处理方法：给元素增加动感模糊；给画面增加飞着的元素如：五彩纸屑、红包、倾斜着的线等。&lt;/h4&gt;

&lt;h4 id=&quot;2---动的页面还可以通过用现在较流行的h5视差滚动等技术让页面中的不同元素根据用户的鼠标滚动相应的出现&quot;&gt;2､   动的页面还可以通过用现在较流行的h5、视差滚动等技术让页面中的不同元素根据用户的鼠标滚动相应的出现；&lt;/h4&gt;

&lt;h2 id=&quot;08文案设计想法多紧扣主题有内涵&quot;&gt;08、文案设计想法多，紧扣主题有内涵&lt;/h2&gt;
&lt;p&gt;文案，用文笔引导用户产生画面感。&lt;/p&gt;

&lt;h4 id=&quot;在实际应用中-5&quot;&gt;在实际应用中&lt;/h4&gt;

&lt;h4 id=&quot;相比较而言文字虽没有色彩那么实在也没人物动作那么显而易见但是它却是最能走进人们内心的形式&quot;&gt;相比较而言，文字虽没有色彩那么实在，也没人物动作那么显而易见，但是它却是最能走进人们内心的形式。&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/huangmai/20160831/02de5757c4258f0000012e7eb142af.jpg&quot; alt=&quot;02de5757c4258f0000012e7eb142af&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;左图1像土豪一样表白设计师完全找到了文案与形象之间的切入点结合卡通的表现形式使得绘制的形象活生生的表现了某些土豪的豪气&quot;&gt;左图1：像土豪一样表白，设计师完全找到了文案与形象之间的切入点，结合卡通的表现形式，使得绘制的形象活生生的表现了某些土豪的“豪气”。&lt;/h4&gt;

&lt;h4 id=&quot;右图1五折封顶-不留余力设计师通过文案的发散绘制了一个正在点燃的机器像是要引爆全场的感觉&quot;&gt;右图1：五折封顶 不留余力，设计师通过文案的发散，绘制了一个正在点燃的机器，像是要引爆全场的感觉。&lt;/h4&gt;

&lt;h4 id=&quot;当你在设计时-8&quot;&gt;当你在设计时&lt;/h4&gt;

&lt;h4 id=&quot;1好文案往往会联想到一些元素的色彩的风格的关键字这样的好文案往往和图像的贴合度更高&quot;&gt;1､好文案往往会联想到一些元素的、色彩的、风格的关键字，这样的好文案往往和图像的贴合度更高。&lt;/h4&gt;

&lt;h4 id=&quot;2文案的视觉设计往往通过对文案意思具象的抽象型的表达引起用户的共鸣&quot;&gt;2､文案的视觉设计，往往通过对文案意思具象的、抽象型的表达引起用户的共鸣。&lt;/h4&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;以上的8点就是我对视觉元素引导的八个方法&quot;&gt;以上的8点就是我对视觉元素引导的八个方法。&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>H5终端自适应解决方案 -- flexible + rem</title>
   <link href="http://www.blogways.net/blog/2016/08/26/web-rem-share.html"/>
   <updated>2016-08-26T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/08/26/web-rem-share</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;目前移动端现状&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;像素的概念&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3nd&quot;&gt;初识rem与flexible&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;制作rem小例子&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一目前移动端现状&quot;&gt;一、目前移动端现状&lt;/h2&gt;

&lt;h4 id=&quot;随着移动设备的普及不同的手机屏幕与尺寸接连出现作为前端开发人员虽然h5的页面与pc的web页面相比简单了不少但让我们头痛的事情是要想尽办法让页面能适配众多不同的终端设备让我们来看看目前市场上的情况&quot;&gt;随着移动设备的普及，不同的手机屏幕与尺寸接连出现；作为前端开发人员，虽然H5的页面与PC的Web页面相比简单了不少，但让我们头痛的事情是要想尽办法让页面能适配众多不同的终端设备，让我们来看看目前市场上的情况&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160826img01.png&quot; alt=&quot;20160826img01&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;而作为前端开发人员需要适配终端设备数据如下图&quot;&gt;而作为前端开发人员，需要适配终端设备数据如下图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160826img02.png&quot; alt=&quot;20160826img02&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;看到这些数据是否死的心都有了或者说为此捏了一把汗出来&quot;&gt;看到这些数据，是否死的心都有了，或者说为此捏了一把汗出来。&lt;/h4&gt;

&lt;h4 id=&quot;为了应对如此多的终端设备设计师和前端开发之间又应该采用什么协作模式&quot;&gt;为了应对如此多的终端设备，设计师和前端开发之间又应该采用什么协作模式？&lt;/h4&gt;

&lt;h4 id=&quot;目前淘宝的设计思路为&quot;&gt;目前淘宝的设计思路为：&lt;/h4&gt;

&lt;h4 id=&quot;1选择一种尺寸作为设计和开发基准&quot;&gt;1.选择一种尺寸作为设计和开发基准&lt;/h4&gt;

&lt;h4 id=&quot;2定义一套适配规则自动适配剩下的两种尺寸其实不仅这两种你懂的&quot;&gt;2.定义一套适配规则，自动适配剩下的两种尺寸(其实不仅这两种，你懂的)&lt;/h4&gt;

&lt;h4 id=&quot;3特殊适配效果给出设计效果&quot;&gt;3.特殊适配效果给出设计效果&lt;/h4&gt;

&lt;h4 id=&quot;如下图为手淘的协作模式&quot;&gt;如下图为手淘的协作模式&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160826img03.jpg&quot; alt=&quot;20160826img03&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;通过上图可以看出手淘设计师常选择iphone6作为基准设计尺寸交付给前端的设计尺寸是按750px--1334px为准高度会随着内容多少而改变前端开发人员通过一套适配规则flexiblerem自动适配到其他的尺寸flexiblerem会在后面详解&quot;&gt;通过上图可以看出，手淘设计师常选择iPhone6作为基准设计尺寸，交付给前端的设计尺寸是按750px * 1334px为准(高度会随着内容多少而改变)。前端开发人员通过一套适配规则（flexible+rem）自动适配到其他的尺寸，flexible+rem会在后面详解。&lt;/h4&gt;

&lt;h2 id=&quot;二像素的概念&quot;&gt;二、像素的概念&lt;/h2&gt;

&lt;h4 id=&quot;做为前端开发人员对于像素的概念是不可或缺的其中包含了物理像素physical-pixel设备独立像素density-independent-pixelcss像素屏幕密度设备像素比device-pixel-ratio等基本概念让我们一个个的理解&quot;&gt;做为前端开发人员，对于像素的概念是不可或缺的，其中包含了“物理像素(physical pixel)”、“设备独立像素(density-independent pixel)”、“CSS像素”、“屏幕密度”、“设备像素比(device pixel ratio)”等基本概念，让我们一个个的理解&lt;/h4&gt;

&lt;h3 id=&quot;1物理像素physical-pixel&quot;&gt;1.物理像素(physical pixel)&lt;/h3&gt;

&lt;h4 id=&quot;物理像素又被称为设备像素他是显示设备中一个最微小的物理部件每个像素可以根据操作系统设置自己的颜色和亮度正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果&quot;&gt;物理像素又被称为设备像素，他是显示设备中一个最微小的物理部件。每个像素可以根据操作系统设置自己的颜色和亮度。正是这些设备像素的微小距离欺骗了我们肉眼看到的图像效果。&lt;/h4&gt;

&lt;h3 id=&quot;2设备独立像素density-independent-pixel&quot;&gt;2.设备独立像素(density-independent pixel)&lt;/h3&gt;

&lt;h4 id=&quot;设备独立像素也称为密度无关像素可以认为是计算机坐标系统中的一个点这个点代表一个可以由程序使用的虚拟像素比如说css像素然后由相关系统转换为物理像素&quot;&gt;设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。&lt;/h4&gt;

&lt;h3 id=&quot;3css像素&quot;&gt;3.CSS像素&lt;/h3&gt;

&lt;h4 id=&quot;css像素是一个抽像的单位主要使用在浏览器上用来精确度量web页面上的内容一般情况之下css像素称为与设备无关的像素device-independent-pixel简称dips&quot;&gt;CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。&lt;/h4&gt;

&lt;h3 id=&quot;4屏幕密度&quot;&gt;4.屏幕密度&lt;/h3&gt;

&lt;h4 id=&quot;屏幕密度是指一个设备表面上存在的像素数量它通常以每英寸有多少像素来计算ppi&quot;&gt;屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。&lt;/h4&gt;

&lt;h3 id=&quot;5设备像素比device-pixel-ratio&quot;&gt;5.设备像素比(device pixel ratio)&lt;/h3&gt;

&lt;h4 id=&quot;设备像素比简称为dpr其定义了物理像素和设备独立像素的对应关系它的值可以按下面的公式计算得到&quot;&gt;设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：&lt;/h4&gt;

&lt;h4 id=&quot;设备像素比--物理像素--设备独立像素&quot;&gt;设备像素比 ＝ 物理像素 / 设备独立像素&lt;/h4&gt;

&lt;h4 id=&quot;在javascript中可以通过windowdevicepixelratio获取到当前设备的dpr而在css中可以通过-webkit-device-pixel-ratio-webkit-min-device-pixel-ratio和--webkit-max-device-pixel-ratio进行媒体查询对不同dpr的设备做一些样式适配这里只针对webkit内核的浏览器和webview&quot;&gt;在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。而在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。&lt;/h4&gt;

&lt;h4 id=&quot;dip或dpdevice-independent-pixels设备独立像素与屏幕密度有关dip可以用来辅助区分视网膜设备还是非视网膜设备&quot;&gt;dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备&lt;/h4&gt;

&lt;h4 id=&quot;众所周知iphone6的设备宽度和高度为375pt--667pt可以理解为设备的独立像素而其dpr为2根据上面公式我们可以很轻松得知其物理像素为750pt--1334pt&quot;&gt;众所周知，iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素；而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt * 1334pt。&lt;/h4&gt;

&lt;h2 id=&quot;三初识rem与flexible&quot;&gt;三、初识rem与flexible&lt;/h2&gt;

&lt;h3 id=&quot;1css3新成员rem&quot;&gt;1.CSS3新成员：rem&lt;/h3&gt;

&lt;h4 id=&quot;在w3c规范中是这样描述rem的&quot;&gt;在W3C规范中是这样描述rem的:&lt;/h4&gt;

&lt;h4 id=&quot;font-size-of-the-root-element&quot;&gt;font size of the root element.&lt;/h4&gt;

&lt;h4 id=&quot;简单的理解rem就是相对于根元素html的font-size来做计算而我们的方案中使用rem单位是能轻易的根据html的font-size计算出元素的盒模型大小而这个特色对我们来说是特别的有益处&quot;&gt;简单的理解，rem就是相对于根元素&amp;lt;html&amp;gt;的font-size来做计算。而我们的方案中使用rem单位，是能轻易的根据&amp;lt;html&amp;gt;的font-size计算出元素的盒模型大小。而这个特色对我们来说是特别的有益处。&lt;/h4&gt;

&lt;h4 id=&quot;在整个手淘团队我们有一个名叫lib-flexible的库而这个库就是用来解决h5页面终端适配的&quot;&gt;在整个手淘团队，我们有一个名叫lib-flexible的库，而这个库就是用来解决H5页面终端适配的。&lt;/h4&gt;

&lt;h3 id=&quot;2lib-flexible是什么&quot;&gt;2.lib-flexible是什么？&lt;/h3&gt;

&lt;h4 id=&quot;lib-flexible是一个制作h5适配的开源库获取需要的javascript和css文件可以直接下载或直接通过阿里cdn云&quot;&gt;lib-flexible是一个制作H5适配的开源库，获取需要的JavaScript和CSS文件，可以直接下载或直接通过阿里CDN云&lt;/h4&gt;

&lt;h4 id=&quot;下载地址httpsgithubcomamfelib-flexiblearchivemasterzip&quot;&gt;下载地址：https://github.com/amfe/lib-flexible/archive/master.zip&lt;/h4&gt;

&lt;h4 id=&quot;下载后解压同时引入js库如&quot;&gt;下载后解压，同时引入js库，如&lt;/h4&gt;

&lt;h4&gt;&lt;script src=&quot;build/flexible_css.debug.js&quot;&gt;&lt;/script&gt;&lt;/h4&gt;
&lt;h4 id=&quot;-1&quot;&gt;&lt;script src=&quot;build/flexible.debug.js&quot;&gt;&lt;/script&gt;&lt;/h4&gt;

&lt;h4 id=&quot;云引用&quot;&gt;云引用：&lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&gt;&lt;/script&gt;&lt;/h4&gt;

&lt;h4 id=&quot;3lib-flexible有什么用&quot;&gt;3.lib-flexible有什么用？&lt;/h4&gt;

&lt;h4 id=&quot;lib-flexible加入执行后会在html元素上增加一个data-dpr属性以及一个font-size样式&quot;&gt;lib-flexible加入执行后，会在&amp;lt;html&amp;gt;元素上增加一个data-dpr属性，以及一个font-size样式。&lt;/h4&gt;

&lt;h4 id=&quot;js会根据不同的设备添加不同的data-dpr值比如说2或者3同时会给html加上对应的font-size的值比如说75px&quot;&gt;JS会根据不同的设备添加不同的data-dpr值，比如说2或者3，同时会给html加上对应的font-size的值，比如说75px；&lt;/h4&gt;

&lt;h4 id=&quot;如此一来页面中的元素都可以通过rem单位来设置他们会根据html元素的font-size值做相应的计算从而实现屏幕的适配效果&quot;&gt;如此一来，页面中的元素，都可以通过rem单位来设置。他们会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。&lt;/h4&gt;

&lt;h2 id=&quot;四rem小例子分析&quot;&gt;四、rem小例子分析&lt;/h2&gt;

&lt;h4 id=&quot;请用手机扫下面的二维码查看最终实现效果&quot;&gt;请用手机扫下面的二维码查看最终实现效果&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160826img04.jpg&quot; alt=&quot;20160826img04&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;该界面是如何实现的首先我们来看一张750的设计图稿&quot;&gt;该界面是如何实现的？首先我们来看一张750的设计图稿&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160826img05.png&quot; alt=&quot;20160826img05&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;通过该设计稿可知每个元素的边距大小在7501334上的比例前端开发人员可在750设备上完成框架设计即iphone6上进行开发之后通过将px转化为rem实现终端适配详细流程如下&quot;&gt;通过该设计稿可知每个元素的边距、大小在750*1334上的比例；前端开发人员可在750设备上完成框架设计（即iphone6上进行开发），之后通过将px转化为rem实现终端适配，详细流程如下&lt;/h4&gt;

&lt;h3 id=&quot;1创建html模版&quot;&gt;1.创建HTML模版&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-mobile-web-app-capable&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;yes&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-touch-fullscreen&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;telephone=no,email=no&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;format-detection&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;apple-touch-icon&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;favicon.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Shortcut Icon&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;favicon.png&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;image/x-icon&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;flexible+rem实战用例&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;c&quot;&gt;&amp;lt;!-- 页面结构写在这里 --&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;首先需要加载flexible所需的配置&quot;&gt;首先需要加载Flexible所需的配置&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2根据设计图编写body中的内容具体如下&quot;&gt;2.根据设计图编写&amp;lt;body&amp;gt;中的内容，具体如下&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;item-section&quot; data-repeat=&quot;sections&quot;&amp;gt;
    &amp;lt;div class=&quot;item-section_header&quot;&amp;gt;
        &amp;lt;h2&amp;gt;&amp;lt;img src=&quot;http://xxx.cdn.com/B1PNLZKXXXXXaTXXXXXXXXXXXX-750-481.jpg&quot; alt=&quot;&quot;&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;ul&amp;gt;
        &amp;lt;li data-repeat=&quot;items&quot; class=&quot;flag&quot; role=&quot;link&quot; href=&quot;##&quot;&amp;gt;
            &amp;lt;a class=&quot;figure flag-item&quot; href=&quot;##&quot;&amp;gt;
                &amp;lt;img src=&quot;https://placeimg.com/350/350/people/grayscale&quot; alt=&quot;&quot;&amp;gt;
            &amp;lt;/a&amp;gt;
            &amp;lt;div class=&quot;figcaption flag-item&quot;&amp;gt;
                &amp;lt;div class=&quot;flag-title&quot;&amp;gt;&amp;lt;a href=&quot;##&quot; title=&quot;&quot;&amp;gt;Carter's1年式灰色长袖连体衣包脚爬服全棉鲸鱼男婴儿童装115G093&amp;lt;/a&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;flag-price&quot;&amp;gt;&amp;lt;span&amp;gt;双11价&amp;lt;/span&amp;gt;&amp;lt;strong&amp;gt;¥299.06&amp;lt;/strong&amp;gt;&amp;lt;small&amp;gt;(满400减100)&amp;lt;/small&amp;gt;&amp;lt;/div&amp;gt;
                &amp;lt;div class=&quot;flag-type&quot;&amp;gt;1小时内热卖5885件&amp;lt;/div&amp;gt;
                &amp;lt;a class=&quot;flag-btn&quot; href=&quot;##&quot;&amp;gt;马上抢！&amp;lt;/a&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3将px转化为rem以适配不同终端&quot;&gt;3.将px转化为rem，以适配不同终端&lt;/h3&gt;

&lt;h4 id=&quot;在实际生产当中如果每一次计算px转换rem或许会觉得非常麻烦或许直接影响大家平时的开发效率为了能让大家更快进行转换我们团队内的同学各施所长为px转换rem写了各式各样的小工具&quot;&gt;在实际生产当中，如果每一次计算px转换rem，或许会觉得非常麻烦，或许直接影响大家平时的开发效率。为了能让大家更快进行转换，我们团队内的同学各施所长，为px转换rem写了各式各样的小工具。&lt;/h4&gt;

&lt;h4 id=&quot;1cssrem&quot;&gt;（1）CSSREM&lt;/h4&gt;

&lt;h4 id=&quot;cssrem是一个css的px值转rem值的sublime-text3自动完成插件这个插件是由正霖编写先来看看插件的效果&quot;&gt;CSSREM是一个CSS的px值转rem值的Sublime Text3自动完成插件。这个插件是由@正霖编写。先来看看插件的效果：&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/liuyw6/20160826img06.gif&quot; alt=&quot;20160826img06&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;2在线转换器&quot;&gt;（2）在线转换器&lt;/h4&gt;

&lt;h4 id=&quot;地址http520uedcomtoolsrem--该转换器上传工程css文件然后定义html-font-size即可转换&quot;&gt;地址：http://520ued.com/tools/rem ； 该转换器上传工程CSS文件，然后定义html font size，即可转换&lt;/h4&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;h4 id=&quot;本文主要就目前移动终端的适配做了一个简单的阐述目的在于认识移动终端知晓目前主流的适配方法详细的学习请参考丰富的网络资源谢谢&quot;&gt;本文主要就目前移动终端的适配做了一个简单的阐述，目的在于认识移动终端，知晓目前主流的适配方法；详细的学习请参考丰富的网络资源，谢谢！&lt;/h4&gt;
</content>
 </entry>
 
 <entry>
   <title>SVG学习[2]--基本数据及path元素</title>
   <link href="http://www.blogways.net/blog/2016/08/18/web-svg-2.html"/>
   <updated>2016-08-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/08/18/web-svg-2</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;基本属性&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;path路径(SVG)&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;小结&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一基本属性&quot;&gt;一、基本属性&lt;/h2&gt;

&lt;h3 id=&quot;1笔划与填充&quot;&gt;1、笔划与填充&lt;/h3&gt;

&lt;p&gt;第一篇博文中的示例已经演示了围绕对象的笔划或线以及对象内部区域的填充.这些属性实际上还有子属性,也可以设置子属性来创建不同的效果.这些属性包括：&lt;/p&gt;

&lt;p&gt;fill：该属性指定用来填充对象内部区域的颜料.大多数情况下,该属性只是一种颜色,但它也可以是渐变或图案（会在图案中介绍）.这个值通常是关键字、颜色说明或指向预定义元素的 URI.&lt;/p&gt;

&lt;p&gt;fill-opacity：该属性指定元素的透明性.值的范围从完全透明（0）到完全不透明（1）.&lt;/p&gt;

&lt;p&gt;stroke：该属性指定元素外边框的外观.象 fill 一样,它引用颜料,尽管通常将它指定为一种简单颜色.&lt;/p&gt;

&lt;p&gt;stroke-width：该属性指定笔划线的宽度.&lt;/p&gt;

&lt;p&gt;stroke-linecap：该属性确定线末端的形状,可取的值有粗端(butt)、圆(round)和正方形(square).&lt;/p&gt;

&lt;p&gt;stroke-linejoin：该属性确定对象各角的外观.允许的值有直角（缺省值）、圆和斜角,它如示例中所示将尖角的边缘“剪掉”.&lt;/p&gt;

&lt;p&gt;stroke-dasharray：该属性是一个整数系列（如 3、2、3、2、4、3、2 和 3）,它允许对虚线中每一划的相对长度进行控制.&lt;/p&gt;

&lt;p&gt;stroke-opacity：类似于 fill-opacity,该属性确定元素笔划线的相对透明性.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/pyifisys&quot;&gt;Fill And Stroke Example&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2颜色&quot;&gt;2、颜色&lt;/h3&gt;
&lt;p&gt;颜色对于 SVG 图像是极其重要的.单个颜色可以直接使用它们的 RGB 值指定,或者使用差不多 150 个颜色关键字中的一个来间接指定,该关键字也引用 RGB 值.&lt;/p&gt;

&lt;p&gt;RGB 值在 0 到 255 数值范围内指定一种颜色的红、绿、蓝成分的相对亮度,例如:&lt;/p&gt;

&lt;p&gt;fill=”darkorchid”;fill=”lightgrey”;&lt;/p&gt;

&lt;p&gt;fill=”rgb(255,0,0)”;fill=”rgb(0,255,0)”; fill=”rgb(0,0,255)”;&lt;/p&gt;

&lt;p&gt;fille=”#000000”; fill=”#ffffff”.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/2turdmcq&quot;&gt;具体颜色示例&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3渐变&quot;&gt;3、渐变&lt;/h3&gt;

&lt;p&gt;渐变提供了将颜色混合在一起的能力.&lt;/p&gt;

&lt;p&gt;渐变有两种,&amp;lt;linearGradient&amp;gt;(线性渐变) 和 &amp;lt;radialGradient&amp;gt;(放射渐变)&lt;/p&gt;

&lt;p&gt;对于每种情况,代码都指定沿着渐变向量的颜色“停止”或颜色点,渐变到这些点就成为某种颜色.&lt;/p&gt;

&lt;p&gt;例如,指定红色在 0% 停止,白色在 50% 停止而蓝色在 100% 停止的渐变将逐渐由红色变为白色再变为蓝色,白色在渐变向量的中心.&lt;/p&gt;

&lt;p&gt;&amp;lt;linearGradient&amp;gt; 和 &amp;lt;radialGradient&amp;gt; 标签必须嵌套在 &lt;defs&gt; 中.&lt;defs&gt; 标签是 definitions 的缩写,它允许对诸如渐变等特殊元素进行定义.&lt;/defs&gt;&lt;/defs&gt;&lt;/p&gt;

&lt;h4 id=&quot;alineargradient&quot;&gt;A、&amp;lt;linearGradient&amp;gt;&lt;/h4&gt;

&lt;p&gt;&amp;lt;linearGradient&amp;gt;标签属性有:&lt;/p&gt;

&lt;p&gt;id 属性是渐变定义一个唯一的名称,图形元素可通过fill=”url(linearGradientId)”来引用该线性渐变效果;&lt;/p&gt;

&lt;p&gt;x1、x2、y1、y2 属性可定义渐变的开始和结束位置, x1,y1指定起点坐标, x2,y2指定结束坐标;&lt;/p&gt;

&lt;p&gt;渐变的颜色范围可由两种或多种颜色组成.每种颜色通过一个 &lt;stop&gt; 标签来规定.offset 属性用来定义渐变的开始和结束位置.&lt;/stop&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/zls7bjin&quot;&gt;线性渐变示例&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;bradialgradient&quot;&gt;B、&amp;lt;radialGradient&amp;gt;&lt;/h4&gt;

&lt;p&gt;&amp;lt;radialGradient&amp;gt; 标签属性有:&lt;/p&gt;

&lt;p&gt;id 属性是渐变定义一个唯一的名称,图形元素可通过fill=”url(linearGradientId)”来引用该放射渐变效果;&lt;/p&gt;

&lt;p&gt;cx、cy 和 r 属性定义外圈,而 fx 和 fy 定义内圈;&lt;/p&gt;

&lt;p&gt;渐变的颜色范围可由两种或多种颜色组成.每种颜色通过一个 &lt;stop&gt; 标签来规定.offset 属性用来定义渐变的开始和结束位置.&lt;/stop&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/mqw7yjwc&quot;&gt;放射渐变示例&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;4图案pattern&quot;&gt;4、图案(&amp;lt;pattern&amp;gt;)&lt;/h3&gt;

&lt;p&gt;图案 一般用于SVG图形对象的填充 fill 或描边 stroke .这个图形可以是一个SVG元素,也可以是像素图,通过 &amp;lt;pattern&amp;gt; 元素在 x 轴或 y 轴方向以固定的间隔平铺.&lt;/p&gt;

&lt;p&gt;可以在 &amp;lt;pattern&amp;gt; 元素内定义图案,然后通过 id 引用.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;svg width=&quot;660&quot; height=&quot;220&quot;&amp;gt;
 &amp;lt;defs&amp;gt;
   &amp;lt;pattern id=&quot;pattern&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; patternUnits=&quot;userSpaceOnUse&quot;&amp;gt;
     &amp;lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;10&quot; stroke=&quot;none&quot; fill=&quot;#393&quot; /&amp;gt;
   &amp;lt;/pattern&amp;gt;
 &amp;lt;/defs&amp;gt;

 &amp;lt;rect x=&quot;10&quot; y=&quot;10&quot; width=&quot;600&quot; height=&quot;200&quot; stroke=&quot;#630&quot; stroke-width=&quot;5px&quot; fill=&quot;url(#pattern)&quot; /&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/twae9n9z&quot;&gt;图案示例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 &amp;lt;defs&amp;gt; 标签内定义图案, &amp;lt;pattern&amp;gt; 元素中的内容直到引用的时候才会显示.&lt;/p&gt;

&lt;p&gt;&amp;lt;pattern&amp;gt; 中定义一个 id,方便在后面被矩形引用.&lt;/p&gt;

&lt;p&gt;&amp;lt;rect&amp;gt; 元素使用图案作为填充,然后再使用纯色来作为描边.&lt;/p&gt;

&lt;p&gt;在 &amp;lt;pattern&amp;gt; 元素内 ,定义了一个半径为 10(px) 的绿色圆,cx 和 cy 的值（分别为 10px ）设置了 circle 元素的初始圆的原点.&lt;/p&gt;

&lt;p&gt;具体效果点击示例查看,下面来看看&amp;lt;pattern&amp;gt; 元素的属性:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;pattern id=&quot;pattern&quot; x=&quot;0&quot; y=&quot;0&quot; width=&quot;20&quot; height=&quot;20&quot; patternUnits=&quot;userSpaceOnUse&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;x 和 y 属性定义了图案的起点.&lt;/p&gt;

&lt;p&gt;这里把它们都设置为0,这样在图案开始前就不会有偏移,使圆形的中心和图案的起点对齐.&lt;/p&gt;

&lt;p&gt;width 和 height 属性定义了重复图案的宽度和高度,因为图例中是一个圆,所以设置了相同的宽高.&lt;/p&gt;

&lt;p&gt;patternUnits 定义图案的展现方式,它的值有两个:&lt;/p&gt;

&lt;p&gt;userSpaceOnUse: x 、 y 、 width 和 height 表示的值都是当前用户坐标系统的值,也就是说,这些值没有缩放,都是绝对值.&lt;/p&gt;

&lt;p&gt;objectBoundingBox(默认值): x 、 y 、 width 和 height 表示的值都是外框的坐标系统(包裹pattern的元素),也就是说,图案的单位进行了一个缩放,比如:pattern中为 1 的值,会变成和包裹元素的外框的 width 和 height 一样的大小.&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二path路径&quot;&gt;二、path路径&lt;/h2&gt;

&lt;p&gt;path可能是SVG中最常见的形状.你可以用path元素绘制矩形（直角矩形或者圆角矩形）、圆形、椭圆、折线形、多边形,以及一些其他的形状,例如贝塞尔曲线、2次曲线等曲线.&lt;/p&gt;

&lt;p&gt;path只需要设定很少的点,就可以创建平滑流畅的线条（比如曲线）.虽然polyline元素也能实现类似的效果,但是必须设置大量的点（点越密集,越接近连续,看起来越平滑流畅）,并且这种做法不能够放大（放大后,点的离散更明显.所以在绘制SVG时,对路径的良好理解很重要.&lt;/p&gt;

&lt;p&gt;path元素的形状是通过属性d定义的,属性d的值是一个“命令+参数”的序列&lt;/p&gt;

&lt;p&gt;每一个命令都用一个关键字母来表示,比如,字母“M”表示的是“Move to”命令,当解析器读到这个命令时,它就知道你是打算移动到某个点.&lt;/p&gt;

&lt;p&gt;跟在命令字母后面的,是你需要移动到的那个点的x和y轴坐标.比如移动到(10,10)这个点的命令,应该写成“M 10 10”.这一段字符结束后,解析器就会去读下一段命令.&lt;/p&gt;

&lt;p&gt;每一个命令都有两种表示方式,一种是用大写字母,表示采用绝对定位.另一种是用小写字母,表示采用相对定位.&lt;/p&gt;

&lt;p&gt;path标准命令:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;命令&lt;/th&gt;
      &lt;th&gt;名称&lt;/th&gt;
      &lt;th&gt;参数&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;M&lt;/td&gt;
      &lt;td&gt;moveto(移动到)&lt;/td&gt;
      &lt;td&gt;(x,y)+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Z&lt;/td&gt;
      &lt;td&gt;closepath(关闭路径)&lt;/td&gt;
      &lt;td&gt;none&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;L&lt;/td&gt;
      &lt;td&gt;lineto(画线到)&lt;/td&gt;
      &lt;td&gt;(x,y)+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;H&lt;/td&gt;
      &lt;td&gt;horizontal lineto(水平线到)&lt;/td&gt;
      &lt;td&gt;x+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;V&lt;/td&gt;
      &lt;td&gt;vertical lineto(垂直线到)&lt;/td&gt;
      &lt;td&gt;y+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C&lt;/td&gt;
      &lt;td&gt;Bézier curveto(三次贝塞尔曲线到)&lt;/td&gt;
      &lt;td&gt;(x1 y1 x2 y2 x y)+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;S&lt;/td&gt;
      &lt;td&gt;smooth curveto(光滑三次贝塞尔曲线到)&lt;/td&gt;
      &lt;td&gt;(x2 y2 x y)+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Q&lt;/td&gt;
      &lt;td&gt;quadratic Bézier curveto (二次贝塞尔曲线到)&lt;/td&gt;
      &lt;td&gt;(x1 y1 x y)+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;T&lt;/td&gt;
      &lt;td&gt;smooth quadratic Bézier curveto(光滑二次贝塞尔曲线到)&lt;/td&gt;
      &lt;td&gt;(x y)+&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;A&lt;/td&gt;
      &lt;td&gt;elliptical arc(椭圆弧)&lt;/td&gt;
      &lt;td&gt;(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;1直线命令&quot;&gt;1、直线命令&lt;/h3&gt;

&lt;p&gt;&amp;lt;path&amp;gt;元素里有5个画直线的命令,顾名思义,直线命令就是在两个点之间画直线.&lt;/p&gt;

&lt;p&gt;首先是“Move to”命令,M,前面已经提到过,它需要两个参数,分别是需要移动到的点的x轴和y轴的坐标.&lt;/p&gt;

&lt;p&gt;假设,你的画笔当前位于一个点,在使用M命令移动画笔后,只会移动画笔,但不会在两点之间画线.&lt;/p&gt;

&lt;p&gt;因为M命令仅仅是移动画笔,但不画线.所以M命令经常出现在路径的开始处,用来指明从何处开始画.&lt;/p&gt;

&lt;p&gt;能够真正画出线的命令有三个,最常用的是“Line to”命令,L,L需要两个参数,分别是一个点的x轴和y轴坐标,L命令将会在当前位置和新位置（L前面画笔所在的点）之间画一条线段.&lt;/p&gt;

&lt;p&gt;另外还有两个简写命令,用来绘制平行线和垂直线.&lt;/p&gt;

&lt;p&gt;H,绘制平行线.V,绘制垂直线.&lt;/p&gt;

&lt;p&gt;这两个命令都只带一个参数,标明在x轴或y轴移动到的位置,因为它们都只在坐标轴的一个方向上移动.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;svg width=&quot;400px&quot; height=&quot;400px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;
	
        &amp;lt;!-- 用L命令画一条直线 --&amp;gt;
        &amp;lt;path d=&quot;M10 10 L 90,20 &quot; stroke=&quot;red&quot; stroke-width=&quot;2&quot; /&amp;gt;
    
        &amp;lt;!-- 用H命令画一条水平直线 --&amp;gt;
        &amp;lt;path d=&quot;M10 30 H 90 &quot; stroke=&quot;green&quot; stroke-width=&quot;2&quot; /&amp;gt;
        
        &amp;lt;!-- 用V命令画一条水平直线 --&amp;gt;
        &amp;lt;path d=&quot;M10 50 V 90 &quot; stroke=&quot;yellow&quot; stroke-width=&quot;2&quot; /&amp;gt;
	
    &amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/hjfppt2d&quot;&gt;简单线条示例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;现在已经掌握了一些命令,可以开始画一些东西.&lt;/p&gt;

&lt;p&gt;先从简单的地方开始,画一个简单的矩形（同样的效果用&lt;rect&gt;&lt;/rect&gt;元素可以更简单的实现.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;svg width=&quot;400px&quot; height=&quot;400px&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;
	
  &amp;lt;path d=&quot;M10 10 H 90 V 90 H 10 L 10 10&quot; fill='white' stroke='red' stroke-width='2'/&amp;gt;
	
	&amp;lt;!-- 通过“闭合路径命令”Z来简化上面的path,Z命令会从当前点画一条直线到路径的起点,Z命令不用区分大小写.--&amp;gt;
	&amp;lt;path d=&quot;M110 10 H 200 V 90 H 110 Z&quot; fill=&quot;gray&quot; stroke=&quot;yellow&quot;  stroke-width='2'/&amp;gt;
	
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/w7bmzd1t&quot;&gt;简单矩形示例&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2贝塞尔曲线命令&quot;&gt;2、贝塞尔曲线命令&lt;/h3&gt;

&lt;p&gt;贝塞尔曲线(Bézier curve),又称贝兹曲线或贝济埃曲线,是应用于二维图形应用程序的数学曲线,Canvas,CSS3动画函数以及许多画图应用都离不开它.&lt;/p&gt;

&lt;p&gt;由于数学不是很好,不能很好解释贝塞尔曲线,只好放几张图帮助理解,有兴趣可以自行Google,本文只讨论贝塞尔曲线在SVG中的用法.&lt;/p&gt;

&lt;p&gt;线性贝塞尔曲线演示动画,t在[0,1]区间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Bezier_1.gif&quot; alt=&quot;Bezier_1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;二次贝塞尔曲线演示动画,t在[0,1]区间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Bezier_2.gif&quot; alt=&quot;Bezier_2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;三次贝塞尔曲线演示动画,t在[0,1]区间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Bezier_3.gif&quot; alt=&quot;Bezier_3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;四次贝塞尔曲线演示动画,t在[0,1]区间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Bezier_4.gif&quot; alt=&quot;Bezier_4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;五次贝塞尔曲线演示动画,t在[0,1]区间&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Bezier_5.gif&quot; alt=&quot;Bezier_5&quot; /&gt;&lt;/p&gt;

&lt;p&gt;path标签中,与贝塞尔曲线相关的命令有C命令 S命令 Q命令 T命令.&lt;/p&gt;

&lt;h4 id=&quot;acs组合三次贝塞尔曲线命令组合&quot;&gt;A、CS组合(三次贝塞尔曲线命令组合)&lt;/h4&gt;

&lt;p&gt;C命令和S命令是专门绘制三次贝塞尔曲线的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/svg-3curveto.png&quot; alt=&quot;svg-3curveto&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是Photoshop中使用钢笔工具时候的截图再加工.&lt;/p&gt;

&lt;p&gt;所谓钢笔工具抠图实际上就是一个一个贝塞尔曲线连接的结果,各类图形绘制软件类似工具本质上都是贝塞尔曲线.&lt;/p&gt;

&lt;p&gt;图片有4个点出现,曲线的两个端点,以及两个控制点,这就是典型的三次贝塞尔曲线.&lt;/p&gt;

&lt;p&gt;对应的path代码中就是:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;!-- 其中,d=&quot;M20,20 C90,40 130,40 180,20&quot; --&amp;gt;
    &amp;lt;!-- M20,20 表示曲线的起点 --&amp;gt;
    &amp;lt;!-- C90,40 130,40 180,20 对应上图的2个控制点和1个关键点 --&amp;gt;
    &amp;lt;path d=&quot;M20,20 C90,40 130,40 180,20&quot; stroke=&quot;#000000&quot; fill=&quot;none&quot; style=&quot;stroke:red&quot; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码只用到了C命令,那么S命令呢?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/ShortCut_Cubic_Bezier.png&quot; alt=&quot;ShortCut_Cubic_Bezier&quot; /&gt;&lt;/p&gt;

&lt;p&gt;把关注点放在蓝线上面.S指令会自动补出一个对称的控制点（蓝线部分),于是就会有连续的平滑曲线.&lt;/p&gt;

&lt;p&gt;对应path代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;path d=&quot;M20,150 C60,40 80,40 120,150 S180 260 220 80&quot; fill=&quot;none&quot; style=&quot;stroke:yellow&quot;&amp;gt;&amp;lt;/path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/oemt7zmq&quot;&gt;三次赛贝尔示例&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;bqt组合二次次贝塞尔曲线命令组合&quot;&gt;B、QT组合(二次次贝塞尔曲线命令组合)&lt;/h4&gt;

&lt;p&gt;Q命令和T命令是专门绘制三次贝塞尔曲线的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/svg-2curveto-1.png&quot; alt=&quot;svg-2curveto-1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到,跟三次贝塞尔曲线相比,Q命令中就是2个控制点合为1个.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/svg-2curveto-2.png&quot; alt=&quot;svg-2curveto-2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;与S命令类似,T命令也会自动补出一个对称的控制点(蓝线部分),生成连续的平滑曲线.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &amp;lt;svg id=&quot;svg&quot; width=&quot;500&quot; height=&quot;400&quot;&amp;gt;

        &amp;lt;path d=&quot;M20 10 Q120 150 220 10 &quot; stroke=&quot;red&quot; fill=&quot;none&quot; style=&quot;stroke-width: 2px;&quot;&amp;gt;&amp;lt;/path&amp;gt;
     
    	&amp;lt;path d=&quot;M20 110 Q120 250 220 110 T420 110&quot; stroke=&quot;red&quot; fill=&quot;none&quot; style=&quot;stroke-width: 2px;&quot;&amp;gt;&amp;lt;/path&amp;gt;
    	
    &amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/mh3hd7pw&quot;&gt;二次赛贝尔示例&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三小结&quot;&gt;三、小结&lt;/h2&gt;

&lt;p&gt;本文介绍了SVG的基本属性和&amp;lt;path&amp;gt;元素的使用.&lt;/p&gt;

&lt;p&gt;值得一提的是&amp;lt;path&amp;gt;的塞贝尔曲线指令,塞贝尔曲线属于数学范畴,或许学习成本过高,使用画图软件画出图片并用CSS控制展示不是很好吗?&lt;/p&gt;

&lt;p&gt;然而在实际开发中,绘图是小,控制绘图为大,CSS对图片的控制力几乎没有,一旦需求出现细微变更,有可能就得重新绘图.&lt;/p&gt;

&lt;p&gt;如果能用SVG+JS控制曲线的动画效果替代,便可以对图片进行随意的操控,将大大减少重绘的概率,项目也显得”优雅”.&lt;/p&gt;

&lt;p&gt;图形动画领域很多东西都已一脉相承,一通百通的.动画算法也都是一致,图像处理算法也都是一致的.掌握SVG的贝塞尔曲线,肯定对于CSS3动画,Canvas的处理有很大帮助.&lt;/p&gt;

&lt;p&gt;下篇将介绍滤镜和动画(animation).&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>SVG学习[1]--简介及基本元素</title>
   <link href="http://www.blogways.net/blog/2016/08/18/web-svg-1.html"/>
   <updated>2016-08-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/08/18/web-svg-1</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#1st&quot;&gt;像素图与矢量图&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#2nd&quot;&gt;可伸缩矢量图形(SVG)&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#3rd&quot;&gt;基本SVG元素&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;小结&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a id=&quot;1st&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一像素图与矢量图&quot;&gt;一、像素图与矢量图&lt;/h2&gt;

&lt;h3 id=&quot;1像素图与矢量图的比较&quot;&gt;1、像素图与矢量图的比较&lt;/h3&gt;

&lt;p&gt;在万维网历史的大部分时间里，浏览器显示的图形都是像素图格式的。在像素图（如 GIF 或 JPEG 图像）中，文件包含图像中每个像素的颜色值。浏览器读取这些值并做出相应行动。它仅认识到单独的部分，而没有整体概念。&lt;/p&gt;

&lt;p&gt;总的说来，这一系统有其优势，例如忠实再现了摄影图像，但它在某些情形下显得不足。例如，尽管浏览器能以不同大小显示一个图像，但通常会产生锯齿边缘，在这些地方，浏览器不得不为那些在原始图像中不存在的像素插入或猜测数值。此外，像素图格式的二进制性质使得难以（尽管不是不可能）基于数据库信息动态地创建图像，并且动画最多也仅限于“翻动书本”类型的动画，即快速连续地显示单独图像。&lt;/p&gt;

&lt;p&gt;矢量图，通过指定为确定每个像素的值所需的指令而不是指定这些值本身，克服了这些困难中的一部分。例如，矢量图形不再为一个直径100px的圆提供像素值，而是告诉浏览器创建一个直径100px的圆，然后让浏览器（或插件）做其余事情。&lt;/p&gt;

&lt;p&gt;这消除了像素图的许多限制；使用矢量图，浏览器只要知道它必须画一个圆。如果图像需要以正常大小的三倍来显示，那么浏览器只要按正确的大小画圆而不必执行像素图通常的插入法。类似地，浏览器接收的指令可以更容易地与外部信息源（如应用程序和数据库）绑定，要对图像制作动画，浏览器只要接收有关如何操纵属性（如半径或颜色）的指令即可。&lt;/p&gt;

&lt;h3 id=&quot;2web上的矢量图&quot;&gt;2、web上的矢量图&lt;/h3&gt;
&lt;p&gt;Web 上的第一个矢量图可能是虚拟现实标记语言（VRML）图像。VRML 寻求将 HTML 的简易性带到图像创建中来，然而尽管有一些示例给人以深刻的印象，但它的本来目的是为了 3D 造型，而且它太过复杂以至于从未真正流行起来。&lt;/p&gt;

&lt;p&gt;接着是 Macromedia Flash 的介入。Flash 电影是用 Macromedia 的 Flash 应用程序所创建，它允许创建相当复杂的动画，并且将动画与声音和交互性绑定在一起。因为 Flash 文件主要包含有关如何创建图像的指令，所以它们比传统的 Web 电影小得多（例如 QuickTime 电影）— 而且它们可以缩放。&lt;/p&gt;

&lt;p&gt;但是，Flash 文件仍然是二进制文件，这使得动态创建它们比较困难（尽管不是不可能）。而且对从浏览器可以进行的脚本编制有所限制。&lt;/p&gt;

&lt;p&gt;直到出现可伸缩矢量图形(SVG)。&lt;/p&gt;

&lt;p&gt;&lt;a id=&quot;2nd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;二可伸缩矢量图形svg&quot;&gt;二、可伸缩矢量图形(SVG)&lt;/h2&gt;

&lt;h3 id=&quot;1使用文本定义图像&quot;&gt;1、使用文本定义图像&lt;/h3&gt;
&lt;p&gt;SVG通过使用 XML 定义图像、动画和交互性解决了这些问题中的许多问题。浏览器读取（或者更准确地说，浏览器的插件读取）这些基于文本的指令，然后执行这些指令。例如，一个简单的 SVG 矩形图像可能看起来如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot; ?&amp;gt;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.0//EN&quot;

 &quot;http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd&quot;&amp;gt;&lt;/span&gt;
	
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;svg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;300&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;100&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    	&lt;span class=&quot;nt&quot;&gt;&amp;lt;rect&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;x=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;25&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;y=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;280&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;height=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;50&quot;&lt;/span&gt;

          &lt;span class=&quot;na&quot;&gt;fill=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;red&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;stroke=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;blue&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;stroke-width=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/svg&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/c7jyb0yh&quot;&gt;效果展示&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个文档指示浏览器创建一个矩形，并提供属性信息，如位置（x, y）、大小（height, width）、颜色（fill, stroke）和线宽（stroke-width）。&lt;/p&gt;

&lt;h3 id=&quot;2在web浏览器中显示svg&quot;&gt;2、在Web浏览器中显示SVG&lt;/h3&gt;

&lt;p&gt;SVG文件是纯粹的XML，那是如何在Web浏览器中让SVG显示。要在浏览器中显示（前提是浏览器支持），可以通过几种方法来实现：&lt;/p&gt;

&lt;p&gt;假设我们有一个girls.svg文件：
&lt;img src=&quot;/images/girls.svg&quot; alt=&quot;girl&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用编辑器打开，可以看到一大串的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;&amp;lt;!DOCTYPE svg  PUBLIC '-//W3C//DTD SVG 1.1//EN'  'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;svg&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;enable-background=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;new 0 0 145 145&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Layer_1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;1.1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;viewBox=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;0 0 145 145&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xml:space=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;preserve&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2000/svg&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xlink=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/1999/xlink&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;g&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;path&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;M95.727,56.11c-2.29-3.814-4.565-6.092-4.617-6.146c-0.48-0.48-2.289,1.668-2.791,2.309   c-0.762,0.981-2.563,2.625-6.367,4.876c-3.802,2.255-9.599,5.132-18.35,8.687c-3.747,1.524-6.766,3.085-9.192,4.666   c3.136-0.364,6.856-0.784,7.613-0.815c2.007-0.082-0.404,4.203-9.474,2.116c-1.186,0.895-2.195,1.796-3.047,2.699   c-1.388,1.474-2.355,2.959-2.971,4.422c-0.617,1.463-0.877,2.9-0.876,4.246c0.005,3.039,1.285,3.753,2.512,5.495   c1.234,1.746,3.872,2.962,3.872,2.962s-0.704-1.33-1.719-2.789c-1.022-1.463-1.976-3.455-1.971-5.668   c0.001-1.004,0.188-2.065,0.665-3.201c0.275-0.653,0.652-1.335,1.149-2.038c0.466,2.206,1.478,6.081,3.454,10.021   c1.499,2.98,3.555,4.208,6.406,6.524c2.844,2.317,6.521,5.686,11.017,5.679c0.11,0,0.221-0.001,0.332-0.003   c3.876-0.057,7.15-3.391,9.724-5.757c3.87-3.555,6.308-7.082,7.847-12.521c1.531-5.446,2.713-11.542,3.009-15.689   c0.522-7.306,0.163-10.061-0.246-11.266c0.572,0.787,1.188,1.696,1.808,2.743c2.096,3.534,4.127,8.399,4.123,13.856   c-0.002,3.122-0.653,6.447-2.35,9.907c-1.698,3.459-4.452,7.06-8.7,10.68c0,0,9.238-5.66,11.119-9.493   c1.882-3.831,2.628-7.595,2.626-11.095C100.33,65.29,98.012,59.922,95.727,56.11z M77.582,69h11.677C89.259,69,89.259,75,77.582,69   z&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;path&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;M53.943,97.604c-0.348-0.031-0.705-0.008-1.062-0.028c-0.212-0.012-0.425-0.001-0.633-0.02   c-3.854-0.352-6.887-1.923-8.909-4.354c-2.018-2.434-3.053-5.744-2.744-9.682l0.018-0.214c0.262-2.885,1.129-5.415,2.495-7.631   c1.367-2.215,3.437-3.863,5.531-5.702c7.384-6.483,14.57-10.075,21.95-13.905c4.245-2.203,8.488-4.594,12.651-7.22   c0.93-0.589,1.652-1.372,2.303-2.16c0.65-0.79,1.234-1.593,1.838-2.262c0,0-8.906,4.272-12.152,5.812   c-9.81,4.656-19.593,9.548-28.099,16.587c-3.033,2.512-5.808,5.679-7.739,9.131c-1.279,2.286-2.037,4.649-2.252,7.027   c-0.347,3.803,0.713,7.618,3.108,11.164c1.28,1.9,2.797,3.31,4.487,4.276c1.689,0.967,3.541,1.487,5.471,1.66   c1.797,0.162,3.675-0.072,5.585-0.411l7.056-1.355l-7.128-0.644C55.143,97.622,54.545,97.659,53.943,97.604z&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;path&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;d=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;M49.823,71.043c0.97,0.317,1.875,0.565,2.726,0.76c0.576-0.435,1.197-0.869,1.86-1.301   C51.934,70.79,49.823,71.043,49.823,71.043z&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;fill=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;#FFFFFF&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/g&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/svg&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;暂且不需要知道这个代码怎么来的，后面会懂的。接下来，使用不同的方式，让浏览器能正常显示SVG图像。&lt;/p&gt;

&lt;h4 id=&quot;aiframe&quot;&gt;A、iframe&lt;/h4&gt;

&lt;p&gt;自从浏览器支持SVG，可以通过url来加载SVG图像。其中使用&amp;lt;iframe&amp;gt;嵌入SVG就是其中一种方式。如下面的示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;iframe src=&quot;/images/girls.svg&quot; width=&quot;200&quot; height=&quot;200&quot; &amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;bimg&quot;&gt;B、img&lt;/h4&gt;

&lt;p&gt;嵌入SVG图像还可以使用&amp;lt;img&amp;gt;元素加载图像一样。只需要将src的属性值更换成SVG图像对应的url，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;img src=&quot;/images/girls.svg&quot;  width=&quot;300&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cbackground-image&quot;&gt;C、background-image&lt;/h4&gt;
&lt;p&gt;自从浏览器支持SVG图像时，SVG图像就像像素图一样，可以通过background-image属性将SVG图像当做背景图片一样嵌入到HTML页面中。如下面的例子所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;div {
    background: url('/images/girls.svg') no-repeat center;
    background-size : 200px 200px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以通过background-size设置背景图像大小，告诉浏览器SVG图像以多大的尺寸显示。&lt;/p&gt;

&lt;h4 id=&quot;dsvg&quot;&gt;D、SVG&lt;/h4&gt;

&lt;p&gt;嵌入SVG图像到HTML页中，还可以直接使用&amp;lt;svg&amp;gt;元素，通过代码将SVG图像嵌入到HTML代码中。如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;
    &amp;lt;svg enable-background=&quot;new 0 0 145 145&quot; id=&quot;Layer_1&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 145 145&quot; xml:space=&quot;preserve&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&amp;gt;
        &amp;lt;g&amp;gt;
            &amp;lt;path d=&quot;M95.727,56.11c-2.29-3.814-4.565-6.092-4.617-6.146c-0.48-0.48-2.289,1.668-2.791,2.309   c-0.762,0.981-2.563,2.625-6.367,4.876c-3.802,2.255-9.599,5.132-18.35,8.687c-3.747,1.524-6.766,3.085-9.192,4.666   c3.136-0.364,6.856-0.784,7.613-0.815c2.007-0.082-0.404,4.203-9.474,2.116c-1.186,0.895-2.195,1.796-3.047,2.699   c-1.388,1.474-2.355,2.959-2.971,4.422c-0.617,1.463-0.877,2.9-0.876,4.246c0.005,3.039,1.285,3.753,2.512,5.495   c1.234,1.746,3.872,2.962,3.872,2.962s-0.704-1.33-1.719-2.789c-1.022-1.463-1.976-3.455-1.971-5.668   c0.001-1.004,0.188-2.065,0.665-3.201c0.275-0.653,0.652-1.335,1.149-2.038c0.466,2.206,1.478,6.081,3.454,10.021   c1.499,2.98,3.555,4.208,6.406,6.524c2.844,2.317,6.521,5.686,11.017,5.679c0.11,0,0.221-0.001,0.332-0.003   c3.876-0.057,7.15-3.391,9.724-5.757c3.87-3.555,6.308-7.082,7.847-12.521c1.531-5.446,2.713-11.542,3.009-15.689   c0.522-7.306,0.163-10.061-0.246-11.266c0.572,0.787,1.188,1.696,1.808,2.743c2.096,3.534,4.127,8.399,4.123,13.856   c-0.002,3.122-0.653,6.447-2.35,9.907c-1.698,3.459-4.452,7.06-8.7,10.68c0,0,9.238-5.66,11.119-9.493   c1.882-3.831,2.628-7.595,2.626-11.095C100.33,65.29,98.012,59.922,95.727,56.11z M77.582,69h11.677C89.259,69,89.259,75,77.582,69   z&quot;/&amp;gt;
            &amp;lt;path d=&quot;M53.943,97.604c-0.348-0.031-0.705-0.008-1.062-0.028c-0.212-0.012-0.425-0.001-0.633-0.02   c-3.854-0.352-6.887-1.923-8.909-4.354c-2.018-2.434-3.053-5.744-2.744-9.682l0.018-0.214c0.262-2.885,1.129-5.415,2.495-7.631   c1.367-2.215,3.437-3.863,5.531-5.702c7.384-6.483,14.57-10.075,21.95-13.905c4.245-2.203,8.488-4.594,12.651-7.22   c0.93-0.589,1.652-1.372,2.303-2.16c0.65-0.79,1.234-1.593,1.838-2.262c0,0-8.906,4.272-12.152,5.812   c-9.81,4.656-19.593,9.548-28.099,16.587c-3.033,2.512-5.808,5.679-7.739,9.131c-1.279,2.286-2.037,4.649-2.252,7.027   c-0.347,3.803,0.713,7.618,3.108,11.164c1.28,1.9,2.797,3.31,4.487,4.276c1.689,0.967,3.541,1.487,5.471,1.66   c1.797,0.162,3.675-0.072,5.585-0.411l7.056-1.355l-7.128-0.644C55.143,97.622,54.545,97.659,53.943,97.604z&quot;/&amp;gt;
            &amp;lt;path d=&quot;M49.823,71.043c0.97,0.317,1.875,0.565,2.726,0.76c0.576-0.435,1.197-0.869,1.86-1.301   C51.934,70.79,49.823,71.043,49.823,71.043z&quot; fill=&quot;#FFFFFF&quot;/&amp;gt;
        &amp;lt;/g&amp;gt;
    &amp;lt;/svg&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的示例将&amp;lt;svg&amp;gt;放在一个&amp;lt;div&amp;gt;元素中，只是用来说明SVG图像可以通过&amp;lt;svg&amp;gt;元素嵌入到HTML页面中。其实&amp;lt;svg&amp;gt;元素可以不放在一个&amp;lt;div&amp;gt;元素中。&lt;/p&gt;

&lt;p&gt;使用&amp;lt;svg&amp;gt;元素可以直接在HTML页面中嵌入SVG，而不是像前面几种方式那样，将SVG图像文件嵌入到页面当中。你可以设置width和height值，用来控制&amp;lt;svg&amp;gt;元素的大小，从而控制SVG图像的宽度和高度。&lt;/p&gt;

&lt;p&gt;使用&amp;lt;svg&amp;gt;元素嵌入SVG图像，还可以通过CSS给其定义一些样式，实现一些样式效果。&lt;/p&gt;

&lt;h4 id=&quot;eembed&quot;&gt;E、embed&lt;/h4&gt;

&lt;p&gt;早期将SVG图像嵌入到HTML页面中都是通过&amp;lt;embed&amp;gt;元素。当时并不是所有的浏览器都支持原生SVG。来看看怎么使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;embed src=&quot;/images/girls.svg&quot; width=&quot;300&quot; height=&quot;220&quot; type=&quot;image/svg+xml&quot; pluginspage=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;fobject&quot;&gt;F、object&lt;/h4&gt;

&lt;p&gt;&amp;lt;object&amp;gt;元素是HTML4的标准标签元素，被所有较新的流星器支持。它只不过是不允许使用脚本。这个刚好与&amp;lt;embed&amp;gt;标签元素相反：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;object data=&quot;/images/girls.svg&quot; width=&quot;300&quot; height=&quot;200&quot; type=&quot;image/svg+xml&quot; codebase=&quot;http://www.adobe.com/svg/viewer/install/&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;虽然将SVG图像嵌入到HTML页面中，让浏览器能显示。方法有很多种，但更建议使用&amp;lt;img&amp;gt;和&amp;lt;svg&amp;gt;这两种方式。当然，如果SVG图像是给元素做背景图时，可以使用background-image方式引入。&lt;/p&gt;

&lt;h3 id=&quot;3动画和交互性&quot;&gt;3、动画和交互性&lt;/h3&gt;

&lt;p&gt;因为xml文件这一结构，SVG 非常适合于动画和交互性。要更改图形元素的大小、位置或颜色，脚本只要调整相应的属性即可。&lt;/p&gt;

&lt;p&gt;事实上，SVG 有为事件处理而专门设计的属性（很象 HTML），甚至还有特别适合于动画的元素。例如，下面这一代码创建一个在 8 秒期间沿一条特定路线来回移动并无限重复的动画效果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;svg width=&quot;500&quot; height=&quot;300&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;

    &amp;lt;!-- Box around the image --&amp;gt;

    &amp;lt;rect x=&quot;1&quot; y=&quot;1&quot; width=&quot;498&quot; height=&quot;298&quot;

          fill=&quot;none&quot; stroke=&quot;blue&quot; stroke-width=&quot;2&quot;/&amp;gt;

    &amp;lt;!-- Visible path --&amp;gt;

    &amp;lt;path d=&quot;M0,300 S150,100 200,200 S400,400 500,0&quot;

          fill=&quot;none&quot; stroke=&quot;red&quot; stroke-width=&quot;2&quot;/&amp;gt;

    &amp;lt;!-- Group of elements to animate --&amp;gt;

    &amp;lt;g stroke-width=&quot;5&quot; stroke=&quot;black&quot;&amp;gt;

        &amp;lt;!-- Stick figure pieces --&amp;gt;

        &amp;lt;circle cx=&quot;0&quot; cy=&quot;-45&quot; r=&quot;10&quot; fill=&quot;black&quot;/&amp;gt;

        &amp;lt;line x1=&quot;-20&quot; y1=&quot;-30&quot; x2=&quot;0&quot; y2=&quot;-25&quot;/&amp;gt;

        &amp;lt;line x1=&quot;20&quot; y1=&quot;-30&quot; x2=&quot;0&quot; y2=&quot;-25&quot;/&amp;gt;

        &amp;lt;line x1=&quot;-20&quot; y1=&quot;0&quot; x2=&quot;0&quot; y2=&quot;-10&quot;/&amp;gt;

        &amp;lt;line x1=&quot;20&quot; y1=&quot;0&quot; x2=&quot;0&quot; y2=&quot;-10&quot;/&amp;gt;

        &amp;lt;line x1=&quot;0&quot; y1=&quot;-10&quot; x2=&quot;0&quot; y2=&quot;-45&quot;/&amp;gt;

        &amp;lt;!-- Animation controls --&amp;gt;

        &amp;lt;animateMotion path=&quot;M0,300 S150,100 200,200 S400,400 500,0&quot;

                       dur=&quot;8s&quot; repeatCount=&quot;indefinite&quot;

                       rotate=&quot;auto&quot;/&amp;gt;
    &amp;lt;/g&amp;gt;
&amp;lt;/svg&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/pccgzhed&quot;&gt;效果展示&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;3rd&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三基本-svg-元素&quot;&gt;三、基本 SVG 元素&lt;/h2&gt;

&lt;h3 id=&quot;1svg基本形状&quot;&gt;1、SVG基本形状&lt;/h3&gt;

&lt;p&gt;SVG 定义了六种基本形状，这些基本形状和路径(路径相对复杂，放到下一章单独讨论)一起，可以组合起来形成任何可能的图像。每个基本形状都带有指定其位置和大小的属性。它们的颜色和轮廓分别由 fill 和 stroke 属性确定。这些形状是:&lt;/p&gt;

&lt;p&gt;圆（circle）：显示一个圆心在指定点、半径为指定长度的标准的圆。&lt;/p&gt;

&lt;p&gt;椭圆（ellipse）：显示中心在指定点、长轴和短轴半径为指定长度的椭圆。&lt;/p&gt;

&lt;p&gt;矩形（rect）：显示左上角在指定点并且高度和宽度为指定值的矩形（包括正方形）。也可以通过指定边角圆的 x 和 y 半径画成圆角矩形。&lt;/p&gt;

&lt;p&gt;线条（line）：显示两个坐标之间的连线。&lt;/p&gt;

&lt;p&gt;折线（polyline）：显示顶点在指定点的一组线。&lt;/p&gt;

&lt;p&gt;多边形（polygon）：类似于 polyline，但增加了从最末点到第一点的连线，从而创建了一个闭合形状。&lt;/p&gt;

&lt;p&gt;下面示例演示了这些图形:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- 生成SVG画布 --&amp;gt;
&amp;lt;svg width=&quot;400&quot; height=&quot;200&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;

    &amp;lt;g&amp;gt;
		&amp;lt;!-- 圆 --&amp;gt;
    &amp;lt;circle cx=&quot;50&quot; cy=&quot;50&quot; r=&quot;25&quot; /&amp;gt;
			
		&amp;lt;!-- 椭圆 --&amp;gt;
    &amp;lt;ellipse cx=&quot;75&quot; cy=&quot;125&quot; rx=&quot;50&quot; ry=&quot;25&quot; /&amp;gt;
			
		&amp;lt;!-- 矩形 --&amp;gt;
    &amp;lt;rect x=&quot;155&quot; y=&quot;5&quot; width=&quot;75&quot; height=&quot;100&quot;/&amp;gt;
			
		&amp;lt;!-- 矩形 --&amp;gt;
    &amp;lt;rect x=&quot;250&quot; y=&quot;5&quot; width=&quot;75&quot; height=&quot;100&quot; rx=&quot;30&quot; ry=&quot;20&quot; /&amp;gt;
		
		&amp;lt;!-- 线条 --&amp;gt;
    &amp;lt;line x1=&quot;0&quot; y1=&quot;150&quot; x2=&quot;400&quot; y2=&quot;150&quot;
                         stroke-width=&quot;2&quot; stroke=&quot;blue&quot;/&amp;gt;
		&amp;lt;!-- 折线 --&amp;gt;
    &amp;lt;polyline points=&quot;50,175 150,175 150,125 250,200&quot; /&amp;gt;

		
		&amp;lt;!-- 多边形 --&amp;gt;
    &amp;lt;polygon points=&quot;350,75 379,175 355,175 355,200 345,200
                                      345,175 321,175&quot; /&amp;gt;
		
		&amp;lt;!-- 矩形 --&amp;gt;
    &amp;lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;400&quot; height=&quot;200&quot;
            fill=&quot;none&quot; stroke=&quot;red&quot; stroke-width=&quot;3&quot; /&amp;gt;
 &amp;lt;/g&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/8x9vna8i&quot;&gt;效果展示&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2添加文本&quot;&gt;2、添加文本&lt;/h3&gt;

&lt;p&gt;除了形状以外，SVG 图像还可以包含文本。SVG 给予设计人员和开发人员对文本的大量控制，可以获得很好的图形效果而不必借助失去真实纹理信息的图像(.gif或.jpg图像)，下面示例演示了文本的定义:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;svg width=&quot;400&quot; height=&quot;125&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;

    &amp;lt;desc&amp;gt;Basic text&amp;lt;/desc&amp;gt;

    &amp;lt;g&amp;gt;

    &amp;lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;400&quot; height=&quot;125&quot; fill=&quot;none&quot;

            stroke=&quot;blue&quot; stroke-width=&quot;3&quot;/&amp;gt;

     &amp;lt;text x=&quot;10&quot; y=&quot;50&quot; font-size=&quot;30&quot;&amp;gt;Welcome to the world of&amp;lt;/text&amp;gt;

&amp;lt;text x=&quot;10&quot; y=&quot;100&quot; font-size=&quot;40&quot;

       font-family=&quot;Monotype Corsiva&quot;

       fill=&quot;yellow&quot; stroke=&quot;red&quot;&amp;gt;Scalable Vector Graphics!&amp;lt;/text&amp;gt;

 &amp;lt;/g&amp;gt;

&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/7zol2wxr&quot;&gt;效果展示&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;3渲染顺序&quot;&gt;3、渲染顺序&lt;/h3&gt;

&lt;p&gt;当组合多种不同元素时，正象 SVG 图像一样，重要的是牢记各项在页面上的放置顺序，因为这关系到谁“在上面”出现。在一个 HTML 页面上，使用z-index属性来控制这一分层效果，而对于 SVG 图像，则严格按顺序放置各项。每个后继层放置在那些已放置层的上面。&lt;/p&gt;

&lt;p&gt;如果指定一个元素没有填充色（使用fill=”none””），那么在它下面的各项会显现出来，就象这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;svg width=&quot;400&quot; height=&quot;200&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;

    &amp;lt;g&amp;gt;

        &amp;lt;ellipse cx=&quot;125&quot; cy=&quot;50&quot; rx=&quot;50&quot; ry=&quot;25&quot;

                 fill=&quot;none&quot; stroke=&quot;black&quot; /&amp;gt;

        &amp;lt;circle cx=&quot;125&quot; cy=&quot;50&quot; r=&quot;25&quot; fill=&quot;dodgerblue&quot; /&amp;gt;

        &amp;lt;circle cx=&quot;125&quot; cy=&quot;50&quot; r=&quot;10&quot; fill=&quot;black&quot; /&amp;gt;

        &amp;lt;ellipse cx=&quot;250&quot; cy=&quot;50&quot; rx=&quot;50&quot; ry=&quot;25&quot;

                 fill=&quot;none&quot; stroke=&quot;black&quot; /&amp;gt;

        &amp;lt;circle cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;25&quot; fill=&quot;dodgerblue&quot; /&amp;gt;

        &amp;lt;circle cx=&quot;250&quot; cy=&quot;50&quot; r=&quot;10&quot; fill=&quot;black&quot; /&amp;gt;

        &amp;lt;polygon points=&quot;65,50 185,50 185,75, 150,100

                                          100,100 65,75&quot;

                 fill=&quot;none&quot; stroke=&quot;purple&quot; stroke-width=&quot;4&quot;/&amp;gt;

        &amp;lt;polygon points=&quot;190,50 310,50 310,75, 275,100

                                          225,100 190,75&quot;

                 fill=&quot;none&quot; stroke=&quot;purple&quot; stroke-width=&quot;4&quot;/&amp;gt;

        &amp;lt;line x1=&quot;65&quot; y1=&quot;50&quot; x2=&quot;310&quot; y2=&quot;50&quot;

              stroke=&quot;plum&quot; stroke-width=&quot;2&quot;/&amp;gt;

    &amp;lt;/g&amp;gt;

&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;http://runjs.cn/code/f6bhbbeu&quot;&gt;效果展示&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;请注意每个元素会覆盖在它之前出现的元素。&lt;/p&gt;

&lt;h3 id=&quot;4编组元素&quot;&gt;4、编组元素&lt;/h3&gt;

&lt;p&gt;最后，SVG 不仅仅可以定义单个元素,为兼顾可读性和方便性，将元素安排在一组中通常是个好办法。针对这一目的，SVG 提供 &amp;lt;g&amp;gt;&amp;lt;/g&amp;gt; 元素，它创建一个可以将元素置于其中的容器。这个容器可以用来标识元素，或提供一个公共属性（本地定义的属性将会覆盖公共属性）。例如上面渲染顺序使用的示例中:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	...
	&amp;lt;g stroke=&quot;red&quot; stroke-width=&quot;3&quot;&amp;gt;

      &amp;lt;ellipse cx=&quot;125&quot; cy=&quot;50&quot; rx=&quot;50&quot; ry=&quot;25&quot;

                           fill=&quot;none&quot; stroke=&quot;black&quot; /&amp;gt;

      &amp;lt;circle cx=&quot;125&quot; cy=&quot;50&quot; r=&quot;25&quot; fill=&quot;url(#irisGradient)&quot; /&amp;gt;

      &amp;lt;circle cx=&quot;125&quot; cy=&quot;50&quot; r=&quot;10&quot; fill=&quot;black&quot; /&amp;gt;

    &amp;lt;/g&amp;gt;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为&amp;lt;g&amp;gt;&amp;lt;\g&amp;gt;添加属性，则该属性将作用于g标签内部所有元素。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;end&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四小结&quot;&gt;四、小结&lt;/h2&gt;
&lt;p&gt;本文大致介绍了:&lt;/p&gt;

&lt;p&gt;像素图和矢量图的原理及优缺点;&lt;/p&gt;

&lt;p&gt;SVG本质(.XML);&lt;/p&gt;

&lt;p&gt;SVG的web显示方式(推荐使用&amp;lt;svg&amp;gt;标签、&amp;lt;img&amp;gt;标签、background-image);&lt;/p&gt;

&lt;p&gt;SVG的六种基本形状(&amp;lt;rect&amp;gt;、&amp;lt;circle&amp;gt;、&amp;lt;ellipse&amp;gt;、&amp;lt;line&amp;gt;、&amp;lt;polyline&amp;gt;、&amp;lt;polygon&amp;gt;);&lt;/p&gt;

&lt;p&gt;SVG的文本元素&amp;lt;text&amp;gt;和渲染顺序.&lt;/p&gt;

&lt;p&gt;下一篇将介绍元素的基本属性和复杂而强大的路径元素&amp;lt;path&amp;gt;.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CentOS下安装部署iot</title>
   <link href="http://www.blogways.net/blog/2016/07/22/install-iot-on-CentOS-6.5.html"/>
   <updated>2016-07-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/07/22/install-iot-on-CentOS-6.5</id>
   <content type="html">&lt;h1 id=&quot;一iot平台部署概述&quot;&gt;一、iot平台部署概述&lt;/h1&gt;
&lt;p&gt;亚信iot平台由：iot-web、iot-server、zookeeper、kafka、comsumer等模块组成。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;IOT-web&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;IOT-server&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;zookeeper&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;kafka&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;consumer&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h1 id=&quot;二iot-web部署&quot;&gt;二、iot-web部署&lt;/h1&gt;

&lt;h2 id=&quot;21手工编译部署配置&quot;&gt;2.1、手工编译、部署、配置&lt;/h2&gt;

&lt;p&gt;2.1.1. git获取源代码：git clone http://10.20.16.78:3000/iot/iot-web.git&lt;/p&gt;

&lt;p&gt;2.1.2. 编译源代码：mvn clean install 得到war包：iot-web-1.0-SNAPSHOT.war&lt;/p&gt;

&lt;p&gt;2.1.3. 将war包部署到tomcat根【部署方案请参见网络tomcat根部署方法】&lt;/p&gt;

&lt;p&gt;2.1.4. 配置$IOT-WEB-SETUP-PATH/WEB-INF/classes/spring/consumer-dubbo.xml，修改zookeeper正确地址即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dubbo:registry address=&quot;zookeeper://192.168.10.149:2181?backup=192.168.10.154:2181&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.1.5. 停启tomcat即可&lt;/p&gt;

&lt;p&gt;2.1.6. 浏览器打开：http://192.168.10.149:8080/createuser/index.html 看页面是否打开成功&lt;/p&gt;

&lt;h2 id=&quot;22自动化编译部署配置&quot;&gt;2.2、自动化编译、部署、配置&lt;/h2&gt;

&lt;p&gt;自动化构建只要遵守jenkins相关方法即可，为了使自动化部署相对直观，需要添加构建后的触发器，当构建：成功、失败、不稳定时，发送相应邮件到指定人员（自动化构建平台管理员、开发人员、测试人员）。&lt;/p&gt;

&lt;h1 id=&quot;三iot-server部署&quot;&gt;三、iot-server部署&lt;/h1&gt;

&lt;h2 id=&quot;31手工编译部署配置&quot;&gt;3.1、手工编译、部署、配置&lt;/h2&gt;

&lt;p&gt;3.1.1. git获取源代码：git clonehttp://10.20.16.78:3000/iot/iot-server.git&lt;/p&gt;

&lt;p&gt;3.1.2. 编译源代码：mvn clean install 得到war包：iot-server.jar&lt;/p&gt;

&lt;p&gt;3.1.3. copy目标文件到运行目录：&lt;/p&gt;

&lt;p&gt;3.1.4. iot-server服务的启停：./operateServer.sh start、./operateServer.sh stop&lt;/p&gt;

&lt;p&gt;3.1.5. 检测服务是否在zookeeper中注册成功&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：注意在生产环境中调整启动脚本中的java虚拟机的内存分配。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;32自动化编译部署配置&quot;&gt;3.2、自动化编译、部署、配置&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;自动化构建只要遵守jenkins相关方法即可，为了使自动化部署相对直观，需要添加构建后操作的触发器，当构建：成功、失败、不稳定时，发送相应邮件到指定人员（自动化构建平台管理员、开发人员、测试人员）。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;四zookeeper安装部署&quot;&gt;四、zookeeper安装部署&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。
ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。【百度百科】
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;建议：目前部署只使用2台zookeeper服务器，部署版本为zookeeper-3.3.6，理论zookeeper的安装部署集群主机数量需要大于等于3台，建议zookeeper集群主机数量为奇数【因为集群涉及选举leader，部署数量为奇数有利于提高整个系统平台的稳定性与健壮性，zookeeper主机的数量越多整个集群的稳定性越强】。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;41zookeeper安装步骤&quot;&gt;4.1、zookeeper安装步骤&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载zookeeper，版本：zookeeper-3.3.6&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;解压zookeeper到指定目录，如：/root/iot/zookeeper-3.3.6&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置zookeeper的配置文件，路径及文件名为：$ZOOKEEPER_HOME/conf/zoo.conf，&lt;strong&gt;见：注1&lt;/strong&gt;；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置myid文件，根据zoo.conf文件配置myid文件，myid文件只需要配置一个数字编号；&lt;strong&gt;见：注2；&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;zookeeper的启停方法、及状态查询；&lt;strong&gt;见：注3&lt;/strong&gt;；&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;注1：zoo.cfg内容如下：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial
# synchronization phase can take
initLimit=5
# The number of ticks that can pass between
# sending a request and getting an acknowledgement
syncLimit=2
# the directory where the snapshot is stored.
# the port at which the clients will connect

dataDir=/root/iot/data
dataLogDir=/root/iot/dataLog
clientPort=2181
server.1=192.168.10.149:2888:3888
server.2=192.168.10.154:2889:3889
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;注2：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;您看到配置文件中有如下内容：server.1=192.168.10.149:2888:3888，说明如下：192.168.10.149主机需要根据server后的编号配置：/root/iot/data/myid文件；文件中写入：server.x中的x编号；例如本配置，只需在myid文件写入1，即可；同理：192.168.10.154的相应的myid文件写入2；如果配置不正确，则整个zookeeper集群可能无法正常运行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注3：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;启动：$ZOOKEEPER_HOME/bin/zkServer.sh start&lt;/p&gt;

&lt;p&gt;停止：$ZOOKEEPER_HOME/bin/zkServer.sh stop&lt;/p&gt;

&lt;p&gt;状态：$ZOOKEEPER_HOME/bin/zkServer.sh status&lt;/p&gt;

&lt;p&gt;日志：tail -f zookeeper.log&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;zookeeper.log文件刚开始可能不正确认，因为当整个zookeeper集群未完全启动完成时，每个zookeeper节点会去尝试连接配置文件中配置的主机，固会出现连接错误，只有在所有主机节点主机全部启动完成后，如果没有错误信息，则表示整个zookeeper集群成功运行。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;42zookeeper启停及进程查看&quot;&gt;4.2、zookeeper启停及进程查看&lt;/h2&gt;

&lt;p&gt;启动：$ZOOKEEPER_HOME/bin/zkServer.sh start&lt;/p&gt;

&lt;p&gt;停止：$ZOOKEEPER_HOME/bin/zkServer.sh stop&lt;/p&gt;

&lt;p&gt;状态：$ZOOKEEPER_HOME/bin/zkServer.sh status&lt;/p&gt;

&lt;h2 id=&quot;43zookeeper运行日志查看&quot;&gt;4.3、zookeeper运行日志查看&lt;/h2&gt;

&lt;p&gt;启动zookeeper后，默认在启动中径下生成zookeeper.log日志文件；可以通过more、vi、tail查看日志。&lt;/p&gt;

&lt;h2 id=&quot;44zookeeper配置文件说明&quot;&gt;4.4、zookeeper配置文件说明&lt;/h2&gt;

&lt;p&gt;zookeeper配置文件路径：$ZOOKEEPER_HOME/conf/zoo.cfg&lt;/p&gt;

&lt;p&gt;配置文件zoo.cfg内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# The number of milliseconds of each tick
tickTime=2000
# The number of ticks that the initial

# synchronization phase can take
initLimit=5
# The number of ticks that can pass between

# sending a request and getting an acknowledgement
syncLimit=2
# the directory where the snapshot is stored.
# the port at which the clients will connect

dataDir=/root/iot/data
dataLogDir=/root/iot/dataLog
clientPort=2181

# zookeeper集群主机信息
server.1=192.168.10.149:2888:3888
server.2=192.168.10.154:2889:3889
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;zookeeper提供log4j的日志方式，请参见zookeeper的说明文档。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;五kafka&quot;&gt;五、kafka&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;待补充
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;六consumer&quot;&gt;六、consumer&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;待补充
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;七整体iot部署说明&quot;&gt;七、整体iot部署说明&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;由于整个iot系统由多个子模块组成，这其中涉及软件模块的编译、主机的启停、单元测试、系统检验（启停是否成功），故使用jenkins插件：pipeline可以串联整个模块。通过jenkins插件创建pipeline项目之后，设定一个开始项目后，再设定该项目的：构建后操作指定执行的下一步骤即可。

pipeline例程如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/pipeline-flow.jpg&quot; alt=&quot;pipeline&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;触发其它构建后动作如下：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/triger-other-project.jpg&quot; alt=&quot;triger-other-project&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注：pipeline插件并不创建真正的一个jenkins项目，它只是把之前创建的jenkins项目作一个串联并可视化，通过可视化的流程可以看到一个workflow工程经历哪些步骤。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;八其它&quot;&gt;八、其它&lt;/h1&gt;

&lt;p&gt;暂无&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>CentOS下安装keepalived</title>
   <link href="http://www.blogways.net/blog/2016/07/13/install-keepalived-on-CentOS.html"/>
   <updated>2016-07-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/07/13/install-keepalived-on-CentOS</id>
   <content type="html">&lt;h3 id=&quot;一keepalived概述&quot;&gt;一、keepalived概述&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;keepalived是一个类似于layer3, 4 &amp;amp; 7交换机制的软件，也就是我们平时说的第3层、第4层和第7层交换。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Keepalived的作用是检测服务器的状态，如果有一台web服务器死机，或工作出现故障，Keepalived将检测到，并将有故障的服务器从系统中剔除，当服务器工作正常后Keepalived自动将服务器加入到服务器群中，这些工作全部自动完成，不需要人工干涉，需要人工做的只是修复故障的服务器。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Layer3,4&amp;amp;7工作在IP/TCP协议栈的IP层，TCP层，及应用层,原理分别如下：
Layer3：Keepalived使用Layer3的方式工作式时，Keepalived会定期向服务器群中的服务器发送一个ICMP的数据包（既我们平时用的Ping程序）,如果发现某台服务的IP地址没有激活，Keepalived便报告这台服务器失效，并将它从服务器群中剔除，这种情况的典型例子是某台服务器被非法关机。Layer3的方式是以服务器的IP地址是否有效作为服务器工作正常与否的标准。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Layer4:如果您理解了Layer3的方式，Layer4就容易了。Layer4主要以TCP端口的状态来决定服务器工作正常与否。如web server的服务端口一般是80，如果Keepalived检测到80端口没有启动，则Keepalived将把这台服务器从服务器群中剔除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Layer7：Layer7就是工作在具体的应用层了，比Layer3,Layer4要复杂一点，在网络上占用的带宽也要大一些。Keepalived将根据用户的设定检查服务器程序的运行是否正常，如果与用户的设定不相符，则Keepalived将把服务器从服务器群中剔除。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要用作RealServer的健康状态检查以及LoadBalance主机和BackUP主机之间failover的实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;注：摘自百度全科&lt;/p&gt;

&lt;h3 id=&quot;二keepalived在centos安装步骤&quot;&gt;二、keepalived在CentOS安装步骤&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注：以上安装请以root用户操作，当然您也可以使用有root权限的其它用户操作&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;1、安装gcc（g++)
	安装步骤：略；&lt;/p&gt;

&lt;p&gt;2、安装openssl&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.1、下载源码：https://www.openssl.org/source/openssl-1.0.1t.tar.gz
2.2、静态库编译：./configure --prefix=/usr/local/ssl --openssldir=/usr/local/ssl、make、make install
2.3、动态库编译：./configure shared --prefix=/usr/local/ssl --openssldir=/usr/local/ssl、make、make install

注意：一定要编译2次哦，否则keepalived无法找到动态库文件。
2.4、配置环境变量：LD_LIBRARY_PATH=/usr/local/lib64/，【可以ll查看：/usr/local/lib64目录的内容】
2.5、配置系统环境变量：.bash_profile，export LD_LIBRARY_PATH

注意：别忘了让系统环境变更生效（. .bash_profile)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、安装pcre 【Perl Compatible Regular Expressions】&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.1、下载pcre，地址：http://sourceforge.net/projects/pcre/files/
3.2、常规安装，步骤：./configure、make、make install
3.3、配置环境变量：PCRE_HOME、LD_LIBRARY_PATH、export PCRE_HOME LD_LIBRARY_HOME
3.4、. .bash_profile使环境变量生效
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、安装keepalived&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4.1、下载keeepalived，下载地址：
4.2、安装步骤：./configure --prefix=/usr/local/keepalived &amp;amp; make &amp;amp; make instal
4.3、keepalived常规配置
	4.3.1、cp /usr/local/keepalived/sbin/keepalived /usr/sbin/
	4.3.2、cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/
	4.3.3、cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/
	4.3.4、chkconfig --add keepalived
	4.3.5、chkconfig keepalived on
	4.3.6、mkdir /etc/keepalived
	4.3.7、ln -s /usr/local/sbin/keepalived /usr/sbin/
	4.3.8、cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/keepalived.conf
4.4、keepalived配置文件配置
	修改keepalived配置文件：/etc/keepalived/keepalived.conf，如下：

	global_defs {
	    notification_email {
	        xuwn@asiainfo.com
	    }
		    notification_email_from xuwn@asiainfo.com
		    smtp_server 127.0.0.1
		    smtp_connect_timeout 30
		    router_id lnmp_node1
		}
		vrrp_instance lnmp {
		    state MASTER
		    interface eth0
		    virtual_router_id 100
		    priority 170
		    advert_int 5
		    track_interface {
		        eth0
	    }
	    authentication {
	        auth_type PASS
	        auth_pass 123456
	    }
	    virtual_ipaddress {
	        192.168.10.2
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5、keepalived系统日志配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5.1、修改文件：/etc/sysconfig/keepalived，把KEEPALIVED_OPTIONS=&quot;-D&quot; 修改为KEEPALIVED_OPTIONS=&quot;-D -d -S 0&quot;
5.2、修改文件：/etc/rsyslog.conf 在最后添加：
	# keepalived -S 0 
	local0.* /var/log/keepalived.log
5.3、重新启动操作系统日志：/etc/init.d/rsyslog restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6、keepalived启停方法和查看日志&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6.1、/etc/init.d/keepalived start
6.2、/etc/init.d/keepalived stop
6.3、/etc/init.d/keepalived restart

6.4、tailf /var/log/keepalived.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;7、关闭CentOS系统防火墙&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;7.1、service iptables   stop  #停止
7.2、chkconfig iptables off   #禁用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;8、nginx安装及配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;8.1、安装步骤：略； &amp;gt; **注意编译命令应为如下：./configure --prefix=/usr/local/nginx --without-http_gzip_module**

8.2、配置
	server {
		listen       80;
		server_name  localhost:8080;

		location / {
	        proxy_pass http://localhost:8080 ;
		}
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注：以上配置为将对浏览器中：localhost的访问映射为：http://localhost:8080，即tomcat的web服务&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>RHEL5.5下安装jekyll</title>
   <link href="http://www.blogways.net/blog/2016/07/07/install-jekyll-on-RHEL.html"/>
   <updated>2016-07-07T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/07/07/install-jekyll-on-RHEL</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;[jekyll] 是一款简单的博客系统，静态网站生成器。她有一个模版目录，存放整个静态网站的模版文件，可以通过[Liquid]处理模版文件，把使用标记语言[Textile]或[Markdown]编写的内容文件，按照模版格式，转换成最终的静态网站页面。大名鼎鼎的GitHub Pages就是通过她实现的。废话少说了，经过好几天的弯路，终于明白之前安装不上是因为公司RHEL系统的问题。感谢公司同事及时的帮助，让我少走很多的弯路。&lt;/p&gt;

&lt;h3 id=&quot;二安装步骤&quot;&gt;二、安装步骤&lt;/h3&gt;
&lt;p&gt;注：以上安装请以root用户操作。&lt;/p&gt;

&lt;p&gt;1、安装：ruby-2.3.1&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.1、下载ruby-2.3.1源代码
1.2、./configure --prefix=/usr/local/ruby
1.3、make
1.4、make install
1.5、设置ruby环境变量
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、生成key&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2.1、gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、安装稳定版RVM&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.1、curl -L -k https://raw.githubusercontent.com/wayneeseguin/rvm/master/binscripts/rvm-installer | bash -s stable
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、删除源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4.1、gem sources --remove https://rubygems.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5、添加国内镜像源&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5.1、gem sources -a http://ruby.sdutlinux.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6、安装nodejs，并设置nodejs的环境变量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6.1、NODEJS_HOME=安装路径
6.2、PATH=$PATH:$NODEJS_HOME/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三检查rhel55安装jekyll是否成功&quot;&gt;三、检查RHEL5.5安装jekyll是否成功&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll -v
如果打印出版本信息，则表示安装成功。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四jekyll操作&quot;&gt;四、jekyll操作&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;3.1、获取源码，并运行jekyll，命令如下:

	cd ~
	mkdir webroot
	cd webroot
	git clone https://github.com/mojombo/tpw.git
	cd tpw
	jekyll --server

3.2、在浏览器访问`localhost:4000`，显示博客列表。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五其它&quot;&gt;五、其它&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;4.1、安装ruby时无需安装openssl；
4.2、使用jekyll生成的表态HTML文件，在运行：jekyll --server后只能在本机访问，如果需要通过http://ip:4000来访问，请使用nginx或tomcat。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery.dataTables 自定义排序</title>
   <link href="http://www.blogways.net/blog/2016/07/06/datatables-sort.html"/>
   <updated>2016-07-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/07/06/datatables-sort</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;strong&gt;目 录&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#intro&quot;&gt;遇到问题&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#names&quot;&gt;官方更新说明&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#reference&quot;&gt;参考文献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最近在项目中用到了 jQuery.dataTables， 这是一个很强大的 jQuery 插件，调用方便，支持回调对数据进行排序、查询、分页等操作，并且 bootstrap 框架也有对其封装，省了我们界面设计的活。dataTables 自带了string，date，numeric 的排序，但当遇到比较特殊的排序需求时，就得另寻出路了。&lt;/p&gt;

&lt;h2 id=&quot;一遇到问题-&quot;&gt;一、遇到问题 &lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这几天做项目时，正好碰到一个需求，要对下面的分秒的形式进行排序&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\MM-SS.jpg&quot; alt=&quot;mm-ss&quot; /&gt;&lt;/p&gt;

&lt;p&gt;而 dataTables 的自带排序会将这一列视为 string 排序。 显然是不满足我们需求的。一开始以为要大动干戈，后来看了API文档后发现，dataTables 的第三方扩展支持还是很灵活的。&lt;/p&gt;

&lt;h2 id=&quot;二解决方案&quot;&gt;二、解决方案&lt;a name=&quot;names&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;官方文档中提供了两种方法：&lt;/p&gt;

&lt;p&gt;(1) Type based column sorting ;&lt;/p&gt;

&lt;p&gt;(2) Custom data source sorting&lt;/p&gt;

&lt;p&gt;还有一种是在服务端在查数据库时进行排序处理&lt;/p&gt;

&lt;p&gt;这里我主要使用第一种和第三种&lt;/p&gt;

&lt;h3 id=&quot;一type-based-column-sorting&quot;&gt;（一）Type based column sorting&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;主要思路&lt;/strong&gt;：主要思路就是将单元格内容转成可排序的 int 类型&lt;/p&gt;

&lt;p&gt;1.首先创建一个文件叫 dataTables.sort.plungin.js ，加入以下代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend(jQuery.fn.dataTableExt.oSort, {
	&quot;MM-SS-pre&quot;: function (a) {
    	var x = String(a).replace(/&amp;lt;[\s\S]*?&amp;gt;/g, &quot;&quot;);    //去除html标记
    	x = x.replace(/&amp;amp;nbsp;/ig, &quot;&quot;);                   //去除空格
   	    x = x.split('分')[0]*60 + x.split('分')[1].split('秒')[0]           
    	return x;
	},

    &quot;MM-SS-asc&quot;: function (a, b) {                //正序排序引用方法
        return ((a &amp;lt; b) ? -1 : ((a &amp;gt; b) ? 1 : 0));
    },

    &quot;MM-SS-desc&quot;: function (a, b) {                //倒序排序引用方法
        return ((a &amp;lt; b) ? 1 : ((a &amp;gt; b) ? -1 : 0));
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.在前台页面中加入以下的 js 引用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script type=&quot;text/javascript&quot; src=&quot;jquery.dataTables.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.前台JS里添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;aoColumnDefs&quot;: [{ &quot;sType&quot;: &quot;html-percent&quot;, &quot;aTargets&quot;: [8] }]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二在服务端添加排序&quot;&gt;(二)在服务端添加排序&lt;/h3&gt;

&lt;p&gt;因为表里数据为Number格式，存的是秒，可以直接进行排序&lt;/p&gt;

&lt;p&gt;从前端可以获得两个参数&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sortIdx = req.query.iSortCol_0 || -1;
var sortDir = req.query.sSortDir_0 || '';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这俩个参数分别代表所点击列的索引号和该列是升序还是逆序&lt;/p&gt;

  	if (sortIdx !== -1 &amp;amp;&amp;amp; sortDir !== ‘‘&amp;amp;&amp;amp; baseFieldNames !== undefined &amp;amp;&amp;amp;	baseFieldNames.length &amp;gt;= sortIdx) {
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  	if (sortIdx === '0') {
    	sort = { 'departId-avg': -1 };
  	} else {
    	sortDir = sortDir === 'asc' ? 1 : -1;
    	sort[baseFieldNames[sortIdx]] = sortDir;
  	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整合的sort在查表时添加即可。&lt;/p&gt;

&lt;h2 id=&quot;四参考文献&quot;&gt;四、参考文献&lt;a name=&quot;reference&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://datatables.net/plug-ins/sorting/#how_to_data_source&quot;&gt;https://datatables.net/plug-ins/sorting/#how_to_data_source&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>bootstrap的响应式布局</title>
   <link href="http://www.blogways.net/blog/2016/06/05/web-bootstrap.html"/>
   <updated>2016-06-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/06/05/web-bootstrap</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#responsive&quot;&gt;响应式设计(Responsive Web Design)&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#tools&quot;&gt;栅格系统和媒体查询&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#bootstrap&quot;&gt;Bootstrap的响应式布局&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#end&quot;&gt;小结&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#doc&quot;&gt;参考文献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;一响应式设计responsive-web-design-&quot;&gt;一、响应式设计(Responsive Web Design) &lt;a name=&quot;responsive&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;起源&quot;&gt;起源&lt;/h3&gt;

&lt;p&gt;响应式网页设计最初是出自 Ethan Marcotte 在A List Apart发表过一篇文章”Responsive Web Design”，文中援引了响应式建筑设计的概念：&lt;/p&gt;

&lt;p&gt;最近出现了一门新兴的学科——”响应式建筑(responsive architecture)”——提出，物理空间应该可以根据存在于其中的人的情况进行响应。结合嵌入式机器人技术以及可拉伸材料的应用，建筑师们正在尝试建造一种可以根据周围人群的情况进行弯曲、伸缩和扩展的墙体结构；还可以使用运动传感器配合气候控制系统，调整室内的温度及环境光。已经有公司在生产”智能玻璃”：当室内人数达到一定的阀值时，这种玻璃可以自动变为不透明，确保隐私。&lt;/p&gt;

&lt;p&gt;将这个思路延伸到Web设计的领域，我们就得到了一个全新的概念。
为什么一定要为每个用户群各自打造一套设计和开发方案？Web设计应该做到根据不同设备环境自动响应及调整。当然响应式Web设计不仅仅是关于屏幕分辨率自适应以及自动缩放的图片等等，它更像是一种对于设计的全新思维模式；我们应当向下兼容、移动优先。&lt;/p&gt;

&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;

&lt;p&gt;PC互联网加速向移动端迁移：2012年12月底我国网民规模达到5.64亿，互联网普及率为42.1%，手机用户占网民总数的74.5%。预计到2015年，移动互联网的数据流量将超越PC端的流量。&lt;/p&gt;

&lt;p&gt;移动端入口：当用户希望通过手机来完成PC页的操作时，常见的是商家的运营微博，期文案足够吸引用户点击链接参加活动，如果该活动页没做响应式处理：页面体积大、请求多、体验差、兼容性差，层层阻碍最终导致用户放弃参加。&lt;/p&gt;

&lt;h3 id=&quot;目的&quot;&gt;目的&lt;/h3&gt;

&lt;p&gt;因为越来越多的智能移动设备（ mobile, tablet device ）加入到互联网中来，移动互联网不再是独立的小网络了，而是成为了 Internet 的重要组成部分。响应式网络设计 （ RWD / AWD）的出现，目的是为移动设备提供更好的体验，并且整合从桌面到手机的各种屏幕尺寸和分辨率，用技术来使网页适应从小到大（现在到超大）的不同分辨率的屏幕。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;注： Responsive Web Design ＝ RWD，Adaptive Web Design ＝ AWD&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;方法论&quot;&gt;方法论&lt;/h3&gt;

&lt;p&gt;RWD：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;采用 CSS 的 media query 技术&lt;/li&gt;
  &lt;li&gt;流体布局（ fluid grids ）&lt;/li&gt;
  &lt;li&gt;自适应的图片/视频等资源素材
（为小、中、大屏幕做一些优化，目的是让任何尺寸的屏幕空间都能得到充分利用）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;AWD：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CSS media query 技术（仅针对有限几种预设的屏幕尺寸设计）&lt;/li&gt;
  &lt;li&gt;用 Javascript 来操作 HTML 内容&lt;/li&gt;
  &lt;li&gt;在服务器端操作 HTML 内容（比如为移动端减少内容，为桌面端提供更多内容）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;设计思路&quot;&gt;设计思路&lt;/h3&gt;

&lt;p&gt;Mobile First（从移动端开始，RWD ）：
一切从最小屏幕的移动端开始（比如 iPhone 的 320px ），先确定内容，然后逐级往大屏幕设计。
不同于原来网页设计，总是从桌面电脑的 1024px 开始的。
之所以从最小的屏幕开始设计，并不是因为移动端的重要性高于PC端，而是因为以最小的屏幕开始，可以从一开始就知道，哪些内容是必须的，哪些内容是次要的，减少开发受到的阻碍。&lt;/p&gt;

&lt;h2 id=&quot;二栅格系统和媒体查询-&quot;&gt;二、栅格系统和媒体查询 &lt;a name=&quot;tools&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏(portrait)、横屏(landscape)，怎样才能做到让一种设计方案满足所有情况？&lt;/p&gt;

&lt;p&gt;那么我们的布局应该是一种弹性的栅格布局，不同尺寸下弹性适应，如以下页面中各模块在不同尺寸下的位置：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/diffSize.jpg&quot; alt=&quot;gridSystem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么,我们应该如何实现呢?&lt;/p&gt;

&lt;h3 id=&quot;栅格系统grid-system&quot;&gt;栅格系统(Grid System)&lt;/h3&gt;

&lt;p&gt;栅格系统英文为“grid systems”，也有人翻译为“网格系统”，运用固定的格子设计版面布局，其风格工整简洁，是web页面设计的主流风格之一,是响应式设计的一种实现。&lt;/p&gt;

&lt;p&gt;从上图中可以看到，一个页面可以拆分成多个区块来理解，而正是这些区块共同构成了这个页面的布局。根据不同的屏幕尺寸情况，调整这些区块的排版，就可以实现响应式设计。另外，屏幕宽度较大的时候，区块倾向于水平分布，而屏幕宽度较小的时候，区块倾向于竖直堆叠。
这些方方正正的区块是不是和栅格系统的格子挺相似？对的，为了让响应式设计更简单易用，于是有了很多称为“栅格”（grid）的样式库。
栅格样式库一般是这样做的：将页面划分为若干等宽的列（column），然后推荐你通过等宽列来创建响应式的页面区块。
虽然看起来都是这样的思路，但不同的栅格样式库，在方法和表现上有各自的特点。
在第三节，本文将以bootstrap为例，介绍它的Grid System简要原理和用法。&lt;/p&gt;

&lt;h3 id=&quot;媒体查询media-queries&quot;&gt;媒体查询(Media Queries)&lt;/h3&gt;

&lt;p&gt;在CSS中，有一个极其实用的功能：@media 响应式布局。具体来说，就是可以根据客户端的介质和屏幕大小，提供不同的样式表或者只展示样式表中的一部分。通过响应式布局，可以达到只使用单一文件提供多平台的兼容性，省去了诸如浏览器判断之类的代码。&lt;/p&gt;

&lt;p&gt;下面大致介绍一些Media的用法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在 head 链接CSS文件时提供判断语句，选择性加载不同的CSS文件&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;middle.css&quot; media=&quot;screen and (min-width: 400px)&quot;&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这句意味在满足 media 的判断语句 screen and (min-width: 400px) 即 屏幕并且最小宽度不小于400px 的介质上面使用 middle.css 。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;在CSS文件中分段书写不同设备的代码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@media screen and (min-width: 600px) { /* CSS Code */ }  
@media screen and (max-width: 1200px) { /* CSS Code */ }  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;写在 @media 语句段外的是共用代码，第一个 @media 当屏幕宽度以及大于最小宽度600px时执行内部CSS代码 ，第二个 @media 当屏幕宽度小于最大宽度1200px时执行内部CSS代码。&lt;/p&gt;

&lt;p&gt;反应灵敏的栅格系统，搭配上合理的媒体查询，就可以让web页面具备良好的响应性。&lt;/p&gt;

&lt;p&gt;下面将以bootstrap为例，介绍bootstrap的响应式设计。&lt;/p&gt;

&lt;h2 id=&quot;三bootstrap的响应式布局-&quot;&gt;三、Bootstrap的响应式布局 &lt;a name=&quot;bootstrap&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;Bootstrap是Twitter推出的一个用于前端开发的开源工具包。它由Twitter的设计师Mark Otto和Jacob Thornton合作开发,是一个CSS/HTML框架,目前最新版本是v3.3.6(bootstap 4.0即将推出)。
Bootstrap的内容包括三大部分,分别是:全局CSS样式、通用组件以及Javascript插件。
由于响应式设计的实现主要是基于栅格系统和媒体查询,所以直接了解bootstrap的Grid System 和 Media Query。&lt;/p&gt;

&lt;h3 id=&quot;31-布局容器container和栅格系统grid-system&quot;&gt;3.1 布局容器(container)和栅格系统(Grid System)&lt;/h3&gt;

&lt;h3 id=&quot;布局容器container&quot;&gt;布局容器(container)&lt;/h3&gt;
&lt;p&gt;页面内容和栅格系统需要用到一个容器将其包裹起来，为此，bootstrap提供了两个作此用处的类: &lt;font color=&quot;red&quot;&gt;.container .container-fluid&lt;/font&gt;。&lt;/p&gt;

&lt;p&gt;注意，由于 padding 等属性的原因，这两种 容器类不能互相嵌套。&lt;/p&gt;

&lt;font color=&quot;red&quot;&gt;.container&lt;/font&gt;
&lt;p&gt;类用于固定宽度并支持响应式布局的容器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;font color=&quot;red&quot;&gt;.container-fluid&lt;/font&gt;
&lt;p&gt;类用于 100% 宽度，占据全部视区(viewport)的容器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container-fluid&quot;&amp;gt;
  ...
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;栅格系统grid-system-1&quot;&gt;栅格系统(Grid System)&lt;/h3&gt;

&lt;p&gt;Bootstrap提供了一套响应式的流式栅格系统，随着屏幕或视区(viewport)尺寸的增加，系统会自动分为最多12列。它包含了易于使用的预定义类，还有强大的mixin用于生成更具语义的布局。&lt;/p&gt;

&lt;p&gt;栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。下面就介绍一下 Bootstrap 栅格系统的工作原理：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;“行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。&lt;/li&gt;
  &lt;li&gt;通过“行（row）”在水平方向创建一组“列（column）”。&lt;/li&gt;
  &lt;li&gt;你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为行（row）”的直接子元素。&lt;/li&gt;
  &lt;li&gt;类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。&lt;/li&gt;
  &lt;li&gt;通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。&lt;/li&gt;
  &lt;li&gt;栅格系统中的列是通过指定1到12的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。&lt;/li&gt;
  &lt;li&gt;如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。&lt;/li&gt;
  &lt;li&gt;栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-md-* 栅格类适用于与屏幕宽度大于或等于分界点大小的设备,并且针对小屏幕设备覆盖栅格类。因此，在元素上应用任何 .col-lg-* 不存在，也影响大屏幕设备。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;容器（container），行（row）和列（column）之间的层级关系。一个正确的写法示例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;  
    &amp;lt;div class=&quot;row&quot;&amp;gt;  
        &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;&amp;lt;/div&amp;gt;  
        &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;&amp;lt;/div&amp;gt;  
    &amp;lt;/div&amp;gt;  
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;row（.row）必须位于container的内部，column（如.col-md-6）必须位于row的内部。也就是说，container、row、column必须保持特定的层级关系，栅格系统才可以正常工作。
为什么需要这样？查看这些元素的样式，会发现container有15px的水平内边距，row有-15px的水平负外边距，column则有15px的水平内边距。这些边距是故意的、相互关联的，也因此就像齿轮啮合那样，限定了层级结构。
这些边距其实也是Bootstrap栅格的精巧之处。
如果要嵌套使用栅格，正确的做法是在column内直接续接row，然后再继续接column，而不再需要container：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;   
    &amp;lt;div class=&quot;row&quot;&amp;gt;   
        &amp;lt;div class=&quot;col-md-8&quot;&amp;gt;   
            &amp;lt;div class=&quot;row&quot;&amp;gt;   
                &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;&amp;lt;/div&amp;gt;   
                &amp;lt;div class=&quot;col-md-6&quot;&amp;gt;&amp;lt;/div&amp;gt;   
            &amp;lt;/div&amp;gt;   
        &amp;lt;/div&amp;gt;   
        &amp;lt;div class=&quot;col-md-4&quot;&amp;gt;&amp;lt;/div&amp;gt;   
    &amp;lt;/div&amp;gt;   
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;32-媒体查询media-grid&quot;&gt;3.2 媒体查询(Media Grid)&lt;/h3&gt;
&lt;p&gt;Bootstrap栅格的column对应的类名形如.col-xx-y。
y是数字，表示该元素的宽度占据12列中的多少列。而xx只有特定的几个值可供选择，分别是xs、sm、md、lg，它们就是断点类型。
在Bootstrap栅格的设计中，断点的意义是，当视口（viewport）宽度小于断点时，column将竖直堆叠（display: block的默认表现），而当视口宽度大于或等于断点时，column将水平排列（float的效果）。按照xs、sm、md、lg的顺序，断点像素值依次增大，其中xs表示极小，即认为视口宽度永远不小于xs断点，column将始终水平浮动。
有时候，会需要将多种断点类型组合使用，以实现更细致的响应式设计。此时不同的断点类型之间会有怎样的相互作用呢？
先看看Bootstrap的sass源码是如何定义栅格的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@include make-grid-columns;   
@include make-grid(xs);   
@media (min-width: $screen-sm-min) {   
  @include make-grid(sm);   
}   
@media (min-width: $screen-md-min) {   
  @include make-grid(md);   
}   
@media (min-width: $screen-lg-min) {   
  @include make-grid(lg);   
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，用了min-width的写法，而且断点像素值越大的，对应代码越靠后。所以，如果有这样的一些元素：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;   
    &amp;lt;div class=&quot;row&quot;&amp;gt;   
        &amp;lt;div class=&quot;col-sm-6 col-lg-3&quot;&amp;gt;1&amp;lt;/div&amp;gt;   
        &amp;lt;div class=&quot;col-sm-6 col-lg-3&quot;&amp;gt;2&amp;lt;/div&amp;gt;   
        &amp;lt;div class=&quot;col-sm-6 col-lg-3&quot;&amp;gt;3&amp;lt;/div&amp;gt;   
        &amp;lt;div class=&quot;col-sm-6 col-lg-3&quot;&amp;gt;4&amp;lt;/div&amp;gt;   
    &amp;lt;/div&amp;gt;   
&amp;lt;/div&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;那么它们应该是这样的效果：
&lt;img src=&quot;/images/gridSystem.png&quot; alt=&quot;gridSystem&quot; /&gt;&lt;/p&gt;

&lt;p&gt;结合前面的源码，可以想到，在上面这样视口宽度由小变大的过程中，首先是保持默认的竖直堆叠，然后超过了sm的断点，sm的样式生效，变为一行两列的排版，再继续超过lg的断点后，lg的样式也生效，由于lg的样式代码定义在sm之后，所以会覆盖掉sm的样式，从而得到一行四列的排版。
所以，结合使用多个断点类型，就可以引入多个断点变化，把响应式做得更加细致。&lt;/p&gt;

&lt;p&gt;通过下表可以详细查看Bootstrap的栅格系统和媒体查询是如何在多种屏幕设备上工作的。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;超小屏幕 手机 (&amp;lt;768px)&lt;/th&gt;
      &lt;th&gt;小屏幕 平板 (≥768px)&lt;/th&gt;
      &lt;th&gt;中等屏幕 桌面显示器 (≥992px)&lt;/th&gt;
      &lt;th&gt;大屏幕 大桌面显示器 (≥1200px)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;栅格系统行为&lt;/td&gt;
      &lt;td&gt;总是水平排列&lt;/td&gt;
      &lt;td&gt;开始是堆叠在一起的，当大于这些阈值时将变为水平排列&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;.container最大宽度&lt;/td&gt;
      &lt;td&gt;None（自动&lt;/td&gt;
      &lt;td&gt;750px&lt;/td&gt;
      &lt;td&gt;970px&lt;/td&gt;
      &lt;td&gt;1170px&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;类前缀&lt;/td&gt;
      &lt;td&gt;.col-xs-&lt;/td&gt;
      &lt;td&gt;.col-sm-&lt;/td&gt;
      &lt;td&gt;.col-md-&lt;/td&gt;
      &lt;td&gt;.col-lg-&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;列（column）数&lt;/td&gt;
      &lt;td&gt;12&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;最大列（column）宽&lt;/td&gt;
      &lt;td&gt;自动&lt;/td&gt;
      &lt;td&gt;~62px&lt;/td&gt;
      &lt;td&gt;~81px&lt;/td&gt;
      &lt;td&gt;~97px&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;槽（gutter）宽&lt;/td&gt;
      &lt;td&gt;30px(每列左右均有 15px)&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;可嵌套&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;偏移（Offsets）&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;列排序&lt;/td&gt;
      &lt;td&gt;是&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;当然，bootstrap只预定义了基本的媒体查询，bootstrap鼓励用户对其进行扩展，用户可结合项目实际情况，添加、修改媒体查询的规则，让自己的页面在不同的设备环境准确响应。&lt;/p&gt;

&lt;h2 id=&quot;四小结-&quot;&gt;四、小结 &lt;a name=&quot;end&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;完整且层次分明的栅格系统，可扩展的媒体查询，bootstrap基于这两者，构建了自己的强大的响应式布局功能，让用户能够轻松的为自己的页面实现响应式设计。
当然，这也仅仅是技术上的实现，而响应式设计是一种设计方式和理念，还更多的包括前期对页面展示的规划和设计，如何让页面展示得自然、全面，让用户在不同的设备上得到到同样优质的体验，也是响应式设计的重点内容。&lt;/p&gt;

&lt;h2 id=&quot;五参考文献-&quot;&gt;五、参考文献 &lt;a name=&quot;doc&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://getbootstrap.com/&quot;&gt;http://getbootstrap.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jb51.net/css/362199.html/&quot;&gt;http://www.jb51.net/css/362199.html/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://isux.tencent.com/responsive-web-design.html&quot;&gt;http://isux.tencent.com/responsive-web-design.html/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>怎样设计才能让网站看起来高大上</title>
   <link href="http://www.blogways.net/blog/2016/05/23/web-design.html"/>
   <updated>2016-05-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/05/23/web-design</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#intro&quot;&gt;高大上页面的定义&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#names&quot;&gt;网页设计的切入点&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#replace&quot;&gt;总结4个方面做到高大上的网页&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#reference&quot;&gt;参考文献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;最近在构思重新设计博客的网页，想追求页面高大上有质感让人感觉耳目一新的感觉。所以最近在翻看学习很多国内外的优秀网站，从而也总结出了一些关于高大上网页设计的一些观点和想法。&lt;/p&gt;

&lt;h2 id=&quot;一高大上网页的定义-&quot;&gt;一、高大上网页的定义 &lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;现在说到高大上的页面大家的定义基本趋向于极简风，就是用最少的图片和文字能够表达突出网页的所有关键信息。不仅仅理解为视觉层面上如何更好，一个网站不仅仅只有视觉，最终的结果是多方因素的完美结合。核心就是图片的选择编辑，字体的选择和排版。&lt;/p&gt;

&lt;h2 id=&quot;二网页设计的切入点&quot;&gt;二、网页设计的切入点&lt;a name=&quot;names&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;让人感受“高大上”，首先设计需要具备一定的冲击力，高大上，设计感，是最后结果给人的一种感觉。这种评价其实反映出设计的精准感：内容上不多不少，刚刚好；风格上不偏不倚，很舒服。要达到这种精准，首先需要明确这个网站是用来干什么的，满足了用户那些需求，满足了商业上的那些要求。了解了解行业和市场，研究研究同类产品和竞争对手等删去不需要的内容，从而让整个网站更加简洁。&lt;/p&gt;

&lt;h2 id=&quot;三总结以下4个方面做到高大上的网页-&quot;&gt;三、总结以下4个方面做到高大上的网页 &lt;a name=&quot;replace&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;1-质感美图&quot;&gt;1 质感美图&lt;/h3&gt;
&lt;p&gt;图片是渲染气氛最有效的方式，一张高质量的图片本身具备的美感已经足以提网页的质量。
传说中的「黑白噪点压大字，高端大气上档次」就抓住了精髓。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/0e189b48a0cd7f750c18657f3633ae84_r.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-字体变化&quot;&gt;2 字体变化&lt;/h3&gt;
&lt;p&gt;字体排版地好可以画面有层次感，仅仅字体的对比就能产生很多美感。一个设计画面上出现两种字体是标配。但是超过两种字体会让观众分心，这样传递的效果就不强了。一般来说，一个酷炫的字体会搭配一个比较普通的字体，一个做标题，一个做正文。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/9193c9e42577b21733411543cf8979e3_r.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-遵循简单&quot;&gt;3 遵循简单&lt;/h3&gt;
&lt;p&gt;网站并不需要用到很多的特效和大量过分夸张的动画，遵循简单有效的布局，利用细节去改变网站，通过段落的排版，字体的选择，图文的穿插等细节的方式提升美感。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/6b1d1d94bf124949e2c75425255f8ea8_r.png&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-恰当留白&quot;&gt;4 恰当留白&lt;/h3&gt;
&lt;p&gt;留白给人以奢侈的感觉，页面寸土寸金，不到万不得已就没必要把它塞得过满。留白可以更好的凸显主体，适当的留白还能产生别样的意味。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/1f536769af2146ca11e42eed0fb5b8d7_b.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h2&gt;&lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;简单布局、恰当留白、对比关系、就连宋小宝也可以变成国际大片的感觉~~~ 还有什么是设计不能拯救的呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/06ccb6f63f20bd26b86550e99f198c15_b.jpg&quot; alt=&quot;Alt text&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四参考文献&quot;&gt;四、参考文献&lt;a name=&quot;reference&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://baike.baidu.com/link?url=3qsr0wpF6bpD1mZX8HV7ADuuxLHaxn-Ygxa7h0Rdnm9eBUt_or9Cq_uEn_6Z2A8Is4RkT1NcJ7O4ZspX3PvJIMUa4dCkYxaRGbPXrSAEbkq7Lrq0w49ZV-juQCtu341oihS8vkJ4ONYvQejmCBiYVC7GY_V6LB8xxaGXgRwczhARBTJFy3QmEeDCPAcDMLAB9W1AeCkCvllHYSec0ewflCkFD1-vfvn-1Eq1SxnYf8YmQyHULcRhLhYmadr8ww3E2vfOfliys4Rojt2fueux_a&quot;&gt;破茧成蝶：用户体验设计师的成长之路&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.yixieshi.com/16085.html/&quot;&gt;https://http://www.yixieshi.com/16085.html/&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>AIX主机性能监控命令</title>
   <link href="http://www.blogways.net/blog/2016/05/01/AIX-HostMonitor.html"/>
   <updated>2016-05-01T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/05/01/AIX-HostMonitor</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#cpu&quot;&gt;获取CPU数据&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#mem&quot;&gt;获取内存/SWAP数据&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#disk&quot;&gt;获取磁盘数据&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#dir&quot;&gt;获取目录数据&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;一获取cpu数据-&quot;&gt;一、获取CPU数据 &lt;a name=&quot;cpu&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;mpstat是MultiProcessor Statistics的缩写，用于收集和显示系统中的所有处理器的性能统计，并且得到详细的单个处理器的运行状况。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   $mpstat
   
   System configuration: lcpu=16 mode=Capped 
   
   cpu  min  maj  mpc  int   cs  ics   rq  mig lpa sysc us sy wa id   pc
     0 184046638 214424  274 3908673210 3782119157 1326252330    0 26139925 100 6707390946  1  1  0 98 0.14
     1 7171412 14613  254 193245713 154941530 78622875    0 1126081 100 693934930  0  0  0 100 0.14
     2 170845575 230472  101 1308931839 2167522165 818427086    0 26083149 100 4900640467  1  1  0 99 0.14
     3 3193293 7611  101 236575152 198239437 153835438    0 1207732 100 139876648  0  0  0 100 0.14
     4 159868990 227718  129 1130251601 1850725273 692517872    0 12009046 100 2854042300  1  1  0 99 0.14
     5 5647834 30697  101 195761607 162561260 82402841    0 1132055 100 362309277  0  0  0 100 0.14
     6 157000962 211598  128 1099788787 1740814939 640685578    0 11993602 100 2992005605  1  1  0 99 0.14
     ......
   ALL 1370435922 2192633 3012 14099748600 18474769270 6889638308    1 139959495 100 36629470849  0  0  0 99 2.29
   
   #该命令检测系统中全部处理器的利用情况，并且给出各项的总和。下面是几个常用的输出项
   #lcpu: 工作的逻辑处理器的个数 
   #us: 运行的用户程序所占用的 CPU 百分比 
   #sy: 运行的内核程序所占用的 CPU 百分比 
   #wa: CPU 用来等待 IO 所占用的百分比 
   #id: CPU 空闲且不等待 IO 所占用的百分比
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但在实际使用中，往往会加上 -a 参数，即 mpstat -a ，以宽输出模式显示所有的统计信息，下面来感受一下……&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $mpstat -a
    
    
System configuration: lcpu=16 mode=Capped 

cpu    min    maj   mpcs   mpcr    dev   soft    dec     ph     cs    ics  bound     rq   push S3pull  S3grd  S0rd  S1rd  S2rd  S3rd  S4rd  S5rd   sysc    us    sy    wa    id    pc   ilcs   vlcs  istol  bstol S3hrd S4hrd S5hrd
  0 184061070 214424    150    124 4310333 590469189 3306344682 8099285 3782890620 1326486636      0      0      0   7911 172073  98.9   0.0   0.0   1.0   0.0   0.0 6707965194   0.7   1.2   0.0  98.1  0.14      0 2681118967    0.0    0.0 100.0   0.0   0.0
  1 7171412  14613    167     87 4313856 1079722 186685547 1177054 154944893 78624637      0      0      0    579     21  98.6   1.4   0.0   0.0   0.0   0.0 693937155   0.0   0.1   0.0  99.9  0.14     17 200960974    0.0    0.0  99.4   0.0   0.6
  2 170859397 230472      3     98 4311630 24093376 1267078359 13630503 2167851281 818525974      1      1      0   3487  23722  98.1   0.0   0.0   1.9   0.0   0.0 4900880379   0.6   0.8   0.0  98.6  0.14     68 1049149272    0.0    0.0 100.0   0.0   0.0
  3 3193904   7611      3     98 4314206 1526924 229574778 1176611 198256684 153848135      0      0      0    266     44  99.2   0.7   0.0   0.1   0.0   0.0 139878645   0.0   0.1   0.0  99.9  0.14     30 275388781    0.0    0.0  99.7   0.0   0.3
  4 159881624 227718     33     96 4312115 20541062 1104121880 1401356 1850937520 692592197      0      0      0   4393  27574  99.0   0.0   0.0   0.9   0.0   0.1 2854195957   0.5   0.6   0.0  98.8  0.14     60 905205613    0.0    0.0  99.9   0.0   0.1
  5 5647840  30697      3     98 4314215 1797627 188492566 1175045 162579018 82411800      0      0      0    129    978  98.6   1.4   0.0   0.0   0.0   0.0 362318106   0.0   0.1   0.0  99.9  0.14     27 203720025    0.0    0.0  99.3   0.0   0.7
  6 157024188 211598     32     96 4313516 22509032 1071873739 1262410 1741141601 640807004      0      0      0   4196  10466  98.9   0.0   0.0   1.1   0.0   0.0 2992221777   0.5   0.8   0.0  98.7  0.14     56 876887437    0.0    0.0  99.9   0.0   0.1
  ......
ALL 1370536873 2192649   1506   1506 69017506 783158186 13210473966 38730670 18477226175 6890502684      1      1      0  38922 271366  98.8   0.1   0.0   1.1   0.0   0.0 36632650675   0.3   0.4   0.0  99.3  2.29    596 10830086125    0.0    0.0  99.9   0.0   0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出的结果很详细，但也很混乱，让人眼花缭乱，没关系，我们可以将结果格式化处理，得到我们想要的数据.&lt;/p&gt;

&lt;h4 id=&quot;例1获取当前主机总cpu使用率&quot;&gt;例1:获取当前主机总CPU使用率&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $mpstat -a|grep ALL|awk '{printf &quot;当前主机总CPU使用率=%s&quot;,$24+$25}'
    当前主机总CPU使用率=0.7
    
    #通过 grep ALL 仅输出总计一行的数据,再使用 awk 命令,将第24、25域,也就是us和sy两列的数据相加获得完整的CPU使用率
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;例2显示所有处理器的cpu使用率&quot;&gt;例2:显示所有处理器的CPU使用率&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $mpstat -a|sed -n '5,$'p|sed '$d'|awk '{print &quot;cpu&quot;$1&quot;使用率:&quot;,$24+$25}'
    cpu0使用率: 1.9
    cpu1使用率: 0.1
    cpu2使用率: 1.4
    cpu3使用率: 0.1
    cpu4使用率: 1.1
    cpu5使用率: 0.1
    cpu6使用率: 1.3
    cpu7使用率: 0.1
    cpu8使用率: 1.2
    cpu9使用率: 0.2
    cpu10使用率: 1.3
    cpu11使用率: 0.2
    cpu12使用率: 1.2
    cpu13使用率: 0.1
    cpu14使用率: 1.3
    cpu15使用率: 0.1
    
    # sed -n '5,$'p 命令表示取第5行到最后一行的数据
    # sed '$d' 命令表示删除最后一行
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二获取内存swap数据-&quot;&gt;二、获取内存/SWAP数据 &lt;a name=&quot;mem&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;想要获取主机当前内存使用情况，可通过svmon -G来显示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $svmon -G
                   size       inuse        free         pin     virtual   mmode
    memory     65667072    12659615    53007457     3591255     7719427     Ded
    pg space    8388608       20086
    
                   work        pers        clnt       other
    pin         1719367           0           0     1871888
    in use      7719427           0     4940188
    
    PageSize   PoolSize       inuse        pgsp         pin     virtual
    s    4 KB         -    10953407       20086     2153575     6013219
    m   64 KB         -      106638           0       89855      106638


    # 其中,内存情况可查看memory一行
    # pg space一行即SWAP的情况
    # size -- 总容量
    # inuse -- 已使用量
    # free -- 空闲量
    # 另外,这里还有一个要注意的地方
    # 比如上图中,pg space的size为8388608,而这里的单位是页,并不是平常的KB、MB等，这涉及到内存段(segment)的知识，这里就不加以赘述，仅说明换算方式
    # 1页=4KB 1MB=256页
    # 所以,此处pg space的size实际上是 33554432KB 32768MB
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;知道了命令,下面来看看具体的例子。&lt;/p&gt;

&lt;h4 id=&quot;例1获取当前主机内存和swap的总容量已使用量和使用率&quot;&gt;例1:获取当前主机内存和SWAP的总容量、已使用量和使用率&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $svmon -G|grep -E 'memory|pg space'|awk '{if($1==&quot;memory&quot;){print $1,$2/256&quot;M&quot;,$3/256&quot;M&quot;,$3/$2} else {print $1$2,$3/256&quot;M&quot;,$4/256&quot;M&quot;,$4/$3}}'
    memory 256512M 49452.9M 0.19279
    pgspace 32768M 78.4609M 0.00239444
    
    # grep -E 'memory|pg space' 仅输出带有 memory 和 pg space 的两行
    # awk 命令中,首先判断一下当前行是memory还是pg space,因为pg space中有个空格,此处占了两个域,所以必须先判断
    # 之后根据不同情况,输出结果就可以了
    # 值得一提的是,awk的if条件语句与shell的语句是不一样的
    # awk 的if条件语句格式:
    # if(表达式){
    #       语句1
    #     }else if{
    #       语句2
    #     }else{
    #       语句3
    #     }
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;例2获取当前主机内存占用top10的进程的id名称内存占用量&quot;&gt;例2:获取当前主机内存占用top10的进程的id、名称、内存占用量&lt;/h4&gt;

&lt;p&gt;查看进程情况可使用ps命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ps -elf
         F S      UID     PID    PPID   C PRI NI ADDR    SZ    WCHAN    STIME    TTY  TIME CMD
    200003 A     root       1       0   0  60 20 1070187480  1688            Dec 24      -  0:00 /etc/init 
    240001 A     root 1114204  918412   0  60 20 80288480   992            Dec 24      -  0:00 /usr/bin/X11/aixconsole 
    240001 A     root 1245188       1   0  60 20 15b01db480   980            Dec 24      -  0:00 /usr/sbin/srcmstr 
    240001 A     root 1310854       1   0  60 20 2f00af590   428 f1000000a05fc098   Dec 24      -  0:00 /usr/ccs/bin/shlap64 
    240001 A     root 1638646 1377066   0  60 20 4b04cb480   940 f1000e00002a0878   Dec 24   vty2  0:00 /bin/ksh /usr/lib/assist/assist_main 
    240001 A     root 1704120 1245188   0  60 20 a00020480  2452            Dec 24      -  2:13 sendmail: accepting connections 
    40001 A     root 1769708       1   0  60 20 3702b7480   308            Dec 24      -  0:00 /opt/freeware/cimom/pegasus/bin/CIM_diagd 
    240001 A     root 1835192       1   0  60 20 3102b1480  5224 f1000a0a003be4b0   Dec 24      -  0:09 /opt/ibm/director/cimom/bin/tier1slp 
    41001 A     root 1900728       1   0  60 20 1890309480  4500            Dec 24      -  0:11 ./slp_srvreg -D 
    ......
     
    #options:
    # -e 将除内核进程以外所有进程的信息写到标准输出。
    # -l 生成长列表
    # -f 生成一个完整列表
    
    #字段:
    #PID -- 进程ID
    #SZ -- 内存占用量(单位仍是页)
    #CMD -- 内存名
    
    #由此可见,通过ps命令再加上一些格式化处理命令应该可以得到我们想要的结果
      
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面开始尝试输出进程的id、名称、内存占用量&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $ps -elf|sort -rn +9|head -10|awk 'BEGIN{print &quot;PID&quot;,&quot;PNAME&quot;,&quot;SZ&quot;}{print $4,$15,$10}'
    PID PNAME SZ
    2621660 2031:33 3885164
    1639166 ora_lgwr_rhjftst 108252
    1376752 ora_mmon_rhjftst 98324
    1245552 ora_cjq0_rhjftst 97868
    1704826 ora_dbw0_rhjftst 97824
    917888 ora_pmon_rhjftst 97660
    2687194 ora_ckpt_rhjftst 97584
    1049374 ora_smon_rhjftst 95628
    1311046 ora_dbw1_rhjftst 95232
    2752842 0:35 94932
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果让人失望,由于各行的域数量不一致,导致$15无法一直指向进程名所在的域。在经过一系列尝试后，仍然不能单用命令得到进程名，所以改用脚本来获取。&lt;/p&gt;

&lt;h4 id=&quot;用脚本的方式获取&quot;&gt;用脚本的方式获取&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $vi test.sh
    
    
# !/bin/sh

    tops='';
    rst=`ps -ealf|sort -rn +9|head -10|awk '{print $4,$10/256}'`
    cnt=0

    for item in ${rst[*]}
    do
        if [[ $((cnt%2)) -eq 0 ]]
        then
            tops=&quot;${tops}${item},&quot;`ps $item|grep -v PID|awk '{printf &quot;%s,&quot;,$5}'`
        else
            tops=&quot;${tops}&quot;&quot;${item}&quot;&quot;\`&quot;
        fi
        let cnt=$cnt+1
    done

    tops=${tops%\`}
    echo $tops
    
    # 整体思路是先得到top10的进程id和所占内存大小,循环通过id去获得对应的进程名称
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    # 输出结果
    $./test.sh
    2621660,/altibase/bin/altibase,15176.4`1639166,ora_lgwr_rhjftst,422.859`1376752,
    ora_mmon_rhjftst,384.078`1245552,ora_cjq0_rhjftst,382.297`1704826,ora_dbw0_rhjftst,
    382.125`917888,ora_pmon_rhjftst,381.484`2687194,ora_ckpt_rhjftst,381.188`1049374,
    ora_smon_rhjftst,373.547`1311046,ora_dbw1_rhjftst,372`2752842,oraclerhjftst,370.828
    
    # 为了展示效果,稍微调整一下格式
    #2621660,/altibase/bin/altibase,3885164`
    #1639166,ora_lgwr_rhjftst,108252`
    #1376752,ora_mmon_rhjftst,98324`
    #1245552,ora_cjq0_rhjftst,97868`
    #1704826,ora_dbw0_rhjftst,97824`
    #917888,ora_pmon_rhjftst,97660`
    #2687194,ora_ckpt_rhjftst,97584`
    #1049374,ora_smon_rhjftst,95628`
    #1311046,ora_dbw1_rhjftst,95232`
    #2752842,oraclerhjftst,94932
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不得不承认这是一个笨方法,但对于效率没有多少影响,在找到新方法之前,可以先用着。&lt;/p&gt;

&lt;h2 id=&quot;三获取磁盘数据-&quot;&gt;三、获取磁盘数据 &lt;a name=&quot;disk&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;lvps命令可以显示物理卷的相关信息&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $lspv
    hdisk0          00c5cc969e7f0175                    rootvg          active
    hdisk1          00c5cc96a1c7d95e                    datavg          active
    hdisk2          00c5cc96a1c7e1a9                    datavg          active
    hdisk3          00c5cc96a1c7e863                    dicvg           active
    hdisk4          00c5cc96a1c7ef0b                    dicvg           active
    
    # 单独使用lspv可以得到所有物理卷的物理卷名称(pvname)、物理卷ID(pvid)、卷组名称(vgname)以及状态(status)
    
    $lspv hdisk0
    PHYSICAL VOLUME:    hdisk0                   VOLUME GROUP:     rootvg
    PV IDENTIFIER:      00c5cc969e7f0175 VG IDENTIFIER     00c5cc9600004c000000012e9e7f11e5
    PV STATE:           active                                     
    STALE PARTITIONS:   0                        ALLOCATABLE:      yes
    PP SIZE:            512 megabyte(s)          LOGICAL VOLUMES:  16
    TOTAL PPs:          558 (285696 megabytes)   VG DESCRIPTORS:   2
    FREE PPs:           414 (211968 megabytes)   HOT SPARE:        no
    USED PPs:           144 (73728 megabytes)    MAX REQUEST:      1 megabyte
    FREE DISTRIBUTION:  111..03..77..111..112                      
    USED DISTRIBUTION:  01..109..34..00..00                        
    MIRROR POOL:        None
    
    # 使用lspv pvname 则会显示该pv的详细信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;pp（physial partition）是一个物理分区，vg由pv组成，pv里边的最小分配单位就是pp,pp size就是vg里最小分配单位大小,
该物理卷的总容量=TOTAL PPS*PP SIZE/1024,单位是GB。
所以,想要得到所有物理卷的总容量、已使用量、已使用百分比,还是得通过脚本。&lt;/p&gt;

&lt;h4 id=&quot;例1物理卷的总容量已使用量已使用百分比&quot;&gt;例1:物理卷的总容量、已使用量、已使用百分比&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $vi test.sh
        #!/bin/sh
        
        disks=`lspv|awk '{print $1}'`
        
        for disk in $disks
        do
            printf $disk&quot;: &quot;
            lspv $disk|sed -n '5,8p'|awk '{if(NR==1){size=$3}else if(NR==2){total=$3*size/1024}else if(NR==4){used=$3*size/1024}else{}}END{print  &quot;总容量:&quot;total,&quot;已使用量&quot;used,&quot;已使用百分比&quot;used/total}'
        done
    
    $./test.sh
    hdisk0: 总容量:279 已使用量72 已使用百分比0.258065
    hdisk1: 总容量:279 已使用量279 已使用百分比1
    hdisk2: 总容量:279 已使用量276.5 已使用百分比0.991039
    hdisk3: 总容量:279.25 已使用量279.25 已使用百分比1
    hdisk4: 总容量:279.25 已使用量271 已使用百分比0.970457
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四获取目录数据-&quot;&gt;四、获取目录数据 &lt;a name=&quot;dir&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;查看目录情况,一般使用du命令
下面是一些常用选项
-a	显示目录下所有子目录和文件的磁盘使用情况,与-s相对
-g	用 GB 单位统计;
-k	用 1024 字节单位统计;
-m	用 MB 单位统计;
-r	报告不可访问的文件或者目录名,此为缺省设置;
-s	仅显示指定目录的整体磁盘使用情况,不显示子目录及文件使用情况,与-a相对。&lt;/p&gt;

&lt;h4 id=&quot;例1仅获取目录整体磁盘使用情况用gb单位统计&quot;&gt;例1:仅获取目录整体磁盘使用情况,用GB单位统计&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $du -sg $dirname
    3.65    /ngbss/crmdev/.pangu
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;例2显示指定目录下所有子目录及文件磁盘使用情况用mb单位统计&quot;&gt;例2:显示指定目录下所有子目录及文件磁盘使用情况,用MB单位统计&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $du -am $dirname
    
    ......
    0.14    /ngbss/crmdev/.pangu/test/pangu-monitor/test/main.o
    0.00    /ngbss/crmdev/.pangu/test/pangu-monitor/test/monitor.template
    8.13    /ngbss/crmdev/.pangu/test/pangu-monitor/test
    75.58   /ngbss/crmdev/.pangu/test/pangu-monitor
    0.00    /ngbss/crmdev/.pangu/test/runmon.sh
    163.58  /ngbss/crmdev/.pangu/test
    3734.79 /ngbss/crmdev/.pangu
    
    #此命令会在最后一行显示指定目录的整体磁盘使用情况
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;例3显示指定目录下大文件top10&quot;&gt;例3:显示指定目录下大文件Top10&lt;/h4&gt;

&lt;p&gt;本以为会很简单,只要使用降序,再取前10行就可以了&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $du -am $dirname|sort -rn|head -10
    3734.79 /ngbss/crmdev/.pangu
    3347.17 /ngbss/crmdev/.pangu/log
    2045.48 /ngbss/crmdev/.pangu/log/4Glog-20150210
    326.80  /ngbss/crmdev/.pangu/log/134_32_28_198
    310.17  /ngbss/crmdev/.pangu/log/134_32_28_197
    300.05  /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.2
    300.04  /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_127_01.log.2015-02-10.0
    300.02  /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.1
    300.02  /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.0
    300.01  /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_127_01.log.2015-02-10.2
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然而并不是,上面的结果除了文件,还包含着目录。
如果想要只输出文件,必须另寻他法。
尝试过其他很多方法,比如find,比如ls,虽然能达到想要的结果,但是执行效率都不高,没有du来得快,若想用du,关键在于判断该行地址是否是目录。
观察整个命令流程,最有可能可以判断的地方只能是在awk环节。
于是研究了awk的用法后,发现awk的’{}’中,是可以可以执行系统命令及shell命令的。
通过system(cmd)结合getline[var]便可以实现。
于是……&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    $du -am $dirname|sort -rn|awk '{cmd=&quot;test -d &quot;$2&quot;;echo $?&quot;;cmd|getline rst;if(rst==1){print &quot;路径: &quot;$2 ,&quot;占用空间&quot;$1&quot;MB&quot;}}'|head -10
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.2 文件大小: 300.05MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_127_01.log.2015-02-10.0 文件大小: 300.04MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.1 文件大小: 300.02MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.0 文件大小: 300.02MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_127_01.log.2015-02-10.2 文件大小: 300.01MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_127_01.log.2015-02-10.1 文件大小: 300.01MB
    路径: /ngbss/crmdev/.pangu/log/trade_4G_127_01.log 文件大小: 170.82MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_127_01.log.2015-02-10.3 文件大小: 124.88MB
    路径: /ngbss/crmdev/.pangu/log/134_32_28_198/tux20141228.log 文件大小: 122.79MB
    路径: /ngbss/crmdev/.pangu/log/4Glog-20150210/trade_4G_129_01.log.2015-02-10.3 文件大小: 120.45MB
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;终于得到了期望的输出结果。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>DataTables新旧版本对比</title>
   <link href="http://www.blogways.net/blog/2016/04/17/datatables-contrast.html"/>
   <updated>2016-04-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/04/17/datatables-contrast</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#intro&quot;&gt;DataTables简介&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#names&quot;&gt;官方更新说明&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#replace&quot;&gt;实际开发中的更替&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#reference&quot;&gt;参考文献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;我也是近期才接触到DataTables这一款jQuery插件,项目中使用的版本是1.9.4,而目前最新的版本的是1.10.11,官网的DOC和API也是基于1.10以上版本,所以当我参考官网的帮助文档来学习项目中老版本的DataTables时,感觉区别比较大.但当我看了两个版本的源码后才发现,从使用的角度来看,它仅仅是换了个马甲.&lt;/p&gt;

&lt;h2 id=&quot;一datatables简介-&quot;&gt;一、DataTables简介 &lt;a name=&quot;intro&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;DataTables是一款灵活jQuery表格插件，通过它可以轻易地实现table的数据填充、分页、排序、查询、隐藏列等功能。&lt;/p&gt;

&lt;h3 id=&quot;11-构造方法&quot;&gt;1.1 构造方法&lt;/h3&gt;

&lt;p&gt;DataTables在被加载时，就已经定义了默认的功能(包括查询、排序、分页)，所以当要为table初始化DataTables功能是，只需要调用构造方法$().DataTable()，这些功能将会立刻被添加到指定的table中。当然，也可以在调用时传入配置参数定制需要的功能，如:$().DataTable(options)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    /**
     *  调用DataTables的构造方法
     *  @param {options} 初始化参数,如果不设置初始化参数,DataTables将使用默认的初始化
     *  @example:
     *      //生成一个关闭分页和排序功能的DataTable实例
     *       $('#table').DataTable({
     *           'bPaginate' : false,
     *           'bSort' : false
     *       });
     */
    $('#table').DataTable([options]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个看似简单的构造方法就能使table获得诸多功能，如此性感，我自然想看看它的源码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // version 1.9.4
    
    var DataTable = function( oInit )
    {
           ...
           ...
           ...
        return this;
    }
    
    ...
    
    $.fn.DataTable = DataTable;
    $.fn.dataTable = DataTable;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码是1.9.4版本的DataTables。
DataTables在被加载时，就向jQuery的原型$.fn添加了一个DataTable和dataTable方法，指向DataTables的构造方法，将传入的table做一个一系列加工，返回一个加工后的JQuery对象.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // version 1.10.10
    
    //下面两个代码实现了循环引用,使JQuery和DataTable成为了
    //我中有你、你中有我的关系，水平有限，暂不明白此举的意义
    $.fn.dataTable = DataTable;
    DataTable.$ = $;

    $.fn.DataTable = function ( opts ) {
        return $(this).dataTable( opts ).api();
    };

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而在1.10.10版本,$().DataTable不再返回JQuery对象,而是返回一个对象_Api,该对象是DataTables的私有变量,使用该对象对table进行操作,可以有效避免命名冲突,并且不用担心DataTables属性泄露到全局变量中.
新版本推荐使用_Api代替旧版本的JQuery对象来进行table操作，但也提供了$().dataTable()方法获得JQuery对象。&lt;/p&gt;

&lt;h3 id=&quot;12-配置对象解析和分页&quot;&gt;1.2 配置对象解析和分页&lt;/h3&gt;

&lt;p&gt;既然DataTables是把JQuery的table实例进行加工,那么这个加工过程是怎么样的呢?关于这一点,新旧版本是一个思路,下面以1.9.4版本进行说明。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // version 1.9.4
    
    // DataTables的构造函数,参数oInit就是$().DataTable(options)时传入的初始化参数
    var DataTable = function( oInit )
    {
        ...
        ...
        //此处声明了很多方法,用于解析oSettings,并根据配置项加载所需功能.比如:
        _fnInitialise( oSettings ){}
        ...
        ...
        //创建一个配置对象,并在创建时就配置了一些默认的参数,此对象将决定Table是否启用、如何启用DataTables提供的一系列功能
        //而DataTable.models相当于一个预定义的oSettiongs模型,每新建一个oSettings,就以DataTable.models为模板
        var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
            &quot;nTable&quot;:        this,
            &quot;oApi&quot;:          _that.oApi,
            &quot;oInit&quot;:         oInit,
            &quot;sDestroyWidth&quot;: $(this).width(),
            &quot;sInstance&quot;:     sId,
            &quot;sTableId&quot;:      sId
        });
        ...
        ...
        //如果没有传入oInit,则声明oInit为一个空对象
        if ( !oInit ){
           oInit = {};
        }
        //DataTable.defaults是DataTables在加载时就定义好的默认初始化参数对象,
        //而_fnExtend()类似于jQuery.extend(),
        //此方法就是将传入的初始化参数覆盖默认的初始化参数对象
        oInit = _fnExtend( $.extend(true, {}, DataTable.defaults), oInit );
        
        //_fnMap方法 将oInit的参数覆盖oSettings的参数,实现定制 
        _fnMap( oSettings.oFeatures, oInit, &quot;bPaginate&quot; );
        _fnMap( oSettings.oFeatures, oInit, &quot;bLengthChange&quot; );
                    ......
                    ......
        _fnMap( oSettings, oInit, &quot;fnStateLoad&quot; );
        _fnMap( oSettings, oInit, &quot;fnStateSave&quot; );
        _fnMap( oSettings.oLanguage, oInit, &quot;fnInfoCallback&quot; );
        ...
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上是设置功能配置对象oSettings的大致过程,当oSettings生成并配置完毕后,会执行_fnInitialise(oSettings)方法,该方法会解析传入的oSettings,根据配置项绘制table,添加所需功能,下面以分页功能进行说明。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     function _fnInitialise ( oSettings )
     {
        ...
        ...
        //判断是否使用分页功能
        //通过oSettings.oFeatures.bPaginate是否设置为真判断
        else if ( cOption == 'p' &amp;amp;&amp;amp; oSettings.oFeatures.bPaginate )
        {
            //执行加载分页功能的方法
            nTmp = _fnFeatureHtmlPaginate( oSettings );
            iPushFeature = 1;
        }
        ...
        ...
      }  
        function _fnFeatureHtmlPaginate ( oSettings )
        {   
            //如果采用了无限分页,return null
            if ( oSettings.oScroll.bInfinite )
            {
                return null;
            }
            
            //创建一个&amp;lt;div&amp;gt;,容纳翻页栏
            var nPaginate = document.createElement( 'div' );
            //设置样式
            nPaginate.className = oSettings.oClasses.sPaging+oSettings.sPaginationType;
            
            //DataTable.ext放置了一些功能的具体实现,比如排序分页
            //根据sPaginationType执行对应的fnInit方法,此方法在上面的&amp;lt;div&amp;gt;中生成了用于点击翻页&amp;lt;a&amp;gt;,并定义了如当当前页、首页、末页等参数
            DataTable.ext.oPagination[ oSettings.sPaginationType ].fnInit( oSettings, nPaginate,
                function( oSettings ) {
                    //此方法用于计算页数及末页的页码
                    _fnCalculateEnd( oSettings );
                    //此方法用于生成并插入&amp;lt;tr&amp;gt;,插入前会清空当前所有的&amp;lt;tr&amp;gt;
                    _fnDraw( oSettings );
                }
            );

            //为第一次分页功能初始化添加一个回调函数,用于翻页
            if ( !oSettings.aanFeatures.p )
            {
                oSettings.aoDrawCallback.push( {
                    &quot;fn&quot;: function( oSettings ) {
                        //fnUpdate 用于翻页的方法,根据在接收到的参数调整DataTable.ext中的当前页、首页、末页等参数
                        DataTable.ext.oPagination[ oSettings.sPaginationType ].fnUpdate( oSettings, function( oSettings ) {
                            _fnCalculateEnd( oSettings );
                            _fnDraw( oSettings );
                        } );
                    },
                    &quot;sName&quot;: &quot;pagination&quot;
                } );
            }
            return nPaginate;
        }
        
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于篇幅有限,许多方法的代码没有贴出来,等到以后针对某项功能进行介绍时,再一一阐述.&lt;/p&gt;

&lt;p&gt;DataTables在加载时就会定义一系列变量和方法,如:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DataTable.default&lt;/code&gt; – 默认初始化参数对象;
&lt;code class=&quot;highlighter-rouge&quot;&gt;DataTable.models&lt;/code&gt; – 默认table模型;
&lt;code class=&quot;highlighter-rouge&quot;&gt;DataTable.ext&lt;/code&gt; – 分页、排序等功能的具体实现方法;
&lt;code class=&quot;highlighter-rouge&quot;&gt;_fnInitialise(oSettings)&lt;/code&gt; – 解析oSettings的属性,判读调用哪些方法,启用什么功能;
&lt;code class=&quot;highlighter-rouge&quot;&gt;_fnDraw(oSettings)&lt;/code&gt; – 根据oSettings._iDisplayStart、oSettings._iDisplayEnd等属性生成tr.&lt;/p&gt;

&lt;p&gt;当调用其构造方法时,就会将JQuery对象和配置参数传入进行加工,使用$.extend或_fnExtend将DataTable.models、DataTable.default以及传入的配置参数options合并成oSettiong对象,再将此对象传入_fnInitialise(oSettings)并执行,定制出自己的table.&lt;/p&gt;

&lt;p&gt;以上是DataTables的简介,下面来看看官方声明的1.10版本的更新变动.&lt;/p&gt;

&lt;h2 id=&quot;二官方更新说明&quot;&gt;二、官方更新说明&lt;a name=&quot;names&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;主要区别有两点:初始化方法和参数名称.&lt;/p&gt;

&lt;h3 id=&quot;21-初始化方法&quot;&gt;2.1 初始化方法&lt;/h3&gt;

&lt;p&gt;1.10版本以前
$(…).DataTable() 创建一个DataTable并返回一个jQuery对象&lt;/p&gt;

&lt;p&gt;1.10版本以后
$(…).DataTable() 创建一个DataTable并返回一个DataTables API实例
$(…).dataTable() 创建一个dataTable并返回一个jQuery对象&lt;/p&gt;

&lt;p&gt;此区别上文中已提及,这里不再赘述.&lt;/p&gt;

&lt;h3 id=&quot;22-参数名称&quot;&gt;2.2 参数名称&lt;/h3&gt;

&lt;p&gt;在1.10版本以前,DataTables的各配置参数采用的是匈牙利命名法,而在1.10之后,改为了驼峰命名法.
虽然新版本也兼容匈牙利命名法的参数,但是其官网的帮助文档均用新版驼峰命名法的参数进行说明,这也是造成我误以为新老版本天差地别的原因.
下面列举了一些常用参数的新旧版本对照:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;aaData&lt;/td&gt;
      &lt;td&gt;data&lt;/td&gt;
      &lt;td&gt;用于显示的数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;aaSorting&lt;/td&gt;
      &lt;td&gt;order&lt;/td&gt;
      &lt;td&gt;表格初始化排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;aoColumns&lt;/td&gt;
      &lt;td&gt;columns&lt;/td&gt;
      &lt;td&gt;列配置数组&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;aoColumns&lt;/td&gt;
      &lt;td&gt;columnDefs&lt;/td&gt;
      &lt;td&gt;定义多列排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;aoSearchCols&lt;/td&gt;
      &lt;td&gt;searchCols&lt;/td&gt;
      &lt;td&gt;定义初始化查询栏&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;asSorting&lt;/td&gt;
      &lt;td&gt;columns.orderSequence&lt;/td&gt;
      &lt;td&gt;定义升降序序列&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bAutoWidth&lt;/td&gt;
      &lt;td&gt;autoWidth&lt;/td&gt;
      &lt;td&gt;自动设置table宽度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bInfo&lt;/td&gt;
      &lt;td&gt;info&lt;/td&gt;
      &lt;td&gt;设置表格信息展示功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bPaginate&lt;/td&gt;
      &lt;td&gt;paging&lt;/td&gt;
      &lt;td&gt;是否启用分页功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bProcessing&lt;/td&gt;
      &lt;td&gt;processing&lt;/td&gt;
      &lt;td&gt;显示加载信息&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bScrollCollapse&lt;/td&gt;
      &lt;td&gt;scrollCollapse&lt;/td&gt;
      &lt;td&gt;是否启用滚动条&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bSearchable&lt;/td&gt;
      &lt;td&gt;columns.searchable&lt;/td&gt;
      &lt;td&gt;是否启用搜索功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bServerSide&lt;/td&gt;
      &lt;td&gt;serverSide&lt;/td&gt;
      &lt;td&gt;是否启用服务模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bSort&lt;/td&gt;
      &lt;td&gt;ordering&lt;/td&gt;
      &lt;td&gt;是否启用排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bSortCellsTop&lt;/td&gt;
      &lt;td&gt;columns.orderable&lt;/td&gt;
      &lt;td&gt;开关某列的排序&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;bStateSave&lt;/td&gt;
      &lt;td&gt;stateSave&lt;/td&gt;
      &lt;td&gt;是否启用浏览器缓存功能&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fnServerData&lt;/td&gt;
      &lt;td&gt;ajax&lt;/td&gt;
      &lt;td&gt;从Ajax源加载数据&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;fnServerParams&lt;/td&gt;
      &lt;td&gt;ajax&lt;/td&gt;
      &lt;td&gt;设置Ajax传递参数&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;篇幅有限,若想查看全部内容请访问官网.
&lt;a href=&quot;https://datatables.net/upgrade/1.10-convert.html&quot;&gt;https://datatables.net/upgrade/1.10-convert.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;三实际开发中的更替-&quot;&gt;三、实际开发中的更替 &lt;a name=&quot;replace&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;项目中使用的DataTables的版本是1.9.4,当我将其换成1.10.10版本后,所使用的功能一切正常,除了这个地方:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;这是原来旧版的呈现&lt;/code&gt;
&lt;img src=&quot;/images/old_Version.png&quot; alt=&quot;old&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;这是替换成新版后的呈现&lt;/code&gt;
&lt;img src=&quot;/images/new_Version.png&quot; alt=&quot;new&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我试着点击本应该disable的按钮,发现并没有发出任何请求,于是想会不会是样式问题,于是在源码中找到了分页按钮样式的名称.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // version 1.9.4
    
    /* Full numbers paging buttons */
    &quot;sPageButton&quot;: &quot;paginate_button&quot;,
    &quot;sPageButtonActive&quot;: &quot;paginate_active&quot;,
    &quot;sPageButtonStaticDisabled&quot;: &quot;paginate_button paginate_button_disabled&quot;,
    &quot;sPageFirst&quot;: &quot;first&quot;,
    &quot;sPagePrevious&quot;: &quot;previous&quot;,
    &quot;sPageNext&quot;: &quot;next&quot;,
    &quot;sPageLast&quot;: &quot;last&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // version 1.10.10
        
     /* Paging buttons */
    &quot;sPageButton&quot;: &quot;paginate_button&quot;,
    &quot;sPageButtonActive&quot;: &quot;current&quot;,
    &quot;sPageButtonDisabled&quot;: &quot;disabled&quot;
    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发现原因,新旧版本的css文件不一样,class名称自然也会有所不同.
sPageButton的样式名称相同,区别在于Active和Disabled,于是把项目中的plugin.css文件改了一下,把”.paginate_active”改为”.current”,”.paginate_button_disabled”改为”.disables”.
或者反过来,把DataTables的js文件改为与项目css文件一致,都能够回复正常.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/old_Version.png&quot; alt=&quot;old&quot; /&gt;&lt;/p&gt;

&lt;p&gt;排序、分页、Ajax等功能一切正常，或许还有其他的一些错误没有排除，等遇到异常再说吧。&lt;/p&gt;

&lt;h2 id=&quot;四参考文献&quot;&gt;四、参考文献&lt;a name=&quot;reference&quot;&gt;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.datatables.net/&quot;&gt;https://www.datatables.net/&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>ESLint使用介绍</title>
   <link href="http://www.blogways.net/blog/2016/02/02/javascript-eslint.html"/>
   <updated>2016-02-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/02/02/javascript-eslint</id>
   <content type="html">&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;&lt;em&gt;目 录&lt;/em&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#comparison&quot;&gt;JavaScript Linting工具的比较&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#install&quot;&gt;ESLint的安装&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#usage&quot;&gt;ESLint的使用说明&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#editor&quot;&gt;与编辑工具的集成&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#airbnb&quot;&gt;不可不知的airbnb编码规范与配置&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;&lt;a href=&quot;#reference&quot;&gt;参考文献&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;之前用的是JSHint，感觉挺不错的。最近发现了ESLint，试用了一下，发现更好！特此，把所了解的信息分享一下。&lt;/p&gt;

&lt;h2 id=&quot;一linting工具的比较-&quot;&gt;一、Linting工具的比较 &lt;a href=&quot;comparison&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;不用说，大家最常用的JavaScript Linting工具应该是下面四个之一：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JSLint - JSHint - JSCS - ESLint&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这四种工具，工作方式基本相同。他们都定义了一些规则去分析报告JavaScript文件中的问题；可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;npm&lt;/code&gt;进行安装；可以在命令行运行；可以作为Grunt等工具的插件；可以集成到常用编辑工具中去；可以在文件中通过注释进行配置。&lt;/p&gt;

&lt;h3 id=&quot;11-jslint&quot;&gt;1.1 JSLint&lt;/h3&gt;

&lt;p&gt;四个工具中最老的一个。&lt;code class=&quot;highlighter-rouge&quot;&gt;Douglas Crockford&lt;/code&gt;在2002年创建，根据他的经验，强制校验了JavaScript编码中一些更合理的限制规则。其使用最大的缺点，就是不支持个性化配置，但优点也是无需配置，如果你认同这些规则，那么用起来就很顺手。&lt;/p&gt;

&lt;h3 id=&quot;12-jshint&quot;&gt;1.2 JSHint&lt;/h3&gt;

&lt;p&gt;JSHint是JSLint的改良版，支持通过配置文件配置规则级别。对ES6的规范也做了简单的支持。很好用！缺点就是所有规则都是内置的，无法自定义新规则。实际上在大部分项目中，就已经足够用了。&lt;/p&gt;

&lt;h3 id=&quot;13-jscs&quot;&gt;1.3 JSCS&lt;/h3&gt;

&lt;p&gt;JSCS和前两个最大的不同就是没有配置文件就不能工作。他已经有了超过90个内置规则，并且你可以自定义新规则。但是他只是对编码风格进行检查，无法对代码中潜在的bug（如未使用的变量/突兀的全局变量等等）或者错误进行判断。&lt;/p&gt;

&lt;h3 id=&quot;14-eslint&quot;&gt;1.4 ESLint&lt;/h3&gt;

&lt;p&gt;四个工具中最新的。借鉴了前辈的经验。每个规则都可以开关，很多规则都有多个选项，供微调；易于扩展，可以自定义新规则，有很多有用的插件；包含了很多另外三个没有的规则；不但可以发现问题，在某些规则上面，还支持自动纠错；对ES6的支持最到位；是四者中唯一一个支持JSX的。&lt;/p&gt;

&lt;h2 id=&quot;二eslint的安装&quot;&gt;二、ESLint的安装&lt;a name=&quot;install&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;在你的项目目录下，输入命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i eslint --save-dev  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果之前安装了低版本，需要升级，可以如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i eslint@latest --save-dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，你就在当前目录下安装了&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint&lt;/code&gt;。不过，&lt;code class=&quot;highlighter-rouge&quot;&gt;ESLint&lt;/code&gt;作为一个常用工具，我建议最好还是全局安装，这样使用起来会很方便。如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm i eslint -g
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三eslint使用说明&quot;&gt;三、ESLint使用说明&lt;a name=&quot;usage&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;31-创建配置文件&quot;&gt;3.1 创建配置文件&lt;/h3&gt;

&lt;p&gt;如果全局模式安装的&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint&lt;/code&gt;，那么进入项目目录，键入：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eslint --init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果只是在当前目录下安装了&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint&lt;/code&gt;，那么键入：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./node_modules/.bin/eslint --init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，根据提示，使用方向键、空格键或者回车，进行回答。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;eslint --init
? How would you like to configure ESLint? Answer questions about your style
? What style of indentation &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use? Spaces
? What quotes &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;strings? Single
? What line endings &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you use? Unix
? Do you require semicolons? Yes
? Are you using ECMAScript 6 features? No
? Where will your code run? Node, Browser
? Do you use JSX? No
? What format &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;you want your config file to be &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt;? JSON
Successfully created .eslintrc.json file &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; /Users/&amp;lt;username&amp;gt;/path/to/yourdir
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看看刚生成的配置文件：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat .eslintrc.json
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;rules&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;indent&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
            2,
            4
        &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;quotes&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
            2,
            &lt;span class=&quot;s2&quot;&gt;&quot;single&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;linebreak-style&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
            2,
            &lt;span class=&quot;s2&quot;&gt;&quot;unix&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;semi&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;
            2,
            &lt;span class=&quot;s2&quot;&gt;&quot;always&quot;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;env&quot;&lt;/span&gt;: &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;s2&quot;&gt;&quot;node&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;,
        &lt;span class=&quot;s2&quot;&gt;&quot;browser&quot;&lt;/span&gt;: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;extends&quot;&lt;/span&gt;: &lt;span class=&quot;s2&quot;&gt;&quot;eslint:recommended&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，你看到的配置文件有三块内容：&lt;code class=&quot;highlighter-rouge&quot;&gt;rules&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;env&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;extends&quot;: &quot;eslint:recommended&quot;&lt;/code&gt;，指我们使用eslint的推荐配置。你也可以使用自己定制的配置。自定义，也很简单，&lt;a href=&quot;https://github.com/feross/eslint-config-standard&quot;&gt;这里&lt;/a&gt;有个例子，你也可以看&lt;a href=&quot;http://eslint.org/docs/developer-guide/shareable-configs&quot;&gt;ESLint Shareable Configs&lt;/a&gt;的规则，进行了解，简单来说就是分三步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;正常创建一个Node.js模块，模块的名字，需要前缀为&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint-config-&lt;/code&gt;（比如全名&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint-config-myconfig&lt;/code&gt;）,创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;index.js&lt;/code&gt;文件，输出你的配置。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 比如`index.js`内容如下：

    ```javascript
    module.exports = {
        rules: {
            quotes: [2, &quot;double&quot;];
        }
    };
    ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;把这个模块发布到npmjs上供人使用。可以看&lt;a href=&quot;https://docs.npmjs.com/getting-started/publishing-npm-packages&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install&lt;/code&gt;安装&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint-config-myconfig&lt;/code&gt;，并在&lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc&lt;/code&gt;文件中，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;extends&lt;/code&gt;来使用：&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- 比如：

  ```json
  {
    &quot;extends&quot;: &quot;eslint-config-myconfig&quot;
  }
  ```

- 或者，省略前缀，如下使用：

  ```json
  {
    &quot;extends&quot;: &quot;myconfig&quot;
  }
  ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;继续前面话题，&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;env&quot;&lt;/code&gt;指程序运行所在环境，可以是：&lt;code class=&quot;highlighter-rouge&quot;&gt;Node&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Browser&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;amd&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;mocha&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;jasmine&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;jquery&lt;/code&gt;等等，设定了这些环境后，这些环境的全局变量就可以被识别。你可以在文件中采用注释的方式来告诉单个文件的环境变量，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;/*eslint-env node, mocha */&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;rules&quot;&lt;/code&gt;,只一些不包括在&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;extends&quot;&lt;/code&gt;中的配置，或者重新定义&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;extends&quot;&lt;/code&gt;中部分配置。我们注意到，每个规则的值都是一个数组。数组的第一个值是错误级别，第二个值是规则值。错误级别分三个：&lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; - 不报错； &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; - 告警; &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt; - 报错。 各种规则的详细说明，可见&lt;a href=&quot;http://eslint.org/docs/user-guide/configuring#configuring-rules&quot;&gt;ESLint Rules&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;32-查错&quot;&gt;3.2 查错&lt;/h3&gt;

&lt;p&gt;查错命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eslint &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;file|dir]&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eslint file1.js file2.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eslint lib/&lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，相关参数可以通过命令&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint -h&lt;/code&gt;获知。&lt;/p&gt;

&lt;p&gt;欲知各种规则的含义，可以看&lt;a href=&quot;http://eslint.org/docs/rules/&quot;&gt;ESLint Rules&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;33-局部禁止查错&quot;&gt;3.3 局部禁止查错&lt;/h3&gt;

&lt;p&gt;在实际使用中，有些代码需要局部禁止查错，比如：可能是已经存在的依赖的模块，再或者是调试语句。&lt;/p&gt;

&lt;p&gt;这就需要局部禁止查错。支持四种方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;语句块，全部所有规则&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;cm&quot;&gt;/* eslint-disable */&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;//suppress all warnings between comments&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;cm&quot;&gt;/* eslint-enable */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;语句块，禁止指定规则&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;cm&quot;&gt;/* eslint-disable no-alert, no-console */&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'bar'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;cm&quot;&gt;/* eslint-enable no-alert */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单行，禁止所有规则&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// eslint-disable-line&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;单行，禁止指定规则&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'foo'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// eslint-disable-line no-alert&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;34-修正&quot;&gt;3.4 修正&lt;/h3&gt;

&lt;p&gt;光发现错误，还不行，程序员希望可以自动修正错误。&lt;code class=&quot;highlighter-rouge&quot;&gt;ESLint&lt;/code&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--fix&lt;/code&gt;选项，支持对一部分规则进行纠错。命令如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;eslint file.js --fix
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行一下，你就会发现文件内容的缩进按照规则自动纠正了…&lt;/p&gt;

&lt;h3 id=&quot;35-高级&quot;&gt;3.5 高级&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;支持&lt;a href=&quot;http://eslint.org/docs/developer-guide/working-with-rules&quot;&gt;自定义规则&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;支持&lt;a href=&quot;http://eslint.org/docs/developer-guide/working-with-plugins&quot;&gt;自定义插件&lt;/a&gt;;&lt;/li&gt;
  &lt;li&gt;支持&lt;a href=&quot;http://eslint.org/docs/user-guide/configuring#specifying-parser&quot;&gt;自定义解析器&lt;/a&gt;.ESLint默认的解析器是&lt;code class=&quot;highlighter-rouge&quot;&gt;Espree&lt;/code&gt;，你还可以选择其他的解析器，比如webpack在用的&lt;code class=&quot;highlighter-rouge&quot;&gt;Esprima&lt;/code&gt;，或者支持&lt;code class=&quot;highlighter-rouge&quot;&gt;ES2016/ES7&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;babel-eslint&lt;/code&gt;解析器;&lt;/li&gt;
  &lt;li&gt;支持通过&lt;a href=&quot;http://eslint.org/docs/user-guide/configuring#ignoring-files-and-directories&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintignore&lt;/code&gt;&lt;/a&gt;文件配置不检查某些文件或者目录;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四与编辑工具集成&quot;&gt;四、与编辑工具集成&lt;a name=&quot;editor&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;41-webstorm&quot;&gt;4.1 WebStorm&lt;/h3&gt;

&lt;p&gt;在配置界面： Languanges &amp;amp; Frameworks -&amp;gt; JavaScript -&amp;gt; Code Quality Tools -&amp;gt; ESLint，开启。&lt;/p&gt;

&lt;p&gt;Windows系统下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/20160202-01.png&quot; alt=&quot;webstorm-eslint-enable&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;42-atom&quot;&gt;4.2 Atom&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装atom包(&lt;a href=&quot;https://atom.io/packages/linter&quot;&gt;linter&lt;/a&gt;,&lt;a href=&quot;https://atom.io/packages/linter-eslint&quot;&gt;linter-eslint&lt;/a&gt;)：&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; apm install linter linter-eslint
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在当前项目目录下安装npm包(&lt;a href=&quot;https://www.npmjs.com/package/eslint&quot;&gt;eslint&lt;/a&gt;):&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; npm install --save-dev eslint
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五airbnb的编码风格与配置&quot;&gt;五、airbnb的编码风格与配置&lt;a name=&quot;airbnb&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;51-javascript编码风格&quot;&gt;5.1 JavaScript编码风格&lt;/h3&gt;
&lt;p&gt;airbnb在github上分享了他们的的编码规范。可见&lt;a href=&quot;https://github.com/airbnb/javascript/blob/master/README.md&quot;&gt;Airbnb JavaScript Style Guide&lt;/a&gt;. 这个规范，现在已经或者即将，成为国际JavaScript编码规范了。&lt;/p&gt;

&lt;h3 id=&quot;52-规则配置&quot;&gt;5.2 规则配置&lt;/h3&gt;

&lt;p&gt;他们除了分享了编码风格，还提供了与之对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;eslint&lt;/code&gt;配置文件。他们提供的配置文件，根据使用环境不同，分三种（总有一款适合你:D）：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;eslint-config-airbnb&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这块默认的配置，包括&lt;code class=&quot;highlighter-rouge&quot;&gt;EcmaScript 6+&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;React&lt;/code&gt;。使用如下：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save-dev eslint-config-airbnb eslint-plugin-react eslint&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;extends&quot;: &quot;airbnb&quot;&lt;/code&gt;至你的&lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc&lt;/code&gt;文件。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;eslint-config-airbnb/base&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;包括&lt;code class=&quot;highlighter-rouge&quot;&gt;ES6+&lt;/code&gt;但是不需要&lt;code class=&quot;highlighter-rouge&quot;&gt;React&lt;/code&gt;，使用如下：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save-dev eslint-config-airbnb eslint&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;extends&quot;: &quot;airbnb/base&quot;&lt;/code&gt;至你的&lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc&lt;/code&gt;文件。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;eslint-config-airbnb/legacy&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;支持&lt;code class=&quot;highlighter-rouge&quot;&gt;ES5&lt;/code&gt;，使用如下：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;npm install --save-dev eslint-config-airbnb eslint&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;extends&quot;: &quot;airbnb/legacy&quot;&lt;/code&gt;至你的&lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc&lt;/code&gt;文件。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;53-小瑕疵&quot;&gt;5.3 小瑕疵&lt;/h3&gt;

&lt;p&gt;使用了一下，发现他们提供的配置和他们的规范，也有一点小参差。所以，我在使用他们的配置的同时，做了一处修正。&lt;code class=&quot;highlighter-rouge&quot;&gt;.eslintrc.json&lt;/code&gt;如下：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'extends':&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'airbnb/legacy',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'rules':&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'comma-dangle':&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[2,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'never']&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;是的，他们分享的配置中的规则是&lt;code class=&quot;highlighter-rouge&quot;&gt;'comma-dangle': [2, 'always-multiline']&lt;/code&gt;，真是不习惯。&lt;/p&gt;

&lt;h2 id=&quot;六参考文献&quot;&gt;六、参考文献&lt;a name=&quot;reference&quot;&gt;&lt;/a&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;http://www.sitepoint.com/comparison-javascript-linting-tools/&lt;/li&gt;
  &lt;li&gt;http://devnull.guru/get-started-with-eslint/&lt;/li&gt;
  &lt;li&gt;http://eslint.org/docs/user-guide/configuring&lt;/li&gt;
  &lt;li&gt;http://eslint.org/docs/user-guide/command-line-interface&lt;/li&gt;
  &lt;li&gt;http://eslint.org/docs/rules/&lt;/li&gt;
  &lt;li&gt;https://www.npmjs.com/package/eslint-config-airbnb&lt;/li&gt;
  &lt;li&gt;https://github.com/kriasoft/react-starter-kit/blob/master/docs/how-to-configure-text-editors.md&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Html5 建站学习笔记</title>
   <link href="http://www.blogways.net/blog/2016/01/20/html5-somethings.html"/>
   <updated>2016-01-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/01/20/html5-somethings</id>
   <content type="html">&lt;p&gt;以 html5-boilerplate 为引子，围绕其中的关键点，学习了html5相关的知识，笔记之&lt;/p&gt;

&lt;h2 id=&quot;一html5网站常见的目录结构&quot;&gt;一、Html5网站常见的目录结构&lt;/h2&gt;

&lt;p&gt;一个Html5网站常见的目录结构，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
├── css
│   ├── main.css
│   └── normalize.css
├── doc
├── img
├── js
│   ├── main.js
│   ├── plugins.js
│   └── vendor
│       ├── jquery.min.js
│       └── modernizr.min.js
├── .editorconfig
├── .htaccess
├── 404.html
├── apple-touch-icon.png
├── browserconfig.xml
├── index.html
├── humans.txt
├── robots.txt
├── crossdomain.xml
├── favicon.ico
├── tile-wide.png
└── tile.png
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.htaccess&lt;/code&gt; 是Apache web服务器的默认配置文件。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;browserconfig.xml&lt;/code&gt; 是为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer 11&lt;/code&gt; 提供的配置文件，里面自定义了网站的磁贴。&lt;/p&gt;

    &lt;p&gt;在采用新 Windows UI 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Internet Explorer&lt;/code&gt; 中为站点创建自定义磁贴和通知以建立用户兴趣和点击量。 可以为 &lt;code class=&quot;highlighter-rouge&quot;&gt;IE11&lt;/code&gt; 创建自定义磁贴。&lt;/p&gt;

    &lt;p&gt;当用户首次固定你的站点时，它在“开始”屏幕上显示为一个静态磁贴。默认情况下，磁贴上的图像是网站的 Favicon 或默认 IE11 徽标。你可以通过将元数据标志添加到网站的标志或添加浏览器 config 文件来自定义图像。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;browserconfig.xml&lt;/code&gt;的内容大致如下：&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;browserconfig&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;msapplication&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;tile&amp;gt;&lt;/span&gt;
				&lt;span class=&quot;nt&quot;&gt;&amp;lt;square70x70logo&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;tile.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;nt&quot;&gt;&amp;lt;square150x150logo&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;tile.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;nt&quot;&gt;&amp;lt;wide310x150logo&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;tile-wide.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
             &lt;span class=&quot;nt&quot;&gt;&amp;lt;square310x310logo&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;tile.png&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
         &lt;span class=&quot;nt&quot;&gt;&amp;lt;/tile&amp;gt;&lt;/span&gt;
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;/msapplication&amp;gt;&lt;/span&gt;
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/browserconfig&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;你也可以不使用默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;browserconfig.xml&lt;/code&gt;文件名，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;来指定一个文件，示例如下：&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
     ...
     &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;msapplication-config&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;ieconfig.xml&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
     ...
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;另外，Windows8.1 还支持动态磁贴。你可以从&lt;a href=&quot;https://msdn.microsoft.com/library/dn455106.aspx&quot;&gt;这里&lt;/a&gt;找到详细的介绍信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;robots.txt&lt;/code&gt; 告诉爬虫在网站上的爬取权限。（当然了，有些流氓爬虫是无视这个配置文件的）&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;示例：容许爬虫爬取所有内容&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	User-agent: *
 	Disallow:
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;其中：&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;User-agent: *&lt;/code&gt; 表示下面规则对所有web爬虫都适用；&lt;/li&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Disallow:&lt;/code&gt; 表示网站所有内容都可以被抓取。如果你想禁止爬取所有内容，可以配置为&lt;code class=&quot;highlighter-rouge&quot;&gt;Disallow:/&lt;/code&gt;,如果想禁止某个目录，可以配置为&lt;code class=&quot;highlighter-rouge&quot;&gt;Disallow:/path&lt;/code&gt;&lt;/li&gt;
          &lt;li&gt;更多信息可以从&lt;a href=&quot;http://www.robotstxt.org/&quot;&gt;这里&lt;/a&gt;获取&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crossdomain.xml&lt;/code&gt; 是跨域策略文件。此文件是一种 XML 文档，旨在为 Web 客户端，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;Adobe Flash Player&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;Adobe Reader&lt;/code&gt;（但不限于这两类客户端）授予跨域处理数据的权限。当客户端请求获取特定源域上托管的内容、且该内容将请求定向至除自身域以外的其他域时，远程域需要托管跨域策略文件，从而授予源域的访问权限，使客户端继续执行事务。。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;主策略文件。 策略文件用于授予数据读取权限，允许客户端在跨域请求中包含自定义标头，并授予基于套接字的连接权限。策略文件在服务器上的最常见位置是文件名为 crossdomain.xml (例如 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://example.com/crossdomain.xml&lt;/code&gt;) 的目标域根目录中——当客户端需要策略文件时的默认检查位置。以这种方式托管的策略文件称作主策略文件。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;crossdomain.xml 文件示例&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;示例 1：&lt;code class=&quot;highlighter-rouge&quot;&gt;allow-access-from&lt;/code&gt;：允许访问根域&lt;/p&gt;

            &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xml
  &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
  	&amp;lt;!DOCTYPE cross-domain-policy SYSTEM &quot;http://www.adobe.com/xml/dtds/cross-domain-policy.dtd&quot;&amp;gt;
  	&amp;lt;cross-domain-policy&amp;gt;
      &amp;lt;site-control permitted-cross-domain-policies=&quot;master-only&quot;/&amp;gt;
      &amp;lt;allow-access-from domain=&quot;*.example.com&quot;/&amp;gt;
      &amp;lt;allow-access-from domain=&quot;www.example.com&quot;/&amp;gt;
      &amp;lt;allow-http-request-headers-from domain=&quot;*.adobe.com&quot; headers=&quot;SOAPAction&quot;/&amp;gt;
  &amp;lt;/cross-domain-policy&amp;gt;
  	&lt;/code&gt;
  	此处的site-control 元素用于指定该域仅将此主策略文件视为有效文件。allow-access-from 元素用于指定 example.com 请求域中的内容可以访问目标域（保存此策略文件的域）中的所有数据。最后，allow-http-request-headers-from 元素表示，通过从 adobe.com 向目标域发送请求还允许发送SOAPAction 标头。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;示例2：&lt;code class=&quot;highlighter-rouge&quot;&gt;cross-domain-policy&lt;/code&gt;：最严格的限制策略&lt;/p&gt;

            &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE cross-domain-policy SYSTEM &quot;http://www.adobe.com/xml/dtds/cross-domain-policy.dtd&quot;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;cross-domain-policy&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;site-control&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;permitted-cross-domain-policies=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/cross-domain-policy&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;

            &lt;p&gt;这是最严格的主策略文件定义。它可以限制任何策略文件（包括这个文件在内）向发出请求的任何域授予任何类型的权限。&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;示例3：cross-domain-policy：最宽松的限制策略&lt;/p&gt;

            &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE cross-domain-policy SYSTEM &quot;http://www.adobe.com/xml/dtds/cross-domain-policy.dtd&quot;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;cross-domain-policy&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;site-control&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;permitted-cross-domain-policies=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;all&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;allow-access-from&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;domain=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;secure=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;allow-http-request-headers-from&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;domain=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;headers=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;*&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;secure=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;false&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/cross-domain-policy&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
            &lt;p&gt;这是最宽松的主策略文件定义（不推荐使用）。它允许目标域上的任意策略文件授予权限，允许访问它的任何文件，并且允许向服务器发送任何标头，尽管源是 HTTP，即使通过 HTTPS 也可以执行所有操作。&lt;/p&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;关于 &lt;code class=&quot;highlighter-rouge&quot;&gt;crossdomain.xml&lt;/code&gt;的更多信息可以从&lt;a href=&quot;http://www.adobe.com/cn/devnet/adobe-media-server/articles/cross-domain-xml-for-streaming.html&quot;&gt;这里&lt;/a&gt;获取。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;图标&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;favicon.ico&lt;/code&gt; 网站图标&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tile.png&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;tile-wide.png&lt;/code&gt; 是提供给&lt;code class=&quot;highlighter-rouge&quot;&gt;IE11&lt;/code&gt;的磁贴图片&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;apple-touch-icon.png&lt;/code&gt; 提供给iOS设备上的书签图标，或者将网站添加到主屏幕后的图标。不同iOS设备的分辨率不同，推荐图片分辨率大小为:&lt;code class=&quot;highlighter-rouge&quot;&gt;180×180px&lt;/code&gt;。可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中使用如下标签：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;link rel=&quot;apple-touch-icon&quot; href=&quot;apple-touch-icon.png&quot;&amp;gt;&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二关于html的那些事儿&quot;&gt;二、关于Html的那些事儿&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;!doctype html&amp;gt;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&amp;lt;!DOCTYPE&amp;gt; 声明必须是 HTML 文档的第一行，位于 &amp;lt;html&amp;gt; 标签之前。&amp;lt;!DOCTYPE&amp;gt; 声明不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令。在 HTML 4.01 中，&amp;lt;!DOCTYPE&amp;gt; 声明引用 DTD，因为 HTML 4.01 基于 SGML。DTD 规定了标记语言的规则，这样浏览器才能正确地呈现内容。HTML5 不基于 SGML，所以不需要引用 DTD。常用的DOCTYPE 声明，如下：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;HTML5： &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;HTML 4.01 有三种方式：
        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;Strict（该 DTD 包含所有 HTML 元素和属性，但不包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。）：&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Transitional (该 DTD 包含所有 HTML 元素和属性，包括展示性的和弃用的元素（比如 font）。不允许框架集（Framesets）。)&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Frameset (该 DTD 等同于 HTML 4.01 Transitional，但允许框架集内容。)&lt;/p&gt;

            &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;还有一些其他的规范。详见&lt;a href=&quot;https://www.w3.org/QA/2002/04/valid-dtd-list.html&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;lang&lt;/code&gt;. HTML 的 lang 属性可用于网页或部分网页的语言。这对搜索引擎和浏览器是有帮助的。根据 W3C 推荐标准，您应该通过 &amp;lt;html&amp;gt; 标签中的 lang 属性对每张页面中的主要语言进行声明，比如：&lt;/p&gt;

    &lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;zh&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
 ...
 &lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;title&amp;gt;&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;的先后&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;字符集定义&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;/code&gt;，需要包含在HTML文档的前1024个字符内。尽可能早地把它列出来（比如在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;title&amp;gt;&lt;/code&gt;之前），可以避免一些浏览器bug。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;尽可能地把&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&amp;gt;&lt;/code&gt;放在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;title&amp;gt;&lt;/code&gt;和其他的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;之前。&lt;code class=&quot;highlighter-rouge&quot;&gt;x-ua-compatible&lt;/code&gt;这个关键字不区分大小写。&lt;code class=&quot;highlighter-rouge&quot;&gt;Edge&lt;/code&gt;模式通知 &lt;code class=&quot;highlighter-rouge&quot;&gt;Windows Internet Explorer&lt;/code&gt; 以最高级别的可用模式显示内容。&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;IE 8/9/10 支持兼容模式。网站的访问者可能使用的是IE9，但是IE9并不使用最新的渲染引擎，而是使用IE5.5的渲染引擎去渲染页面。你可以设置&lt;code class=&quot;highlighter-rouge&quot;&gt;x-ua-compatible&lt;/code&gt;元标签&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;ie=edge&quot;&amp;gt;&lt;/code&gt;，或者是在页面的HTTP响应头里添加&lt;code class=&quot;highlighter-rouge&quot;&gt;X-UA-Compatible: IE=edge&lt;/code&gt;，这样就会强制IE 8/9/10使用最新的渲染引擎，获取最佳的体验效果。推荐使用HTTP响应头的方式，而非&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;元标签，这样 IE 能兼顾各种情况，支持得更好。更多信息可以看&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/jj676915(v=vs.85).aspx&quot;&gt;这里&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;移动设备支持（&lt;code class=&quot;highlighter-rouge&quot;&gt;viewtype&lt;/code&gt;）。为了尽可能更合适地在移动终端上显示页面。需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;里添加元标签：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/h5bp/html5-boilerplate/blob/5.3.0/dist/doc/TOC.md&quot;&gt;https://github.com/h5bp/html5-boilerplate/blob/5.3.0/dist/doc&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/library/dn455106.aspx&quot;&gt;https://msdn.microsoft.com/library/dn455106.aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.adobe.com/cn/devnet/adobe-media-server/articles/cross-domain-xml-for-streaming.html&quot;&gt;http://www.adobe.com/cn/devnet/adobe-media-server/articles/cross-domain-xml-for-streaming.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://css-tricks.com/favicon-quiz/&quot;&gt;https://css-tricks.com/favicon-quiz/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/jj676915(v=vs.85).aspx&quot;&gt;https://msdn.microsoft.com/en-us/library/jj676915(v=vs.85).aspx&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/tags/tag_doctype.asp&quot;&gt;http://www.w3school.com.cn/tags/tag_doctype.asp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.w3.org/QA/2002/04/valid-dtd-list.html&quot;&gt;https://www.w3.org/QA/2002/04/valid-dtd-list.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.w3school.com.cn/tags/html_ref_language_codes.asp&quot;&gt;http://www.w3school.com.cn/tags/html_ref_language_codes.asp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>webpack的几个常用loader</title>
   <link href="http://www.blogways.net/blog/2016/01/19/webpack-loader.html"/>
   <updated>2016-01-19T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/01/19/webpack-loader</id>
   <content type="html">&lt;p&gt;使用webpack对原有web工程进行改造，遇到各种问题，适当地使用各种loader加以解决。感觉有些问题具备普遍性，还是有必要记录一下的。故有此文！&lt;/p&gt;

&lt;p&gt;在webpack中对javascript的管理也是模块化管理，所以需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;exports&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt;来对js模块进行引用或者导出。&lt;/p&gt;

&lt;p&gt;当你的前端web工程没有采用js模块化编码，那么就会遇到一些问题。问题的根源分为两种：js的调用者，没有&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;；js的提供者，没有&lt;code class=&quot;highlighter-rouge&quot;&gt;exports&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;此时，你一个个文件去修改，按规范添加&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;exports&lt;/code&gt;，当然可以解决这些问题。你也可以使用webpack提供的各种&lt;code class=&quot;highlighter-rouge&quot;&gt;loader&lt;/code&gt;去解决这些问题。&lt;/p&gt;

&lt;p&gt;下面，我们分情况讨论解决。&lt;/p&gt;

&lt;h2 id=&quot;一和jquery相关的那些事儿&quot;&gt;一、和jQuery相关的那些事儿&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;本身并没有问题，自身代码里兼容了&lt;code class=&quot;highlighter-rouge&quot;&gt;exports&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;只是，很多依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;模块的js文件，都没有&lt;code class=&quot;highlighter-rouge&quot;&gt;require('jquery')&lt;/code&gt;，导致文件内的&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;对象不可识别。&lt;/p&gt;

&lt;p&gt;比如&lt;code class=&quot;highlighter-rouge&quot;&gt;Bootstrap v3.3.2&lt;/code&gt;，走上来，就是如下代码：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'undefined'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Bootstrap\'s JavaScript requires jQuery'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;作为模块化调用，当然无法识别&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;解决方法有三个：&lt;/p&gt;

&lt;h3 id=&quot;1-方法一采用import-loader&quot;&gt;1. 方法一：采用&lt;code class=&quot;highlighter-rouge&quot;&gt;import-loader&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1.1 解决方法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在加载&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap.js&lt;/code&gt;时，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;imports-loader&lt;/code&gt;,
代码如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'imports?jQuery=jquery!bootstrap/dist/js/bootstrap'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，可以正常使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap.js&lt;/code&gt;了！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.2 原理&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;imports-loader会在bootstrap的源码前面，注入如下代码:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*** IMPORTS FROM imports-loader ***/&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;jQuery&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jquery&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1.3 使用说明:&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;查询参数&lt;/th&gt;
      &lt;th&gt;等效代码&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;angular&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var angular = require('angular');&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$=jquery&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var $ = require('jquery');&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config=&amp;gt;{size:50}&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var config = {size:50};&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;this=&amp;gt;window&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(function(){...}).call(window);&lt;/code&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;支持一次多个查询参数，之间通过逗号分隔，比如：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;imports?$=jquery,jQuery=jquery,angular,config=&amp;gt;{size:50}!./file.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-方法二采用expose-loader&quot;&gt;2. 方法二：采用&lt;code class=&quot;highlighter-rouge&quot;&gt;expose-loader&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expose-loader&lt;/code&gt;的思路是将某个对象暴露成一个全局变量。&lt;/p&gt;

&lt;p&gt;具体到这个问题中，就是把&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;对象暴露成全局变量。这样，那些&lt;code class=&quot;highlighter-rouge&quot;&gt;bootstrap.js&lt;/code&gt;之类的文件就都能访问这个变量了。&lt;/p&gt;

&lt;p&gt;具体做法，修改&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;文件:&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;module:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;loaders:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;test:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require.resolve(&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;jquery&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;expose?$!expose?jQuery&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3-方法三使用webpackprovideplugin&quot;&gt;3. 方法三：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack.ProvidePlugin&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;具体做法，修改&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack.config.js&lt;/code&gt;文件：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;plugins:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;   
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;webpack.ProvidePlugin(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;jquery&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;jQuery&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jquery&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;window.jQuery&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;jquery&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4-小节&quot;&gt;4. 小节&lt;/h3&gt;

&lt;p&gt;从上面的介绍可以看出，三种解决方法的思路分两类：方法一，是修改调用者；方法二、三是修改提供者。&lt;/p&gt;

&lt;h2 id=&quot;二自定义的js文件&quot;&gt;二、自定义的js文件&lt;/h2&gt;

&lt;p&gt;这里问题，属于模块提供方没有调用&lt;code class=&quot;highlighter-rouge&quot;&gt;export&lt;/code&gt;导出模块，或者没有&lt;code class=&quot;highlighter-rouge&quot;&gt;define&lt;/code&gt;定义模块。&lt;/p&gt;

&lt;p&gt;好办，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exports-loader&lt;/code&gt;!这个作用和前面提到的&lt;code class=&quot;highlighter-rouge&quot;&gt;imports-loader&lt;/code&gt;类似，他是在文件的最后添加一行，类似如下的代码：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*** EXPORTS FROM exports-loader ***/&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;YouModule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样，如果需要一次导出多个对象，如同&lt;code class=&quot;highlighter-rouge&quot;&gt;imports-loader&lt;/code&gt;调用，多个对象间也是逗号分隔。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require(&quot;exports?file,parse=helpers.parse!./file.js&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，&lt;code class=&quot;highlighter-rouge&quot;&gt;./file.js&lt;/code&gt;文件的最后会添加如下代码：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*** EXPORTS FROM exports-loader ***/&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;file&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;parse&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三稍微复杂一点的情况&quot;&gt;三、稍微复杂一点的情况&lt;/h2&gt;

&lt;p&gt;自定义的多个js模块直接存在相互调用的情况。&lt;/p&gt;

&lt;p&gt;比如，&lt;code class=&quot;highlighter-rouge&quot;&gt;b.js&lt;/code&gt;里面调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt;提供的对象，但是都没有&lt;code class=&quot;highlighter-rouge&quot;&gt;exports&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;require&lt;/code&gt;。见示例：&lt;/p&gt;

&lt;p&gt;文件： &lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文件: &lt;code class=&quot;highlighter-rouge&quot;&gt;b.js&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(....)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解决办法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;require([
	'expose?A!exports?A!./a.js',
	'./b.js'
], ...);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上，把&lt;code class=&quot;highlighter-rouge&quot;&gt;a.js&lt;/code&gt;中的A定义成全景对象公布出去，这样&lt;code class=&quot;highlighter-rouge&quot;&gt;b.js&lt;/code&gt;里面就可以正常使用&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;对象了。&lt;/p&gt;

&lt;p&gt;除此之外，还有一个解决方案（不推荐）：使用&lt;code class=&quot;highlighter-rouge&quot;&gt;script-loader&lt;/code&gt;，它可以在全局环境下执行一次指定的脚本，比如：&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;
	&lt;span class=&quot;s1&quot;&gt;'script!./a.js'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
	&lt;span class=&quot;s1&quot;&gt;'./b.js'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里，会把&lt;code class=&quot;highlighter-rouge&quot;&gt;./a.js&lt;/code&gt;直接作为脚本执行一次。在&lt;code class=&quot;highlighter-rouge&quot;&gt;node.js&lt;/code&gt;环境下，&lt;code class=&quot;highlighter-rouge&quot;&gt;script-loader&lt;/code&gt;什么都不做。&lt;/p&gt;

&lt;h2 id=&quot;四其他&quot;&gt;四、其他&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;file-loader&lt;/code&gt; : 修改文件名，放在输出目录下，并返其对应的 url .&lt;/p&gt;

    &lt;p&gt;默认修改后的文件名，是文件内容的MD5哈希串。你也可以自定义文件名。比如：&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=js/[hash].script.[ext]!./javascript.js&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; js/0dcbbaa701328a3c262cfd45869e351f.script.js&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=html-[hash:6].html!./page.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; html-109fa8.html&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=[hash]!./flash.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; c31e9820c001c9c4a86bce33ce43b679&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=[sha512:hash:base64:7].[ext]!./image.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; gdyb21L.png&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// use sha512 hash instead of md5 and with only 7 chars of base64&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=img-[sha512:hash:base64:7].[ext]!./image.jpg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; img-VqzT5ZC.jpg&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// use custom name, sha512 hash instead of md5 and with only 7 chars of base64&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=picture.png!./myself.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; picture.png&lt;/span&gt;

 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;file?name=[path][name].[ext]?[hash]!./dir/file.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; dir/file.png?e43b20c069c4a01867c31e98cbce33c9&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;url-loader&lt;/code&gt; : 这个加载器的工作方式很像&lt;code class=&quot;highlighter-rouge&quot;&gt;file-loader&lt;/code&gt;。只是当文件大小小于限制值时，它可以返回一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Data Url&lt;/code&gt;。限制值可以作为查询参数传入。默认不限制。比如：&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;url?limit=10000!./file.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; 如果&quot;file.png&quot;小于10kb，则转成一个DataUrl&lt;/span&gt;
	
 &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;url?mimetype=image/png!./file.png&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;c1&quot;&gt;// =&amp;gt; 指定文件的mimetype (不指定，则根据文件后缀推测.)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;style-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;css-loader&lt;/code&gt;: 这个很常用了，不解释。推荐用法是：&lt;code class=&quot;highlighter-rouge&quot;&gt;require(&quot;style!css!./file.css&quot;);&lt;/code&gt;,类似的还有&lt;code class=&quot;highlighter-rouge&quot;&gt;less-loader&lt;/code&gt;，推荐使用：&lt;code class=&quot;highlighter-rouge&quot;&gt;require(&quot;style!css!less!./file.less&quot;);&lt;/code&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;raw-loader&lt;/code&gt;: 把文件内容作为字符串返回。&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fileContent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'raw!./file.txt'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;这里，把&lt;code class=&quot;highlighter-rouge&quot;&gt;./file.txt&lt;/code&gt;的内容作为字符串返回。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;html-loader&lt;/code&gt;: 把Html文件输出成字符串。与&lt;code class=&quot;highlighter-rouge&quot;&gt;raw-loader&lt;/code&gt;不同的是，它默认处理html中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img src=&quot;image.png&quot;&amp;gt;&lt;/code&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;require(&quot;./image.png&quot;)&lt;/code&gt;，你同时需要在你的配置中指定image文件的加载器，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;url-loader&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;file-loader&lt;/code&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;你可以通过加载器的查询参数&lt;code class=&quot;highlighter-rouge&quot;&gt;attrs&lt;/code&gt;来指定哪些html标签可以被处理。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;attrs=img:src&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;html-loader&lt;/code&gt;默认只处理图片，你也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;attrs&lt;/code&gt;,告诉他也处理javascript文件，比如：&lt;/p&gt;

        &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;html?attrs=attrs=script:src img:src!./file.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;或者&lt;/p&gt;

        &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;html?attrs[]=script:src&amp;amp;attrs[]=img:src!./file.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;多个标签用空格分隔或者使用数组设定。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你也可以告诉加载器，什么都不转换，包括默认处理的&lt;code class=&quot;highlighter-rouge&quot;&gt;image&lt;/code&gt;。如下设置：&lt;/p&gt;

        &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;html?attrs=false!./file.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;或者&lt;/p&gt;

        &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nx&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;html?-attrs!./file.html&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack --optimize-minimize&lt;/code&gt;时，&lt;code class=&quot;highlighter-rouge&quot;&gt;html-loader&lt;/code&gt;会对加载的html内容最小化。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;source-map-loader&lt;/code&gt;: 方便调试，不解释。&lt;/p&gt;

    &lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;exports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;na&quot;&gt;preLoaders&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;sr&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;[\.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;js$/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;na&quot;&gt;loader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;source-map-loader&quot;&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;上例，是对后缀为&lt;code class=&quot;highlighter-rouge&quot;&gt;.min.js&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;-min.js&lt;/code&gt;结尾的文件，做&lt;code class=&quot;highlighter-rouge&quot;&gt;source-map&lt;/code&gt;操作。不过，你要确保&lt;code class=&quot;highlighter-rouge&quot;&gt;min.js&lt;/code&gt;文件中按规范指定了&lt;code class=&quot;highlighter-rouge&quot;&gt;//# sourceMappingURL=xxxx.map&lt;/code&gt;才行！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;

&lt;p&gt;我们讨论了常用的&lt;code class=&quot;highlighter-rouge&quot;&gt;loader&lt;/code&gt;，包括：&lt;code class=&quot;highlighter-rouge&quot;&gt;imports-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;exports-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;expose-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;script-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;file-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;url-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;css-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;style-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;raw-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;html-loader&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;source-map-loader&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;官网还提供了一些其他的&lt;code class=&quot;highlighter-rouge&quot;&gt;loader&lt;/code&gt;，你也可以根据个性化需要，自定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;loader&lt;/code&gt;。这里就不再继续讨论了。&lt;/p&gt;

&lt;p&gt;更多&lt;code class=&quot;highlighter-rouge&quot;&gt;webpack&lt;/code&gt;的知识可以从官网获取。网上也有一些不错的第三方入门的博文，比如下面两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/petehunt/webpack-howto&quot;&gt;github.com/petehunt/webpack-howto&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://christianalfoni.github.io/react-webpack-cookbook/&quot;&gt;christianalfoni.github.io/react-webpack-cookbook/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>lamp下安装joomla和joomla模板</title>
   <link href="http://www.blogways.net/blog/2016/01/07/joomla-templates-install.html"/>
   <updated>2016-01-07T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/01/07/joomla-templates-install</id>
   <content type="html">&lt;h2 id=&quot;一joomla简介&quot;&gt;一、joomla简介&lt;/h2&gt;
&lt;p&gt;joomla是一个内容管理系统，Joomla是使用PHP语言加上MySQL数据库所开发的软件系统，可以在Linux、 Windows、MacOSX等各种不同的平台上执行。&lt;/p&gt;
&lt;h2 id=&quot;二joomla安装环境&quot;&gt;二、joomla安装环境&lt;/h2&gt;
&lt;p&gt;lamp环境，先前安装wordpress时已经在主机上搭建好。&lt;/p&gt;
&lt;h2 id=&quot;三安装joomla&quot;&gt;三、安装joomla&lt;/h2&gt;
&lt;h3 id=&quot;1下载安装包&quot;&gt;1.下载安装包&lt;/h3&gt;
&lt;p&gt;进入官网下载&lt;a href=&quot;https://www.joomla.org/download.html&quot;&gt;https://www.joomla.org/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装包Joomla_3.4.8-Stable-Full_Package.zip&lt;/p&gt;
&lt;h3 id=&quot;2解压并上传到指定根目录&quot;&gt;2.解压，并上传到指定根目录&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo scp -r joomla/ spdev@10.20.16.79:/var/www/html&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;3建立数据库&quot;&gt;3.建立数据库&lt;/h3&gt;
&lt;p&gt;在安装之前最好先建立一个数据库，在安装网站时会用到。&lt;/p&gt;

&lt;p&gt;建库地址：&lt;a href=&quot;10.20.16.79/phpmyadmin/&quot;&gt;10.20.16.79/phpmyadmin/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;4进入安装&quot;&gt;4.进入安装&lt;/h3&gt;
&lt;p&gt;安装地址：&lt;a href=&quot;10.20.16.79/joomla/&quot;&gt;10.20.16.79/joomla/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;进入安装界面开始安装:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(1) 第一步是基本配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选择语言，输入网站的名称，管理员的邮箱，用户名和密码，然后点击下一步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(2) 第二步是配置网站的数据库&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据库类型是默认的MySQLi，数据库的主机名：localhost，数据库的用户名：root，数据库名：joomla（提前用phpmyadmin为Joomla创建一个数据库）。Joomla会随机自动我们添加一个数据表前缀。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;旧数据库的处理这里，如果你现在使用的数据库里以前安装过Joomla，并且你正在安装的Joomla与之前的Joomla的数据表前缀是一样的。那么这里的设置可能影响到之前安装的Joomla的数据库。选择备份或者删除以前的数据表。设置好以后点击下一步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(3) ftp设置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以跳过，点下一步。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(4) 第四步安装选择&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;选择安装示范数据的类型。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(5) 检查配置&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;预览安装之前填入的一些信息，另外还有服务器环境的相关的配置，如果有某些配置不符合Joomla的要求，需要修改服务器的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(6) 点击安装&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;安装成功会提示删除installation目录，需手动删除。
 同时安装成功也会显示警告：在创建配置文件的过程中发生错误，根据警告提示要在网站根目录下创建configuration.php文件，代码在警告下的代码框中可供复制。&lt;/p&gt;

&lt;p&gt;测试安装成果：&lt;a href=&quot;10.20.16.79/joomla&quot;&gt;10.20.16.79/joomla&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;后台的地址：&lt;a href=&quot;10.20.16.79/joomla/administrator/&quot;&gt;10.20.16.79/joomla/administrator/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;四安装joomla模板&quot;&gt;四、安装joomla模板&lt;/h2&gt;
&lt;h3 id=&quot;1快速安装&quot;&gt;1.快速安装&lt;/h3&gt;

&lt;p&gt;从weidea.net网站上下载的joomla模板都会提供快速安装包。只需把安装包解压到&lt;code class=&quot;highlighter-rouge&quot;&gt;/var/www/html&lt;/code&gt;目录，安装过程和安装joomla是一样的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;要特别注意的是:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于网站的根目录，文件或者是文件夹的拥有者不能是root和用户组不能是root，如果网站的根目录和根目录下面的文件和目录的拥有者是root的话，会导致不能网站正常的运行，出现500服务器错误。&lt;/p&gt;

&lt;p&gt;进入网站的根目录，输入&lt;code class=&quot;highlighter-rouge&quot;&gt;chmod -R 775 html&lt;/code&gt;，网站方可正常运行。&lt;/p&gt;
&lt;h3 id=&quot;2登录joomla后台安装&quot;&gt;2.登录joomla后台安装&lt;/h3&gt;

&lt;p&gt;(1) 主菜单下点击Extensions，在下拉列表中点击manage，会看到&lt;code class=&quot;highlighter-rouge&quot;&gt;Upload &amp;amp; Install Joomla Extension&lt;/code&gt;这里提供了一个入口可以上传joomla主题模板包。&lt;/p&gt;

&lt;p&gt;(2)如果下载下来的joomla模板文件里有框架包，则必须在上传主题前先上传框架包，框架是主题能得以应用的前提。&lt;/p&gt;

&lt;p&gt;(3) 在同样的入口，上传插件包。这些插件使得主题某些特效能显示的关键。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;个人体会：&lt;/strong&gt;以上两种安装joomla模板的方法，推荐用第一种方法，比较靠谱。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>在Drupal上部署主题</title>
   <link href="http://www.blogways.net/blog/2016/01/05/drupal-arrange-themes.html"/>
   <updated>2016-01-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/01/05/drupal-arrange-themes</id>
   <content type="html">&lt;h1 id=&quot;在drupal上部署主题&quot;&gt;在Drupal上部署主题&lt;/h1&gt;

&lt;h2 id=&quot;一简单粗暴法profile文件&quot;&gt;一.简单粗暴法（profile文件）&lt;/h2&gt;

&lt;p&gt;以Avira主题为例&lt;/p&gt;

&lt;h4 id=&quot;1系统需求&quot;&gt;1.系统需求&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Drupal 7&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;主题文件：avira_install_profile.zip&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Web server：Apache，Nginx&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PHP 5.2.5 or higher&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MySQL 5.0.15 or higher&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2主题安装&quot;&gt;2.主题安装&lt;/h4&gt;

&lt;p&gt;将主题文件解压到服务器目录下，用浏览器打开该目录，接下来的步骤和安装drupal的步骤类似，可根据视频所示安装即可。&lt;/p&gt;

&lt;iframe width=&quot;560&quot; height=&quot;315&quot; src=&quot;https://www.youtube.com/embed/I9sScpIcO7E&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;

&lt;blockquote&gt;
  &lt;p&gt;该视屏在youtobe上，可能需要翻墙观看&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;二修改数据库法&quot;&gt;二.修改数据库法&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;进入phpmyadmin，新建数据库，当然也可以使用命令新建数据库。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mysql -u root -p
 create database Ariva;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进入该数据库，将主题的数据库文件导入数据库。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; use Ariva;
 source /data/spdev/chenfan/Ariva/Ariva.sql;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后把主题包解压放到服务器目录下，修改主题配置文件。主题配置文件在主题目录/sites/default/setting.php,并且修改该文件。然后用浏览器打开该主题目录即可&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; sudo vi /data/spdev/chenfan/Ariva/sites/default/settings.php
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;　　修改下图部分:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\database.jpg&quot; alt=&quot;database&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三在已有drupal中安装主题&quot;&gt;三.在已有drupal中安装主题&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载主题文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用FTP工具将其放在drupal的&lt;code class=&quot;highlighter-rouge&quot;&gt;sites/all/themes/&lt;/code&gt;目录下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开drupal admin toolbar，点击 Appearance，找到导入的主题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后点击主题下的Enable and set default，设置成默认主题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;点击Theme settings，可以设置一些主题的基本操作&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四在已有的drupal中部署主题&quot;&gt;四.在已有的drupal中部署主题&lt;/h2&gt;

&lt;p&gt;在三中安装后的主题，是没有任何内容，这时我们需要加载一些模块来充实内容，使用这种方式也可以比较自由的设计自己心目当中想要的模块&lt;/p&gt;

&lt;p&gt;因为这里的内容较多，我只对常用的几大模块做些介绍&lt;/p&gt;

&lt;h4 id=&quot;1slider幻灯片模块&quot;&gt;1.slider（幻灯片模块）&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&quot;http://your-site.com/admin/modules&quot;&gt;drupal官网&lt;/a&gt;下载 jquery_update、imce、Layer slider，并将其解压放到&lt;code class=&quot;highlighter-rouge&quot;&gt;sites/all/modules/&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;打开 drupal admin toolbar ，点击Modules，使下载的模块enable&lt;/p&gt;

&lt;p&gt;然后在drupal admin toolbar 中会显示layer slider，点击设计幻灯片&lt;/p&gt;

&lt;p&gt;在Home » Administration » Structure 中将该幻灯片放在你想放的位置，一般我们作为首页展示，会放在主页位置&lt;/p&gt;

&lt;p&gt;如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\slider.jpg&quot; alt=&quot;slider&quot; /&gt;&lt;/p&gt;

&lt;p&gt;便可以在主页前端看到出现该幻灯片&lt;/p&gt;

&lt;h4 id=&quot;2菜单栏&quot;&gt;2.菜单栏&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&quot;http://your-site.com/admin/modules&quot;&gt;drupal官网&lt;/a&gt;下载 Superfish 模块在设计菜单栏，并将其解压放到&lt;code class=&quot;highlighter-rouge&quot;&gt;sites/all/modules/&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;打开 drupal admin toolbar ，点击Modules，使下载的模块enable&lt;/p&gt;

&lt;p&gt;在Home » Administration » Structure 中，有 “Superfish 1 (Superfish)”  点击”Configure”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在模块 title field 输入 : &lt;none&gt;&lt;/none&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在模块 description 输入: Main menu&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 Region settings -&amp;gt; Nevia 选择 “Main menu”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;拉到底部点击”save block”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;3主页模块&quot;&gt;3.主页模块&lt;/h4&gt;

&lt;p&gt;打开 drupal admin toolbar ，点击Content，然后add content，选择Basic page在这里你可以添加自己的页面，然后在settings里连接到想到链接的页面&lt;/p&gt;

&lt;h4 id=&quot;4blog&quot;&gt;4.blog&lt;/h4&gt;

&lt;p&gt;在&lt;a href=&quot;http://your-site.com/admin/modules&quot;&gt;drupal官网&lt;/a&gt;下载 blog page 模块在设计菜单栏，并将其解压放到&lt;code class=&quot;highlighter-rouge&quot;&gt;sites/all/modules/&lt;/code&gt;中&lt;/p&gt;

&lt;p&gt;打开 drupal admin toolbar ，点击Modules，使下载的模块enable&lt;/p&gt;

&lt;p&gt;然后点击Content ，add content选择blog，该模块可以添加标签等功能&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Drupal安装教程</title>
   <link href="http://www.blogways.net/blog/2016/01/04/drupal-install.html"/>
   <updated>2016-01-04T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2016/01/04/drupal-install</id>
   <content type="html">&lt;h1 id=&quot;drupal安装教程&quot;&gt;Drupal安装教程&lt;/h1&gt;

&lt;h2 id=&quot;一下载drupal&quot;&gt;一.下载drupal&lt;/h2&gt;

&lt;p&gt;访问Drupal官方网站下载Drupal程序（http://drupal.org/download），同时把下载到的压缩包进行解压并上传到空间根目录，在浏览器中输入网站域名，将会自动进入Drupal的安装界面。&lt;/p&gt;

&lt;h2 id=&quot;二新建数据库&quot;&gt;二.新建数据库&lt;/h2&gt;

&lt;p&gt;打开phpmyadmin，点击新建数据库，名字为drupal&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\shujuku.jpg&quot; alt=&quot;shujuku&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三选择安装类型&quot;&gt;三.选择安装类型&lt;/h2&gt;

&lt;p&gt;如图，标准Standard和迷你Minimal，区别是安装系统模块的多少，如果只是普通文章应用选择Minimal即可，此处选择标准型，然后点击Save and continue进入下一步。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\profile.jpg&quot; alt=&quot;shujuku&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四选择程序的语言&quot;&gt;四.选择程序的语言，&lt;/h2&gt;

&lt;p&gt;默认即提供英文版，如需其它语言，点击“Learn how to install Drupal in other languages”进入新界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\yuyan.jpg&quot; alt=&quot;shujuku&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;如需要安装中文可以下载根据说明下载，并将下载的文件放到/profiles/standard/translations/中即可&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\zhongwen.jpg&quot; alt=&quot;shujuku&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;五安装需求&quot;&gt;五.安装需求&lt;/h2&gt;

&lt;p&gt;选择语言后，点击确定，会出现下图需求问题&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\requirement.jpg&quot; alt=&quot;xuqiu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先目录sites/default/files 不存在，则需要在该目录下建立该文件夹。&lt;/p&gt;

&lt;p&gt;进入sites/default，输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mkdir files
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并将该文件权限设置为可写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo chmod -R 777 files
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后复制 ./sites/default/default.settings.php 文件到./sites/default/settings.php&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cp default.settings.php settings.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并将其设置成可写&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sudo chmod 777 settings.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;六设置数据库&quot;&gt;六.设置数据库&lt;/h2&gt;

&lt;p&gt;设置数据库信息，根据提示设置MYSQL或sqlite数据库的用户名、数据库名和密码。Localhost一般保持默认即可，数据库端口和表前缀没有强制要求，如果同一数据库下安装多个Drupal，要设置表前缀。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\mysql1.jpg&quot; alt=&quot;mysql1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\mysql2.jpg&quot; alt=&quot;mysql2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;进入下一步，系统会自动安装Drupal相关模块，等待安装完成&lt;/p&gt;

&lt;h2 id=&quot;七设置站点信息&quot;&gt;七.设置站点信息&lt;/h2&gt;

&lt;p&gt;根据自己的需要自主设置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\site.jpg&quot; alt=&quot;site&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;八安装完成&quot;&gt;八.安装完成&lt;/h2&gt;

&lt;p&gt;drupal安装完成后会出现如下界面&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\images\post\site.jpg&quot; alt=&quot;Drupal_Complete&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;九常见问题&quot;&gt;九.常见问题&lt;/h2&gt;

&lt;p&gt;1.在安装数据库时，没有mysql选项&lt;/p&gt;

&lt;p&gt;原因：在没有php没有打开mysql扩展&lt;/p&gt;

&lt;p&gt;解决办法：进入php的安装目录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/bin/phpize
./configure --with-php-config=/usr/local/bin/php-config --with-mysql=/usr/local/mysql/
make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;mysql/modules&lt;/code&gt;下会看到mysql.so&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;修改php.ini&lt;/p&gt;

&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;extensions = &quot;mysql.so&quot;&lt;/code&gt;前的分号去掉，打开mysql扩展&lt;/p&gt;

&lt;p&gt;将mysql.so拷贝到extension_dir目录下，extension_dir在php.ini中设置&lt;/p&gt;

&lt;p&gt;重启apache即可&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;apacheclt restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>linux下源码安装wordpress全过程</title>
   <link href="http://www.blogways.net/blog/2015/12/22/wordpress-install.html"/>
   <updated>2015-12-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/12/22/wordpress-install</id>
   <content type="html">&lt;h2 id=&quot;搭建lamp环境&quot;&gt;搭建lamp环境&lt;/h2&gt;
&lt;h3 id=&quot;一-准备安装包&quot;&gt;一 准备安装包&lt;/h3&gt;
&lt;h4 id=&quot;库文件&quot;&gt;库文件：&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;libxml2-2.6.30.tar.gz&lt;/li&gt;
  &lt;li&gt;libmcrypt-2.5.8.tar.gz&lt;/li&gt;
  &lt;li&gt;zlib-1.2.3.tar.gz&lt;/li&gt;
  &lt;li&gt;libpng-1.2.31.tar.gz&lt;/li&gt;
  &lt;li&gt;jpegsrc.v6b.tar.gz&lt;/li&gt;
  &lt;li&gt;freetype-2.3.5.tar.gz&lt;/li&gt;
  &lt;li&gt;autoconf-2.61.tar.gz&lt;/li&gt;
  &lt;li&gt;gd-2.0.35.tar.gz&lt;/li&gt;
  &lt;li&gt;apr-1.4.6.tar.gz&lt;/li&gt;
  &lt;li&gt;apr-util-1.5.1.tar.gz&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;主要文件&quot;&gt;主要文件:&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;httpd-2.2.9.tar.gz&lt;/li&gt;
  &lt;li&gt;mysql-5.1.59.tar.gz&lt;/li&gt;
  &lt;li&gt;php-5.2.6.tar.gz&lt;/li&gt;
  &lt;li&gt;phpMyAdmin-3.0.0&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;将安装包都上传到usrlocalsrc目录&quot;&gt;将安装包都上传到/usr/local/src目录&lt;/h4&gt;
&lt;h3 id=&quot;二-安装apache前期准备库文件安装&quot;&gt;二 安装apache前期准备（库文件安装）&lt;/h3&gt;
&lt;h4 id=&quot;1-解包&quot;&gt;1. 解包&lt;/h4&gt;
&lt;h5 id=&quot;编写一个shell脚本tarsh进行解包&quot;&gt;编写一个shell脚本tar.sh进行解包。&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/sh&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /usr/local/src
ls &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.tar.gz &amp;gt; ls.list      
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;TAR &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; ’cat ls.list‘
&lt;span class=&quot;k&quot;&gt;do
&lt;/span&gt;tar -zxvf &lt;span class=&quot;nv&quot;&gt;$TAR&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;执行脚本tarsh进行解包&quot;&gt;执行脚本tar.sh进行解包&lt;/h5&gt;
&lt;h4 id=&quot;2-按顺序安装&quot;&gt;2. 按顺序安装&lt;/h4&gt;
&lt;h5 id=&quot;安装libxml2&quot;&gt;【安装libxml2】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd libxml2-2.6.30  
./configure --prefix=/usr/local/libxml2/  
make   
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装libmcrypt&quot;&gt;【安装libmcrypt】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd libmcrypt-2.5.8  
./configure --enable-ltdl-install  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装zlib&quot;&gt;【安装zlib】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd zlib-1.2.3  
./configure  
make  
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装libpng&quot;&gt;【安装libpng】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd libpng-1.2.31  
./configure --prefix=/usr/local/libpng/  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装jpegsrcv6b&quot;&gt;【安装jpegsrc.v6b】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir /usr/local/jpeg6  
mkdir /usr/local/jpeg6/bin  
mkdir /usr/local/jpeg6/lib  
mkdir /usr/local/jpeg6/include  
mkdir -p /usr/local/jpeg6/man/man1  
cd jpeg-6b  
./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装freetype&quot;&gt;【安装freetype】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd freetype-2.3.5  
./configure --prefix=/usr/local/freetype/  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装autoconf&quot;&gt;【安装autoconf】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd autoconf-2.61  
./configure  
make  
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装gd&quot;&gt;【安装gd】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd gd-2.0.35  
./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装apr&quot;&gt;【安装apr】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure
make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;安装apr-util&quot;&gt;【安装apr-util】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure  --with-apr=/usr/local/apr/
make
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;三-安装apache&quot;&gt;三 安装apache&lt;/h3&gt;
&lt;h4 id=&quot;apache安装与配置&quot;&gt;apache安装与配置&lt;/h4&gt;
&lt;h5 id=&quot;安装apache&quot;&gt;【安装apache】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd httpd-2.2.9  
./configure --prefix=/usr/local/apache2/ --sysconfdir=/etc/httpd/ --with-included-apr --disable-userdir --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite=shared --enable-static-support  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;启动apache&quot;&gt;启动apache&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/local/apache2/bin/apachectl start  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;修改配置文件&quot;&gt;修改配置文件&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/httpd/httpd.conf
#查找ServerName,将注释去掉  
ServerName 'www.example.com:80'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;将apache添加到系统服务中&quot;&gt;将apache添加到系统服务中&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp /usr/local/apache2/bin/apachectl /etc/init.d/httpd  
vi /etc/rc.d/init.d/httpd  
#在#!/bin/sh后添加下面两行(包含&quot;#&quot;)  
# chkconfig:2345 85 15
# description:Apache
#添加执行权限  
chmod 755 /etc/init.d/httpd  
#添加到系统服务中  
chkconfig --add httpd  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;开启apache&quot;&gt;开启apache&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service httpd start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;四-安装mysql&quot;&gt;四 安装mysql&lt;/h3&gt;
&lt;h4 id=&quot;mysql安装与配置&quot;&gt;mysql安装与配置&lt;/h4&gt;
&lt;h5 id=&quot;安装mysql&quot;&gt;【安装mysql】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;groupadd mysql  
useradd -g mysql mysql  
cd mysql-5.1.59  
./configure --prefix=/usr/local/mysql/ --with-extra-charsets=all  
make  
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp support-files/my-medium.cnf /etc/my.cnf  
/usr/local/mysql/bin/mysql_install_db --user=mysql  
chown -R root /usr/local/mysql  
chown -R mysql /usr/local/mysql/var  
chgrp -R mysql /usr/local/mysql  
/usr/local/mysql/bin/mysqld_safe  --user=mysql &amp;amp;  
cp /lamp/src/mysql-5.1.59/support-files/mysql.server /etc/rc.d/init.d/mysqld  
chown root.root /etc/rc.d/init.d/mysqld  
chmod 755 /etc/rc.d/init.d/mysqld  
chkconfig --add mysqld  
chkconfig --list mysqld  
chkconfig --levels 245 mysqld off  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;配置mysql&quot;&gt;配置mysql&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /usr/local/mysql  
bin/mysqladmin version //简单的测试  
bin/mysqladmin Variables //查看所有mysql参数  
bin/mysql -uroot //没有密码可以直接登录本机服务器  
DELETE FROM mysql.user WHERE Host='localhost' AND User='';  
FLUSH PRIVILEGES;  
#设置root密码为123456  
SET PASSWORD FOR 'root'@'localhost' = PASSWORD('123456');  
#配置可远程连接mysql  
use mysql  
SELECT user,password,host FROM user;  
DELETE FROM user WHERE host='localhsot.localdomain'  
DELETE FROM user WHERE host='10.20.16.79';  
UPDATE user SET host='%' WHERE user='root';  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;重启mysql&quot;&gt;重启mysql&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service mysqld restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;五-安装php&quot;&gt;五 安装php&lt;/h3&gt;
&lt;h4 id=&quot;php安装与配置&quot;&gt;php安装与配置&lt;/h4&gt;
&lt;h5 id=&quot;安装php&quot;&gt;【安装php】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd php-5.2.6  
./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql/ --with-libxml-dir=/usr/local/libxml2/ --with-jpeg-dir=/usr/local/jpeg6/ --with-freetype-dir=/usr/local/freetype/ --with-gd=/usr/local/gd2/ --with-mcrypt=/usr/local/libmcrypt/ --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets  
make  
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;创建配置文件&quot;&gt;创建配置文件&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# cp php.ini-dist /usr/local/php/etc/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;使用vi编辑apache配置文件&quot;&gt;使用vi编辑apache配置文件&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# vi /etc/httpd/httpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;添加这一条代码&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Addtype application/x-httpd-php .php .phtml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;重启apache&quot;&gt;重启Apache&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# /usr/local/apache2/bin/apachectl restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;apache配置&quot;&gt;【apache配置】&lt;/h5&gt;
&lt;p&gt;######建立工作目录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p /var/www/html  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;修改httpdconf&quot;&gt;修改httpd.conf&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/httpd/httpd.conf  
#功能: 设置工作目录  
#说明: 搜索DocumentRoot, 修改为  
DocumentRoot &quot;/var/www/html&quot;  
#功能: 设置目录选项
搜索&amp;lt;Directory &quot;/usr/local/apache2//htdocs&quot;&amp;gt;, 修改为  
&amp;lt;Directory &quot;/var/www/html&quot;&amp;gt;  
#功能: 设置默认文档  
搜索&amp;lt;IfModule dir_module&amp;gt;, 修改为  
DirectoryIndex index.html index.php
#功能: 增加php类型  
搜索 AddType application/x-gzip .gz .tgz在后面添加  
AddType application/x-httpd-php .html .php  
功能: 不允许访问目录  
说明: 搜索Options Indexes FollowSymLinks项并注释  
#Options Indexes FollowSymLinks   
#注意: 修改配置文件后, 重启apache才能生效  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;重启apache-1&quot;&gt;重启apache&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service httpd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;添加pdo_mysql扩展&quot;&gt;【添加PDO_MYSQL扩展】&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /lamp/src/php-5.2.6/ext/pdo_mysql  
/usr/local/php/bin/phpize  
./configure --with-php-config=/usr/local/php/bin/php-config --with-pdo-mysql=/usr/local/mysql  
make  
make install  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;执行完make-install后会生成&quot;&gt;执行完make install后会生成&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#Installing shared extensions: /usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h6 id=&quot;修改phpini&quot;&gt;修改php.ini&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /usr/local/php/etc/php.ini  
#查找extension_dir,修改为
extension_dir = &quot;/usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/&quot;  
#添加pdo_mysql
extension = pdo_mysql.so  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;######重启apache&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;service httpd restart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h3 id=&quot;六-安装phpmyadmin&quot;&gt;六 安装phpmyadmin&lt;/h3&gt;
&lt;h4 id=&quot;phpmyadmin安装与配置&quot;&gt;phpmyadmin安装与配置&lt;/h4&gt;
&lt;h5 id=&quot;安装phpmyadmin&quot;&gt;【安装phpmyadmin】&lt;/h5&gt;
&lt;h6 id=&quot;拷贝目录到指定位置并改名为phpmyadmin&quot;&gt;拷贝目录到指定位置并改名为phpmyadmin&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#cp -a  phpMyAdmin-3.0.0-rc1-all-languages /var/www/html/phpmyadmin
#cd /var/www/html/phpmyadmin/
#cp config.sample.inc.php config.inc.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;配置phpmyadmin&quot;&gt;配置phpMyAdmin&lt;/h5&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#vi /var/www/html/phpmyadmin/config.inc.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;将auth_type 改为http&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cfg['Servers'][$i]['auth_type'] = 'http';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;测试&quot;&gt;测试&lt;/h5&gt;
&lt;h6 id=&quot;编写infophp文件查看php配置详细&quot;&gt;编写info.php文件，查看php配置详细&lt;/h6&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; vi /var/www/html/info.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php
phpinfo();
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;h5 id=&quot;通过浏览器访问http10201679infophp获得php的详细配置信息&quot;&gt;通过浏览器访问http://10.20.16.79/info.php，获得php的详细配置信息&lt;/h5&gt;

&lt;h2 id=&quot;安装wordpress&quot;&gt;安装wordpress&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;将解压后的wordpress移动到/var/www/html目录下&lt;/li&gt;
  &lt;li&gt;在浏览器中访问 http://localhost/wordpress/wp-admin/install.php，会访问失败，问题解决方法是修改wp-config.php配置信息，提供数据库的名(wordpress)，用户名(root)，密码()。然后刷新浏览器就能成功访问&lt;/li&gt;
  &lt;li&gt;根据提示注册账号，登录即可进入&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;安装过程参考网址&quot;&gt;安装过程参考网址&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/BTMaster/p/3551073.html&quot;&gt;http://www.cnblogs.com/BTMaster/p/3551073.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/mchina/archive/2012/11/28/2778779.html&quot;&gt;http://www.cnblogs.com/mchina/archive/2012/11/28/2778779.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>公司主机装载apache+PHP+phpmyadmin+wordpress</title>
   <link href="http://www.blogways.net/blog/2015/12/22/wordpress-install-78.html"/>
   <updated>2015-12-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/12/22/wordpress-install-78</id>
   <content type="html">&lt;h1 id=&quot;wordpress-公司主机安装教程&quot;&gt;wordpress 公司主机安装教程&lt;/h1&gt;

&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;介绍&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;安装前准备&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;配置变量环境&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;安装Apache&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;安装MySql&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;安装PHP&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#7&quot;&gt;安装phpMyAdmin&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#8&quot;&gt;安装WordPress&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;h2 id=&quot;一-介绍&quot;&gt;一.&lt;a name=&quot;1&quot;&gt;&lt;/a&gt; 介绍&lt;/h2&gt;

&lt;p&gt;　　WordPress是一个注重美学、易用性和网络标准的个人信息发布平台。WordPress虽为免费的开源软件，但其价值无法用金钱来衡量。当前WordPress插件数据库中有超过18000个插件，包括SEO、控件等等。个人可以根据它的核心程序提供的规则自己开发模板和插件。这些插件可以快速地把你的博客改变成cms、forums、门户等各种类型的站点。&lt;/p&gt;

&lt;h2 id=&quot;二-安装前准备&quot;&gt;二. &lt;a name=&quot;2&quot;&gt;&lt;/a&gt;安装前准备&lt;/h2&gt;

&lt;p&gt;Apache版本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;httpd-2.4.17.tar.gz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mysql 版本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;mysql-5.0.41.tar.gz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Php版本：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;php-7.0.0.tar.gz&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;库文件准备：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;autoconf-2.61.tar.gz&lt;/li&gt;
  &lt;li&gt;freetype-2.3.5.tar.gz&lt;/li&gt;
  &lt;li&gt;gd-2.1.1.tar.gz&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;jpegsrc.v6b.tar.gz&lt;/li&gt;
  &lt;li&gt;libmcrypt-2.5.8.tar.gz&lt;/li&gt;
  &lt;li&gt;libpng-1.2.31.tar.gz&lt;/li&gt;
  &lt;li&gt;libxml2-2.6.30.tar.gz&lt;/li&gt;
  &lt;li&gt;zlib-1.2.3.tar.gz&lt;/li&gt;
  &lt;li&gt;phpMyAdmin-4.5.2-rc1-all-languages.tar.gz&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三-配置变量环境&quot;&gt;三. &lt;a name=&quot;3&quot;&gt;&lt;/a&gt;配置变量环境&lt;/h2&gt;

&lt;h3 id=&quot;1-安装libxml2&quot;&gt;1. 安装libxml2&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/libxml2-2.6.30
$./configure --prefix=/usr/local/libxml2
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-安装libmcrypt&quot;&gt;2. 安装libmcrypt&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/libmcrypt-2.5.8
$./configure --prefix=/usr/local/libmcrypt
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3-安装zlib&quot;&gt;3. 安装zlib&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/zlib-1.2.3
$./configure
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;4-安装libpng&quot;&gt;4. 安装libpng&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/libpng-1.2.31
$./configure --prefix=/usr/local/libpng
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5-安装jpeg6&quot;&gt;5. 安装jpeg6&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$mkdir /usr/local/jpeg6
$mkdir /usr/local/jpeg6/bin
$mkdir /usr/local/jpeg6/lib
$mkdir /usr/local/jpeg6/include
$mkdir -p /usr/local/jpeg6/man/ma
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;这个软件包安装有些特殊，其它软件包安装时如果目录不存在，会自动创建，但这个软件包安装时需要手动创建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/jpeg-6b
$./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6-安装freetype&quot;&gt;6. 安装freetype&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/freetype-2.3.5
$./configure --prefix=/usr/local/freetype
$make
$make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;7-安装autoconf&quot;&gt;7. 安装autoconf&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/autoconf-2.61
$./configure
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;8-安装gd库&quot;&gt;8. 安装GD库&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/gd-2.1.1
$./configure \
--prefix=/usr/local/gd2/ \
--enable-m4_pattern_allow \
--with-zlib=/usr/local/zlib/ \
--with-jpeg=/usr/local/jpeg6/ \
--with-png=/usr/local/libpng/ \
--with-freetype=/usr/local/freetype/
$make
$make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;　执行 make 报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make[2]: *** [gd_png.lo] Error 1  
make[2]: Leaving directory /usr/local/src/gd-2.1.1  
make[1]: *** [all-recursive] Error 1  
make[1]: Leaving directory /usr/local/src/gd-2.1.1'  
make: *** [all] Error 2  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;分析&lt;/strong&gt;：这个问题是由于 gd 库中的 gd_png.c 源文件包含 png.h 时，png.h 没有找到导致的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;：在编译文件里 &lt;code class=&quot;highlighter-rouge&quot;&gt;vi gd_png.c&lt;/code&gt; 将 &lt;code class=&quot;highlighter-rouge&quot;&gt;include &quot;png.h&quot;&lt;/code&gt; 改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;include &quot;/usr/local/libpng/include/png.h&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt;　出现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;X--tag=CC: command not found
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;：修改 aclocal.m4 文件，将上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;LIBTOOL＝'$(SHELL) $(top _builddir)/libtool'&lt;/code&gt; 改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;LIBTOOL='$(SHELL)  /usr/bin/libtool' &lt;/code&gt;后重新执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3)&lt;/strong&gt;　Invalid libtool wrapper script when make installing Apache&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make clean
--with-pcre=/usr/local/pcre
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四-安装apache&quot;&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四. 安装Apache&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd /usr/local/src/httpd-2.2.9
$./configure \
--prefix=/usr/local/apache2 \
--sysconfdir=/etc/httpd \
--with-z=/usr/local/zlib \
--with-included-apr \
--with-apr=/usr/local/apr \
--with-apr-util=/usr/local/apr-util /
--with-pcre=/usr/local/pcre \
--enable-so \
--enable-deflate=shared \
--enable-expires=shared \
--enable-rewrite=shared \
$make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;1)&lt;/strong&gt;　执行 configure 出错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;configure: error: Bundled APR requested but not found at ./srclib/.
Download and unpack the corresponding apr and apr-util packages to ./srclib/.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;： 下载 api 和 api-util 安装到 apache 的 ./srclib/ 目录.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2)&lt;/strong&gt;　&lt;code class=&quot;highlighter-rouge&quot;&gt;./configure&lt;/code&gt; 命令后在执行 make 命令的时候报如下错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/ld: /usr/local/lib/libz.a(crc32.o): relocation RX86\_64\_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC   **解决**：下载 zlib-1.2.3.tar.gz 放在 /usr/local 目录执行以下命令：

tar -zxvf zlib-1.2.3.tar.gz
cd zlib-1.2.3
./configure
vi Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;CFLAGS=-O3 -DUSE\_MMAP&lt;/code&gt;
在后面加入-fPIC，即变成 &lt;code class=&quot;highlighter-rouge&quot;&gt;CFLAGS=-O3 -DUSE\_MAP -fPIC&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;启动Apache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;/usr/local/apache2/bin/apachectl start&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;关闭Apache&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;/usr/local/apache2/bin/apachectl stop&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看80端口是否开启&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;netstat -tnl&lt;/td&gt;
      &lt;td&gt;grep 80&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;配置Apache&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;标红部分为需要需改的地方&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lt;font color=#DC143C&amp;gt;ServerRoot “/usr/local/apache2”&amp;lt;/font&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;你的apache软件安装的位置。其它指定的目录如果没有指定绝对路径，则目录是相对于该目录。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PidFile logs/httpd.pid&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;第一个httpd进程(所有其他进程的父进程)的进程号文件位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Listen 80&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;服务器监听的端口号。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&amp;lt;font color=#DC143C&amp;gt;ServerName 10.20.16.78:80&amp;lt;/font&amp;gt;&lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;主站点名称（网站的主机名）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;ServerAdmin admin@clusting.com&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;管理员的邮件地址。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;DocumentRoot “/data/spdev/chenfan”&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;主站点的网页存储位置。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 变更路径
&amp;lt;Directory &quot;/data/spdev/chenfan &quot;&amp;gt;
	Options FollowSymLinks
	AllowOverride None
	Order allow,deny
	#修改权限
	Allow from all
&amp;lt;/Directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五-安装mysql&quot;&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五. 安装Mysql&lt;/h2&gt;

&lt;h3 id=&quot;1-添加一个mysql标准组&quot;&gt;1. 添加一个mysql标准组&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$groupadd mysql
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2-添加mysql用户并加到mysql组中&quot;&gt;2. 添加mysql用户并加到mysql组中&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;amp;useradd -g mysql mysql
&amp;amp;cd /usr/local/src/mysql-5.0.41
&amp;amp;./configure \
--prefix=/usr/local/mysql/ \
--with-extra-charsets=all
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;六-安装php&quot;&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;六. 安装PHP&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$./configure \
--prefix=/usr/local/php \
--with-config-file-path=/usr/local/php/etc \
--with-apxs2=/usr/local/apache2/bin/apxs \
--with-mysql=/usr/local/mysql/mysql-cluster-gpl-7.2.8-linux2.6-x86_64/ \
--with-libxml-dir=/usr/local/libxml2/ \
--with-png-dir=/usr/local/libpng/ \
--with-jpeg-dir=/usr/local/jpeg6/ \
--with-freetype-dir=/usr/local/freetype/ \
-with-gd=/usr/local/gd2/ \
--with-zlib-dir=/usr/local/zlib/ \
--with-mcrypt=/usr/local/libmcrypt/ \
--with-mysqli=/usr/local/mysql/mysql-cluster-gpl-7.2.8-linux2.6-x86_64/bin/mysql_config \
--enable-soap \
--enable-mbstring=all \
--enable-sockets
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;配置PHP&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cp /usr/local/src/php-5.3.16/php.ini-development  /usr/local/php/lib/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编辑 apache 配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$vi /etc/httpd/httpd.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加这一条代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Addtype application/x-httpd-php .php .phtml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在 apache 的 htdocs 下建立一个 php 文件 test.php，里面的内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;?php  
	phpinfo();  
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在浏览器里输入 &lt;a href=&quot;http://10.20.16.78/test.php&quot;&gt;http://10.20.16.78/test.php&lt;/a&gt;，出现 php 信息则为安装正确。&lt;/p&gt;

&lt;h2 id=&quot;七-装载phpmyadmin&quot;&gt;&lt;a name=&quot;7&quot;&gt;&lt;/a&gt;七. 装载phpmyadmin&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tar -zxvf phpMyAdmin-7.0.0-all-languages.tar.gz &amp;gt;此时路径 /data/spdev/chenfan/phpMyAdmin-7.0.0-all-languages.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;配置phpmyadmin&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;重启apache 找到 /libraries/config.default.php文件(config.default.php复制到phpmyadmin目录下，然后更名为config.inc.php)，在linux下直接用vi编辑.&lt;/li&gt;
  &lt;li&gt;查找 &lt;code class=&quot;highlighter-rouge&quot;&gt;$cfg['PmaAbsoluteUri']&lt;/code&gt; 修改为你将上传到空间的phpMyAdmin的网址
如：&lt;code class=&quot;highlighter-rouge&quot;&gt;$cfg['PmaAbsoluteUri'] = 'http://10.20.16.78/admin/';&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;查找 &lt;code class=&quot;highlighter-rouge&quot;&gt;$cfg['Servers'][$i]['host'] = '10.20.16.78';&lt;/code&gt;（通常用默认，也有例外，可以不用修改）&lt;/li&gt;
  &lt;li&gt;查找 ` $cfg[‘Servers’][$i][‘auth_type’] = ‘config’;`
在自己的机子里调试用config；如果在网络上的空间用cookie，这里我们既然在前面已经添加了网址，就修改成cookie ，这里建议使用cookie.\&lt;/li&gt;
  &lt;li&gt;查找 &lt;code class=&quot;highlighter-rouge&quot;&gt;$cfg['Servers'][$i]['user'] = 'root';&lt;/code&gt; // MySQL user（mysql用户名，自己机里用root；）&lt;/li&gt;
  &lt;li&gt;查找 &lt;code class=&quot;highlighter-rouge&quot;&gt;$cfg['Servers'][$i]['password'] = '123456'; &lt;/code&gt;// MySQL password (mysql用户的密码,自己的服务器一般都是mysql用户root的密码)&lt;/li&gt;
  &lt;li&gt;查找 ` $cfg[‘Servers’][$i][‘only_db’] = ‘’;` // If set to a db-name, only（你只有一个数据就设置一下；如果你在本机或想架设服务器，那么建议留空）&lt;/li&gt;
  &lt;li&gt;查找 ` $cfg[‘DefaultLang’] = ‘zh’; `（这里是选择语言，zh代表简体中文的意思,这里不知道填gbk对否）&lt;/li&gt;
  &lt;li&gt;设置完毕后保存&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;出现错误&lt;/strong&gt;：数据库连接错误&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：绝对路径没有配置对&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;：修改 &lt;code class=&quot;highlighter-rouge&quot;&gt;$cfg['PmaAbsoluteUri'] = 'http://10.20.16.78/phpmyadmin/';&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;八装载wordpress&quot;&gt;&lt;a name=&quot;8&quot;&gt;&lt;/a&gt;八.装载wordpress&lt;/h2&gt;

&lt;p&gt;解压 wordpress&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$tar -zxvf wordpress-4.3.1-zh_CN.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改配置文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cp wp-config-sample.php wp-config.php
$vi wp-config.php
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;define(‘DB_NAME’, ‘wordpress’);&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;数据库&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;define(‘DB_USER’, ‘root’);&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;数据库名称&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;define(‘DB_PASSWORD’, ‘&lt;em&gt;**&lt;/em&gt;’);&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;数据库密码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;出现错误&lt;/strong&gt;：装载 php 时错误找不到 mysql_config&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;原因&lt;/strong&gt;：指定的路径出错&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;mysql\_config&lt;/code&gt; 改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;with-mysqli=/usr/local/mysql/mysql-cluster-gpl-7.2.8-linux2.6-x86\_64/bin/mysql_config \&lt;/code&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>linux下搭建属于自己的博客</title>
   <link href="http://www.blogways.net/blog/2015/12/21/wordpress-install-on-linux.html"/>
   <updated>2015-12-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/12/21/wordpress-install-on-linux</id>
   <content type="html">&lt;h1 id=&quot;linux下安装wordpress&quot;&gt;linux下安装Wordpress&lt;/h1&gt;

&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;安装Apache&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;安装PHP服务&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;安装mysql&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;安装phpMyAdmin&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;安装Wordpress&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;常见错误&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;
&lt;h2 id=&quot;一安装apache服务器&quot;&gt;一.&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;安装Apache服务器&lt;/h2&gt;
&lt;p&gt;在linux终端输入&lt;br /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install apache2 **测试**：安装后在浏览器中打开：http://localhost/或者http://127.0.0.1,如果出现It works！则说明安装成功。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二安装php服务&quot;&gt;二.&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;安装PHP服务&lt;/h2&gt;
&lt;p&gt;在linux终端输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get install php5 **测试**：打开sudo gedit /var/www/testphp.php&amp;lt;br&amp;gt;   然后随意输入字符，这里我输入的是chenfan，在浏览器中输入localhost/testphp.php,如果浏览器出现chenfan则说明安装成功 ## 三.&amp;lt;a name=&quot;3&quot;&amp;gt;&amp;lt;/a&amp;gt;安装mysql 在linux终端输入

sudo apt-get install mysql-server
sudo apt-get install mysql-admin
sudo apt-get install mysql-client 安装过程中提示要求输入root密码。   ## 四.&amp;lt;a name=&quot;4&quot;&amp;gt;&amp;lt;/a&amp;gt;安装phpMyAdmin

sudo apt-get install phpmyadmin 此时的phpmyadmin文件夹被安装在/usr/share/phpmyadmin下，为了能在浏览器中访问到phpmyadmin，需要在/var/www下做一个软连接到该文件夹：     进入/var/www文件夹，在该目录下执行如下操作:

sudo ln -s /usr/share/phpmyadmin 安装完毕后别忘了重启apache 和 mysql:

sudo /etc/init.d/apache2 restart
sudo /etc/init.d/mysql restart **测试**：在浏览器中输入localhost/phpmyadmin,如果出现    ![phpmyadmin](\images\post\phpmyadmin.jpg)   则说明安装成功！ 成功后点击新建数据库，建立一个wordpress数据库。 ## 五.&amp;lt;a name=&quot;5&quot;&amp;gt;&amp;lt;/a&amp;gt;安装Wordpress ### 1. 下载下载wordpress(WordPress) 下载地址：   http://wordpress.org/download/ ### 2.解压Wordpress 在linux终端输入

$sudo tar -zxvf wordpress-3.2.1.tar.gz 得到wordpress文件夹，然后按要求编辑wp-config.php文件，主要是提供数据库的名字(如这里的wordpress)，用户名(如root)，密码(如安装mysql时键入的密码)。 ### 3.将Wordpress文件夹拷贝到Apache服务器目录/var/www下
sudo cp -a ./wordpress /var/www 安装完毕后重启apache 和 mysql:

sudo /etc/init.d/apache2 restart
sudo /etc/init.d/mysql restart **测试**：此时在浏览器中访问http://localhost/wordpress/wp-admin/install.php就可以正常安装wordpress ## 六.&amp;lt;a name=&quot;6&quot;&amp;gt;&amp;lt;/a&amp;gt;常见错误 ### 1.php装好 输入在浏览器中打开：http://localhost/或者http://127.0.0.1出现：Not FoundThe requested URL /testphp.php was not found on this server.Apache/2.4.7 (Ubuntu) Server at 127.0.0.1 Port 80   **原因：**apache的根目录里并不包含test.php文件   **解决办法：**修改Apache配置文件 在/etc/apache2/sites-available中修改000-default.conf   输入代码:

sudo vi /etc/apache2/sites-available/000-default.conf 修改 DocumentRoot 修改成你想好存放的目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>meteor入门学习笔记二：一个基础的例子</title>
   <link href="http://www.blogways.net/blog/2015/12/16/meteor-tutorial-2.html"/>
   <updated>2015-12-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/12/16/meteor-tutorial-2</id>
   <content type="html">
&lt;p&gt;这几天在学习Meteor，当前版本为:&lt;code class=&quot;highlighter-rouge&quot;&gt;1.2.1&lt;/code&gt;。学习的主要资料来自官网，笔记如下.&lt;/p&gt;

&lt;h2 id=&quot;一创建一个应用&quot;&gt;一、创建一个应用&lt;/h2&gt;

&lt;p&gt;在这里，我们将要创建一个简单的应用，管理一个任务清单。这样就可以和其他人一起使用这个任务清单，进行合作了。&lt;/p&gt;

&lt;p&gt;为了创建这个应用，需要打开终端，输入命令：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor create simple-todos
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个命令会创建一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-todos&lt;/code&gt;的目录，目录里面有Meteor应用所需要的一些文件，列表如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;simple-todos.js     #一个被服务器和客户端都使用的javascript文件
simple-todos.html   #一个html文件，里面定义了页面视图模版
simple-todos.css    #一个css文件，定义了应用的式样
.meteor             #一个隐藏目录，里面有meteor运行需要的文件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行这个应用，可以输入命令：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;simple-todos
meteor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，打开你的浏览器，然后输入&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:3000&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果你修改了simple-todos.html，你会发现几秒后，浏览器上打开的页面内容也会自动发生相应的变化。这就是Meteor所谓的“代码热部署”。&lt;/p&gt;

&lt;h2 id=&quot;二使用模版来定义页面视图&quot;&gt;二、使用模版来定义页面视图&lt;/h2&gt;

&lt;p&gt;好了，我们继续制作我们的任务清单程序。&lt;/p&gt;

&lt;h3 id=&quot;21-修改代码&quot;&gt;2.1 修改代码&lt;/h3&gt;
&lt;p&gt;我们用下面的代码替代之前Meteor默认生成的代码。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-todos.html&lt;/code&gt;的代码修改如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Todo List&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Todo List&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;  
      {{#each tasks}}
        {{&amp;gt; task}}
      {{/each}}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;template&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;{{text}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-todos.js&lt;/code&gt;的代码修改如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is task 1&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is task 2&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;This is task 3&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;替换完上面的代码，静待几秒，浏览器中展现的内容就会发生变化，类似如下：&lt;/p&gt;

&lt;blockquote&gt;

  &lt;h1 id=&quot;todo-list&quot;&gt;Todo List&lt;/h1&gt;

  &lt;ul&gt;
    &lt;li&gt;This is task 1&lt;/li&gt;
    &lt;li&gt;This is task 2&lt;/li&gt;
    &lt;li&gt;This is task 3&lt;/li&gt;
  &lt;/ul&gt;

&lt;/blockquote&gt;

&lt;p&gt;挺有意思的，不是吗？好吧，让我们看看它们是怎么工作的。&lt;/p&gt;

&lt;h3 id=&quot;22-meteor使用html文件来定义模版&quot;&gt;2.2 Meteor使用HTML文件来定义模版&lt;/h3&gt;

&lt;p&gt;Meteor解析你的应用目录下的所有HTML文件。识别出三个顶级标签:&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;template&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其中,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;标签和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签里的内容都会被发送到客户端页面中，对应的标签下面去。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;template&amp;gt;&lt;/code&gt;标签里面的内容，会被编译成Meteor模版。Meteor模版或者被HTML中的&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&amp;gt;templateName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;引用，或者被JavaScript程序中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.templateName&lt;/code&gt;所引用。&lt;/p&gt;

&lt;h3 id=&quot;23-给模版添加逻辑和数据&quot;&gt;2.3 给模版添加逻辑和数据&lt;/h3&gt;

&lt;p&gt;Meteor使用Spacebars来编译HTML文件中的代码。Spacebars用双括号将语句括起来，比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{#each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{#if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;。使用这种方式给模版添加逻辑和数据。&lt;/p&gt;

&lt;p&gt;我们可以借用&lt;code class=&quot;highlighter-rouge&quot;&gt;helpers&lt;/code&gt;从JavsScript代码中把数据传给模版。在上面的代码中，我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.body&lt;/code&gt;上定义了一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;tasks&lt;/code&gt;的帮助器(helper)。它返回的是一个数组。在HTML的body标签内，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{#each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;来遍历整个数组，插入一个&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;模版来显示数组中的每个值。在&lt;code class=&quot;highlighter-rouge&quot;&gt;#each&lt;/code&gt;语句块内，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;来显示数组中每项的&lt;code class=&quot;highlighter-rouge&quot;&gt;text&lt;/code&gt;属性值。&lt;/p&gt;

&lt;p&gt;关于模版的更多内容：https://github.com/meteor/meteor/blob/devel/packages/spacebars/README.md&lt;/p&gt;

&lt;h3 id=&quot;24-添加css&quot;&gt;2.4 添加CSS&lt;/h3&gt;

&lt;p&gt;这个应用不添加额外的css式样，也可以正常运行，但是为了更加美观，我们给这个应用添加一些CSS式样。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;simple-todos.css&lt;/code&gt;文件内容修改如下：&lt;/p&gt;

&lt;div class=&quot;language-css highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;/* CSS declarations go here */&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;body&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-family&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sans-serif&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#315481&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear-gradient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#315481&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#918e82&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-attachment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;fixed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;absolute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;nl&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;14px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.container&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;max-width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;600px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;min-height&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#d2edf4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background-image&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;linear-gradient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#d0edf5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#e1e5f0&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;20px&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15px&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15px&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;#login-buttons&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;h1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1.5em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin-bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inline-block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin-right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;form&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin-top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin-bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;-10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.new-task&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;box-sizing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;border-box&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;transparent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;border&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;100%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;padding-right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;80px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.new-task&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;input&lt;/span&gt;&lt;span class=&quot;nd&quot;&gt;:focus&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;outline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;ul&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.delete&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;bold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;font-size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1em&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;border&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;relative&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;list-style&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;border-bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#eee&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;solid&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin-left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;10px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.checked&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#888&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.checked&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.text&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;text-decoration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;line-through&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;.private&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;background&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#eee&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;border-color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;#ddd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;header&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;.hide-completed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;.toggle-private&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;margin-left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@media&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max-width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;600px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;li&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;padding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;12px&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;15px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;.search&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;width&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;150px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;both&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nc&quot;&gt;.new-task&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nl&quot;&gt;padding-bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三使用集合来存储数据&quot;&gt;三、使用集合来存储数据&lt;/h2&gt;

&lt;p&gt;集合是Meteor用来存储持久化数据的方法。其特殊之处在于，它既可被服务端访问，也可被客户端访问。这样就很容易做到，无需编写大量服务端代码就可以实现页面逻辑。他们也可以自动更新，所以由集合支持的页面视图组件可以自动显示最新数据。&lt;/p&gt;

&lt;p&gt;在你的JavaScript代码里，通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;MyCollection = new Mongo.Collection(&quot;my-collection&quot;);&lt;/code&gt;，可以很容易地创建一个新的集合。在服务器端，这行代码会设置一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;my-collection&lt;/code&gt;的MongoDB集合；在客户端，这行代码会创建一个缓存，这个缓存和服务器端集合存在连接。后面，我们会了解的更多详情，现在就让我们假设整个数据库都存在于客户端。&lt;/p&gt;

&lt;p&gt;下面我们修改JavaScript代码，从数据库集合中获取任务：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Mongo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用上面代码后，静待几秒钟，等待Meteor“热部署”完成。我们会发现任务列表中的记录消失了，这是因为数据库集合是空的。我们需要向数据库集合中插入一些任务数据。&lt;/p&gt;

&lt;h3 id=&quot;从服务器端数据库控制台插入任务数据&quot;&gt;从服务器端数据库控制台插入任务数据&lt;/h3&gt;

&lt;p&gt;数据库集合里的数据被称为文档。下面，我们在服务器端使用数据库的控制台插入一些文档到任务集合中去。&lt;/p&gt;

&lt;p&gt;打开一个新的终端页，进入应用所在目录，然后输入命令:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当前控制台会连上应用的本地开发数据库，在数据库的交互模式下，输入命令：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hello world!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再看看浏览器，你将发现应用界面立刻显示出了新任务记录。你会发现我们在客户端和服务端之间并没有写什么连接代码，但是数据恰恰自动更新了。&lt;/p&gt;

&lt;p&gt;在数据库控制台上，用相同的方法，再插入一些不同内容的任务记录。&lt;/p&gt;

&lt;p&gt;下面，我们看看怎么给应用页面增加功能，不通过后端数据库控制台，直接通过前端页面增加任务记录。&lt;/p&gt;

&lt;h2 id=&quot;四通过页面添加任务&quot;&gt;四、通过页面添加任务&lt;/h2&gt;

&lt;p&gt;在这一环节，我们要提供一个输入框给用户，以便向任务清单中添加任务记录。&lt;/p&gt;

&lt;p&gt;首先，我们在HTML里添加一个form。完整的simple-todos.html如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Todo List&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Todo List&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;

      &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;new-task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;placeholder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Type to add new tasks&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
      {{#each tasks}}
        {{&amp;gt; task}}
      {{/each}}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
 
&lt;span class=&quot;nt&quot;&gt;&amp;lt;template&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;{{text}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Javascript代码中，我们需要增加对页面form的&lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt;事件的监听方法。完整的simple-todos.js文件如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Mongo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;submit .new-task&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Prevent default browser form submit&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Get value from form element&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Insert a task into the collection&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// current time&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Clear form&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在应用有了一个新的输入框。要添加任务记录，只需要在输入框输入内容，然后点击回车就好了。如果你另外打开一个浏览器窗口，并新窗口中打开应用，你会发现多个客户端上的任务记录是自动同步的！&lt;/p&gt;

&lt;p&gt;###给模版绑定事件&lt;/p&gt;

&lt;p&gt;给模版添加事件的方式如同helpers方法的使用：调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.templateName.events(...)&lt;/code&gt;，传入一个key-value字典类型参数。其中key描述监听的事件，其中value是事件句柄方法。&lt;/p&gt;

&lt;p&gt;在上面的例子中，我们监听CSS选择器&lt;code class=&quot;highlighter-rouge&quot;&gt;.new-task&lt;/code&gt;匹配的任意元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;submit&lt;/code&gt;事件。当用户在输入框内按下回车键时，将会触发这个事件，我们设置的事件方法就会被调用。&lt;/p&gt;

&lt;p&gt;被调用的事件方法有一个输入参数&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;，这个参数包含了被触发的事件的一些信息。在这里，&lt;code class=&quot;highlighter-rouge&quot;&gt;event.target&lt;/code&gt;是我们这个页面上的form元素，我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;event.target.text.value&lt;/code&gt;来获取输入框中的输入值。你可以在浏览器的控制台，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log(event)&lt;/code&gt;来查看&lt;code class=&quot;highlighter-rouge&quot;&gt;event&lt;/code&gt;的各个属性。&lt;/p&gt;

&lt;p&gt;最好，在这个事件方法的最后一行，我们清除了输入框中的内容，准备下一次输入。&lt;/p&gt;

&lt;p&gt;###向集合中插入数据&lt;/p&gt;

&lt;p&gt;在这个事件方法中，我们通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Tasks.insert()&lt;/code&gt;来向&lt;code class=&quot;highlighter-rouge&quot;&gt;tasks&lt;/code&gt;集合中添加一条任务记录。我们不需要事先定义集合的结构，就可以向集合中的记录添加各种属性字段，比如：被创建的时间。&lt;/p&gt;

&lt;p&gt;###排序查询结果&lt;/p&gt;

&lt;p&gt;现在，所有新的任务记录都显示在页面的底部。这种体验不是太好，我们更希望先看到最新的任务。&lt;/p&gt;

&lt;p&gt;我们可以利用&lt;code class=&quot;highlighter-rouge&quot;&gt;createdAt&lt;/code&gt;字段来排序查询结果。所需做的，仅是给&lt;code class=&quot;highlighter-rouge&quot;&gt;find&lt;/code&gt;方法添加一个排序选项。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Show newest tasks at the top&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五已处理与删除任务&quot;&gt;五、已处理与删除任务&lt;/h2&gt;

&lt;p&gt;前面，我们学习了怎么向集合中插入数据，下面学习如何更新及删除数据。&lt;/p&gt;

&lt;p&gt;我们先给&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;模版增加两个页面元素：一个复选框和一个删除按钮。&lt;/p&gt;

&lt;p&gt;替换simple-todos.html文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;模版，内容如下:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;template&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{#if checked}}checked{{/if}}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;delete&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;times;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;checkbox&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{checked}}&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;toggle-checked&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;{{text}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;仅添加UI元素，页面发生了变化，但是新元素不能使用。我们需要添加相应的事件。&lt;/p&gt;

&lt;p&gt;修改simple-todos.js文件，增加相关事件：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .toggle-checked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Set the checked property to the opposite of its current value&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;$set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .delete&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，静待Meteor“热部署”后，点击页面上的复选框或者删除按钮。看看效果吧！&lt;/p&gt;

&lt;h3 id=&quot;在事件方法中获取数据&quot;&gt;在事件方法中获取数据&lt;/h3&gt;

&lt;p&gt;在事件方法中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;指向当前这个任务对象。在数据库集合中，每个插入的文档都有一个唯一值&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;字段，可以使用这个字段找到每个文档。我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;this.id&lt;/code&gt;来获取当前任务记录的&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;字段。一旦有了&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;，那么我们就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;方法来修改对应的任务记录了。&lt;/p&gt;

&lt;h3 id=&quot;更新&quot;&gt;更新&lt;/h3&gt;

&lt;p&gt;集合的&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;方法有两个参数。第一个参数，是选择器，可以筛选出集合的子集；第二个参数是个更新参数，列出匹配的结果都做如何修改。&lt;/p&gt;

&lt;p&gt;在上面这个例子中，选择器就是任务的&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;字段值；更新参数使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$set&lt;/code&gt;去切换&lt;code class=&quot;highlighter-rouge&quot;&gt;checked&lt;/code&gt;字段的值，来代表当前任务记录是否处理完成。&lt;/p&gt;

&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;

&lt;p&gt;集合的&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;方法只有一个参数——选择器，它决定了集合中的哪项记录被删除。&lt;/p&gt;

&lt;p&gt;###使用对象的属性(或者使用helpers)去添加/删除页面式样&lt;/p&gt;

&lt;p&gt;你如果标记某些任务已经完成，你会发现被标记处理完成的任务都有一条删除线。这个效果由下面代码实现：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{#if checked}}checked{{/if}}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果任务的&lt;code class=&quot;highlighter-rouge&quot;&gt;checked&lt;/code&gt;属性为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;checked&lt;/code&gt;式样类，就要加到这个&lt;code class=&quot;highlighter-rouge&quot;&gt;li&lt;/code&gt;元素上。使用这个类，我们可以让完成处理的任务项很容易识别出来。&lt;/p&gt;

&lt;h2 id=&quot;六发布应用&quot;&gt;六、发布应用&lt;/h2&gt;

&lt;p&gt;现在，我们已经有了一个可以工作的任务清单应用了。我们可以把他分享给朋友们。Meteor很容易地支持把应用发布到网络上，让网络上的其他人使用。&lt;/p&gt;

&lt;p&gt;进入你的应用所在目录，输入：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor deploy my_app_name.meteor.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一旦你回答完所有交互问题，并上传成功。你就可以通过访问&lt;code class=&quot;highlighter-rouge&quot;&gt;http://my_app_name.meteor.com&lt;/code&gt;，来在互联网上使用你的应用了。&lt;/p&gt;

&lt;h2 id=&quot;七在android或ios上运行你的应用&quot;&gt;七、在Android或iOS上运行你的应用&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;目前，Meteor不支持在Windows上创建移动端应用。如果，你是在Windows上使用Meteor，请跳过本节。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;p&gt;此处省去若干内容，有待日后另起篇章记录。&lt;/p&gt;

&lt;h2 id=&quot;八使用session变量去存储临时的ui状态&quot;&gt;八、使用Session变量去存储临时的UI状态&lt;/h2&gt;

&lt;p&gt;在这里，我们要给应用增加一个客户端筛选功能，以便用户可以点击一个复选框去查看待处理的任务。我们学着在客户端使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Session&lt;/code&gt;变量去存储临时变化的状态。&lt;/p&gt;

&lt;p&gt;首先，我们需要在页面模版中增加一个复选框，simple-todos.html页面中&lt;code class=&quot;highlighter-rouge&quot;&gt;body&lt;/code&gt;模版的代码如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;container&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Todo List&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;

      &lt;span class=&quot;nt&quot;&gt;&amp;lt;label&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hide-completed&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;checkbox&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{hideCompleted}}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        Hide Completed Tasks
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/label&amp;gt;&lt;/span&gt;

      &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;new-task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;placeholder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Type to add new tasks&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
      {{#each tasks}}
        {{&amp;gt; task}}
      {{/each}}
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着，我们需要添加一个事件处理方法，在复选框的状态发生变化时，去更新&lt;code class=&quot;highlighter-rouge&quot;&gt;Session&lt;/code&gt;变量。&lt;code class=&quot;highlighter-rouge&quot;&gt;Session&lt;/code&gt;是一个非常好的可以存放临时UI状态的地方。如同集合一样，可以在helpers方法中被调用。&lt;/p&gt;

&lt;p&gt;修改simple-todos.js文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.body.events(...)&lt;/code&gt;，修改后内容如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;submit .new-task&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Prevent default browser form submit&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Get value from form element&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Insert a task into the collection&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// current time&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Clear form&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

    &lt;span class=&quot;s2&quot;&gt;&quot;change .hide-completed input&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，我们需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.body.helpers&lt;/code&gt;。下面这段代码增加了一个新的&lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt;语句块，去实现当复选框被选中时对任务清单的过滤；增加了一个新的方法，去获取Session变量中记录的复选框状态。&lt;/p&gt;

&lt;p&gt;修改simple-todos.js文件中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.body.helpers(...)&lt;/code&gt;，修改为：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If hide completed is checked, filter tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Otherwise, return all of the tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hideCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在如果你选中复选框，那么任务清单中只显示没有完成的任务了！&lt;/p&gt;

&lt;h3 id=&quot;session是客户端的一个响应式数据存储&quot;&gt;Session是客户端的一个响应式数据存储&lt;/h3&gt;

&lt;p&gt;截止目前，我们已经把所有数据都存储到集合中去了，当数据库集合中的数据发生变化，前端页面也会自动更新。这是因为Mongo的集合是Meteor公认的响应式数据源，这意味着，一旦其中的数据发生变化，Meteor就知道了。Session也同样如此，但它不和服务器端通讯，这点与集合不同。因此，Session非常适合存放UI的一些临时状态，比如上例中的复选框。如同集合，当Session变量发生变化后，我们无需编写太多的编码。仅需要在帮助器（helper)方法里调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Session.get(...)&lt;/code&gt;就足够了。&lt;/p&gt;

&lt;h3 id=&quot;更多显示待处理任务总数&quot;&gt;更多：显示待处理任务总数&lt;/h3&gt;

&lt;p&gt;现在我们写了一个查询，可以筛选待处理的任务，我们也可以使用同样的查询，去显示待处理任务的总数。在JavaScript文件中增加一个方法，修改HTML一行代码就可以实现了。&lt;/p&gt;

&lt;p&gt;在simple-todos.js中修改&lt;code class=&quot;highlighter-rouge&quot;&gt;Template.body.helpers(...)&lt;/code&gt;，增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;incompleteCount&lt;/code&gt;方法，修改后的如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If hide completed is checked, filter tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Otherwise, return all of the tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hideCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;incompleteCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改simple-todos.html文件，显示待处理记录总数:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Todo List ({{incompleteCount}})&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;九添加账号管理功能&quot;&gt;九、添加账号管理功能&lt;/h2&gt;

&lt;p&gt;Meteor自带一个账号系统，以及下拉式登录页面。可以让你的应用在几分钟内添加多用户功能。&lt;/p&gt;

&lt;p&gt;为了可以使用账号系统以及相关的UI，我们需要添加相关的包。在你的应用所在目录，执行下面命令：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor add accounts-ui accounts-password
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述命令运行完后，原先的meteor服务会自动更新部署。我们继续下面操作。&lt;/p&gt;

&lt;p&gt;在HTML文件中，复选框的正下方，添加一个用户登录代码，代码片段如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;header&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Todo List ({{incompleteCount}})&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;

      &lt;span class=&quot;nt&quot;&gt;&amp;lt;label&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hide-completed&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;checkbox&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{hideCompleted}}&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        Hide Completed Tasks
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/label&amp;gt;&lt;/span&gt;

      {{&amp;gt; loginButtons}}

      &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;new-task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;placeholder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Type to add new tasks&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/header&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认的登录界面是使用邮箱及密码登录，我们修改JavaScript文件，增加下面的代码来配置登录界面，使用用户名代替邮箱登录。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Accounts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ui&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;passwordSignupFields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;USERNAME_ONLY&quot;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，使用者可以创建账号登录你的应用了！只是登录登出并没有什么效果。让我们增加两个功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;只对登陆用户显示新任务输入框；&lt;/li&gt;
  &lt;li&gt;显示我们创建的每个任务&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为此，我们需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;task&lt;/code&gt;集合中增加两个新的字段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;owner&lt;/code&gt; - 创建此任务的账号的&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt; - 创建此任务的账号的&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;。我们直接把&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;保存在任务对象中，以便在显示任务时，无需每次都去关联账号信息查询用户名。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先，我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;submit .new-task&lt;/code&gt;事件处理方法中，增加一些代码去保存新增的字段，修改的代码片段如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// current time&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// _id of logged in user&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;username&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// username of logged in user&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着，修改HTML文件，增加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;#if&lt;/code&gt;判断语句，仅当账号登录后才显示任务添加框。simple-todos.html中相关代码片段如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{{#if currentUser}}
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;form&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;new-task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;placeholder=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Type to add new tasks&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
{{/if}}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，在每个任务信息的左边增加一个Spacebars语句去显示用户名(&lt;code class=&quot;highlighter-rouge&quot;&gt;username&lt;/code&gt;)字段。&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;strong&amp;gt;&lt;/span&gt;{{username}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/strong&amp;gt;&lt;/span&gt; - {{text}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，大功告成了！&lt;/p&gt;

&lt;h3 id=&quot;自动账号ui&quot;&gt;自动账号UI&lt;/h3&gt;

&lt;p&gt;如果应用添加了&lt;code class=&quot;highlighter-rouge&quot;&gt;accounts-ui&lt;/code&gt;包，想增加一个下拉式登录窗口，只需使用&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&amp;gt;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;loginButtons&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;语句来调用&lt;code class=&quot;highlighter-rouge&quot;&gt;loginButtons&lt;/code&gt;模版。这个模版会自动判断支持哪些登录方式及显示相关的控制。在这个例子中，我们仅开启了账号密码(&lt;code class=&quot;highlighter-rouge&quot;&gt;accounts-password&lt;/code&gt;)登录方式，所以下拉窗口中只有密码字段。如果你想做更多的尝试，你可以添加&lt;code class=&quot;highlighter-rouge&quot;&gt;accounts-facebook&lt;/code&gt;包，来给你的应用开启Facebook账号登录功能，这样，Facebook的案例就会自动出现在下拉界面中了。&lt;/p&gt;

&lt;p&gt;想尝试就执行下面的命令:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor add accounts-facebook
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;关于登录用户的更多信息&quot;&gt;关于登录用户的更多信息&lt;/h3&gt;

&lt;p&gt;在HTML中，我们可以使用内置的帮助器(helper)&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{currentUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;去检查账号是否登录，及获取账号相关信息。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{currentUser.username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;可以显示登录账号的用户名。&lt;/p&gt;

&lt;p&gt;在JavaScript代码中，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.userId()&lt;/code&gt;获取当前账号的&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.user()&lt;/code&gt;获取整个账号信息。&lt;/p&gt;

&lt;h2 id=&quot;十使用methods方法实现安全控制&quot;&gt;十、使用&lt;code class=&quot;highlighter-rouge&quot;&gt;methods&lt;/code&gt;方法实现安全控制&lt;/h2&gt;

&lt;p&gt;在这之前，应用的每个账号都能编辑数据库中的信息。这对一个内部小应用或者实例而言，可能没有什么问题。但任何一个实时应用都需要对它的数据进行权限控制。在Meteor中，最好的办法就是定义&lt;code class=&quot;highlighter-rouge&quot;&gt;methods&lt;/code&gt;方法，代替客户端直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;方法。它将检查账号是否有权限进行当前操作，有权限则以客户端名义修改数据库中数据。&lt;/p&gt;

&lt;h3 id=&quot;移除insecure包&quot;&gt;移除&lt;code class=&quot;highlighter-rouge&quot;&gt;insecure&lt;/code&gt;包&lt;/h3&gt;

&lt;p&gt;每个新创建的Meteor工程都会默认添加&lt;code class=&quot;highlighter-rouge&quot;&gt;insecure&lt;/code&gt;包。这个包容许用户从客户端修改数据库数据。&lt;/p&gt;

&lt;p&gt;使用下面命令可以删除这个包：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor remove insecure
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;移除这个包后，再使用应用，你将发现输入框和按钮不再正常工作了。这是因为客户端所有数据库权限都被终止了。我们需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;methods&lt;/code&gt;重写应用的部分功能。&lt;/p&gt;

&lt;h3 id=&quot;定义methods&quot;&gt;定义methods&lt;/h3&gt;

&lt;p&gt;首先，我们需要定义一些方法.我们需要为在客户端执行的每个数据库操作定义一个方法。这些方法被定义在即被服务端执行，也被客户端执行的代码中。&lt;/p&gt;

&lt;p&gt;修改simple-todos.js，增加以下代码片段：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Make sure the user is logged in before inserting a task&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;username&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;deleteTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;$set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，方法都定义好了。我们把之前对集合操作的代码都用这些方法替换。&lt;/p&gt;

&lt;p&gt;修改后的完整的simple-todos.js文件内容如下:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Mongo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If hide completed is checked, filter tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Otherwise, return all of the tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hideCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;incompleteCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;submit .new-task&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Prevent default browser form submit&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Get value from form element&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Insert a task into the collection&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;addTask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Clear form&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

    &lt;span class=&quot;s2&quot;&gt;&quot;change .hide-completed input&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .toggle-checked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Set the checked property to the opposite of its current value&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;setChecked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .delete&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;deleteTask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Accounts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ui&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;passwordSignupFields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;USERNAME_ONLY&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Make sure the user is logged in before inserting a task&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;username&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;deleteTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;$set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，我们的输入框和按钮又可以正常工作了！稍微总结一下本章节收获：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当我们向数据库插入任务时，我们可以做一些安全性校验，比如：用户是否登录；创建时间、用户名等字段是否正确。使用者无法假冒任何人。&lt;/li&gt;
  &lt;li&gt;当任务被私有化时，我们可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;setChecked&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;deleteTask&lt;/code&gt;方法中增加一些逻辑校验。（后文会介绍）&lt;/li&gt;
  &lt;li&gt;客户端代码与数据库逻辑更加分离了。我们提炼一些方法可以在各处被调用，而不再是大量逻辑都放在页面的事件处理方法里了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;optimistic-ui&quot;&gt;Optimistic UI&lt;/h3&gt;

&lt;p&gt;那么我们为什么要同时定义我们的方法在客户端和服务器端？我们这样做是为了实现一个我们称之为“optimistic UI”的特效。&lt;/p&gt;

&lt;p&gt;当我们在客户端使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.call&lt;/code&gt;调用一个方法时，Meteor会同时做两件事：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;客户端发送请求至服务器端，在一个安全的环境下去运行这个方法，如同AJAX请求一样工作；&lt;/li&gt;
  &lt;li&gt;试图预测服务器端正常的处理结果，而在客户端模仿这个方法运行。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就意味着，一个新创建的任务，还未从服务器端接收反馈结果，就立刻出现在页面上了。&lt;/p&gt;

&lt;p&gt;如果服务端返回的结果和客户端模拟的结果一致，那么不再做任何处理；不一致，那么UI将按照服务端返回结果进行修正。&lt;/p&gt;

&lt;p&gt;利用Meteor的方法（methods）和optimistic UI，我们可以鱼与熊掌兼得——服务端代码安全与无延迟交互！&lt;/p&gt;

&lt;h2 id=&quot;十一利用发布与订阅来过滤数据&quot;&gt;十一、利用发布与订阅来过滤数据&lt;/h2&gt;

&lt;p&gt;我们已经把应用的所有敏感代码都移到了Methods里了，我们还需要了解一些Meteor其他的安全知识。截止目前，我们的工作都是基于假设整个数据库都在客户端的基础上的，这意味着，如果调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Tasks.find()&lt;/code&gt;，我们将从集合中查询所有数据。如果应用的使用者想存储一些隐私数据，这个机制就不合适了。我们需要一个方案去控制哪些数据可以发送到客户端数据库。&lt;/p&gt;

&lt;p&gt;如同&lt;code class=&quot;highlighter-rouge&quot;&gt;insecure&lt;/code&gt;包一样，Meteor新创建的每个新应用都会自带一个&lt;code class=&quot;highlighter-rouge&quot;&gt;autopublish&lt;/code&gt;包。&lt;/p&gt;

&lt;p&gt;我们删除这个包，看看发生了什么：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor remove autopublish
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当应用刷新后，任务清单就空了。没有了这个包，我们需要显示地列出需要服务器端发送哪些数据到客户端。Meteor中实现这个功能的函数是&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.publish&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.subscrib&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;在simple-todos.js文件中增加以下代码片段:&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the server&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等待代码”热部署“后，页面的任务清单又出现了。&lt;/p&gt;

&lt;p&gt;服务器端通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.publish&lt;/code&gt;方法，注册了一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;tasks&quot;&lt;/code&gt;的发布。在客户端，使用这个发布名调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.subscribe&lt;/code&gt;方法，这个客户端就订阅了所有来自发布发布的数据，在这个例子中，就所有的任务清单。&lt;/p&gt;

&lt;p&gt;为了真实地展示发布/订阅模式的强大之处，我们来实现一个功能，容许账号去标记任务为”私人的”，以便不被其他账号看见。&lt;/p&gt;

&lt;h3 id=&quot;实现私人任务&quot;&gt;实现私人任务&lt;/h3&gt;

&lt;p&gt;首先，我们给任务记录增加一个名为”private”的属性，给用户提供一个按钮，去标记任务是否是私人的。这个按钮只显示给任务的所有者，并且将显示任务当前所处的状态。&lt;/p&gt;

&lt;p&gt;另外，我们还要给任务记录增加一个式样类，用来标记这个任务是否为私人的。&lt;/p&gt;

&lt;p&gt;simple-todos.html中task模版修改后的代码如下：&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;template&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;task&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;li&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{#if checked}}checked{{/if}}  {{#if private}}private{{/if}}&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;delete&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;times;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;input&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;checkbox&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;{{checked}}&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;toggle-checked&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    {{#if isOwner}}
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;button&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;toggle-private&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        {{#if private}}
          Private
        {{else}}
          Public
        {{/if}}
      &lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
    {{/if}}
 
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;strong&amp;gt;&lt;/span&gt;{{username}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/strong&amp;gt;&lt;/span&gt; - {{text}}&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/template&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结合页面所做的修改，我们需要同时修改三处JavaScript代码：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;增加一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;isOwner&lt;/code&gt;的帮助器(helper)&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
   &lt;span class=&quot;na&quot;&gt;isOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  	&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;setPrivate&lt;/code&gt;的Meteor方法。&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nx&quot;&gt;setPrivate&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setToPrivate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
   &lt;span class=&quot;c1&quot;&gt;// Make sure only the task owner can make a task private发布&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
   &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;$set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setToPrivate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;增加一个按钮点击事件方法。&lt;/p&gt;

    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;s2&quot;&gt;&quot;click .toggle-private&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;setPrivate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;基于隐私状态有选择地发布任务&quot;&gt;基于隐私状态有选择地发布任务&lt;/h3&gt;

&lt;p&gt;我们已经可以设置哪些任务是私人的了，我们继续完善我们的发布程序，只发送数据给有权限的用户浏览。&lt;/p&gt;

&lt;p&gt;修改simple-todos.js中相关代码，相关代码片段如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the server&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Only publish tasks that are public or belong to the current user&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;$or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以打开两个浏览器，使用不同的账号登录，来测试效果。&lt;/p&gt;

&lt;h3 id=&quot;完善安全控制&quot;&gt;完善安全控制&lt;/h3&gt;

&lt;p&gt;为了完善我们的私人任务功能，我们需要给&lt;code class=&quot;highlighter-rouge&quot;&gt;deleteTask&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;setChecked&lt;/code&gt;俩方法增加检查，以便任务的所有者可以删除或完成一个私人任务。&lt;/p&gt;

&lt;p&gt;完整的simple-todos.js文件代码如下：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Mongo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Collection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the server&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// Only publish tasks that are public or belong to the current user&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;publish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;$or&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// This code only runs on the client&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tasks&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If hide completed is checked, filter tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Otherwise, return all of the tasks&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({},&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}});&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;hideCompleted&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;incompleteCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;$ne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;body&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;submit .new-task&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Prevent default browser form submit&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;preventDefault&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Get value from form element&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Insert a task into the collection&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;addTask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
      &lt;span class=&quot;c1&quot;&gt;// Clear form&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

    &lt;span class=&quot;s2&quot;&gt;&quot;change .hide-completed input&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Session&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hideCompleted&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;helpers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;isOwner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Template&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;events&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .toggle-checked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Set the checked property to the opposite of its current value&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;setChecked&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .delete&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;deleteTask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;s2&quot;&gt;&quot;click .toggle-private&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;call&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;setPrivate&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;Accounts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ui&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
    &lt;span class=&quot;na&quot;&gt;passwordSignupFields&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;USERNAME_ONLY&quot;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;methods&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;addTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Make sure the user is logged in before inserting a task&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;createdAt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Date&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;owner&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;username&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;username&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;deleteTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// If the task is private, make sure only the owner can delete it&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// If the task is private, make sure only the owner can check it off&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;$set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setChecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;na&quot;&gt;setPrivate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setToPrivate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;findOne&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 
    &lt;span class=&quot;c1&quot;&gt;// Make sure only the task owner can make a task private&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;owner&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;userId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;not-authorized&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 
    &lt;span class=&quot;nx&quot;&gt;Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;update&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskId&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;$set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setToPrivate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;“注意现在任何人都可以删除公共任务，代码再做一些微调，就可以实现仅任务的所有者才能删除他们”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;好了，我们完成了个人任务功能！现在我们的应用已经安全了，可以防止攻击者浏览或者修改他人的任务了！&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>meteor入门学习笔记一：开始</title>
   <link href="http://www.blogways.net/blog/2015/12/09/meteor-tutorial-1.html"/>
   <updated>2015-12-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/12/09/meteor-tutorial-1</id>
   <content type="html">&lt;p&gt;这几天在学习Meteor，当前版本为:&lt;code class=&quot;highlighter-rouge&quot;&gt;1.2.1&lt;/code&gt;。学习的主要资料来自官网，笔记如下.&lt;/p&gt;

&lt;h2 id=&quot;一安装&quot;&gt;一、安装&lt;/h2&gt;

&lt;p&gt;Meteor目前支持OS X，Windows,和Linux主机，安装非常方便。
在Mac OS X 10.7（Lion)以上版本，和基于x86/x86_64架构的Linux主机上，可以通过命令行进行安装。
Window版本的支持Windows 7,Windows 8.1,Windows Server 2008和Windows Server 2012。&lt;/p&gt;

&lt;h3 id=&quot;11-os-x-或-linxu系统&quot;&gt;1.1 OS X 或 Linxu系统&lt;/h3&gt;

&lt;p&gt;使用下面命令安装：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;curl https://install.meteor.com/ |sh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以使用下面命令删除:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rm  /usr/local/bin/meteor
rm -rf ~/.meteor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;12-windows系统&quot;&gt;1.2 Windows系统&lt;/h3&gt;

&lt;p&gt;猛戳&lt;a href=&quot;https://install.meteor.com/windows&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;二快速开始&quot;&gt;二、快速开始&lt;/h2&gt;

&lt;p&gt;安装Meteor之后，创建一个应用程序非常简单。由于Meteor提供免费的托管，你也可以通过命令，很容易地在线部署到它的免费服务器上，供世界各地的人来浏览。&lt;/p&gt;

&lt;p&gt;创建一个新的应用程序：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor create ~/my_cool_app
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在本地运行：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/my_cool_app
meteor
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本地访问: &lt;a href=&quot;http://localhost:3000&quot;&gt;http://localhost:3000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在线部署到他提供的免费服务器上:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor deploy myapp.meteor.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三原则&quot;&gt;三、原则&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;只传输数据。&lt;/strong&gt; Meteor不通过网络发送Html，服务器端仅发送数据，由客户端负责渲染页面。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Javascript是唯一的开发语言。&lt;/strong&gt;整个程序，无论服务器端还是客户端都由Javascript开发。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;随处都可访问数据库。&lt;/strong&gt;无论服务端还是客户端，都使用相同的方法访问数据库。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;延迟补偿。&lt;/strong&gt; 在客户端，采用预读数据和模拟模型，使与服务器的交互如同立即返回.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;全栈响应式。&lt;/strong&gt; Meteor中，默认是实时处理。从数据库到模版层，所有的层级，都是按需自动更新。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;拥抱开源。&lt;/strong&gt;Meteor本身就是开源的，集成了很多开源的工具与框架.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;简单而高效。&lt;/strong&gt;让每一点都很简单，Meteor的主要功能代码都是一些简练而经典的API。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四目录结构&quot;&gt;四、目录结构&lt;/h2&gt;

&lt;p&gt;Meteor有固定的目录结构，它可以据此自动加载工程中的各类文件。&lt;/p&gt;

&lt;h3 id=&quot;41-默认的加载方式&quot;&gt;4.1 默认的加载方式&lt;/h3&gt;

&lt;p&gt;下文&lt;code class=&quot;highlighter-rouge&quot;&gt;4.2 特定目录&lt;/code&gt;以外的文件，按以下逻辑处理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTML模版被编译，发送给客户端。&lt;/li&gt;
  &lt;li&gt;CSS文件也被发送至客户端。在生产模式下，他们会把合并及压缩。&lt;/li&gt;
  &lt;li&gt;Javascript文件会被客户端及服务端调用。可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.isClient&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.isServer&lt;/code&gt;，在代码中区分执行的环境。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果你想做更多的控制，可以使用Meteor的特定目录。&lt;/p&gt;

&lt;h3 id=&quot;42-特定目录&quot;&gt;4.2 特定目录&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/client&lt;/code&gt;&lt;/strong&gt; 这个目录下的所有文件都会被发送到客户端。你可以将 HTML、CSS及和UI有关的Javascript文件都放在这里。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/server&lt;/code&gt;&lt;/strong&gt; 这个目录下的所有文件只在服务器端使用，不会暴露给客户端&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/public&lt;/code&gt;&lt;/strong&gt; 这个目录下的文件也是给客户端使用的，你可以存放诸如图片的一些资源。例如：存放一个图片于&lt;code class=&quot;highlighter-rouge&quot;&gt;/public/background.png&lt;/code&gt;。那么你可以在HTML模版中，如此引用：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;img src='/background.png'/&amp;gt;&lt;/code&gt;；或者在css文件中，如此引用：&lt;code class=&quot;highlighter-rouge&quot;&gt;background-image:
url(/background.png)&lt;/code&gt;。需要注意的是：&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/public&lt;/code&gt;不要出现在图片资源URL中。&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;/private&lt;/code&gt;&lt;/strong&gt; 这个目录下的文件只能在服务器端，被&lt;code class=&quot;highlighter-rouge&quot;&gt;Assets&lt;/code&gt;API所使用。不对客户端开放。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;文件的加载顺序依次按如下规则:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;HTML模版文件总是最先被加载；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;main.&lt;/code&gt;开头的文件，在同类文件中最后被加载；&lt;/li&gt;
  &lt;li&gt;路径中包含&lt;code class=&quot;highlighter-rouge&quot;&gt;lib/&lt;/code&gt;的文件被接着加载；&lt;/li&gt;
  &lt;li&gt;子目录中的文件被接着加载（也就是说，父目录中的文件后加载）；&lt;/li&gt;
  &lt;li&gt;同一目录下的不同文件按文件名的字母顺序加载；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;加载顺序，举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nav.html
main.html
client/lib/methods.js
client/lib/styles.js
lib/feature/styles.js
lib/collections.js
client/feature-y.js
feature-x.js
client/main.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五构建移动端应用&quot;&gt;五、构建移动端应用&lt;/h2&gt;

&lt;p&gt;如果使用了Meteor构建了你的web应用，那么你可以很容易地给你的应用打一个原始的包，发布到Google Play商店或者iOS应用商店，做到这些仅仅需要几个命令而已。Meteor在桌面版和移动版之间，已经定制了很多相同的包及API，所以，你不需要太关心移动端应用开发的一些边边角角的琐事。&lt;/p&gt;

&lt;h3 id=&quot;51-环境准备&quot;&gt;5.1 环境准备&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;iOS&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要想使你构建的应用能够在iOS设备或者模拟器上运行，你需要安装&lt;a href=&quot;https://itunes.apple.com/us/app/xcode/id497799835?ls=1&amp;amp;mt=12&quot;&gt;Xcode&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Android&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;你需要安装Android开发工具以及Java JDK。
Mac环境下的安装可以看&lt;a href=&quot;https://github.com/meteor/meteor/wiki/Mobile-Development-Install:-Android-on-Mac&quot;&gt;这里&lt;/a&gt;，Linux下的安装细节看&lt;a href=&quot;&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;52-添加删除平台&quot;&gt;5.2 添加删除平台&lt;/h3&gt;

&lt;p&gt;每个Meteor工程都可以设置自己的可以适配的平台。使用&lt;code class=&quot;highlighter-rouge&quot;&gt;meteor add-platform&lt;/code&gt;命令来向工程中添加平台。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;meteor add-platform ios&lt;/code&gt; 在工程中添加iOS平台&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;meteor add-platform android&lt;/code&gt; 在工程中添加Android平台&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;meteor remove-platform ios android&lt;/code&gt; 从工程中删除iOS和Android平台&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;meteor list-platforms&lt;/code&gt; 列出工程的目标平台&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;53-运行&quot;&gt;5.3 运行&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;在模拟器中运行&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor run android             &lt;span class=&quot;c&quot;&gt;# for Android&lt;/span&gt;
meteor run ios                 &lt;span class=&quot;c&quot;&gt;# for iOS&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;在设备上运行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;用USB线连接设备与电脑，输入命令：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor run android-device      &lt;span class=&quot;c&quot;&gt;# for Android&lt;/span&gt;
meteor run ios-device          &lt;span class=&quot;c&quot;&gt;# for iOS&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以指定本地服务器的端口:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor run android-device -p &amp;lt;&lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;port&amp;gt;
meteor run ios-device -p &amp;lt;&lt;span class=&quot;nb&quot;&gt;local &lt;/span&gt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;--mobile-server&lt;/code&gt;参数来指定客户端访问的服务器ip:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor run android-device --mobile-server &amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
meteor run io-device --mobile-server &amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果运行出错，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--verbose&lt;/code&gt;打开详细日志:&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;meteor run android-device --verbose
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;54-cordova侧javascript代码&quot;&gt;5.4 Cordova侧Javascript代码&lt;/h3&gt;

&lt;p&gt;在Javascript文件中，类似可以&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.isServer&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.isClient&lt;/code&gt;来区分服务器端代码和客户端代码，我们也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.isCordova&lt;/code&gt;来区分Cordova侧的代码，这些代码就只会在移动设备中运行。&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;仅在服务器中运行&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;在浏览器和移动端App中运行&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isCordova&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;仅在移动端App中运行&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，有些函数依赖Cordova插件，那么需要包在&lt;code class=&quot;highlighter-rouge&quot;&gt;Meteor.startup()&lt;/code&gt;代码块内。比如：&lt;/p&gt;

&lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nx&quot;&gt;Meteor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 正确的方式&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;navigator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;geolocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getCurrentPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 错误，无法正常工作&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;navigator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;geolocation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;getCurrentPosition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多细节看&lt;a href=&quot;https://github.com/meteor/mobile-packages&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;55-配置应用的图标和元数据&quot;&gt;5.5 配置应用的图标和元数据&lt;/h3&gt;

&lt;p&gt;可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;mobile-config.js&lt;/code&gt;文件中配置移动App的图标、标题、版本号，启动界面等等元数据。&lt;/p&gt;

&lt;h3 id=&quot;56-更多&quot;&gt;5.6 更多&lt;/h3&gt;

&lt;p&gt;更多信息可以查看&lt;a href=&quot;https://github.com/meteor/meteor/wiki/Meteor-Cordova-integration&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;六参考&quot;&gt;六、参考&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;http://docs.meteor.com/&lt;/li&gt;
  &lt;li&gt;http://stackoverflow.com/questions/24686971/how-can-i-completely-uninstall-and-then-reinstall-meteor-js&lt;/li&gt;
  &lt;li&gt;https://github.com/meteor/meteor/wiki/Meteor-Cordova-integration&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery form plugin中文使用说明</title>
   <link href="http://www.blogways.net/blog/2015/11/29/jQuery-form-plugin.html"/>
   <updated>2015-11-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/11/29/jQuery-form-plugin</id>
   <content type="html">&lt;h1 id=&quot;jquery插件form表单插件&quot;&gt;jQuery插件–Form表单插件&lt;/h1&gt;
&lt;p&gt;jQuery Form插件是一个优秀的Ajax表单插件，可以非常容易地、无侵入地升级HTML表单以支持Ajax。 插件里面主要的方法, ajaxForm 和 ajaxSubmit, 能够从form组件里采集信息确定如何处理表单的提交过程。两个方法都支持众多的可选参数，能够让你对表单里数据的提交做到完全的控制。这让采用AJAX方式提交一个表单的过程简单的不能再简单了！&lt;/p&gt;
&lt;h2 id=&quot;一入门指导&quot;&gt;一、入门指导&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在你的页面里写一个简单的表单，不需要任何特殊标记&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;form id=&quot;myForm&quot; action=&quot;comment.php&quot; method=&quot;post&quot;&amp;gt;
     Name: &amp;lt;input type=&quot;text&quot; name=&quot;name&quot; /&amp;gt;
     Comment: &amp;lt;textarea name=&quot;comment&quot;&amp;gt;&amp;lt;/textarea&amp;gt;
     &amp;lt;input type=&quot;submit&quot; value=&quot;Submit Comment&quot; /&amp;gt;
 &amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;引入jQuery和Form Plugin Javascript脚本文件并且添加几句简单的代码让页面在DOM加载完成后初始化表单：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;head&amp;gt;
     &amp;lt;script type=&quot;text/javascript&quot; src=&quot;path/to/jquery.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
     &amp;lt;script type=&quot;text/javascript&quot; src=&quot;path/to/form.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
	
     &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
         // wait for the DOM to be loaded
         $(document).ready(function() {
             // bind 'myForm' and provide a simple callback function
             $('#myForm').ajaxForm(function() {
                 alert(&quot;Thank you for your comment!&quot;);
             });
         });
     &amp;lt;/script&amp;gt;
 &amp;lt;/head&amp;gt; 这就行了！ 当表单提交后 `name`  和  `comment` 的值就会被提交给 `comment.php`. 如果服务器端返回成功的状态，用户将会看到一句提示信息  `&quot;Thank you&quot;` 。  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二form-plugin-api&quot;&gt;二、Form Plugin API&lt;/h2&gt;
&lt;p&gt;Form Plugin API 里提供了很多有用的方法可以让你轻松的处理表单里的数据和表单的提交过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ajaxForm&lt;/strong&gt;&lt;br /&gt;
预处理将要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;AJAX&lt;/code&gt; 方式提交的表单，将所有需要用到的事件监听器添加到其中。它不是提交这个表单。 在页面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;ready&lt;/code&gt; 函数里使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;ajaxForm&lt;/code&gt; 来给你页面上的表单做这些 &lt;code class=&quot;highlighter-rouge&quot;&gt;AJAX&lt;/code&gt; 提交的准备工作。  &lt;code class=&quot;highlighter-rouge&quot;&gt;ajaxForm&lt;/code&gt; 需要零个或一个参数。这唯一的一个参数可以是一个回调函数或者是一个可选参数对象。并支持&lt;strong&gt;&lt;em&gt;连环调用&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
例子:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $('#myFormId').ajaxForm();   此方法适用于以表单提交方式处理 `ajax `技术（需要提供表单的`action`、`id`、`method`，最好在表单中提供 `submit` 按钮）它大大简化了使用 `ajax` 技术提交表单时的数据传递问题，使用`ajaxForm()`你不需要逐个的以 `JavaScript` 的方式获取每个表单属性的值，并且也不需要在请求路径后面通过 `url` 重写的方式传递数据。`ajaxForm()` 会自动收集当前表单中每个属性的值，然后将其以表单提交的方式提交到目标 `url`。这种方式提交数据较安全，并且使用起来更简单，不必写过多冗余的 `JavaScript` 代码：  

  $(document).ready(function(){
	
           registerForm'表单id
	
  data回调数据
	
          $('#registerForm').ajaxForm(function(data){
	
              alert(data);//弹出ajax请求后的回调结果
	
          });
	
  });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ajaxSubmit&lt;/strong&gt; &lt;br /&gt;
立即通过AJAX方式提交表单。最常见的用法是对用户提交表单的动作进行响应时调用它。 ajaxForm 需要零个或一个参数。唯一的一个参数可以是一个回调函数或者是一个可选参数对象。支持连环调用。&lt;br /&gt;
例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 绑定表单提交事件处理器t
  $('#myFormId').submit(function() {
      // 提交表单
      $(this).ajaxSubmit();
      // return false，这样可以阻止正常的浏览器表单提交和页面转向
      return false;
  });    适用于以事件的机制以 `ajax` 提交 `form` 表单（超链接、图片的 click 事件），该方法作用与 `ajaxForm()` 类似，但它更为灵活，因为他依赖于事件机制，只要有事件存在就能使用该方法。你只需指定该 `form` 的 `action` 属性即可，不需要提供 `submit` 按钮。  

  $(document).ready(function(){
	
      $('#btn').click(function(){
	
              $('#registerForm').ajaxSubmit(function(data){
	
                  alert(data);
	
              });
	
              return false;
	
      });
	
      });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;formSerialize（）&lt;/strong&gt; &lt;br /&gt;
将表单序列化成一个查询字符串，这个方法将返回以下格式的字符串：name1=value1&amp;amp;name2=value2。不能连环调用，此方法返回一个字符串。&lt;br /&gt;
实例：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var queryString = $('#myFormId').formSerialize();
	
  // 现在可以使用$.get、$.post、$.ajax等来提交数据
  $.post('myscript.php', queryString);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fieldSerialize（）&lt;/strong&gt; &lt;br /&gt;
将表单里的元素序列化成字符串。当你只需要将表单的部分元素序列化时可以用到这个方法。 这个方法将返回一个形如：  &lt;code class=&quot;highlighter-rouge&quot;&gt;name1=value1&amp;amp;name2=value2&lt;/code&gt; 的字符串。不能连环调用, 这个方法返回的是一个字符串。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  var queryString = $('#myFormId .specialFields').fieldSerialize();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fieldValue（）&lt;/strong&gt; &lt;br /&gt;
返回匹配插入数组中的表单元素值。从0.91版起，该方法将总是以数组的形式返回数据。如果元素值被判定可能无效，则数组为空，否则它将包含一个或多于一个的元素值。不能连环调用，此方法返回一个数组。
例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 取得密码输入值
  var value = $('#myFormId :password').fieldValue(); 
  alert('The password is: ' + value[0]); 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;resetForm（）&lt;/strong&gt; &lt;br /&gt;
通过调用表单元素原有的 &lt;code class=&quot;highlighter-rouge&quot;&gt;DOM&lt;/code&gt; 方法，将表单恢复到初始状态。此方法可以连环调用，&lt;br /&gt;
例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $('#myFormId').resetForm();  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;clearForm（）&lt;/strong&gt; &lt;br /&gt;
清除表单元素。该方法将所有的文本（text）输入字段、密码（password）输入字段和文本区域（textarea）字段置空，清除任何&lt;code class=&quot;highlighter-rouge&quot;&gt;select&lt;/code&gt;元素中的选定，以及将所有的单选（radio）按钮和多选（checkbox）按钮重置为非选定状态。此方法能连环调用。&lt;br /&gt;
例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $('#myFormId').clearForm();  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;clearFields（）&lt;/strong&gt; &lt;br /&gt;
清除字段元素。只有部分表单元素需要清除时才方便使用。此方法能连环调用。 &lt;br /&gt;
例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $('#myFormId .specialFields').clearFields(); **Options对象**   `ajaxForm `和 `ajaxSubmit` 都支持众多的选项参数，这些选项参数可以使用一个 `Options` 对象来提供。`Options` 只是一个 `JavaScript` 对象，它包含了如下一些属性与值的集合：   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;target&lt;/strong&gt; &lt;br /&gt;
指明页面中由服务器响应进行更新的元素。元素的值可能被指定为一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt; 选择器字符串，一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt; 对象，或者一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;DOM&lt;/code&gt; 元素。 &lt;br /&gt;
默认值：null。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;url&lt;/strong&gt; &lt;br /&gt;
表单提交的地址。 &lt;br /&gt;
缺省值： 表单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;action&lt;/code&gt; 的值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;&lt;br /&gt;
表单提交的方式，&lt;code class=&quot;highlighter-rouge&quot;&gt;'GET'&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;'POST'&lt;/code&gt;.
缺省值： 表单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;method&lt;/code&gt; 的值 (如果没有指明则认为是 ‘GET’)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;beforeSubmit&lt;/strong&gt;&lt;br /&gt;
表单提交前执行的方法。这个可以用在表单提交前的预处理，或表单校验。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;'beforeSubmit'&lt;/code&gt; 指定的函数返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，则表单不会被提交。 &lt;code class=&quot;highlighter-rouge&quot;&gt;'beforeSubmit'&lt;/code&gt; 函数调用时需要3个参数：数组形式的表单数据，&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt; 对象形式的表单对象，可选的用来传递给 &lt;code class=&quot;highlighter-rouge&quot;&gt;ajaxForm/ajaxSubmit &lt;/code&gt;的对象。 数组形式的表单数据是下面这样的格式：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  [ { name: 'username', value: 'jresig' }, { name: 'password', value: 'secret' } ] 缺省值：null   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;success&lt;/strong&gt; &lt;br /&gt;
当表单提交后执行的函数。 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;'success'&lt;/code&gt; 回调函数被指定，当&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;端返回对表单提交的响应后，这个方法就会被执行。 &lt;code class=&quot;highlighter-rouge&quot;&gt;responseText&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;responseXML&lt;/code&gt; 的值会被传进这个参数 (这个要依赖于dataType的类型).&lt;br /&gt;
缺省值： &lt;code class=&quot;highlighter-rouge&quot;&gt;null &lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;dataType&lt;/strong&gt; &lt;br /&gt;
指定服务器响应返回的数据类型。其中之一: null, &lt;code class=&quot;highlighter-rouge&quot;&gt;'xml'&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;'script'&lt;/code&gt;, 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;'json'&lt;/code&gt;. 这个 &lt;code class=&quot;highlighter-rouge&quot;&gt;dataType&lt;/code&gt; 选项用来指示你如何去处理server端返回的数据。 这个和 &lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.httpData&lt;/code&gt; 方法直接相对应。 下面就是可以用的选项:   &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;‘xml’:&lt;/em&gt;&lt;/strong&gt; 如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;dataType == 'xml'&lt;/code&gt; 则 &lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt; 端返回的数据被当作是 XML 来处理， 这种情况下’success’指定的回调函数会被传进去 &lt;code class=&quot;highlighter-rouge&quot;&gt;responseXML&lt;/code&gt; 数据  &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;‘json’&lt;/em&gt;&lt;/strong&gt;: 如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;dataType == 'json'&lt;/code&gt; 则 &lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt; 端返回的数据将会被执行，并传进&lt;code class=&quot;highlighter-rouge&quot;&gt;'success'&lt;/code&gt;回调函数  &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;‘script’&lt;/em&gt;&lt;/strong&gt;:  如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;dataType == 'script'&lt;/code&gt; 则&lt;code class=&quot;highlighter-rouge&quot;&gt;server&lt;/code&gt;端返回的数据将会在上下文的环境中被执行 &lt;br /&gt;
缺省值： &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;semantic&lt;/strong&gt;&lt;br /&gt;
一个布尔值，用来指示表单里提交的数据的顺序是否需要严格按照语义的顺序。一般表单的数据都是按语义顺序序列化的，除非表单里有一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;type=&quot;image&quot;&lt;/code&gt; 元素. 所以只有当表单里必须要求有严格顺序并且表单里有 &lt;code class=&quot;highlighter-rouge&quot;&gt;type=&quot;image&quot;&lt;/code&gt; 时才需要指定这个。&lt;br /&gt;
缺省值： &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;resetForm&lt;/strong&gt;&lt;br /&gt;
布尔值，指示表单提交成功后是否需要重置。&lt;br /&gt;
缺省值： &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;clearForm&lt;/strong&gt;&lt;br /&gt;
布尔值，指示表单提交成功后是否需要清空。&lt;br /&gt;
缺省值： &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;iframe&lt;/strong&gt;&lt;br /&gt;
布尔值，用来指示表单是否需要提交到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;iframe&lt;/code&gt;里。 这个用在表单里有&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;域要上传文件时。更多信息请参考 代码示例 页面里的&lt;code class=&quot;highlighter-rouge&quot;&gt;File Uploads&lt;/code&gt; 文档。 &lt;br /&gt;
缺省值： false&lt;br /&gt;
例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // 准备好Options对象
  var options = {
      target:     '#divToUpdate',
      url:        'comment.php',
      success: function() {
        alert('Thanks for your comment!');
      } };
	
     // 将options传给ajaxForm
  $('#myForm').ajaxForm(options);   **注意**：`Options` 对象还可以用来将值传递给 `jQuery` 的`$.ajax` 方法。如果你熟悉 `$.ajax` 所支持的 `options` ，你可以利用它们来将 `Options` 对象传递给 `ajaxForm` 和 `ajaxSubmit`。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery-datatable中文文档</title>
   <link href="http://www.blogways.net/blog/2015/11/25/jQuery-datatableAPI.html"/>
   <updated>2015-11-25T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/11/25/jQuery-datatableAPI</id>
   <content type="html">&lt;h2 id=&quot;一datatable中文api实例及基本参数&quot;&gt;一、Datatable中文API—实例及基本参数&lt;/h2&gt;

&lt;h3 id=&quot;一实例&quot;&gt;一、实例&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;前端JS：&lt;/strong&gt;&lt;/p&gt;

   	&lt;script type=&quot;text/javascript&quot; language=&quot;javascript&quot;&gt;
&lt;/script&gt;    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $(document).ready(function() {
     $(&quot;#example&quot;).dataTable({
        &quot;bPaginate&quot;: true, //开关，是否显示分页器
        &quot;bInfo&quot;: true, //开关，是否显示表格的一些信息
         &quot;bFilter&quot;: true, //开关，是否启用客户端过滤器
         &quot;sDom&quot;: &quot;&amp;lt;&amp;gt;lfrtip&amp;lt;&amp;gt;&quot;,
        &quot;bAutoWith&quot;: false,
         &quot;bDeferRender&quot;: false,
         &quot;bJQueryUI&quot;: false, //开关，是否启用JQueryUI风格
         &quot;bLengthChange&quot;: true, //开关，是否显示每页大小的下拉框
         &quot;bProcessing&quot;: true,
         &quot;bScrollInfinite&quot;: false,
         &quot;sScrollY&quot;: &quot;800px&quot;, //是否开启垂直滚动，以及指定滚动区域大小,可设值：'disabled','2000px'
         &quot;bSort&quot;: true, //开关，是否启用各列具有按列排序的功能
         &quot;bSortClasses&quot;: true,
         &quot;bStateSave&quot;: false, //开关，是否打开客户端状态记录功能。这个数据是记录在cookies中的，打开了这个记录后，即使刷新一次页面，或重新打开浏览器，之前的状态都是保存下来的- ------当值为true时aoColumnDefs不能隐藏列
         &quot;sScrollX&quot;: &quot;50%&quot;, //是否开启水平滚动，以及指定滚动区域大小,可设值：'disabled','2000%'
         &quot;aaSorting&quot;: [[0, &quot;asc&quot;]],
         &quot;aoColumnDefs&quot;: [{ &quot;bVisible&quot;: false, &quot;aTargets&quot;: [0]}]//隐藏列
         &quot;sDom&quot;: '&amp;lt;&quot;H&quot;if&amp;gt;t&amp;lt;&quot;F&quot;if&amp;gt;',
         &quot;bAutoWidth&quot;: false, //自适应宽度
         &quot;aaSorting&quot;: [[1, &quot;asc&quot;]],
         &quot;sPaginationType&quot;: &quot;full_numbers&quot;,
         &quot;oLanguage&quot;: {
             &quot;sProcessing&quot;: &quot;正在加载中......&quot;,
             &quot;sLengthMenu&quot;: &quot;每页显示 _MENU_ 条记录&quot;,
             &quot;sZeroRecords&quot;: &quot;对不起，查询不到相关数据！&quot;,
             &quot;sEmptyTable&quot;: &quot;表中无数据存在！&quot;,
             &quot;sInfo&quot;: &quot;当前显示 _START_ 到 _END_ 条，共 _TOTAL_ 条记录&quot;,
             &quot;sInfoFiltered&quot;: &quot;数据表中共为 _MAX_ 条记录&quot;,
             &quot;sSearch&quot;: &quot;搜索&quot;,
             &quot;oPaginate&quot;: {
                 &quot;sFirst&quot;: &quot;首页&quot;,
                 &quot;sPrevious&quot;: &quot;上一页&quot;,
                 &quot;sNext&quot;: &quot;下一页&quot;,
                 &quot;sLast&quot;: &quot;末页&quot;
             }
         } //多语言配置
 
     });
 });  &amp;lt;/script&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;最简单的就是零配置方式&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $(document).ready(function(){
     $('#example').dataTable();
 });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;html代码：&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;div class=&quot;row-fluid&quot;&amp;gt;
     &amp;lt;table id=&quot;example&quot; class=&quot;table table-striped table-hover&quot;&amp;gt;
         &amp;lt;thead&amp;gt;
         &amp;lt;tr&amp;gt;
             &amp;lt;% for (var i = 0; i &amp;lt; tabColNames.length; i++) { %&amp;gt;
             &amp;lt;th style=&quot;text-align: center&quot;&amp;gt;&amp;lt;%= tabColNames[i] %&amp;gt;&amp;lt;/th&amp;gt;
             &amp;lt;% } %&amp;gt;
         &amp;lt;/tr&amp;gt;
         &amp;lt;/thead&amp;gt;
         &amp;lt;tbody&amp;gt;
         &amp;lt;/tbody&amp;gt;
     &amp;lt;/table&amp;gt;
 &amp;lt;/div&amp;gt;   
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;后端JS&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;后端就是处理前端发来的请求，取数据、处理数据。还有一种方式是不需要从向后端发送请求去取数据，可以直接在前端直接加载已有的数据，需要&lt;strong&gt;&lt;em&gt;注意&lt;/em&gt;&lt;/strong&gt;的是在页面在进行下一次加载页面的时候需要对上一次的datatable进行清除，用以解决数据缓存带来的问题。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $(&quot;#example&quot;).dataTable().fnClearTable();
 $(&quot;#example&quot;).dataTable().fnDestroy();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二参数说明&quot;&gt;二、参数说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bAutoWidth:&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
类型：boolean&lt;br /&gt;
启用或禁用自动列宽度的计算。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready( function () {
      $('#example').dataTable( {
          &quot;bAutoWidth&quot;: false  //关闭后，表格将不会自动计算表格大小，在浏览器大化小化的时候会挤在一坨
      } );
  } );  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bDeferRender:&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
延期渲染，可以有个速度的提升，当datatable使用Ajax或者JS源表的数据。这个选项设置为true，将导致datatable推迟创建表元素的每个元素，直到他们都创建完成–目的就是节省大量的时间。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready( function() {
      var oTable = $('#example').dataTable( {
          &quot;sAjaxSource&quot;: &quot;sources/arrays.txt&quot;,
          &quot;bDeferRender&quot;: true   
      } );
  } );  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bFilter：&lt;/strong&gt;&lt;br /&gt;
默认值是：true&lt;br /&gt;
是否对数据进行过滤，数据过滤十分灵活，允许终端用户输入多个用空格分隔开的关键字。匹配包含这些关键字的行，即使管子的顺序不是用户输入的顺序，过滤操作会跨列进行匹配，关键字可以分布在一行中的不同列。需要&lt;strong&gt;注意&lt;/strong&gt;的是如果你想在DataTable中使用过滤，该选项必须设置为true，如果想移除默认过滤输入框但是保留过滤功能，请设置为false(API没写，推测是false)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bInfo:&lt;/strong&gt;&lt;br /&gt;
默认值:true&lt;br /&gt;
是否显示表格信息，是指当前页面上显示的数据的信息，如果有过滤操作执行，也会显示过滤操作的信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bJQueryUI：&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
是否开启jQuery UI ThemeRoller支持，需要一些ThemeRoller使用的标记，这些标记有些与DataTable传统使用的有轻微的差异，有些是额外附加的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bLengthChange：&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
允许终端用户从一个选择列表中选择分页的页数，页数为10,25和100，需要分页组件bPaginate的支持&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bPaginage：&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
是否开启分页功能,即使设置为false,仍然会有一个默认的&amp;lt;前进,后退&amp;gt;分页组件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bProcessing：&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
当表格在处理的时候（比如排序操作）是否显示“处理中…”&lt;br /&gt;
当表格的数据中的数据过多以至于对其中的记录进行排序时会消耗足以被察觉的时间的时候，该选项会有些用处&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bScrollInfinite:&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
是否开启不限长度的滚动条（和sSrolly属性结合使用），不限制长度的滚动条意味着当用户拖动滚动条的时候datatable会不断加载数据。&lt;br /&gt;
当数据集十分大的时候会有些用处，该选项无法和分页选项同时使用，分页选项会被自动禁止，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bServerSide:&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
配置DataTable使用服务器端处理，注意，sAjaxSource参数必须指定，以便给DataTable一个为每一行获取数据的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bSort：&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
是否开启列排序，对单独列的设置在每一列的bSortable选项中指定&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bSortClasses：&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
是否在当前被排序的列上额外添加sorting_1,sorting_2,sorting_3三个class，当该列被排序的时候，可以切换其背景颜色&lt;br /&gt;
 该选项作为一个来回切换的属性会增加执行时间（当class被移除和添加的时候）&lt;br /&gt;
当对大数据集进行排序的时候你或许希望关闭该选项&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bStateSave：&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
是否开启状态保存，当选项开启的时候会使用一个cookie保存表格展示的信息的状态，例如分页信息，展示长度，过滤和排序等&lt;br /&gt;
这样当终端用户重新加载这个页面的时候可以使用以前的设置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;sScrollX:&lt;/strong&gt;“100%”&lt;br /&gt;
默认值为空字符串，即无效&lt;br /&gt;
是否开启垂直滚动，垂直滚动会驱使DataTable设置为给定的长度，任何溢出到当前视图之外的数据可以通过垂直滚动进行察看&lt;br /&gt;
当在小范围区域中显示大量数据的时候，可以在分页和垂直滚动中选择一种方式，该属性可以是css设置，或者一个数字（作为像素量度来使用）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;自定义语言设计&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &quot;oLanguage&quot;:  
  {
      &quot;oAria&quot;:{  
              &quot;sSortAscending&quot;: &quot; - click/return to 			sort ascending&quot;,  
      /*  
       默认值为activate to sort column ascending  
       当一列被按照升序排序的时候添加到表头的ARIA标签，注意列头是这个字符串的前缀  
      */  

              &quot;sSortDescending&quot;: &quot; - click/return to sort descending&quot;  
      /*  
       默认值为activate to sort column ascending  
       当一列被按照升序降序的时候添加到表头的ARIA标签，注意列头是这个字符串的前缀  */  
              }
      &quot;oPaginate&quot;: {  
                    &quot;sFirst&quot;: &quot;First page&quot;,  
      /*  
       默认值为First  
       当使用全数字类型的分页组件的时候，到第一页按钮上的文字
      */
		
                    &quot;sLast&quot;: &quot;Last page&quot;,  
      /*  
       默认值为Last  
       当使用全数字类型的分页组件的时候，到最后一页按钮上的文字  
      */  

                    &quot;sNext&quot;: &quot;Next page&quot;,  
      /*  
       默认值为Next  
       当使用全数字类型的分页组件的时候，到下一页按钮上的文字
      */  

                     &quot;sPrevious&quot;: &quot;Previous page&quot;  
      /*  
       默认值为Previous  
       当使用全数字类型的分页组件的时候，到前一页按钮上的文字
      */
                  }  

  &quot;sEmptyTable&quot;: &quot;No data available in table&quot;,  
  /*  
   默认值activate to sort column ascending    
   当表格中没有数据（无视因为过滤导致的没有数据）时，该字符串年优先与sZeroRecords显示  
   注意这是个可选参数，如果没有指定，sZeroRecrods会被使用（既不是默认值也不是给定的值）
  */  

  &quot;sInfo&quot;: &quot;Got a total of _TOTAL_ entries to show (_START_ to _END_)&quot;,  
  /*  
   默认值为Showing _START_ to _END_ of _TOTAL_ entries   
    该属性给终端用户提供当前页面的展示信息，字符串中的变量会随着表格的更新被动态替换，而且可以被任意移动和删除
  */  

  &quot;sInfoEmpty&quot;: &quot;No entries to show&quot;,  
  /*  
    默认值为Showing 0 to 0 of 0 entries   
   当表格中没有数据时展示的表格信息，通常情况下格式会符合sI默认值为空字符串nfo的格式
  */  

  &quot;sInfoFiltered&quot;: &quot; - filtering from _MAX_ records&quot;,  
  /*  
   默认值为(filtered from _MAX_ total entries)   
   当用户过滤表格中的信息的时候，该字符串会被附加到信息字符串的后面，从而给出过滤器强度的直观概念
  */  

  &quot;sInfoPostFix&quot;: &quot;All records shown are derived from real information.&quot;,  
  /*  
   默认值为空字符串  
   使用该属性可以很方便的向表格信息字符串中添加额外的信息，被添加的信息在任何时候都会被附加到表格信息组件的后面  
   sInfoEmpty和sInfoFiltered可以以任何被使用的方式进行结合  
  */  

  &quot;sInfoThousands&quot;: &quot;'&quot;,  
  /*
   默认值为','  
   DataTable有内建的格式化数字的工具，可以用来格式化表格信息中较大的数字  
   默认情况下会自动调用，可以使用该选项来自定义分割的字符 
  */  

  &quot;sLengthMenu&quot;: &quot;Display _MENU_ records&quot;,  
  /*  
   默认值为Show _MENU_ entries  
   描述当分页组件的下拉菜单的选项被改变的时候发生的动作，'_MENU_'变量会被替换为默认的10，25，50，100  
   如果需要的话可以被自定义的下拉组件替换
  */  

  &quot;sLoadingRecords&quot;: &quot;Please wait - loading...&quot;,  
  /*  
   默认值为Loading...  
   当使用Ajax数据源和表格在第一次被加载搜集数据的时候显示的字符串，该信息在一个空行显示  
   向终端用户指明数据正在被加载，注意该参数在从服务器加载的时候无效，只有Ajax和客户端处理的时候有效
  */  

  &quot;sProcessing&quot;: &quot;DataTables is currently busy&quot;,  
  /*  
   默认值为Processing...  
   当表格处理用户动作（例如排序或者类似行为）的时候显示的字符串
  */

  &quot;sSearch&quot;: &quot;Apply filter _INPUT_ to table&quot;,  
  /*
   默认为Search:  
   描述用户在输入框输入过滤条件时的动作，变量'_INPUT_',如果用在字符串中  
   DataTable会使用用户输入的过滤条件替换_INPUT_为HTML文本组件，从而可以支配它（即用户输入的过滤条件）出现在信息字符串中的位置   
   如果变量没有指定，用户输入会自动添加到字符串后面
  */  

  &quot;sUrl&quot;: &quot;http://www.sprymedia.co.uk/dataTables/lang.txt&quot;,  
  /*
   默认值为空字符串，即：无效  
   所有语言信息可以被存储在服务器端的文件中，DataTable可以根据该参数指定的URL去寻找  
   必须保存语言文件的URL信息，必须是JSON格式，对象和初始化中使用的oLanguage对象具有相同的属性
  */  

  &quot;sZeroRecords&quot;: &quot;No records to display&quot;  
  /*  
   默认值为No matching records found  
   当对数据进行过滤操作后，如果没有要显示的数据，会在表格记录中显示该字符串  
   sEmptyTable只在表格中没有数据的时候显示，忽略过滤操作
  */
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bRetrieve:&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
使用指定的选择器检索表格，&lt;strong&gt;注意&lt;/strong&gt;，如果表格已经被初始化，该参数会直接返回已经被创建的对象 &lt;br /&gt;
并不会顾及你传递进来的初始化参数对象的变化，将该参数设置为true说明你确认已经明白这一点&lt;br /&gt;
如果你需要的话，bDestroy可以用来重新初始化表格&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bScrollAutoCss：&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
指明DataTable中滚动的标题元素是否被允许设置内边距和外边距等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bScrollCollapse&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
当垂直滚动被允许的时候，DataTable会强制表格视图在任何时候都是给定的高度（对布局有利）&lt;br /&gt;
不过，当把数据集过滤到十分小的时候看起来会很古怪，而且页脚会留在最下面。当结果集的高度比给定的高度小时该参数会使表格高度自适应&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bSortCellsTop：&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
 是否允许DataTable使用顶部（默认为true）的单元格，或者底部（默认为false）的单元格，当使用复合表头的时候会有些用处&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;iDeferLoading：&lt;/strong&gt;&lt;br /&gt;
默认值：null&lt;br /&gt;
当选项被开启的时候，DataTable在非加载第一次的时候不会向服务器请求数据，而是会使用页面上的已有数据（不会应用排序等），因此在加载的时候保留一个XmlHttpRequest，iDeferLoading被用来指明需要延迟加载，而且也用来通知DataTable一个满的表格有多少条数据。信息元素和分页会被正确保留&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;iDisplayLength：&lt;/strong&gt;&lt;br /&gt;
默认值：10&lt;br /&gt;
单页显示的数据的条数，如果bLengthChange属性被开启，终端用户可以通过一个弹出菜单重写该数值&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;iDisplayStart：&lt;/strong&gt;&lt;br /&gt;
默认值：0&lt;br /&gt;
当开启分页的时候，定义展示的记录的起始序号，不是页数，因此如果你每个分页有10条记录而且想从第三页开始，需要把该参数指定为20&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;oSearch：&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
该参数允许你在初始化的时候使用已经定义的全局过滤状态，sSearch对象必须被定义，但是所有的其它选项都是可选的，当bRegex为true的时候，搜索字符串会被当作正则表达式，当为false（默认）的时候，会被直接当作一个字符串。当bSmart为true的时候，DataTable会使用使用灵活过滤策略（匹配任何可能的数据），为false的时候不会这样做&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;sAjaxDataProp：&lt;/strong&gt;&lt;br /&gt;
默认值：aadata&lt;br /&gt;
当使用Ajax数据源或者服务器端处理的时候，DataTable会默认搜索aaData属性作为数据源,该选项允许变更数据源的名称，你可以使用JavaScript的点号对象表示法去访问多级网状数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;sAjaxSource:&lt;/strong&gt; &lt;br /&gt;
默认值：null&lt;br /&gt;
该参数用来向DataTable指定加载的外部数据源（如果想使用现有的数据，请使用aData），可以简单的提供一个可以用来获得数据url或者JSON对象，该对象必须包含aaData，作为表格的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;sDom：&lt;/strong&gt;&lt;br /&gt;
默认值为&lt;code class=&quot;highlighter-rouge&quot;&gt;lfrtip (when bJQueryUI is false) or &amp;lt;&quot;H&quot;lfr&amp;gt;t&amp;lt;&quot;F&quot;ip&amp;gt; (when bJQueryUI is true)&lt;/code&gt;&lt;br /&gt;
该初始化属性用来指定你想把各种控制组件注入到dom节点的位置（比如你想把分页组件放到表格的顶部），DIV元素（带或者不带自定的class）可以添加目标样式，下列语法被使用&lt;br /&gt;
可供使用的选项&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  'l' - 长度改变  
  'f' - 过滤输入  
  't' - 表格  
  'i' - 信息  
  'p' - 分页  
  'r' - 处理    可供使用的常量  

  'H' - jQueryUI theme &quot;header&quot; classes('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')  
  'F' - jQueryUI theme &quot;footer&quot; classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')    需要的语法  

  '&amp;lt;' 和 '&amp;gt;' - div元素  
  '&amp;lt;&quot;class&quot; and '&amp;gt;' - 带有class属性的div元素  
  '&amp;lt;&quot;#id&quot; and '&amp;gt;' - 带有id属性的div元素   例子  

  '&amp;lt;&quot;wrapper&quot;flipt&amp;gt;'
  '&amp;lt;lf&amp;lt;t&amp;gt;ip&amp;gt;'
	
      $(document).ready(function(){  
        $('#example').dataTable( {  
         &quot;sDom&quot;: '&amp;lt;&quot;top&quot;i&amp;gt;rt&amp;lt;&quot;bottom&quot;flp&amp;gt;&amp;lt;&quot;clear&quot;&amp;amp;lgt;  '
        });  
      });    
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;sServerMethod：&lt;/strong&gt;&lt;br /&gt;
默认值：GET&lt;br /&gt;
设置使用Ajax方式调用的服务器端的处理方法或者Ajax数据源的HTTP请求方式&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function(){  
      $('#example').dataTable({  
          &quot;bServerSide&quot;: true,  
          &quot;sAjaxSource&quot;: &quot;scripts/post.php&quot;,  
          &quot;sServerMethod&quot;: &quot;POST&quot;  
      });  
  });  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnCreatedRow&lt;/strong&gt;
无默认值&lt;br /&gt;
当一个新的TR元素（并且所有TD子元素被插入）被创建或者被作为一个DOM资源被注册时调用该函数，允许操作该TR元素&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function(){
       $('#example').dataTable({
           &quot;fnCreatedRow&quot;: function( nRow, aData, iDataIndex ){
               // Bold the grade for all 'A' grade browsers
               if ( aData[4] == &quot;A&quot; )
       {
           $('td:eq(4)', nRow).html( '&amp;lt;b&amp;gt;A&amp;lt;/b&amp;gt;' );
       }
           }
       });
   });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnDrawCallback&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
每当draw事件发生时调用该函数，允许你动态编辑新建的dom对象的任何属性&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready( function(){   
        $('#example').dataTable({  
           &quot;fnDrawCallback&quot;: function(){  
               alert( 'DataTables has redrawn the table' );  
           }  
       });  
   });  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnInitComplete&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
当表格被初始化后调用该函数，通常DataTable会被持续初始化，并不需要该函数，可是，当使用异步的XmlHttpRequest从外部获得语言信息时，初始化并不是持续的&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready( function(){  
       $('#example').dataTable({  
           &quot;fnInitComplete&quot;: function(oSettings, json) {  
               alert( 'DataTables has finished its initialisation.' );  
           }  
       });  
   }) 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnPreDrawCallback&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
在每一个表格draw事件发生前调用该函数，通过返回false来取消draw事件，其它任何的返回值，包括undefined都会导致draw事件的发生&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready( function(){  
       $('#example').dataTable({  
           &quot;fnPreDrawCallback&quot;: function( oSettings ) {  
               if ( $('#test').val() == 1 ) {  
                   return false;  
               }  
           }  
       });  
   });  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnRowCallback&lt;/strong&gt;&lt;br /&gt;
无默认值
你可以通过该函数在每一个表格绘制事件发生之后，渲染到屏幕上之前，向表格里的每一行传递’处理过程’，该函数可以用来设置行的class名字等&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function(){
       $('#example').dataTable({
           &quot;fnRowCallback&quot;: function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
               // Bold the grade for all 'A' grade browsers
               if ( aData[4] == &quot;A&quot; )
       {
           $('td:eq(4)', nRow).html( '&amp;lt;b&amp;gt;A&amp;lt;/b&amp;gt;' );
       }
           }
        });
   });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnServerData&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
你可以使用该参数重写从服务器获取数据的方法（$.getJSON）,从而使其更适合你的应用，例如你可以使用POST方式提交，或者从Google Gears或者AIR数据库获取数据&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // POST data to server  

   $(document).ready(function(){
        $('#example').dataTable( {
           &quot;bProcessing&quot;: true,
           &quot;bServerSide&quot;: true,
           &quot;sAjaxSource&quot;: &quot;xhr.php&quot;,
           &quot;fnServerData&quot;: function ( sSource, aoData, fnCallback ) {
               $.ajax( {
                   &quot;dataType&quot;: 'json',
               &quot;type&quot;: &quot;POST&quot;,
               &quot;url&quot;: sSource,
               &quot;data&quot;: aoData,
               &quot;success&quot;: fnCallback
               } );
           }
       });
   });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnServerParams&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
用来在向服务器发送Ajax请求时发送额外的数据，例如自定义的过滤信息，该函数使向服务器发送额外参数变得简单，传递进来的参数是DataTable建立的数据集合，你可以根据需要添加或者修改该集合&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function(){
       $('#example').dataTable( {
           &quot;bProcessing&quot;: true,
           &quot;bServerSide&quot;: true,
           &quot;sAjaxSource&quot;: &quot;scripts/server_processing.php&quot;,
           &quot;fnServerParams&quot;: function ( aoData ) {
               aoData.push( { &quot;name&quot;: &quot;more_data&quot;, &quot;value&quot;: &quot;my_value&quot; } );
           }
       });
    });  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;aDataSort&lt;/strong&gt;&lt;br /&gt;
默认为null,自动使用列序号作为默认&lt;br /&gt;
在排序一列的时候同时将其它几列也排序，例如名和姓作为多列排序&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // Using aoColumnDefs  
  $(document).ready(function(){
       $('#example').dataTable({
           &quot;aoColumnDefs&quot;: [
       { &quot;aDataSort&quot;: [ 0, 1 ], &quot;aTargets&quot;: [ 0 ] },
           { &quot;aDataSort&quot;: [ 1, 0 ], &quot;aTargets&quot;: [ 1 ] },
           { &quot;aDataSort&quot;: [ 2, 3, 4 ], &quot;aTargets&quot;: [ 2 ] }
       ]
       });
   }); 
 
  // Using aoColumns  
  $(document).ready(function(){
       $('#example').dataTable({
            &quot;aoColumns&quot;: [
        { &quot;aDataSort&quot;: [ 0, 1 ] },
           { &quot;aDataSort&quot;: [ 1, 0 ] },
           { &quot;aDataSort&quot;: [ 2, 3, 4 ] },
           null,
           null
           ]
       });
   });  
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bSearchable&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
是否在列上应用过滤&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function(){
       $('#example').dataTable({
           &quot;aoColumnDefs&quot;: [
       { &quot;bSearchable&quot;: false, &quot;aTargets&quot;: [ 0 ] }
       ]} );
   });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bSortable&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
是否在某一列上开启排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bVisible&lt;/strong&gt;&lt;br /&gt;
默认值：true&lt;br /&gt;
是否展示某一列&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function() {
       $('#example').dataTable( {
           &quot;aoColumnDefs&quot;: [
       { &quot;bVisible&quot;: false, &quot;aTargets&quot;: [ 0 ] }
       ] } );
   } );
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;fnRender&lt;/strong&gt;&lt;br /&gt;
无默认值&lt;br /&gt;
自定义列中每个单元格被展示的时候调用的展示函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready(function() {
       $('#example').dataTable( {
           &quot;aoColumnDefs&quot;: [
       {
           &quot;fnRender&quot;: function ( o, val ) {
               return o.aData[0] +' '+ o.aData[3];
           },
           &quot;aTargets&quot;: [ 0 ]
       }
       ]
       } );
   } );
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;iDataSort&lt;/strong&gt;&lt;br /&gt;
默认值为-1，使用自动计算的列标&lt;br /&gt;
当选择该列进行排序的时候，你希望调用排序操作的列的列号，该参数可以用来按隐藏列排序&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;bServerSide&lt;/strong&gt;&lt;br /&gt;
默认值：false&lt;br /&gt;
配置使用服务器端处理的DataTable，注意sAjaxSource参数必须指定，以便给DataTable一个获取每行数据的数据源&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $(document).ready( function () {
       $('#example').dataTable( {
           &quot;bServerSide&quot;: true,
           &quot;sAjaxSource&quot;: &quot;xhr.php&quot;
       } );
   } );
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</content>
 </entry>
 
 <entry>
   <title>express 4.x的迁移</title>
   <link href="http://www.blogways.net/blog/2015/10/24/moving-to-express4.x.html"/>
   <updated>2015-10-24T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/24/moving-to-express4.x</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://expressjs.com/en/guide/migrating-4.html&quot;&gt;http://expressjs.com/en/guide/migrating-4.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Express 4.x较Express 3.x进行了较大的改动，原来基于Express 3.x的项目无法直接升级到 4.x。本文对Express网站的内容进行了简单的总结，希望能够帮助大家更好的了解Express 4.x，同时方便大家迁移。&lt;/p&gt;
&lt;h2 id=&quot;一express-4x的主要变化&quot;&gt;一、Express 4.x的主要变化&lt;/h2&gt;
&lt;p&gt;1、重新撰写Express内核，取消了原来对于Connect的依赖&lt;br /&gt;
2、移除了大部分Build-in的Middleware&lt;br /&gt;
3、Middleware可以仅对特定url前缀的请求执行，并且支持url中的参数&lt;br /&gt;
4、对Routing系统的扩展&lt;/p&gt;
&lt;h3 id=&quot;取消connect的依赖&quot;&gt;取消Connect的依赖&lt;/h3&gt;
&lt;p&gt;Express 3.x是基于Connect构建的。重构后的Express 4.x取消了对Connect的依赖，变成了完全独立的模块。但由于采用一致的Middleware处理方法，新的Express 4.x仍然对Connect的所有Middleware向下兼容，所以在Express中仍然可以使用Connect的Middleware。&lt;/p&gt;
&lt;h3 id=&quot;移除绝大多数build-in的middleware&quot;&gt;移除绝大多数Build-in的Middleware&lt;/h3&gt;
&lt;p&gt;Express 4.x的理念是仅专注于最核心的routing功能，而将其他组建的选择全部交由用户配置，一方面提供更好的灵活和定制性，另一方面可以始终让用户使用最新的Middleware而将其和Express的更新独立开来。其核心中仅保留了express.static，其余Middleware均需要通过npm安装并且require。下表中是主要移除的模块列表：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;express 3&lt;/th&gt;
      &lt;th&gt;express 4&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;express.bodyParser&lt;/td&gt;
      &lt;td&gt;body-parser+mnlter&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.comperss&lt;/td&gt;
      &lt;td&gt;compression&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.cookieSession&lt;/td&gt;
      &lt;td&gt;cookie-session&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.cookieParser&lt;/td&gt;
      &lt;td&gt;cookie-parser&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.logger&lt;/td&gt;
      &lt;td&gt;morgan&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.session&lt;/td&gt;
      &lt;td&gt;express.session&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.favicon&lt;/td&gt;
      &lt;td&gt;serve-favicon&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.responseTime&lt;/td&gt;
      &lt;td&gt;response-time&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.errorHandler&lt;/td&gt;
      &lt;td&gt;errorhandler&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.methodOverride&lt;/td&gt;
      &lt;td&gt;method-override&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.timeout&lt;/td&gt;
      &lt;td&gt;connect-timeout&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.vhost&lt;/td&gt;
      &lt;td&gt;vhost&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.csrf&lt;/td&gt;
      &lt;td&gt;csurf&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.directory&lt;/td&gt;
      &lt;td&gt;serve-index&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;express.static&lt;/td&gt;
      &lt;td&gt;serve-static&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面是Express 4的中间件的完整列表。
在大多数情况下，你可以简单地用express 4替换旧版本express 3中对应的中间件。有关详细信息，请参阅GitHub的模块文档。&lt;/p&gt;
&lt;h3 id=&quot;appuse-accepts-parameters&quot;&gt;app.use accepts parameters&lt;/h3&gt;
&lt;p&gt;在第4版，你现在可以在具有可变参数的路径上加载中间件，并从路由处理程序中读取参数值。 例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use('/book/:id', function(req, res, next) {
  console.log('ID:', req.params.id);
  next();
}); ### The routing system 应用隐式加载路由中间件，所以，现在你不必担心 router 路由中间件加载的次序问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定义路由的方式没有发生变化，现在增加了两个新的特性来帮助组织路由系统。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;新的方法 route，针对一个路由路径创建链式的路由处理器。&lt;/li&gt;
    &lt;li&gt;新的类 express.Router，创建模块化的路由处理器。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;approute-method&quot;&gt;app.route() method&lt;/h3&gt;
&lt;p&gt;新的 app.route 方法对特定的路由路径创建链式的路由处理器。由于可以在一个地方定义路径，这样有助于创建模块话的路由规则，减少重复。&lt;/p&gt;

&lt;p&gt;路由的详细信息，可以参见 Route() 的文档。&lt;br /&gt;
下面的示例演示了路由的链式定义&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.route('/book')
  .get(function(req, res) {
    res.send('Get a random book');
  })
  .post(function(req, res) {
    res.send('Add a book');
  })
  .put(function(req, res) {
    res.send('Update the book');
  }) ### express.Router class 另外一个帮助组织路由的特性是新的类 express.Router，可以帮助创建模块话的路由处理器。一个 Router 的实例就是一个完整的中间件和路由系统，由于这个原因，它经常被称为 迷你应用。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面演示了创建一个名为 bird.js 的路由文件，内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var router = express.Router();

// middleware specific to this router
router.use(function timeLog(req, res, next) {
  console.log('Time: ', Date.now());
  next();
})
// define the home page route
router.get('/', function(req, res) {
  res.send('Birds home page');
})
// define the about route
router.get('/about', function(req, res) {
  res.send('About birds');
})

module.exports = router; 然后在应用中加载这个路由模块。

var birds = require('./birds');
...
app.use('/birds', birds); 这个应用现在可以处理请求 /birds 和 /birds/about，还可以调用 timeLog 中间件。   ### Other changes 下表列出了其它小的但是重要的修改  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;table class=&quot;table-striped table-condensed&quot;&gt;
	&lt;tr&gt;
		&lt;td&gt;对象&lt;/td&gt;
		&lt;td&gt;说明&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Node&lt;/td&gt;
		&lt;td&gt;Express 4 需要 Node 0.10.x 及其以上版本，已经不支持 0.8.x&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;http.createServer&lt;/td&gt;
		&lt;td&gt;不再需要 http 模块，应用使用 app.listen() 启动&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;app.configure()&lt;/td&gt;
		&lt;td&gt;app.configure() 已经被移除，使用 process.env.NODE_ENV 或者 app.get(“env”) 来检测环境、配置应用&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;json.spaces()&lt;/td&gt;
		&lt;td&gt;在 Express 4 中默认禁用了 json spaces&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Req.location()&lt;/td&gt;
		&lt;td&gt;不再能获取相对 url&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Req.params&lt;/td&gt;
		&lt;td&gt;原来是一个数组，现在是对象&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Res.locals&lt;/td&gt;
		&lt;td&gt;原来是函数，现在是对象&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Res.headerSent&lt;/td&gt;
		&lt;td&gt;修改为 res.headersSent&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;App.route&lt;/td&gt;
		&lt;td&gt;现在作为 app.mountpath 存在&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Res.on(“header”)&lt;/td&gt;
		&lt;td&gt;删除&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Res.charset&lt;/td&gt;
		&lt;td&gt;删除&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;Res.setHeader(“Set-Cookie”, val)&lt;/td&gt;
		&lt;td&gt;这个功能现在限制为设置基本的 cookie 值，使用 res.cookie() 的添加功能&lt;/td&gt;
	&lt;/tr&gt;  
&lt;/table&gt;

&lt;h2 id=&quot;二-示例&quot;&gt;二 、示例&lt;/h2&gt;
&lt;p&gt;这里是一个从 Express 3 升级到 Express 4 的示例。&lt;/p&gt;
&lt;h3 id=&quot;version-3-app&quot;&gt;Version 3 app&lt;/h3&gt;
&lt;h4 id=&quot;appjs&quot;&gt;app.js&lt;/h4&gt;
&lt;p&gt;原来的 app.js 如下：&lt;br /&gt;
	var express = require(‘express’);
	var routes = require(‘./routes’);
	var user = require(‘./routes/user’);
	var http = require(‘http’);
	var path = require(‘path’);&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = express();

// all environments
app.set('port', process.env.PORT || 3000);
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'jade');
app.use(express.favicon());
app.use(express.logger('dev'));
app.use(express.methodOverride());
app.use(express.session({ secret: 'your secret here' }));
app.use(express.bodyParser());
app.use(app.router);
app.use(express.static(path.join(__dirname, 'public')));

// development only
if ('development' == app.get('env')) {
  app.use(express.errorHandler());
}

app.get('/', routes.index);
app.get('/users', user.list);

http.createServer(app).listen(app.get('port'), function(){
  console.log('Express server listening on port ' + app.get('port'));
}); package.json 如下所示   附带的第3版的package.json文件可能看起来像这样：

{
  &quot;name&quot;: &quot;application-name&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node app.js&quot;
  },
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;3.12.0&quot;,
    &quot;jade&quot;: &quot;*&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;迁移过程&quot;&gt;迁移过程&lt;/h3&gt;
&lt;p&gt;在迁移之前，先安装 Express 4 需要的中间件，还要更新 express，Jade 到最新的版本。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;$ npm install serve-favicon morgan method-override express-session body-parser multer errorhandler express@latest jade@latest –save&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对 app.js 进行一下的修改。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;http 模块已经使用了，所以，删除 var http = require( “http” );&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内建的中间件 express.favicon, express.logger, express.methodOverride, express.session, express.bodyParser 和 express.errorHandler 已经不存在了，你必须手动安装，然后在应用中替换它们。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;不再需要加载 app.router ，实际上，它也已经不是 Express 4 中的对象，所以，删除 app.use( app.router );&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用 app.listen() 来取代 http.createServer 启动。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;version-4-app&quot;&gt;Version 4 app&lt;/h3&gt;
&lt;h4 id=&quot;packagejson&quot;&gt;package.json&lt;/h4&gt;
&lt;p&gt;执行上面的命令，会如下更新 package.json 文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;application-name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;version&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;0.0.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;private&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;scripts&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;node app.js&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;dependencies&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;body-parser&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.5.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;errorhandler&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.1.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;express&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^4.8.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;express-session&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.7.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;jade&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.5.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;method-override&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^2.1.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;morgan&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^1.2.2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;multer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^0.1.3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;serve-favicon&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;^2.0.1&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;####&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.js&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;然后，删除无效的代码，加载需要的中间件，完成其它必须的修改，最终的&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.js&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;看起来如下所示：&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;express&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('express');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;routes&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('./routes');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;user&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('./routes/user');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;path&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('path');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;favicon&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('serve-favicon');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;logger&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('morgan');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;methodOverride&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('method-override');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;session&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('express-session');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bodyParser&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('body-parser');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;multer&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('multer');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;errorHandler&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;require('errorhandler');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;var&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;express();&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;all&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;environments&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.set('port',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;process.env.PORT&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;||&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.set('views',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;path.join(__dirname,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'views'));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.set('view&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;engine',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'jade');&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(favicon(__dirname&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'/public/favicon.ico'));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(logger('dev'));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(methodOverride());&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(session(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;resave:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;true,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;saveUninitialized:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;true,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;secret:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'uwotm8'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(bodyParser.json());&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(bodyParser.urlencoded(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;extended:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(multer());&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(express.static(path.join(__dirname,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'public')));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;development&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;only&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;('development'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.get('env'))&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.use(errorHandler());&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.get('/',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;routes.index);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.get('/users',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;user.list);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.listen(app.get('port'),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;function()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log('Express&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;listening&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.get('port'));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;除非你需要直接与HTTP模块（socket.io/SPDY/HTTPS）工作，加载它不是必需的，并且app可以使用这种方式简单的启动：&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.listen(app.get('port'),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;function()&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;console.log('Express&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;listening&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;on&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app.get('port'));&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;);&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;###&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;运行app&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;现在，迁移已经完成了，使用如下命令启动。&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;

&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用浏览器访问 http://localhost:3000，查看使用 Express 4 生成的页面。&lt;/p&gt;
&lt;h2 id=&quot;升级到-express-4-的应用生成器&quot;&gt;升级到 Express 4 的应用生成器&lt;/h2&gt;
&lt;p&gt;生成一个 Express 4 的命令行工具还是 express，但是，升级到新版本的话，需要先卸载 Express 3 的生成器，然后安装新的生成器。&lt;/p&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;p&gt;如果你已经安装过 Express 3 的生成器，必须先卸载&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm uninstall –g express 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;依赖与你的目录权限和配置，可能需要先执行 sudo 提升权限。
现在，安装新的生成器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Npm install –g express-generator
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，你系统中的 express 命令已经升级为 Express 4 的生成器了.&lt;/p&gt;
&lt;h3 id=&quot;生成器的变化&quot;&gt;生成器的变化&lt;/h3&gt;
&lt;p&gt;除了下面的变化，基本上与以前相同。&lt;/p&gt;

&lt;p&gt;–sessions 选项被删除了&lt;br /&gt;
–jshtml 选项被删除了&lt;br /&gt;
–hogan 被添加，以便支持 Hogan.js&lt;/p&gt;
&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;
&lt;p&gt;执行下面的命令，创建 app4 应用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;express app4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你查看 app4 文件夹中的 app.js 文件，你会发现所有的中间件被替换为独立的中间件加载，router 中间件不再显式加载。你还会注意到 app.js 现在是一个 Node 模块。&lt;br /&gt;
安装依赖的文件之后，使用下面的命令启动应用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm start
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你查看 package.json 中的启动脚本，你会注意到实际的启动脚本是 node ./bin/www，在 Express 3 中是 node app.js.由于 Express 4 新生成的 app.js 已经是一个 Node 模块，它可以不再需要通过一个独立的应用来启动，它可以在 Node 文件中加载，通过 Node 文件启动，这里就是 ./bin/www.不管是 bin 文件夹，还是 www 文件，他们都是手工由 Express 生成器生成的，所以，需要的话，都可以进行修改。为了与 Express 3 保持一致，删除 module.experts = app；在 app.js 的最后，添加下面的代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('port', process.env.PORT || 3000);

var server = app.listen(app.get('port'), function() {
  debug('Express server listening on port ' + server.address().port);
});  确认加载 debug 模块。

var debug = require('debug')('app4'); 然后将 package.json 文件中的 start: &quot;node ./bin/www&quot; 修改为 &quot;start&quot;: &quot;node app.js&quot;。现在，已经从 ./bin/www 回到了 app.js。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x API</title>
   <link href="http://www.blogways.net/blog/2015/10/24/express3.x-API.html"/>
   <updated>2015-10-24T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/24/express3.x-API</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://expressjs.com/en/3x/api.html&quot;&gt;http://expressjs.com/en/3x/api.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一express&quot;&gt;一、express()&lt;/h2&gt;

&lt;p&gt;创建一个express应用程序，express()函数是一个顶层函数express模块的导出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');	
var app = express();	

app.get('/', function(req, res){	
res.send('hello world');	
});	

app.listen(3000);	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二application应用&quot;&gt;二、Application（应用）&lt;/h2&gt;

&lt;h3 id=&quot;appsetnamevalue&quot;&gt;app.set(name,value)&lt;/h3&gt;

&lt;p&gt;用用于指定变量的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('title', 'My Site');    
app.get('title');	
// =&amp;gt; &quot;My Site&quot;		
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appgetname&quot;&gt;app.get(name)&lt;/h3&gt;

&lt;p&gt;获得设置项的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('title');    
// =&amp;gt; undefined		

app.set('title', 'My Site');  
app.get('title');  
// =&amp;gt; &quot;My Site&quot;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appenablename&quot;&gt;app.enable(name)&lt;/h3&gt;

&lt;p&gt;将设置项 name 的值设为 true 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.enable('trust proxy');  
app.get('trust proxy');  
// =&amp;gt; true	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appdisablename&quot;&gt;app.disable(name)&lt;/h3&gt;

&lt;p&gt;将设置项 name 的值设为 false 。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.disable('trust proxy');  
app.get('trust proxy');  
// =&amp;gt; false	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appenabledname&quot;&gt;app.enabled(name)&lt;/h3&gt;

&lt;p&gt;检查设置项 name 是否已启用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.enabled('trust proxy');	  
// =&amp;gt; false	  
app.enable('trust proxy');  
app.enabled('trust proxy');	  
// =&amp;gt; true	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appdisabledname&quot;&gt;app.disabled(name)&lt;/h3&gt;

&lt;p&gt;检查设置项 name 是否已禁用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.disabled('trust proxy');  
// =&amp;gt; true	

app.enable('trust proxy');	
app.disabled('trust proxy');  	
// =&amp;gt; false	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appconfigureenv-callback&quot;&gt;app.configure([env], callback)&lt;/h3&gt;

&lt;p&gt;当 env 和 app.get(‘env’) (也就是 process.env.NODE_ENV) 匹配时, 调用 callback 。		
保留这个方法是出于历史原因，后面列出的 if 语句的代码其实更加高效、直接。  		
使用 app.set 配合其它一些配置方法后,没有必要再使用这个方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	// 所有环境  

	app.configure(function(){    
	app.set('title', 'My Application');		
	})		
	
	// 开发环境  
	app.configure('development', function(){  
	app.set('db uri', 'localhost/dev');  
	})	

	// 只用于生产环境	
	app.configure('production', function(){	
	app.set('db uri', 'n.n.n.n/prod');  
	})	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更高效且直接的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	// 所有环境	
	app.set('title', 'My Application');	
	// 只用于开发环境	
	if ('development' == app.get('env')) {	
	app.set('db uri', 'localhost/dev');	
	}	
	// 只用于生产环境	
	if ('production' == app.get('env')) {	
	app.set('db uri', 'n.n.n.n/prod');	
	}	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appusepath-function&quot;&gt;app.use([path], function)&lt;/h3&gt;

&lt;p&gt;使用中间件 function，可选参数 path 默认是 “/”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	var express = require('express');  
	var app = express();	
	
	// 一个简单的 logger  
	app.use(function(req, res, next){	
	console.log('%s %s', req.method, req.url);	
  	next();	
	});	
	
	// 响应
	app.use(function(req, res, next){  
	res.send('Hello World');	
	});  
	
	app.listen(3000);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;挂载路径被剥离出来，对于中间件函数来说是不可见的。	
这么设计是为了让中间件在不用修改任何代码的情况下就可以在任意前缀的路径下执行。&lt;/p&gt;

&lt;p&gt;路由将匹配任何路径，以遵循“/”、“./”。	
例如：app.use(‘/apple’,…)将会匹配 /apple, /apple/images, /apple/images/news, /apple.html,/apple.html.txt等等。&lt;/p&gt;

&lt;p&gt;这里有一个具体的例子，通过express.static()方法使用./public来管理文件服务用例的中间件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /javascripts/jquery.js	
// GET /style.css	
// GET /favicon.ico	
app.use(express.static(__dirname + '/public'));	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如你想为自有的静态文件增加前缀’/static’，你可以使用’mounting’功能。	
挂载的中间件函数不会被调用，除非req.url包含这个前缀，当函数被调用时，前缀是被剥离出去的。	
当然这只会影响到这个函数，挂载好后随后的中间件还是会通过包含/static的req.url查看到。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /static/javascripts/jquery.js	
// GET /static/style.css	
// GET /static/favicon.ico	
app.use('/static', express.static(__dirname + '/public'));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中间件使用app.use()定义的顺序是非常重要的，它们依次被调用，因此这个决定了中间件的优先级。	
例如，一般来说日志中间件是你要用到的第一个中间件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.logger());	
app.use(express.static(__dirname + '/public'));
app.use(function(req, res){
res.send('Hello');
});	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在假设你想忽略静态文件的请求日志，	
但又想在logger()定义之后继续使用日志路由，你只需要将static()移动前面就可以了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));	
app.use(logger());	
app.use(function(req, res){	
res.send('Hello');	
});	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个具体的例子是从众多的目录文件服务中，给予”./public”最高的优先级：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));		
app.use(express.static(__dirname + '/files'));			
app.use(express.static(__dirname + '/uploads'));  	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;settings&quot;&gt;settings&lt;/h3&gt;

&lt;p&gt;下面的内建的可以改变 Express 行为的设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;env 运行时环境，默认为 process.env.NODE_ENV 或者 “development”
trust proxy 激活反向代理，默认是未激活状态
jsonp callback name 修改 ?callback= 的默认 callback 的名字
json replacer JSON 替换时的回调, 默认为 null
json spaces JSON 响应被格式化时的空格数量，开发环境下是 2 ，生产环境是 0
case sensitive routing 路由的大小写敏感, 默认是关闭状态，”/Foo” 和 “/foo” 被认为是一样的
strict routing路由的严格格式, 默认情况下 “/foo” 和 “/foo/” 被路由认为是一样的
view cache E模板缓存，在生产环境中是默认开启的
view engine 默认的模板引擎
views 模板的目录, 默认是 “process.cwd() + ‘/views’” 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appengineext-callback&quot;&gt;app.engine(ext, callback)&lt;/h3&gt;

&lt;p&gt;注册模板引擎的 callback 用来处理 ext 扩展名的文件。
注册给定的模板引擎的callback默认用来处理扩展名为ext的文件。
例如，如果你试图渲染一个”foo.jade”文件，Express将在内部调用以下代码，并缓存require()给后续调用以提高性能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.engine('jade', require('jade').__express);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;引擎没有提供._express渲染方法，或者你想映射一个不一样的扩展名在模板引擎上，你可以用这个方法。
例如映射EJS模板引擎来渲染”.html”文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.engine('html', require('ejs').renderFile);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这种情况下，EJS提供.renderFile()方法使用Express定义的参数：(path, options, callback)，
但要注意这个方法是在内部给ejs._express取一个别名，如果你使用”.ejs”可以什么都不要做。&lt;/p&gt;

&lt;p&gt;有些模板引擎并不遵循这一规则，consolidate.js库的建立是为了映射所有的node流行模板引擎遵循这一规则，
从而使得他们在Express内无缝工作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan);  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appparamname-callback&quot;&gt;app.param([name], callback)&lt;/h3&gt;
&lt;p&gt;映射路由参数规则。&lt;br /&gt;
例如当:user存在于一个路由路径中，你需要自动提供req.user给路由映射启动逻辑，或者执行输入参数验证。&lt;/p&gt;

&lt;p&gt;下面的代码说明了如果callback很像中间件，从而支持异常操作，
但却增加了一个参数，这里命名为id。然后尝试执行加载用户信息，赋值给req.user，否则传递一个错误到next(err)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.param('user', function(req, res, next, id){
	User.find(id, function(err, user){
		if (err) {
  		next(err);
			} else if (user) {
  				req.user = user;
  				next();
			} else {
  					next(new Error('failed to load user'));
					}
				});
});  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，你可能只传递一个回调函数，
在这种情况下你有机会改变app.param()API。例如express-params定义了下面的回调函数，它允许你使用给定的正则表达式限制参数。&lt;/p&gt;

&lt;p&gt;这个例子有点更先进，检查当第二个参数是正则表达式，返回回调函数很像”user”参数例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.param(function(name, fn){
	if (fn instanceof RegExp) {
	return function(req, res, next, val){
  	var captures;
  	if (captures = fn.exec(String(val))) {
    req.params[name] = captures;
    next();
  	} else {
    		next('route');
  			}
		}
	}
}); 该方法可以被用来有效的验证参数，或者解析提供匹配分组：

app.param('id', /^\d+$/);  

app.get('/user/:id', function(req, res){
res.send('user ' + req.params.id);
});
app.param('range', /^(\w+)\.\.(\w+)?$/);

app.get('/range/:range', function(req, res){
	var range = req.params.range;
res.send('from ' + range[1] + ' to ' + range[2]);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appverbpath-callback-callback&quot;&gt;app.VERB(path, [callback…], callback)&lt;/h3&gt;

&lt;p&gt;Express中App.WEB()方法提供了路由功能，其中VERB是一个HTTP动作，跟app.post()类似。
可提供多个回调函数，都是一视同仁，表现跟中间件一样，唯一不一样的是通过调用next(‘route’)来继续其余的路由回调。
这个机制可以用来执行路由的前提条件，然后将控制权传递给随后的路由，没有理由进行路由的匹配。&lt;/p&gt;

&lt;p&gt;下面的代码说明了多个简单路由定义的可行性。Express将路径字符串转换成正由表达式，用来在内部匹配到来的请求。
在执行这些匹配时查询字符串不考虑，例如”GET /”将匹配以下的路由，如”GET /?name=tobi”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/', function(req, res){
	res.send('hello world');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;正由表达式也可以使用，如果你有非常特殊的限制可能是有用的，
例如下面的”GET /commits/71dbb9c”表达式将很好的匹配”GET /commits/71dbb9c..4c084f9”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
	var from = req.params[0];
	var to = req.params[1] || 'HEAD';
res.send('commit range ' + from + '..' + to);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以传递一些回调函数，对于利用中间件加载资源、执行验证等很有用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/user/:id', user.load, function(){
// ... 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你有多个共同的中间件路由，可以使用路由api的all。两个中间件将用来处理GET和POST请求&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var middleware = [loadForum, loadThread];

app.route('/forum/:fid/thread/:tid')
	.all(loadForum)
	.all(loadThread)
	.get(function() { //... });
	.post(function() { //... });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appallpath-callback-callback&quot;&gt;app.all(path, [callback…], callback)&lt;/h3&gt;

&lt;p&gt;此方法功能就像app.VERB()方法，但它匹配所有HTTP的动作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all('*', requireAuthentication, loadUser);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等价于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all('*', requireAuthentication)
app.all('*', loadUser);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个非常赞的例子是“全局”白名单函数。
这里有一个例子跟前一个很像，但是它限制前缀为 “/api”:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all('/api/*', requireAuthentication);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;applocals&quot;&gt;app.locals&lt;/h3&gt;

&lt;p&gt;应用本地变量会附加给所有的在这个应用程序内渲染的模板。这是一个非常有用的模板函数，就像应用程序级数据一样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.locals.title = 'My App';
app.locals.strftime = require('strftime');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;app.locals 对象是一个 JavaScript Function，执行的时候它会把属性合并到它自身，
提供了一种简单展示已有对象作为本地变量的方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.locals({
  title: 'My App',
  phone: '1-250-858-9990',
  email: 'me@myapp.com'
});

app.locals.title
// =&amp;gt; 'My App'

app.locals.email
// =&amp;gt; 'me@myapp.com'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;app.locals 对象最终会是一个 Javascript 函数对象，你不可以使用 Functions 和 Objects 内置的属性，
比如 name、apply、bind、call、arguments、length、constructor。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.locals({name: 'My App'});

app.locals.name
// =&amp;gt; 返回 'app.locals' 而不是 'My App' (app.locals 是一个函数 !)
// =&amp;gt; 如果 name 变量用在一个模板里，则返回一个 ReferenceError 。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;全部的保留字列表可以在很多规范里找到。 JavaScript 规范介绍了原来的属性，
有一些还会被现代的 JavaScript 引擎识别，EcmaScript 规范在它的基础上，
统一了值，添加了一些，删除了一些废弃的。如果感兴趣，可以看看 Functions 和 Objects 的属性值。&lt;/p&gt;

&lt;p&gt;默认情况下Express只有一个应用程序级本地变量，它是 settings。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('title', 'My App');
// 在 view 里使用 settings.title
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;apprenderview-options-callback&quot;&gt;app.render(view, [options], callback)&lt;/h3&gt;

&lt;p&gt;使用回调函数返回的渲染字符串渲染视图。这是res.render()的应用程序级别的版本，它们的行为是一样的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;approutes&quot;&gt;app.routes&lt;/h3&gt;

&lt;p&gt;The app.routes 对象存储了所有的被 HTTP 动作定义的路由。这个对象可以用在一些内部功能上，
比如 Express 不仅用它来做路由分发，同时在没有 app.options() 定义的情况下用它来处理默认的
OPTIONS
行为。你的应用程序或者框架也可以很轻松的通过在这个对象里移除路由来达到删除路由的目的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log(app.routes)

{ get: 
   [ { path: '/',
       method: 'get',
       callbacks: [Object],
       keys: [],
       regexp: /^\/\/?$/i },
     { path: '/user/:id',
       method: 'get',
       callbacks: [Object],
       keys: [{ name: 'id', optional: false }],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ],
  delete: 
   [ { path: '/user/:id',
       method: 'delete',
       callbacks: [Object],
       keys: [Object],
       regexp: /^\/user\/(?:([^\/]+?))\/?$/i } ] }

app.listen()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在给定的主机和端口上监听请求，这个和 node 文档中的 http.Server#listen() 是一致的。
	var express = require(‘express’);
	var app = express();
	app.listen(3000);&lt;/p&gt;

&lt;p&gt;express() 返回的 app 实际上是一个 JavaScript  Function,它被设计为传给 node 的 http servers 作为处理请求的回调函数。
因为 app 不是从 HTTP 或者 HTTPS 继承来的，它只是一个简单的回调函数，你可以以同一份代码同时处理 HTTP 和 HTTPS 版本的服务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三request&quot;&gt;三、Request&lt;/h2&gt;

&lt;h3 id=&quot;reqparams&quot;&gt;req.params&lt;/h3&gt;

&lt;p&gt;此属性是一个包含映射路由”parameters”的对象。例如你使用/user/:name路由，那么”name”属性对你来说就是一个req.params.name变量。
该对象默认为{}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /user/tj
req.params.name
// =&amp;gt; &quot;tj&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当在定义路由规则时使用了正则表达式，使用req.params[N]获取所有参数匹配数组，其中N表示数组的第几个。此规则适用于包含未定义的通配符的路由字符串，例如/file/*：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /file/javascripts/jquery.js
req.params[0]
// =&amp;gt; &quot;javascripts/jquery.js&quot;

req.query 此属性是一个包含解析查询字符串的对象，默认为{}。

// GET /search?q=tobi+ferret
req.query.q
// =&amp;gt; &quot;tobi ferret&quot;

// GET /shoes?order=desc&amp;amp;shoe[color]=blue&amp;amp;shoe[type]=converse
req.query.order
// =&amp;gt; &quot;desc&quot;

req.query.shoe.color
// =&amp;gt; &quot;blue&quot;

req.query.shoe.type
// =&amp;gt; &quot;converse&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqbody&quot;&gt;req.body&lt;/h3&gt;

&lt;p&gt;此属性是一个包含解析的请求体的对象。它的特点是提供一个bodyParser()中间件。虽然其他的体解析中间件也遵循此约定，
当使用bodyparser（）使用时，默认值为{}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// POST user[name]=tobi&amp;amp;user[email]=tobi@learnboost.com
req.body.user.name
// =&amp;gt; &quot;tobi&quot;

req.body.user.email
// =&amp;gt; &quot;tobi@learnboost.com&quot;

// POST { &quot;name&quot;: &quot;tobi&quot; }
req.body.name
// =&amp;gt; &quot;tobi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqfiles&quot;&gt;req.files&lt;/h3&gt;
&lt;p&gt;这个属性是一个上传文件的对象，它的特点是提供一个bodyParser()中间件。虽然其他的体解析中间件也遵循此约定，
当使用bodyparser（）使用时，默认值为{}。&lt;/p&gt;

&lt;p&gt;例如一个文件字段被命名为“image”，和一个文件被上传，req.files.image包含如下文件对象：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;size:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;74643,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;path:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'/tmp/8ef9c52abe857867fd0a4e9a819d1876',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'edge.png',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;type:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'image/png',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;hash:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;lastModifiedDate:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Thu&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Aug&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;09&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2012&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;20:07:51&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;GMT-0700&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;(PDT),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;_writeStream:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
   &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;path:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'/tmp/8ef9c52abe857867fd0a4e9a819d1876',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;fd:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;13,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;writable:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;flags:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'w',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;encoding:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'binary',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;mode:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;438,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;bytesWritten:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;74643,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;busy:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;false,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;_queue:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;_open:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[Function],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
     &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;drainable:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;length:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;filename:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;mime:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;Getter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;bodyparser()中间件利用节点强大的模块内部，并接受相同的选项。一个例子是keepextensions强大的选项，
在给出文件名“/tmp/8ef9c52abe857867fd0a4e9a819d1876”.png扩展名的情况下默认值是false。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.bodyParser({ keepExtensions: true, uploadDir: '/my/files' }));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqparamname&quot;&gt;req.param(name)&lt;/h3&gt;
&lt;p&gt;返回当前参数name的值
		// ?name=tobi
		req.param(‘name’)
		// =&amp;gt; “tobi”&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	// POST name=tobi
	req.param('name')
	// =&amp;gt; &quot;tobi&quot;

	// /user/tobi for /user/:name 
	req.param('name')
	// =&amp;gt; &quot;tobi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查找优先级如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	req.params
	req.body
	req.query
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接使用req.body，req.params，和req.query应该更新清晰，除非你确实需要接收每个对象的输入。&lt;/p&gt;

&lt;h3 id=&quot;reqroute&quot;&gt;req.route&lt;/h3&gt;

&lt;p&gt;当前匹配的路由包含多个属性，如路由的原始路径字符串以及转换后的正则表达式等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/user/:id?', function(req, res){
  console.log(req.route);
});
上面的代码输出结果：

{ path: '/user/:id?',
  keys: [ { name: 'id', optional: true } ],
  regexp: /^\/user(?:\/([^\/]+?))?\/?$/i,
  params: [ id: '12' ] }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqcookies&quot;&gt;req.cookies&lt;/h3&gt;

&lt;p&gt;当cookieParser()中间件使用时该对象默认为{}，除此之外还包含由用户代理发送的cookies。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Cookie: name=tj
req.cookies.name
// =&amp;gt; &quot;tj&quot; 如有任何问题或者疑问请参阅cookie-parser附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqsignedcookies&quot;&gt;req.signedCookies&lt;/h3&gt;

&lt;p&gt;当cookieParser(secret)中间件使用该对象默认为{}，还包括用户代理发送的签名cookies，未签名以及准备使用的。签名cookies存放于一个单独的对象，以显示开发者的意图，否则可以通过在req.cookie设置值发起恶意攻击，从而很轻易的欺骗。需要注意的是签名的cookie并不意味着它是隐藏的或者是加密的，这个防止篡改的秘密只是简单的将签名私有化。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// =&amp;gt; &quot;tobi&quot; 如有任何问题或者疑问请参阅cookie-parser附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqgetfield&quot;&gt;req.get(field)&lt;/h3&gt;
&lt;p&gt;获取请求头内的field字段，不区分大小写。Referrer和Referer字段可以互换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	req.get('Content-Type');
	// =&amp;gt; &quot;text/plain&quot;
	
	req.get('content-type');
	// =&amp;gt; &quot;text/plain&quot;
	
	req.get('Something');
	// =&amp;gt; undefined 别名为req.header(field)。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查给定的types是不是可以接受的，当结果为true时返回最佳匹配，否则返回undefined，在这种情况下你应该返回406”Not Acceptable”。&lt;/p&gt;

&lt;p&gt;type可以是单一的mine类型的字符串，比如”application/json”，扩展名如”json”，也可以是以逗号分隔的列表或者数组。当为列表或数组时将返回最佳匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Accept: text/html
req.accepts('html');
// =&amp;gt; &quot;html&quot;

// Accept: text/*, application/json
req.accepts('html');
// =&amp;gt; &quot;html&quot;
req.accepts('text/html');
// =&amp;gt; &quot;text/html&quot;
req.accepts('json, text');
// =&amp;gt; &quot;json&quot;
req.accepts('application/json');
// =&amp;gt; &quot;application/json&quot;

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// =&amp;gt; undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
req.accepts('html, json');
// =&amp;gt; &quot;json&quot; 如有任何问题或者疑问，请参阅accepts附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqacceptscharsetcharset&quot;&gt;req.acceptsCharset(charset)&lt;/h3&gt;

&lt;p&gt;检查给定的字符集是否可以支持。
如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqacceptslanguagelang&quot;&gt;req.acceptsLanguage(lang)&lt;/h3&gt;

&lt;p&gt;检查给定的lang是否支持。
如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqistype&quot;&gt;req.is(type)&lt;/h3&gt;

&lt;p&gt;检查传入请求字符串是否包含了”Content-Type”头字段，并且给出匹配的mine类型。
	// With Content-Type: text/html; charset=utf-8
	req.is(‘html’);
	req.is(‘text/html’);
	req.is(‘text/*’);
	// =&amp;gt; true&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// =&amp;gt; true

req.is('html');
// =&amp;gt; false 如有任何问题或者疑问，请参阅type-is附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqip&quot;&gt;req.ip&lt;/h3&gt;
&lt;p&gt;返回远程地址，或者当信任代理已启用时返回代理地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.ip
// =&amp;gt; &quot;127.0.0.1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqips&quot;&gt;req.ips&lt;/h3&gt;

&lt;p&gt;当信任代理为true时，解析”X-Forwarded-For”ip地址列表返回一个数组，否则返回一个空数组。
例如当值为”client, proxy1, proxy2”时你会获得[“client”, “proxy1”, “proxy2”]数组，其中”proxy2”是最远的下游地址。&lt;/p&gt;

&lt;h3 id=&quot;reqpath&quot;&gt;req.path&lt;/h3&gt;
&lt;p&gt;返回请求的URL路径名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// example.com/users?sort=desc
req.path
// =&amp;gt; &quot;/users&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqfresh&quot;&gt;req.fresh&lt;/h3&gt;
&lt;p&gt;检查请求是否刷新，通过对Last-Modified和/或ETag进行匹配，表明资源是不是最新的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.fresh
// =&amp;gt; true 如有任何问题或者疑问，请参阅fresh附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqstale&quot;&gt;req.stale&lt;/h3&gt;
&lt;p&gt;检查请求是否过期，如果Last-Modified和/或ETag不匹配，表有资源是过期的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.stale
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqxhr&quot;&gt;req.xhr&lt;/h3&gt;
&lt;p&gt;检查请求头里是否包含”X-Requested-With”字段并且值为”XMLHttpRequest”(jQuery等)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.xhr
// =&amp;gt; true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqprotocol&quot;&gt;req.protocol&lt;/h3&gt;
&lt;p&gt;当使用TLS请求时返回”http”或”https”协议字符串。当信任路由设置为开启时”X-Forwarded-Proto”头字段将被信任。
如果你正在运行一个支持https协议的反向代理，那么这个是支持的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.protocol
// =&amp;gt; &quot;http&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqsecure&quot;&gt;req.secure&lt;/h3&gt;
&lt;p&gt;检查TLS连接是否建立。这是一个简写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'https' == req.protocol;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqsubdomains&quot;&gt;req.subdomains&lt;/h3&gt;
&lt;p&gt;返回子域数组。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Host: &quot;tobi.ferrets.example.com&quot;
req.subdomains
// =&amp;gt; [&quot;ferrets&quot;, &quot;tobi&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqoriginalurl&quot;&gt;req.originalUrl&lt;/h3&gt;
&lt;p&gt;此属性很像req.url，但它保留了原始请求的url，允许你在做内部路由时自由重写req.url。
例如app.use()中间件将重写req.url重新定义挂载点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /search?q=something
req.originalUrl
// =&amp;gt; &quot;/search?q=something&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四response&quot;&gt;四、Response&lt;/h2&gt;

&lt;h3 id=&quot;resstatuscode&quot;&gt;res.status(code)&lt;/h3&gt;
&lt;p&gt;res.statusCode=可链接节点的别名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.status(404).sendfile('path/to/404.png');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ressetfield-value&quot;&gt;res.set(field, [value])&lt;/h3&gt;
&lt;p&gt;设置响应头内字段值，或者通过一个对象一次设置多个字段。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.set('Content-Type', 'text/plain');
res.set({
	 'Content-Type': 'text/plain',
	 'Content-Length': '123',
	 'ETag': '12345'
}) res.header(field, [value])别名。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resgetfield&quot;&gt;res.get(field)&lt;/h3&gt;
&lt;p&gt;获取响应头内字段值，不区分大小写。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	res.get('Content-Type');
	// =&amp;gt; &quot;text/plain&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rescookiename-value-options&quot;&gt;res.cookie(name, value, [options])&lt;/h3&gt;
&lt;p&gt;设置cookie名称和值，可以是字符串或者对象转换成的JSON。路径选项默认为”/”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
	res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;maxAge选项可以很方便的设置从当前时间开始以毫秒为单位的过期时间。下面的写法等同于上一个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个对象可以通过序列化成JSON传递，它由bodyParser()中间件自动解析。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 }); 这种方法也支持签名cookie。添加一个简单的signed选项。 res.cookie()将隐藏传递给cookieParser(secret)对值签名。

res.cookie('name', 'tobi', { signed: true });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后你可以使用req.signedCookie来访问这个值。&lt;/p&gt;

&lt;h3 id=&quot;resclearcookiename-options&quot;&gt;res.clearCookie(name, [options])&lt;/h3&gt;
&lt;p&gt;删除cookie里面值。默认路径为”/”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resredirectstatus-url&quot;&gt;res.redirect([status], url)&lt;/h3&gt;
&lt;p&gt;重定向到给定的url，可选状态编码默认为302”Found”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Express支持几种形式的重定向，首先一个完整合格的URI重定向到不同的域名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('http://google.com');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第二种形式是相对路径的重定向，例如你正在http://example.com/admin/post/new，
接着重定向到/admin，你将会登录http://example.com/admin：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('/admin');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reslocation&quot;&gt;res.location&lt;/h3&gt;
&lt;p&gt;设置位置头&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.location('/foo/bar');
res.location('foo/bar');
res.location('http://example.com');
res.location('../login');
res.location('back'); 你可以使用res.redirect()相同的urls。 例如你的应用挂载在/blog下，使用下面的代码设置location头为/blog/admin：

res.location('admin')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rescharset&quot;&gt;res.charset&lt;/h3&gt;
&lt;p&gt;分配字符集。默认的为“utf-8”.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.charset = 'value';
res.send('&amp;lt;p&amp;gt;some html&amp;lt;/p&amp;gt;');
// =&amp;gt; Content-Type: text/html; charset=value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ressendbodystatus-body&quot;&gt;res.send([body|status], [body])&lt;/h3&gt;
&lt;p&gt;发送一个响应&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('&amp;lt;p&amp;gt;some html&amp;lt;/p&amp;gt;');
res.send(404, 'Sorry, we cannot find that!');
res.send(500, { error: 'something blew up' });
res.send(200);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此方法适用于执行大量的简单非流式的响应任务，例如在未提前定义和提供自动HEAD和HTTP缓存刷新支持的情况下自动设定Content-Length。 &lt;br /&gt;
当传入的内容为Buffer，那么Content-Type会被设置为”application/octet-stream”，除非预先定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.set('Content-Type', 'text/html');
res.send(new Buffer('&amp;lt;p&amp;gt;some html&amp;lt;/p&amp;gt;')); 当发送字符串时Content-Type设置默认为&quot;text/html&quot;：

res.send('&amp;lt;p&amp;gt;some html&amp;lt;/p&amp;gt;'); 当发送数组或者对象时Express将会转换成JSON格式：

res.send({ user: 'tobi' })
res.send([1,2,3])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后如果返回的是一个数字，没有前面提到的任何一个响应体，Express会为你设置一个响应字符串。例如200将会响应文本”OK”，400响应”Not Found”等等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.send(200)
res.send(404)
res.send(500)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resjsonstatusbody-body&quot;&gt;res.json([status|body], [body])&lt;/h3&gt;
&lt;p&gt;发送一个JSON响应，当返回对象或者数组时该方法与res.send()相同，然而它可以用来将非对象(null, undefined, 等等)转换成精准的JSON，尽管严格来说这些并不是有效的JSON。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' })
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resjsonpstatusbody-body&quot;&gt;res.jsonp([status|body], [body])&lt;/h3&gt;
&lt;p&gt;使用JSONP发送JSON响应。该方法与res.json()相同，但多了对JSONP回调的支持。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.jsonp(null)
// =&amp;gt; null
	
res.jsonp({ user: 'tobi' })
// =&amp;gt; { &quot;user&quot;: &quot;tobi&quot; }
	
res.jsonp(500, { error: 'message' })
// =&amp;gt; { &quot;error&quot;: &quot;message&quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认JSONP回调函数名是callback，但你可以通过修改jsonp callback name参数重新定义。以下是JSONP响应的一些例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ?callback=foo
res.jsonp({ user: 'tobi' })
// =&amp;gt; foo({ &quot;user&quot;: &quot;tobi&quot; })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.jsonp(500, { error: 'message' })
// =&amp;gt; foo({ &quot;error&quot;: &quot;message&quot; })
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;restypetype&quot;&gt;res.type(type)&lt;/h3&gt;
&lt;p&gt;设置Content-Type类型为mime查找的类型，或者当”/”存在时Content-Type被简单的设置成该类型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.type('.html');
res.type('html');
res.type('json');
res.type('application/json');
res.type('png');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resformatobject&quot;&gt;res.format(object)&lt;/h3&gt;
&lt;p&gt;执行请求时存在请求Accept头上下文转换。该方法使用req.accepted，这是一个按可接受类型重要性排序的数组，否则第一个回调函数被调用。当没有匹配的回调函数执行时服务器返回406 “Not Acceptable”，或者调用默认的回调函数。&lt;/p&gt;

&lt;p&gt;设置Content-Type为你选择一个回调函数，但你可以在回调函数中使用res.set()或者res.type()等修改。&lt;/p&gt;

&lt;p&gt;下例当Accept头字段设置成”application/json”或”/json”时响应{ “message”: “hey” }，但如果设置成”/*“时将会响应”hey”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.format({
  'text/plain': function(){
    res.send('hey');
  },

  'text/html': function(){
    res.send('&amp;lt;p&amp;gt;hey&amp;lt;/p&amp;gt;');
  },

  'application/json': function(){
    res.send({ message: 'hey' });
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了规范化的MIME类型你还可以使用扩展名映射这些类型，提供一个冗长实施：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.format({
  text: function(){
    res.send('hey');
  },

  html: function(){
    res.send('&amp;lt;p&amp;gt;hey&amp;lt;/p&amp;gt;');
  },

  json: function(){
    res.send({ message: 'hey' });
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resattachmentfilename&quot;&gt;res.attachment([filename])&lt;/h3&gt;
&lt;p&gt;设置Content——disposition头字段为“attachment”。如果给定一个文件名，那么Content-Type将会通过res.type()自动设置成基于扩展名的类型，Content-Disposition的”filename=”参数同时也被设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.attachment();  
// Content-Disposition: attachment
		
res.attachment('path/to/logo.png');  
// Content-Disposition: attachment;   filename=&quot;logo.png&quot;  
// Content-Type: image/png
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ressendfilepath-options-fn&quot;&gt;res.sendfile(path, [options], [fn])&lt;/h3&gt;
&lt;p&gt;传输文件到给定的路径。&lt;br /&gt;
自动设置默认基于文件扩展名的Content-Type响应头。当传输发生错误时fn(err)回调函数被调用。&lt;br /&gt;
选项：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;maxAge 以毫秒为单位默认为0&lt;/li&gt;
    &lt;li&gt;root 相对文件名根目录&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;在下例中该方法为文件服务提供细粒度支持：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		app.get('/user/:uid/photos/:file', function(req, res){
		  var uid = req.params.uid
		    , file = req.params.file;
		
		  req.user.mayViewFilesFrom(uid, function(yes){
		    if (yes) {
		      res.sendfile('/uploads/' + uid + '/' + file);
		    } else {
		      res.send(403, 'Sorry! you cant see that.');
		    }
		  });
		});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resdownloadpath-filename-fn&quot;&gt;res.download(path, [filename], [fn])&lt;/h3&gt;
&lt;p&gt;传输路径中的文件作为附件，通常浏览器会提醒用户下载。Content-Disposition “filename=”参数，也就是显示在浏览器对话框的默认文件名，你也可以提供一个自定义文件名。&lt;/p&gt;

&lt;p&gt;当传输完成或者中途发生错误时将会调用fn回调函数，该方法使用res.sendfile()来传输文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	res.download('/report-12345.pdf');
	
	res.download('/report-12345.pdf', 'report.pdf');
	
	res.download('/report-12345.pdf', 'report.pdf', function(err){
	  if (err) {
	    // handle error, keep in mind the response may be partially-sent
	    // so check res.headersSent
	  } else {
	    // decrement a download credit etc
	  }
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reslinkslinks&quot;&gt;res.links(links)&lt;/h3&gt;
&lt;p&gt;加入给定的链接来填充”Link”响应头字段。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	res.links({
	  next: 'http://api.example.com/users?page=2',
	  last: 'http://api.example.com/users?page=5'
	}); 处理后  

	Link: &amp;amp;lt;http://api.example.com/users?page=2&amp;amp;gt;; rel=&quot;next&quot;, 
	      &amp;amp;lt;http://api.example.com/users?page=5&amp;amp;gt;; rel=&quot;last&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reslocals&quot;&gt;res.locals&lt;/h3&gt;
&lt;p&gt;响应本地化变量作用域为request，因此只适用于在该request/response周期内呈现的视图，如果有的话。其实该API跟app.locals是等同的。&lt;br /&gt;
这个对象适用于的request级别的信息，例如request路径，用户认证，用户设置等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	app.use(function(req, res, next){
	  res.locals.user = req.user;
	  res.locals.authenticated = ! req.user.anonymous;
	  next();
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;resrenderview-locals-callback&quot;&gt;res.render(view, [locals], callback)&lt;/h3&gt;
&lt;p&gt;渲染一个视图，同时向回调函数传递渲染后的字符串。发生错误时内部调用next(err)。回调函数传入可能发生的错误以及渲染后的页面，这样就不会自动执行响应了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	res.render('index', function(err, html){
	  // ...
	});
	
	res.render('user', { name: 'Tobi' }, function(err, html){
	  // ...
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五middleware&quot;&gt;五、Middleware&lt;/h2&gt;

&lt;h3 id=&quot;basicauth&quot;&gt;basicAuth()&lt;/h3&gt;
&lt;p&gt;基本身份验证的中间件，在req.user里添加用户名&lt;br /&gt;
用户名字和密码的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.basicAuth('username', 'password'));   校验回调： 
 
app.use(express.basicAuth(function(user, pass){
	 return 'tj' == user &amp;amp;&amp;amp; 'wahoo' == pass;
}));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;异步校验接受参数fn(err, user), 下面的例子req.user 将会作为user对象传递.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(connect.basicAuth(function(user, pass, fn){
	 User.authenticate({ user: user, pass: pass }, fn);
}))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;bodyparser&quot;&gt;bodyParser()&lt;/h3&gt;
&lt;p&gt;支持 JSON, urlencoded和multipart requests的请求体解析中间件。 这个中间件是json(), urlencoded(),和multipart() 这几个中间件的简单封装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.bodyParser());
// 等同于:
app.use(express.json());
app.use(express.urlencoded());
app.use(express.multipart());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从安全上考虑，如果你的应用程序不需要文件上传功能，最好关闭它。我们只使用我们需要的中间件。例如：我们不使用bodyParser、multipart() 这两个中间件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.json());
app.use(express.urlencoded());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;compress&quot;&gt;compress()&lt;/h3&gt;
&lt;p&gt;通过gzip / deflate压缩响应数据. 这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.logger());
app.use(express.compress());
app.use(express.methodOverride());
app.use(express.bodyParser());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cookieparser&quot;&gt;cookieParser()&lt;/h3&gt;
&lt;p&gt;解析请求头里的Cookie, 并用cookie名字的键值对形式放在 req.cookies 你也可以通过传递一个secret 字符串激活签名了的cookie&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.cookieParser());
app.use(express.cookieParser('some secret'));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cookiesession&quot;&gt;cookieSession()&lt;/h3&gt;
&lt;p&gt;提供一个以cookie为基础的sessions, 设置在req.session里。 这个中间件有以下几个&lt;br /&gt;
选项:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;key cookie 的名字，默认是 connect.sess&lt;/li&gt;
    &lt;li&gt;secret 防止篡改&lt;/li&gt;
    &lt;li&gt;cookie session cookie 设置, 默认是 { path: ‘/’, httpOnly: true, maxAge: null }&lt;/li&gt;
    &lt;li&gt;proxy 当设置安全cookies时信任反向代理 (通过 “x-forwarded-proto”)&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.cookieSession()); 清掉一个cookie, 只需要在响应前把null赋值给session:

req.session = null
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;csrf&quot;&gt;csrf()&lt;/h3&gt;
&lt;p&gt;CSRF防护中间件&lt;br /&gt;
默认情况下这个中间件会产生一个名为”_csrf”的标志，这个标志应该添加到那些需要服务器更改的请求里，可以放在一个表单的隐藏域，请求参数等。这个标志可以通过 req.csrfToken()方法进行校验。&lt;/p&gt;

&lt;p&gt;bodyParser() 中间件产生的 req.body , query()产生的req.query,请求头里的”X-CSRF-Token”是默认的 value 函数检查的项&lt;/p&gt;

&lt;p&gt;这个中间件需要session支持，因此它的代码应该放在session()之后.&lt;/p&gt;

&lt;h3 id=&quot;directory&quot;&gt;directory()&lt;/h3&gt;
&lt;p&gt;文件夹服务中间件，用 path 提供服务。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.directory('public'))
app.use(express.static('public'))
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个中间件接收如下参数：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;hidden 显示隐藏文件，默认是false&lt;/li&gt;
    &lt;li&gt;icon 显示图标，默认值是false&lt;/li&gt;
    &lt;li&gt;filter 在文件上应用这些过滤函数，默认值是false&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

</content>
 </entry>
 
 <entry>
   <title>为express设置代理</title>
   <link href="http://www.blogways.net/blog/2015/10/24/express-behind-proxies.html"/>
   <updated>2015-10-24T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/24/express-behind-proxies</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://expressjs.com/en/guide/behind-proxies.html&quot;&gt;http://expressjs.com/en/guide/behind-proxies.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;当在代理服务器之后运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;Express&lt;/code&gt; 时，请将应用变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;trust proxy&lt;/code&gt; 设置（使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;app.set()&lt;/code&gt;）为下述序列中的一项。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;如果没有设置应用变量 &lt;code class=&quot;highlighter-rouge&quot;&gt;trust proxy&lt;/code&gt;，应用将不会运行，除非 &lt;code class=&quot;highlighter-rouge&quot;&gt;trust proxy&lt;/code&gt; 设置正确，否则应用会误将代理服务器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt; 地址注册为客户端 &lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt; 地址.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1boolean&quot;&gt;1、Boolean&lt;/h2&gt;
&lt;p&gt;如果为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，客户端 &lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt; 地址为 &lt;code class=&quot;highlighter-rouge&quot;&gt;X-Forwarded-*&lt;/code&gt; 头最左边的项。&lt;br /&gt;
如果为 &lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;, 应用直接面向互联网，客户端 &lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt; 地址从 &lt;code class=&quot;highlighter-rouge&quot;&gt;req.connection.remoteAddress&lt;/code&gt; 得来，这是默认的设置。&lt;/p&gt;

&lt;h2 id=&quot;2ip-地址&quot;&gt;2、IP 地址&lt;/h2&gt;
&lt;p&gt;IP 地址、子网或 &lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt; 地址数组和可信的子网。下面是预配置的子网列表。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;loopback - 127.0.0.1/8, ::1/128&lt;/li&gt;
    &lt;li&gt;linklocal - 169.254.0.0/16, fe80::/10&lt;/li&gt;
    &lt;li&gt;uniquelocal - 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, fc00::/7&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用如下方式设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;IP&lt;/code&gt; 地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('trust proxy', 'loopback') // 指定唯一子网
app.set('trust proxy', 'loopback, 123.123.123.123') // 指定子网和 IP 地址
app.set('trust proxy', 'loopback, linklocal, uniquelocal') // 指定多个子网
app.set('trust proxy', ['loopback', 'linklocal', 'uniquelocal']) // 使用数组指定多个子网 当指定地址时，`IP` 地址或子网从地址确定过程中被除去，离应用服务器最近的非受信 `IP` 地址被当作客户端 `IP` 地址。  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;3number&quot;&gt;3、Number&lt;/h2&gt;
&lt;p&gt;将代理服务器前第 n 跳当作客户端。&lt;/p&gt;

&lt;h2 id=&quot;4function&quot;&gt;4、Function&lt;/h2&gt;
&lt;p&gt;定制实现，只有在您知道自己在干什么时才能这样做。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('trust proxy', function (ip) {
  if (ip === '127.0.0.1' || ip === '123.123.123.123') return true; // 受信的 IP 地址
  else return false;
}) 以上就是 `trust proxy` 设置项  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;trust proxy&lt;/code&gt; 为非假值会带来三个重要变化：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;反向代理可能设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;X-Forwarded-Proto&lt;/code&gt; 来告诉应用使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;https&lt;/code&gt; 或简单的 &lt;code class=&quot;highlighter-rouge&quot;&gt;http&lt;/code&gt; 协议。请参考 &lt;code class=&quot;highlighter-rouge&quot;&gt;req.protocol&lt;/code&gt;。&lt;/li&gt;
    &lt;li&gt;无论是 &lt;code class=&quot;highlighter-rouge&quot;&gt;HTTP&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;HTTPS&lt;/code&gt; 或者是无效的名称，都可以通过反向代理来设置 &lt;code class=&quot;highlighter-rouge&quot;&gt;X-Forwarded-For&lt;/code&gt; 通知应用程序。这个值是通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;req.protocol&lt;/code&gt; 来反应的。&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;req.ip&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;req.ips&lt;/code&gt; 的值将会由 &lt;code class=&quot;highlighter-rouge&quot;&gt;X-Forwarded-For&lt;/code&gt; 中列出的 IP 地址构成。&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trust proxy&lt;/code&gt; 设置由 &lt;code class=&quot;highlighter-rouge&quot;&gt;proxy-addr&lt;/code&gt; 软件包实现，请参考其文档了解更多信息。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x-模板引擎</title>
   <link href="http://www.blogways.net/blog/2015/10/18/express-using-template-engines.html"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/18/express-using-template-engines</id>
   <content type="html">&lt;p&gt;原文：
&lt;a href=&quot;http://expressjs.com/guide/using-template-engines.html&quot;&gt;http://expressjs.com/guide/using-template-engines.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;在-express-中使用模板引擎&quot;&gt;在 Express 中使用模板引擎&lt;/h1&gt;

&lt;p&gt;需要在应用中进行如下设置才能让 Express 渲染模板文件：&lt;/p&gt;

&lt;p&gt;·views, 放模板文件的目录，比如： app.set(‘views’, ‘./views’)&lt;/p&gt;

&lt;p&gt;·view engine, 模板引擎，比如： app.set(‘view engine’, ‘jade’)
然后安装相应的模板引擎 npm 软件包。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install jade --save 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;和 Express 兼容的模板引擎，比如 Jade，通过 res.render() 调用其导出方法__express(filePath,options, callback) 渲染模板。有一些模板引擎不遵循这种约Consolidate.js 能将 Node 中所有流行的模板引擎映射为这种约定，这样就可以和 Express 无缝衔接。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一旦 view engine 设置成功，就不需要显式指定引擎，或者在应用中加载模板引擎模块，Express 已经在内部加载，如下所示。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('view engine', 'jade'); 在 views 目录下生成名为 index.jade 的 Jade 模板文件，内容如下：

html
  head
    title!= title
  body
    h1!= message 然后创建一个路由渲染 index.jade 文件。如果没有设置 view engine，您需要指明视图文件的后缀，否则就会遗漏它。

app.get('/', function (req, res) {
  res.render('index', { title: 'Hey', message: 'Hello there!'});
}); 此时向主页发送请求，“index.jade” 会被渲染为 HTML。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;请阅读 “为 Express 开发模板引擎” 了解模板引擎在 Express 中是如何工作的。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x-中间件</title>
   <link href="http://www.blogways.net/blog/2015/10/18/express-using-middlewar.html"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/18/express-using-middlewar</id>
   <content type="html">&lt;p&gt;原文 &lt;a href=&quot;http://expressjs.com/guide/using-middleware.html&quot;&gt;http://expressjs.com/guide/using-middleware.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;使用中间件&quot;&gt;使用中间件&lt;/h1&gt;

&lt;p&gt;Express 是一个自身功能极简，完全是由路由和中间件构成一个的 web 开发框架：从本质上来说，一个 Express 应用就是在调用各种中间件。&lt;/p&gt;

&lt;p&gt;中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。&lt;/p&gt;

&lt;p&gt;中间件的功能包括：&lt;/p&gt;

&lt;p&gt;·执行任何代码。&lt;/p&gt;

&lt;p&gt;·修改请求和响应对象。&lt;/p&gt;

&lt;p&gt;·终结请求-响应循环。&lt;/p&gt;

&lt;p&gt;·调用堆栈中的下一个中间件。&lt;/p&gt;

&lt;p&gt;如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则      请求就会挂起。&lt;/p&gt;

&lt;p&gt;Express 应用可使用如下几种中间件：&lt;/p&gt;

&lt;p&gt;·应用级中间件&lt;/p&gt;

&lt;p&gt;·路由级中间件&lt;/p&gt;

&lt;p&gt;·错误处理中间件&lt;/p&gt;

&lt;p&gt;·内置中间件&lt;/p&gt;

&lt;p&gt;·第三方中间件&lt;/p&gt;

&lt;p&gt;使用可选则挂载路径，可在应用级别或路由级别装载中间件。另外，你还可以同时装在一系列中间件函数，从而在一个挂载点上创建一个子中间件栈。&lt;/p&gt;

&lt;h1 id=&quot;应用级中间件&quot;&gt;应用级中间件&lt;/h1&gt;
&lt;p&gt;应用级中间件绑定到 app 对象 使用 app.use() 和 app.METHOD()， 其中， METHOD 是需要处理的 HTTP 请求的方法，例如 GET, PUT, POST 等等，全部小写。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = express();

// 没有挂载路径的中间件，应用的每个请求都会执行该中间件
app.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});

// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它
app.use('/user/:id', function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});

// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求
app.get('/user/:id', function (req, res, next) {
  res.send('USER');
}); 下面这个例子展示了在一个挂载点装载一组中间件。

// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息
app.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}, function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
}); 作为中间件系统的路由句柄，使得为路径定义多个路由成为可能。在下面的例子中，为指向 /user/:id 的 GET 请求定义了两个路由。第二个路由虽然不会带来任何问题，但却永远不会被调用，因为第一个路由已经终止了请求-响应循环。

// 一个中间件栈，处理指向 /user/:id 的 GET 请求
app.get('/user/:id', function (req, res, next) {
  console.log('ID:', req.params.id);
  next();
}, function (req, res, next) {
  res.send('User Info');
});

// 处理 /user/:id， 打印出用户 id
app.get('/user/:id', function (req, res, next) {
  res.end(req.params.id);
}); 如果需要在中间件栈中跳过剩余中间件，调用 next('route') 方法将控制权交给下一个路由。 注意： next('route') 只对使用 app.VERB() 或 router.VERB() 加载的中间件有效。

// 一个中间件栈，处理指向 /user/:id 的 GET 请求
app.get('/user/:id', function (req, res, next) {
  // 如果 user id 为 0, 跳到下一个路由
  if (req.params.id == 0) next('route');
  // 否则将控制权交给栈中下一个中间件
  else next(); //
}, function (req, res, next) {
  // 渲染常规页面
  res.render('regular');
});

// 处理 /user/:id， 渲染一个特殊页面
app.get('/user/:id', function (req, res, next) {
  res.render('special');
}); # 路由级中间件 路由级中间件和应用级中间件一样，只是它绑定的对象为  express.Router()。

var router = express.Router(); 路由级使用 router.use() 或 router.VERB() 加载。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述在应用级创建的中间件系统，可通过如下代码改写为路由级：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = express();
var router = express.Router();

// 没有挂载路径的中间件，通过该路由的每个请求都会执行该中间件
router.use(function (req, res, next) {
  console.log('Time:', Date.now());
  next();
});

// 一个中间件栈，显示任何指向 /user/:id 的 HTTP 请求的信息
router.use('/user/:id', function(req, res, next) {
  console.log('Request URL:', req.originalUrl);
  next();
}, function (req, res, next) {
  console.log('Request Type:', req.method);
  next();
});

// 一个中间件栈，处理指向 /user/:id 的 GET 请求
router.get('/user/:id', function (req, res, next) {
  // 如果 user id 为 0, 跳到下一个路由
  if (req.params.id == 0) next('route');
  // 负责将控制权交给栈中下一个中间件
  else next(); //
}, function (req, res, next) {
  // 渲染常规页面
  res.render('regular');
});

// 处理 /user/:id， 渲染一个特殊页面
router.get('/user/:id', function (req, res, next) {
  console.log(req.params.id);
  res.render('special');
});

// 将路由挂载至应用
app.use('/', router); # 错误处理中间件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;错误处理中间件有 4 个参数，定义错误处理中间件时必须使用这 4 个参数。即使不需要 next 对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;错误处理中间件和其他中间件定义类似，只是要使用 4 个参数，而不是 3 个，其签名如下： (err, req, res, next)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
}); 请参考 错误处理 一章了解更多关于错误处理中间件的内容。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;内置中间件&quot;&gt;内置中间件&lt;/h1&gt;
&lt;p&gt;从 4.x 版本开始，, Express 已经不再依赖 Connect 了。除了 express.static, Express 以前内置的中间件现在已经全部单独作为模块安装使用了。请参考 中间件列表。&lt;/p&gt;

&lt;h4 id=&quot;expressstaticroot-options&quot;&gt;express.static(root, [options])&lt;/h4&gt;

&lt;p&gt;express.static 是 Express 唯一内置的中间件。它基于 serve-static，负责在 Express 应用中提托管静态资源。&lt;/p&gt;

&lt;p&gt;参数 root 指提供静态资源的根目录。&lt;/p&gt;

&lt;p&gt;可选的 options 参数拥有如下属性。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
      &lt;th&gt;类型&lt;/th&gt;
      &lt;th&gt;缺省值&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;dotfiles&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;是否对外输出文件名以点（&lt;code&gt;.&lt;/code&gt;）开头的文件。可选值为 “allow”、“deny” 和 “ignore”&lt;/td&gt;
      &lt;td&gt;String&lt;/td&gt;
      &lt;td&gt;“ignore”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;etag&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;是否启用 etag 生成&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;extensions&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置文件扩展名备份选项&lt;/td&gt;
      &lt;td&gt;Array&lt;/td&gt;
      &lt;td&gt;[]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;index&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;发送目录索引文件，设置为 false 禁用目录索引。&lt;/td&gt;
      &lt;td&gt;Mixed&lt;/td&gt;
      &lt;td&gt;“index.html”&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;lastModified&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置 Last-Modified 头为文件在操作系统上的最后修改日期。可能值为 true 或 false。&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;maxAge&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;以毫秒或者其字符串格式&amp;lt;/a&amp;gt;设置 Cache-Control 头的 max-age 属性。&lt;/td&gt;
      &lt;td&gt;Number&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;redirect&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;当路径为目录时，重定向至 “/”。&lt;/td&gt;
      &lt;td&gt;Boolean&lt;/td&gt;
      &lt;td&gt;true&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code&gt;setHeaders&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;设置 HTTP 头以提供文件的函数。&lt;/td&gt;
      &lt;td&gt;Function&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;下面的例子使用了 express.static 中间件，其中的 options 对象经过了精心的设计。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var options = {
  dotfiles: 'ignore',
  etag: false,
  extensions: ['htm', 'html'],
  index: false,
  maxAge: '1d',
  redirect: false,
  setHeaders: function (res, path, stat) {
    res.set('x-timestamp', Date.now());
  }
}

app.use(express.static('public', options)); 每个应用可有多个静态目录。

app.use(express.static('public'));
app.use(express.static('uploads'));
app.use(express.static('files')); 更多关于 serve-static 和其参数的信息，请参考 serve-static 文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第三方中间件
通过使用第三方中间件从而为 Express 应用增加更多功能。&lt;/p&gt;

&lt;p&gt;安装所需功能的 node 模块，并在应用中加载，可以在应用级加载，也可以在路由级加载。&lt;/p&gt;

&lt;p&gt;下面的例子安装并加载了一个解析 cookie 的中间件： cookie-parser&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install cookie-parser
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;····&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var app = express();
var cookieParser = require('cookie-parser');

// 加载用于解析 cookie 的中间件
app.use(cookieParser()); 请参考 第三方中间件 获取 Express 中经常用到的第三方中间件列表。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x-路由</title>
   <link href="http://www.blogways.net/blog/2015/10/18/express-routing.html"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/18/express-routing</id>
   <content type="html">&lt;p&gt;原文:
 &lt;a href=&quot;http://expressjs.com/guide/routing.html&quot;&gt;http://expressjs.com/guide/routing.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;路由&quot;&gt;路由&lt;/h1&gt;

&lt;p&gt;路由是指如何定义应用的端点（URIs）以及如何响应客户端的请求。&lt;/p&gt;

&lt;p&gt;路由是由一个 URI、HTTP 请求（GET、POST等）和若干个句柄组成，它的结构如下： app.METHOD(path, [callback…], callback)， app 是 express 对象的一个实例， METHOD 是一个 HTTP 请求方法， path 是服务器上的路径， callback 是当路由匹配时要执行的函数。&lt;/p&gt;

&lt;p&gt;下面是一个基本的路由示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var app = express();

// respond with &quot;hello world&quot; when a GET request is made to the homepage
app.get('/', function(req, res) {
  res.send('hello world');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;路由方法&quot;&gt;路由方法&lt;/h1&gt;

&lt;p&gt;路由方法源于 HTTP 请求方法，和 express 实例相关联。&lt;/p&gt;

&lt;p&gt;下面这个例子展示了为应用跟路径定义的 GET 和 POST 请求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET method route
app.get('/', function (req, res) {
  res.send('GET request to the homepage');
});

// POST method route
app.post('/', function (req, res) {
  res.send('POST request to the homepage');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Express 定义了如下和 HTTP 请求对应的路由方法： get, post, put, head, delete, options, trace, copy, lock, mkcol, move, purge, propfind, proppatch, unlock, report, mkactivity, checkout, merge, m-search, notify, subscribe, unsubscribe, patch, search, 和 connect。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;有些路由方法名不是合规的 JavaScript 变量名，此时使用括号记法，比如： app[‘m-search’](‘/’, function …&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;app.all() 是一个特殊的路由方法，没有任何 HTTP 方法与其对应，它的作用是对于一个路径上的所有请求加载中间件。&lt;/p&gt;

&lt;p&gt;在下面的例子中，来自 “/secret” 的请求，不管使用 GET、POST、PUT、DELETE 或其他任何 http 模块支持的 HTTP 请求，句柄都会得到执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all('/secret', function (req, res, next) {
  console.log('Accessing the secret section ...');
  next(); // pass control to the next handler
});	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;路由路径&quot;&gt;路由路径&lt;/h1&gt;
&lt;p&gt;路由路径和请求方法一起定义了请求的端点，它可以是字符串、字符串模式或者正则表达式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Express 使用 path-to-regexp 匹配路由路径，请参考文档查阅所有定义路由路径的方法。 Express Route Tester 是测试基本 Express 路径的好工具，但不支持模式匹配.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;查询字符串不是路由路径的一部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用字符串的路由路径示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 匹配根路径的请求
app.get('/', function (req, res) {
  res.send('root');
});

// 匹配 /about 路径的请求
app.get('/about', function (req, res) {
  res.send('about');
});

// 匹配 /random.text 路径的请求
app.get('/random.text', function (req, res) {
  res.send('random.text');
}); 使用字符串模式的路由路径示例：

// 匹配 acd 和 abcd
app.get('/ab?cd', function(req, res) {
  res.send('ab?cd');
});

// 匹配 abcd、abbcd、abbbcd等
app.get('/ab+cd', function(req, res) {
  res.send('ab+cd');
});

// 匹配 abcd、abxcd、abRABDOMcd、ab123cd等
app.get('/ab*cd', function(req, res) {
  res.send('ab*cd');
});

// 匹配 /abe 和 /abcde
app.get('/ab(cd)?e', function(req, res) {
 res.send('ab(cd)?e');
});	 ···
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符 ?、+、* 和 () 是正则表达式的子集，- 和 . 在基于字符串的路径中按照字面值解释。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用正则表达式的路由路径示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	// 匹配任何路径中含有 a 的路径：
app.get(/a/, function(req, res) {
  res.send('/a/');
});

// 匹配 butterfly、dragonfly，不匹配 butterflyman、dragonfly man等
app.get(/.*fly$/, function(req, res) {
  res.send('/.*fly$/');
}); #路由句柄 可以为请求处理提供多个回调函数，其行为类似 中间件。唯一的区别是这些回调函数有可能调用 next('route') 方法而略过其他路由回调函数。可以利用该机制为路由定义前提条件，如果在现有路径上继续执行没有意义，则可将控制权交给剩下的路径。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;路由句柄有多种形式，可以是一个函数、一个函数数组，或者是两者混合，如下所示.&lt;/p&gt;

&lt;p&gt;使用一个回调函数处理路由：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/example/a', function (req, res) {
  res.send('Hello from A!');
}); 使用多个回调函数处理路由（记得指定 next 对象）：

app.get('/example/b', function (req, res, next) {
  console.log('response will be sent by the next function ...');
  next();
}, function (req, res) {
  res.send('Hello from B!');
}); 使用回调函数数组处理路由：

var cb0 = function (req, res, next) {
  console.log('CB0');
  next();
}

var cb1 = function (req, res, next) {
  console.log('CB1');
  next();
}

var cb2 = function (req, res) {
  res.send('Hello from C!');
}

app.get('/example/c', [cb0, cb1, cb2]); 混合使用函数和函数数组处理路由：

var cb0 = function (req, res, next) {
  console.log('CB0');
  next();
}

var cb1 = function (req, res, next) {
  console.log('CB1');
  next();
}

app.get('/example/d', [cb0, cb1], function (req, res, next) {
  console.log('response will be sent by the next function ...');
  next();
}, function (req, res) {
  res.send('Hello from D!');
}); #响应方法 下表中响应对象（res）的方法向客户端返回响应，终结请求响应的循环。如果在路由句柄中一个方法也不调用，来自客户端的请求会一直挂起。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;方法&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;res.download&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;提示下载文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.end&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;终结响应处理流程。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.json&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;发送一个 JSON 格式的响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.jsonp&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;发送一个支持 JSONP 的 JSON 格式的响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.redirect&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;重定向请求。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.render&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;渲染视图模板。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.send&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;发送各种类型的响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.sendFile&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;以八位字节流的形式发送文件。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;res.sendStatus&amp;lt;/a&amp;gt;&lt;/td&gt;
      &lt;td&gt;设置响应状态代码，并将其以字符串形式作为响应体的一部分发送。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;###app.route()&lt;br /&gt;
可使用 app.route() 创建路由路径的链式路由句柄。由于路径在一个地方指定，这样做有助于创建模块化的路由，而且减少了代码冗余和拼写错误。请参考 Router() 文档 了解更多有关路由的信息。&lt;/p&gt;

&lt;p&gt;下面这个示例程序使用 app.route() 定义了链式路由句柄。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.route('/book')
  .get(function(req, res) {
    res.send('Get a random book');
  })
  .post(function(req, res) {
    res.send('Add a book');
  })
  .put(function(req, res) {
    res.send('Update the book');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;###express.Router
可使用 express.Router 类创建模块化、可挂载的路由句柄。Router 实例是一个完整的中间件和路由系统，因此常称其为一个 “mini-app”。&lt;/p&gt;

&lt;p&gt;下面的实例程序创建了一个路由模块，并加载了一个中间件，定义了一些路由，并且将它们挂载至应用的路径上。&lt;/p&gt;

&lt;p&gt;在 app 目录下创建名为 birds.js 的文件，内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var router = express.Router();

// 该路由使用的中间件
router.use(function timeLog(req, res, next) {
  console.log('Time: ', Date.now());
  next();
});
// 定义网站主页的路由
router.get('/', function(req, res) {
  res.send('Birds home page');
});
// 定义 about 页面的路由
router.get('/about', function(req, res) {
  res.send('About birds');
});

module.exports = router;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在应用中加载路由模块：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var birds = require('./birds');
...
app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x-错误处理</title>
   <link href="http://www.blogways.net/blog/2015/10/18/express-error-handling.html"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/18/express-error-handling</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://expressjs.com/guide/error-handling.html&quot;&gt;http://expressjs.com/guide/error-handling.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;错误处理&quot;&gt;错误处理&lt;/h2&gt;

&lt;p&gt;定义错误处理中间件和定义其他中间件一样，除了需要 4 个参数，而不是 3 个，其格式如下 (err, req, res, next)。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
}); 在其他 app.use() 和路由调用后，最后定义错误处理中间件，比如：

var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(function(err, req, res, next) {
  // 业务逻辑
}); 中间件返回的响应是随意的，可以响应一个 HTML 错误页面、一句简单的话、一个 JSON 字符串，或者其他任何您想要的东西。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为了便于组织（更高级的框架），您可能会像定义常规中间件一样，定义多个错误处理中间件。比如您想为使用 XHR 的请求定义一个，还想为没有使用的定义一个，那么：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var bodyParser = require('body-parser');
var methodOverride = require('method-override');

app.use(bodyParser());
app.use(methodOverride());
app.use(logErrors);
app.use(clientErrorHandler);
app.use(errorHandler);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;logErrors 将请求和错误信息写入标准错误输出、日志或类似服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function logErrors(err, req, res, next) {
  console.error(err.stack);
  next(err);
} clientErrorHandler 的定义如下（注意这里将错误直接传给了 next）：

function clientErrorHandler(err, req, res, next) {
  if (req.xhr) {
    res.status(500).send({ error: 'Something blew up!' });
  } else {
    next(err);
  }
} errorHandler 能捕获所有错误，其定义如下：

function errorHandler(err, req, res, next) {
  res.status(500);
  res.render('error', { error: err });
} 如果向 next() 传入参数（除了 ‘route’ 字符串），Express 会认为当前请求有错误的输出，因此跳过后续其他非错误处理和路由/中间件函数。如果需做特殊处理，需要创建新的错误处理路由，如下节所示。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果路由句柄有多个回调函数，可使用 ‘route’ 参数跳到下一个路由句柄。比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/a_route_behind_paywall', 
  function checkIfPaidSubscriber(req, res, next) {
    if(!req.user.hasPaid) { 
    
      // 继续处理该请求
      next('route');
    }
  }, function getPaidContent(req, res, next) {
    PaidContent.find(function(err, doc) {
      if(err) return next(err);
      res.json(doc);
    });
}); 在这个例子中，句柄 getPaidContent 会被跳过，但 app 中为 /a_route_behind_paywall 定义的其他句柄则会继续执行。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;next() 和 next(err) 类似于 Promise.resolve() 和 Promise.reject()。它们让您可以向 Express 发信号，告诉它当前句柄执行结束并且处于什么状态。next(err) 会跳过后续句柄，除了那些用来处理错误的句柄。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;缺省错误处理句柄&quot;&gt;缺省错误处理句柄&lt;/h2&gt;

&lt;p&gt;Express 内置了一个错误处理句柄，它可以捕获应用中可能出现的任意错误。这个缺省的错误处理中间件将被添加到中间件堆栈的底部。&lt;/p&gt;

&lt;p&gt;如果你向 next() 传递了一个 error ，而你并没有在错误处理句柄中处理这个 error，Express 内置的缺省错误处理句柄就是最后兜底的。最后错误将被连同堆栈追踪信息一同反馈到客户端。堆栈追踪信息并不会在生产环境中反馈到客户端。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;设置环境变量 NODE_ENV 为 “production” 就可以让应用运行在生产环境模式下。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果你已经开始向 response 输出数据了，这时才调用 next() 并传递了一个 error，比如你在将向客户端输出数据流时遇到一个错误，Express 内置的缺省错误处理句柄将帮你关闭连接并告知 request 请求失败。&lt;/p&gt;

&lt;p&gt;因此，当你添加了一个自定义的错误处理句柄后，如果已经向客户端发送包头信息了，你还可以将错误处理交给 Express 内置的错误处理机制。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function errorHandler(err, req, res, next) {
  if (res.headersSent) {
    return next(err);
  }
  res.status(500);
  res.render('error', { error: err });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x-调试</title>
   <link href="http://www.blogways.net/blog/2015/10/18/express-debugging.html"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/18/express-debugging</id>
   <content type="html">&lt;p&gt;原文：&lt;a href=&quot;http://expressjs.com/guide/debugging.html&quot;&gt;http://expressjs.com/guide/debugging.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;调试-express&quot;&gt;调试 Express&lt;/h1&gt;

&lt;p&gt;Express 内部使用 debug 模块记录路由匹配、使用到的中间件、应用模式以及请求-响应循环。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;debug 有点像改装过的 console.log，不同的是，您不需要在生产代码中注释掉 debug。它会默认关闭，而且使用一个名为 DEBUG 的环境变量还可以打开。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在启动应用时，设置 DEBUG 环境变量为 express:*，可以查看 Express 中用到的所有内部日志。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ DEBUG=express:* node index.js 在 Windows 系统里，使用如下的命令。

&amp;gt; set DEBUG=express:* &amp;amp; node index.js 在由 express 应用生成器 生成的默认应用中执行，会打印出如下信息：

$ DEBUG=express:* node ./bin/www
  express:router:route new / +0ms
  express:router:layer new / +1ms
  express:router:route get / +1ms
  express:router:layer new / +0ms
  express:router:route new / +1ms
  express:router:layer new / +0ms
  express:router:route get / +0ms
  express:router:layer new / +0ms
  express:application compile etag weak +1ms
  express:application compile query parser extended +0ms
  express:application compile trust proxy false +0ms
  express:application booting in development mode +1ms
  express:router use / query +0ms
  express:router:layer new / +0ms
  express:router use / expressInit +0ms
  express:router:layer new / +0ms
  express:router use / favicon +1ms
  express:router:layer new / +0ms
  express:router use / logger +0ms
  express:router:layer new / +0ms
  express:router use / jsonParser +0ms
  express:router:layer new / +1ms
  express:router use / urlencodedParser +0ms
  express:router:layer new / +0ms
  express:router use / cookieParser +0ms
  express:router:layer new / +0ms
  express:router use / stylus +90ms
  express:router:layer new / +0ms
  express:router use / serveStatic +0ms
  express:router:layer new / +0ms
  express:router use / router +0ms
  express:router:layer new / +1ms
  express:router use /users router +0ms
  express:router:layer new /users +0ms
  express:router use / &amp;lt;anonymous&amp;gt; +0ms
  express:router:layer new / +0ms
  express:router use / &amp;lt;anonymous&amp;gt; +0ms
  express:router:layer new / +0ms
  express:router use / &amp;lt;anonymous&amp;gt; +0ms
  express:router:layer new / +0ms 当应用收到请求时，能看到 Express 代码中打印出的日志。

  express:router dispatching GET / +4h
  express:router query  : / +2ms
  express:router expressInit  : / +0ms
  express:router favicon  : / +0ms
  express:router logger  : / +1ms
  express:router jsonParser  : / +0ms
  express:router urlencodedParser  : / +1ms
  express:router cookieParser  : / +0ms
  express:router stylus  : / +0ms
  express:router serveStatic  : / +2ms
  express:router router  : / +2ms
  express:router dispatching GET / +1ms
  express:view lookup &quot;index.jade&quot; +338ms
  express:view stat &quot;/projects/example/views/index.jade&quot; +0ms
  express:view render &quot;/projects/example/views/index.jade&quot; +1ms 设置 DEBUG 的值为 express:router，只查看路由部分的日志；设置 DEBUG 的值为 express:application，只查看应用部分的日志，依此类推。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;通过-express-生成应用&quot;&gt;通过 express 生成应用&lt;/h1&gt;
&lt;p&gt;通过 express 命令行生成的应用也使用了 debug 模块，它的命名空间限制在应用中。&lt;/p&gt;

&lt;p&gt;如果您通过下述命令生成应用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ express sample-app 则可通过下述命令打开调试信息：

$ DEBUG=sample-app node ./bin/www 可通过逗号隔开的名字列表来指定多个调试命名空间，如下所示：

$ DEBUG=http,mail,express:* node index.js 请查阅 调试指南 获取更多有关 debug 的文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>express3.x-数据库集成</title>
   <link href="http://www.blogways.net/blog/2015/10/18/express-database-integration.html"/>
   <updated>2015-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/10/18/express-database-integration</id>
   <content type="html">&lt;p&gt;原文
&lt;a href=&quot;http://expressjs.com/guide/database-integration.html&quot;&gt;http://expressjs.com/guide/database-integration.html&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;集成数据库&quot;&gt;集成数据库&lt;/h1&gt;

&lt;p&gt;为 Express 应用添加连接数据库的能力，只需要加载相应数据库的 Node.js 驱动即可。这里将会简要介绍如何为 Express 应用添加和使用一些常用的数据库 Node 模块。&lt;/p&gt;

&lt;p&gt;·Cassandra&lt;/p&gt;

&lt;p&gt;·CouchDB&lt;/p&gt;

&lt;p&gt;·LevelDB&lt;/p&gt;

&lt;p&gt;·MySQL&lt;/p&gt;

&lt;p&gt;·MongoDB&lt;/p&gt;

&lt;p&gt;·Neo4j&lt;/p&gt;

&lt;p&gt;·PostgreSQL&lt;/p&gt;

&lt;p&gt;·Redis&lt;/p&gt;

&lt;p&gt;·SQLite&lt;/p&gt;

&lt;p&gt;·ElasticSearch&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;这些数据库驱动只是其中一部分，可在 npm 官网 查找更多驱动。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Cassandra
模块: cassandra-driver
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install cassandra-driver 示例

var cassandra = require('cassandra-driver');
var client = new cassandra.Client({ contactPoints: ['localhost']});

client.execute('select key from system.local', function(err, result) {
  if (err) throw err;
  console.log(result.rows[0]);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;couchdb&quot;&gt;CouchDB&lt;/h3&gt;
&lt;p&gt;模块: nano
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install nano 示例

var nano = require('nano')('http://localhost:5984');
nano.db.create('books');
var books = nano.db.use('books');

//Insert a book document in the books database
books.insert({name: 'The Art of war'}, null, function(err, body) {
  if (!err){
    console.log(body);
  }
});

//Get a list of all books
books.list(function(err, body){
  console.log(body.rows);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;leveldb&quot;&gt;LevelDB&lt;/h3&gt;
&lt;p&gt;模块: levelup
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install level levelup leveldown 示例

var levelup = require('levelup');
var db = levelup('./mydb');

db.put('name', 'LevelUP', function (err) {

  if (err) return console.log('Ooops!', err);
  db.get('name', function (err, value) {
    if (err) return console.log('Ooops!', err);
    console.log('name=' + value)
  });

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mysql&quot;&gt;MySQL&lt;/h3&gt;
&lt;p&gt;模块: mysql
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install mysql 示例

var mysql      = require('mysql');
var connection = mysql.createConnection({
  host     : 'localhost',
  user     : 'dbuser',
  password : 's3kreee7'
});

connection.connect();

connection.query('SELECT 1 + 1 AS solution', function(err, rows, fields) {
  if (err) throw err;
  console.log('The solution is: ', rows[0].solution);
});

connection.end();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mongodb&quot;&gt;MongoDB&lt;/h3&gt;
&lt;p&gt;模块: mongoskin
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install mongoskin 示例

var db = require('mongoskin').db('localhost:27017/animals');

db.collection('mamals').find().toArray(function(err, result) {
  if (err) throw err;
  console.log(result);
});
If you want a object model driver for MongoDB, checkout Mongoose.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;neo4j&quot;&gt;Neo4j&lt;/h3&gt;
&lt;p&gt;模块: apoc
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install apoc 示例

var apoc = require('apoc');

apoc.query('match (n) return n').exec().then(
  function (response) {
    console.log(response);
  },
  function (fail) {
    console.log(fail);
  }
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;postgresql&quot;&gt;PostgreSQL&lt;/h3&gt;
&lt;p&gt;模块: pg
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install pg 示例

var pg = require('pg');
var conString = &quot;postgres://username:password@localhost/database&quot;;

pg.connect(conString, function(err, client, done) {

  if (err) {
    return console.error('error fetching client from pool', err);
  }
  client.query('SELECT $1::int AS number', ['1'], function(err, result) {
    done();
    if (err) {
      return console.error('error running query', err);
    }
    console.log(result.rows[0].number);
  });

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;redis&quot;&gt;Redis&lt;/h3&gt;
&lt;p&gt;模块: redis
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install redis 示例

var client = require('redis').createClient();

client.on('error', function (err) {
  console.log('Error ' + err);
});

client.set('string key', 'string val', redis.print);
client.hset('hash key', 'hashtest 1', 'some value', redis.print);
client.hset(['hash key', 'hashtest 2', 'some other value'], redis.print);

client.hkeys('hash key', function (err, replies) {

  console.log(replies.length + ' replies:');
  replies.forEach(function (reply, i) {
    console.log('    ' + i + ': ' + reply);
  });

  client.quit();

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sqlite&quot;&gt;SQLite&lt;/h3&gt;
&lt;p&gt;模块: sqlite3
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install sqlite3 示例

var sqlite3 = require('sqlite3').verbose();
var db = new sqlite3.Database(':memory:');

db.serialize(function() {

  db.run('CREATE TABLE lorem (info TEXT)');
  var stmt = db.prepare('INSERT INTO lorem VALUES (?)');

  for (var i = 0; i &amp;lt; 10; i++) {
    stmt.run('Ipsum ' + i);
  }

  stmt.finalize();

  db.each('SELECT rowid AS id, info FROM lorem', function(err, row) {
    console.log(row.id + ': ' + row.info);
  });
});

db.close();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;elasticsearch&quot;&gt;ElasticSearch&lt;/h3&gt;
&lt;p&gt;模块: elasticsearch
安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install elasticsearch 示例

var elasticsearch = require('elasticsearch');
var client = elasticsearch.Client({
  host: 'localhost:9200'  
});

client.search({
  index: 'books',
  type: 'book',
  body: {
    query: {
      multi_match: {
        query: 'express js',
        fields: ['title', 'description']
      }
    }
  }
}).then(function(response) {
  var hits = response.hits.hits;
}, function(error) {
  console.trace(error.message);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery2.1.1源码学习[2] -- 核心设计</title>
   <link href="http://www.blogways.net/blog/2015/09/18/jquery-211-study-2.html"/>
   <updated>2015-09-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/09/18/jquery-211-study-2</id>
   <content type="html">&lt;p&gt;##一、静态与实力方法共享的设计
学习jqeury的时候会发现也和其它编程语言一样存在有实例方法和静态方法，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;.a&quot;).each()   //作为实例方法存在
$.each()             //作为静态方法存在 上面是对class=a的进行遍历，下面是可以遍历任何想要遍历的东西，在jQuery中都是通过一个方法实现的

jQuery.prototype = {
    each: function( callback, args ) {
        return jQuery.each( this, callback, args );
    }
} 可以看到这样就能公用一个方法

ajQuery.fn = ajQuery.prototype = {
        name: 'aaron',
        init: function(selector) {
               this.selector = selector;
               return this;
        },
        constructor: ajQuery
}
ajQuery.fn.init.prototype = ajQuery.fn
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法都是要构造才行的，静态的each 可以直接添加进jquery构造器，但是实力方法不行，通过上面的代码将jQuery的原型对象覆盖了init构造器的原型对象，这样也可以直接构造实例方法了。&lt;/p&gt;

&lt;p&gt;##二、方法链式调用的设计
使用jQuery的时候经常链式调用，可以一直操作你取出来的一段东西，方便，代码量少&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;map: function( callback ) {
	return this.pushStack( jQuery.map(this, function( elem, i ) {
		return callback.call( elem, i, elem );
	}));
},

slice: function() {
	return this.pushStack( slice.apply( this, arguments ) );
},

first: function() {
	return this.eq( 0 );
},

last: function() {
	return this.eq( -1 );
},

eq: function( i ) {
	var len = this.length,
		j = +i + ( i &amp;lt; 0 ? len : 0 );
	return this.pushStack( j &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;lt; len ? [ this[j] ] : [] );
},

end: function() {
	return this.prevObject || this.constructor(null);
} 比如说以上的各种 return this 这样就可以一直调用了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;##三、插件接口的设计
jQuery 可以自己扩展方法，一般方法存在于下面两个地方&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend({
    data:function(){},
    removeData:function(){}
})

jQuery.fn.extend({
    data:function(){},
    removeData:function(){}
}) 就相当于自己扩展其它语言里的实例方法和静态方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Prototype.js  源码学习</title>
   <link href="http://www.blogways.net/blog/2015/09/09/Prototype-js.html"/>
   <updated>2015-09-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/09/09/Prototype-js</id>
   <content type="html">&lt;h2 id=&quot;一整体架构学习&quot;&gt;一、整体架构学习&lt;/h2&gt;
&lt;p&gt;总的来说prototype.js主要给js原生的类扩展了各的方法，通过两种方式扩展，主要用到下面这个函数扩展。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object.extend = function(destination, source) {
	  for (property in source) {
	    destination[property] = source[property];
	  }
	  return destination;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一种就是直接扩展，这样就直接扩展进了某个类的方法中，可以直接调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object.extend(String.prototype, {
    /*
     * 将Html转换为纯文本，例如：
     * var s=&quot;&amp;lt;font color='red'&amp;gt;hello&amp;lt;/font&amp;gt;&quot;;
     * s.stripTags()将得到“hello”。
     */
    stripTags: function() {
        return this.replace(/&amp;lt;//?[^&amp;gt;]+&amp;gt;/gi, '');
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第二种就是现在源码中定义一个类，然后直接扩展进去比如定义的Enumerable类可以扩展进Array 和 Hash 等，方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var YourObject = Class.create(); 
Object.extend(YourObject.prototype, Enumerable); 
Object.extend(YourObject.prototype, { 
	initialize: function() { 
		// 构造函数
	}, 
	_each: function(iterator) { 
		// 迭代代码，每次循环时调用 iterator 
	}, 
	// 其它自定义方法，包括需要重写的 Enumerable 方法 
});  要用到Enumerable 必须添加进 _each方法。 prototype.js 就是通过这种方式扩展的方法，这个源码都遵循这两个规则。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二-方法学习&quot;&gt;二 方法学习&lt;/h2&gt;

&lt;p&gt;最常用的就是this.each(function(value, index)这样进行迭代，相比下面总是省下了很多代码。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (var index = 0; index &amp;lt; myArray.length; ++index) {
	var value = myArray[index]; 
	// 你的代码... 
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方法一个个也说不完，总的来说就是掌握好源码内部定义的工具类和方法  然后再掌握好JS里原生方法，再掌握好一些判断的知识就能很好的学习Prototype.js ，有很多方法仅仅对原生方法进行简单的封装使之更容易调用。学习的时候代码中如何进行变量名命名，注意代码的格式等。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery2.1.1源码学习[1] -- 整体架构</title>
   <link href="http://www.blogways.net/blog/2015/09/08/jquery-211-study-1.html"/>
   <updated>2015-09-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/09/08/jquery-211-study-1</id>
   <content type="html">&lt;h2 id=&quot;一整体架构&quot;&gt;一、整体架构&lt;/h2&gt;

&lt;p&gt;jQuery一共13个模块，从2.1版开始jQuery支持通过AMD模块划分，jQuery在最开始发布的1.0版本是很简单的，只有CSS选择符、事件处理和AJAX交互3大块，所以源码学习很重要，浏览器兼容、各种属性的获取、逻辑流程、性能等都可以在学习源码的过程中体会到。
&lt;img src=&quot;/images/zk-jq-1.png&quot; alt=&quot;架构表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这个架构图里面可可以清晰的看出jquery内部是如何工作的， 整体架构一目了然。&lt;/p&gt;

&lt;h2 id=&quot;二-代码开始如何进行整体架构&quot;&gt;二、 代码开始如何进行整体架构&lt;/h2&gt;

&lt;p&gt;首先是jquery代码的开始&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(function(window, undefined) {
var jQuery = function() {}
// ...
window.jQuery = window.$ = jQuery;
})(window); 这里首先用了“JS高级程序中”关于第7章，模仿块级作用域的知识，js中是没有块级作用域的这和其它面向对象的语言有很大区别。而这里为了不污染全局变量采用了这种写 法，而且这个函数是自执行的。undefined 并不是作为关键字，因此可以允许用户对其赋值。同时这里也用了立即调用表达式 上面的代码等同于
 
var factory = function(){
return function(){
    //执行方法
}
}
var jQuery = factory();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看到这里会发现 JQuery中有很多类似的东西：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function() {
// ...代码...
})
//document ready 简写
$(function() {
// ...代码...
})
$(document).load(function() {
// ...代码...
})。 这些都是加载文档的方式，需要记住的是ready先执行，load后执行。 在源码中还会经常出现：

jQuery.extends()
 	jQuery.fn.extends()
jQuery.extend = jQuery.fn.extend 分别扩展jquery 以及jquery 原型  类似面向对象语言里面的类方法和实例方法
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还会出现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.prototype = jQuery.fn jQuery.fn.init.prototype 
return jQuery.fn.init 这些都是方便jquery直接创建实例。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jquery对象是可以像数组一样被操作的，下面是常用调用的方式，他们都可以被当做数组或对象操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	1. jQuery([selector,[context]])
	2. jQuery(element)
	3. jQuery(elementArray)
	4. jQuery(object)
	5. jQuery(jQuery object)
	6. jQuery(html,[ownerDocument])
	7. jQuery(html,[attributes])
	8. jQuery()
	9. jQuery(callback) 为什么可以这样操作，因为在jquery内部通过一种叫做类数组对象的方式存储数据,既可以当做数组操作也可以当做对象处理。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>在linux上安装oracle client</title>
   <link href="http://www.blogways.net/blog/2015/08/20/install-oracleclient-on-linux.html"/>
   <updated>2015-08-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/08/20/install-oracleclient-on-linux</id>
   <content type="html">&lt;h2 id=&quot;一资源&quot;&gt;一、资源&lt;/h2&gt;

&lt;p&gt;登录Oracle官网 &lt;a href=&quot;http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html&quot;&gt;http://www.oracle.com/technetwork/topics/linuxx86-64soft-092277.html&lt;/a&gt; 。&lt;/p&gt;

&lt;h2 id=&quot;二选择&quot;&gt;二、选择&lt;/h2&gt;

&lt;p&gt;首先，选择你所需要的版本。&lt;/p&gt;

&lt;p&gt;我选择的是 Version 11.2.0.4.0.&lt;/p&gt;

&lt;p&gt;可以选择zip格式的，也可以选择rpm格式的。&lt;/p&gt;

&lt;p&gt;我想自定义安装的路径，所以选择的是zip格式的。&lt;/p&gt;

&lt;p&gt;根据说明，我选择了三个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#Basic: All files required to run OCI, OCCI, and JDBC-OCI applications 
instantclient-basic-linux.x64-12.1.0.1.0.zip 

#SDK: Additional header files and an example makefile for developing Oracle applications with Instant Client
instantclient-sdk-linux.x64-12.1.0.1.0.zip 

#SQL*Plus: Additional libraries and executable for running SQL*Plus with Instant Client
instantclient-sqlplus-linux.x64-12.1.0.1.0.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果仅仅需要运行环境，下载第一个就可以了。如果还需要开发编译环境，还需要下载第二个。想用sqlplus，要下第三个。&lt;/p&gt;

&lt;h2 id=&quot;三安装&quot;&gt;三、安装&lt;/h2&gt;

&lt;p&gt;把三个zip包传到要安装的目录下，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/oracle&lt;/code&gt;。执行下面命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unzip instantclient-basic-linux.x64-12.1.0.1.0.zip
unzip instantclient-sdk-linux.x64-12.1.0.1.0.zip
unzip instantclient-sqlplus-linux.x64-12.1.0.1.0.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;解压后的文件都在&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/oracle/instantclient_11_2&lt;/code&gt;目录下面。&lt;/p&gt;

&lt;p&gt;如果需要编译环境，还要设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd /home/oracle/instantclient_11_2
ln -s libclntsh.so.11.1 libclntsh.so
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置环境变量：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export ORACLE_HOME=/home/oracle/instantclient_11_2
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$ORACLE_HOME/lib
export PATH=$PATH:$ORACLE_HOME/bin
export TNS_ADMIN=$ORACLE_HOME
export NLS_LANG=american_america.ZHS16GBK
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;$ORACLE_HOME&lt;/code&gt;目录下配置你的&lt;code class=&quot;highlighter-rouge&quot;&gt;tnsnames.ora&lt;/code&gt;文件&lt;/p&gt;

&lt;p&gt;在编译oci/occi程序时，编译命令需要添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;-I$ORACLE_HOME/sdk/include&lt;/code&gt; ,链接命令需要添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;-L$ORACLE_HOME&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;四测试&quot;&gt;四、测试&lt;/h2&gt;

&lt;p&gt;在命令行输入：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sqlplus user/passwd@sid
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到熟悉的提示，就表示大功告成了！&lt;/p&gt;

&lt;h2 id=&quot;五回顾&quot;&gt;五、回顾&lt;/h2&gt;

&lt;p&gt;我当时按上面步骤安装后，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;sqlplus&lt;/code&gt;会报一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ORA-21561&lt;/code&gt;错误。后来在&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/hosts&lt;/code&gt;文件中配置上的主机的名字，问题就解决了。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Git Stat</title>
   <link href="http://www.blogways.net/blog/2015/07/14/git-stat.html"/>
   <updated>2015-07-14T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/07/14/git-stat</id>
   <content type="html">&lt;h2 id=&quot;git-stat&quot;&gt;Git Stat&lt;/h2&gt;
&lt;p&gt;最近项目在搞人力资源配置优化，其中一个就是对代码提交量做统计，项目使用的是 Git 仓库，本来想偷懒去网上找个现成的工具，结果有点失望，没有找到能用的，绝大部分都是 shell 脚本，虽然也能执行，但想要达到要求的结果还得大改，而且显示也不直观，再加上我 shell 水平比较弱，最后决定用 java 来写个分析工具，将分析结果放到 web 页面来展示。&lt;/p&gt;

&lt;h3 id=&quot;实现原理&quot;&gt;实现原理&lt;/h3&gt;
&lt;p&gt;由于是做一个全局的 Git 提交分析，这边只对 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 的结果分析，分析的结果只显示增加的行数以及删除的行数，代码贡献以增加的行数为基础统计，个人提交明细显示统计时间段内每天提交量，横轴以[1-N]天来显示，并不显示具体的日期、周或者月份。&lt;/p&gt;

&lt;p&gt;具体统计的执行脚本，例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git log --pretty=format:&quot;%cn;%ad;%d&quot; --numstat --date=iso --since=2015-07-06 --until=2015-07-11
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;本来想把&lt;code class=&quot;highlighter-rouge&quot;&gt;committer&lt;/code&gt;参数带进去的，但项目在配 git 用户的时候用户名跟提交名并没有完全配成一样的，所以这个功能没有实现，目前的做法为一次性取出指定时间段内的所有提交结果，统一分析，将分析结果一起返回到前台页面，这样的话只要执行一次命令就可以了，但结果分析需要多花一些时间，尤其是统计时间长，提交人员多的时候响应会有点延时。几十个人的团队建议统计半年以内的结果，再大的我也没测过，如果有需求的话也可以跟我联系。&lt;/p&gt;

&lt;h3 id=&quot;界面展示&quot;&gt;界面展示&lt;/h3&gt;
&lt;p&gt;界面部分我也搞得比较素，没有用 UI，图表展示的时候用到了百度的 echarts，echarts 确实做得很好，渲染也很快，免费而且没有让人讨厌的水印。&lt;/p&gt;

&lt;p&gt;下面看看几个主要的界面：&lt;/p&gt;

&lt;p&gt;统计列表&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/git-stat-1.png&quot; alt=&quot;统计列表&quot; /&gt;&lt;/p&gt;

&lt;p&gt;贡献饼图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/git-stat-2.png&quot; alt=&quot;统计饼图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;个人提交明细&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/git-stat-3.png&quot; alt=&quot;个人提交明细&quot; /&gt;&lt;/p&gt;

&lt;p&gt;前台 js 框架用的是 zepto，所以不兼容一些低版本的浏览器，推荐使用 chrome。&lt;/p&gt;

&lt;h3 id=&quot;操作说明&quot;&gt;操作说明&lt;/h3&gt;
&lt;p&gt;目前只提供一天内、一周内、一月内、自定义四种统计方式，自定义需要选择起始、结束日期，还有一个右上角的 &lt;code class=&quot;highlighter-rouge&quot;&gt;local git path&lt;/code&gt; 第一次需要指定下，直接拷贝你本地的 git 仓库目录，Windows、Linux 都是支持的。&lt;/p&gt;

&lt;p&gt;需要注意的是统计只是在本地的 git 项目仓库目录下执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 并对结果进行统计分析，也就是说，分析只限于已经 &lt;code class=&quot;highlighter-rouge&quot;&gt;git pull&lt;/code&gt; 代码，如果想要统计最新的提交记录，需要拉取最新项目代码再统计，如果是 Windows ，首先要确保 &lt;code class=&quot;highlighter-rouge&quot;&gt;git&lt;/code&gt; 命令在 &lt;code class=&quot;highlighter-rouge&quot;&gt;cmd&lt;/code&gt; 命令行里面可以执行。&lt;/p&gt;

&lt;p&gt;我已经把应用打成 war 包放在 csdn 上，下下来直接部署在 tomcat 服务器就能跑。&lt;/p&gt;

&lt;p&gt;下载：&lt;a href=&quot;http://download.csdn.net/download/yajunshen/8899423&quot;&gt;statgit.war&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最后说明下，类似的统计只是一个辅助手段，并不能完全确定个人的工作量。同一个功能实现方式不同代码量可能差异比较大，而且 git log 命令本身并不能确定修改的行数以及修改的字节数，只能统计增加和删除行数，也不能简单的相减来算工作量，所以我对结果没有做合并，大家有好的思路可以交流下。E-mail: &lt;a href=&quot;mailto:jhkgogpl@163.com&quot;&gt;JackyShen&lt;/a&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java SE 7 Third Edition 规范翻译之－异常</title>
   <link href="http://www.blogways.net/blog/2015/06/12/jls7-3-11.html"/>
   <updated>2015-06-12T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/06/12/jls7-3-11</id>
   <content type="html">&lt;h1 id=&quot;java-se-7-third-edition-规范翻译之异常&quot;&gt;Java SE 7 Third Edition 规范翻译之－异常&lt;/h1&gt;

&lt;p&gt;当一个程序违反了Java语言的语义约束，Java虚拟机将抛出异常。&lt;/p&gt;

&lt;p&gt;一个典型的违反约束的例子是企图索引一个越界的数组。一些语言通过强制终止程序来处理这种类型的错误；另一些语言允许这种实现，但处理方式是随意的或者不可预知的。不同于这两种实现，Java SE平台的设计目标是：提供可移值性和健壮性。&lt;/p&gt;

&lt;p&gt;Java编程语言指出当语义约束遭到违反时将抛出一个异常，同时程序将指出导致异常的代码，并交出控制权。&lt;/p&gt;

&lt;p&gt;异常被认为从导致它的地方抛出，并且在这个地方交出控制权。&lt;/p&gt;

&lt;p&gt;程序也可以使用throw语句抛出自定义异常。自定义异常通过返回值来替代老式风格的错误处理机制，例如一个整数不希望出现负值时，经验表明调用者经常忽略了这样的验证，导致程序不健壮，产生不希望的结果，或者两者兼有。&lt;/p&gt;

&lt;p&gt;每个异常都是Throwable或者它的子类的一个实例(§11.1)。异常对象可以用来承载异常发生时的信息，提供给处理程序，由try语句抛出，catch语句创建处理程序(§14.20)。&lt;/p&gt;

&lt;p&gt;在抛出异常的过程中，Java虚拟机意外中止，一个接一个，任何当前线程已经开始的表达式，语句，方法，构造函数，初始化，属性初始化表达式将挂起，直到找到这个异常处理类或者异常父类的处理类(§11.2)。如果没有对应的处理类，那么会当成未被处理的异常处理，因为所做的努力都是避免让异常没有对应的处理方法。&lt;/p&gt;

&lt;p&gt;Java SE平台的异常机制集成了其同步模式(§17.1)，使监视器异常中止时开启为同步声明(§14.19)以及同步方法调用(§8.4.3.6, §15.12)&lt;/p&gt;

&lt;h2 id=&quot;111-the-kinds-and-causes-of-exceptions&quot;&gt;11.1 The Kinds and Causes of Exceptions&lt;/h2&gt;
&lt;h3 id=&quot;1111-the-kinds-of-exceptions&quot;&gt;11.1.1 The Kinds of Exceptions&lt;/h3&gt;

&lt;p&gt;一个异常代表Throwable（Object的直接子类）或者它子类的一个实例&lt;/p&gt;

&lt;p&gt;Throwable和它所有的子类统称为异常类。需要注意的是Throwable的子类一定是不能通用的(§8.1.2)。&lt;/p&gt;

&lt;p&gt;类Exception和Error都是Throwable的直接子类。&lt;/p&gt;

&lt;p&gt;Exception是程序希望可以继续运行时抛出的所有异常的父类。&lt;/p&gt;

&lt;p&gt;Error是不希望程序继续运行时抛出的所有异常的父类。&lt;/p&gt;

&lt;p&gt;Error和它的子类被统称为错误类。&lt;/p&gt;

&lt;p&gt;Error类是Throwable的独立的子类，和Exception是两个不同的分支，允许程序使用语法 “} catch (Exception e) {“ (§11.2.3) 捕获所有的异常从而恢复运行是可行的，想通过捕获错误来恢复运行是不可行的。&lt;/p&gt;

&lt;p&gt;RuntimeException类是Exception的一个直接子类。&lt;/p&gt;

&lt;p&gt;RuntimeException是所有表达式赋值运行时各种异常的父类，但仍可以继续运行。&lt;/p&gt;

&lt;p&gt;RuntimeException和它的所有子类统称为运行时异常类。&lt;/p&gt;

&lt;p&gt;未检查异常类包括运行时异常类和错误类。&lt;/p&gt;

&lt;p&gt;非检查异常类之外的异常都属于检查异常类。也就是说，检查异常类都继承自Throwable类，而不是RuntimeException和它子类或者Error和它子类。&lt;/p&gt;

&lt;p&gt;程序可以在throw语句里使用Java SE平台API定义好的异常类，或者自定义的Throwable或者它子类的子类。利用编译时检查异常处理(§11.2)，这个是典型的大部分检查异常类的定义方法，换句话说检查异常类是Exception的子类而不是RuntimeException的子类。&lt;/p&gt;

&lt;h3 id=&quot;1112-the-causes-of-exceptions&quot;&gt;11.1.2 The Causes of Exceptions&lt;/h3&gt;
&lt;p&gt;抛出异常的三个原因：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;throw语句(§14.18)被执行。&lt;/li&gt;
  &lt;li&gt;由Java虚拟机同步检测的异常执行情况，即：
    &lt;ul&gt;
      &lt;li&gt;运算表达式违反Java程序主义，例如整数除以0。&lt;/li&gt;
      &lt;li&gt;程序加载，连接，或者初始化部分导致的错误(§12.2, §12.3, §12.4)；在这种情况下抛出一个LinkageError子类的实例。&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;内部错误或者资源访问限制阻止Java虚拟机实现Java程序方法；在这种情况下抛出一个VirtualMethodError子类的实例。&lt;/p&gt;

        &lt;p&gt;这些异常不需要在程序里显式的抛出，而是在运算表达式或者语句执行时可能导致的异常。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;发生异步异常(§11.1.3)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;1113-asynchronous-exceptions&quot;&gt;11.1.3 Asynchronous Exceptions&lt;/h3&gt;

&lt;p&gt;大部分异常在线程执行时同步抛出，并且指出导致这个异常可能的地方。相比之下异步异常可能发生在程序执行的任何地方。&lt;/p&gt;

&lt;p&gt;异步异常仅发生在：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;调用线程或者线程组（过期的）stop方法。一个线程调用（过期的）stop方法影响到另外一个线程或者一个特别线程组里面所有的线程。他们是异步的，因为他们可以在其他线程或者线程组里面任何地方执行。&lt;/li&gt;
  &lt;li&gt;Java虚拟机一个内部错误或者资源访问阻止了Java语义的实现。在这种情况下，抛出VirtualMethodError子类的一个实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是StackOverflowError，VirtualMethodError的一个子类，既可以在方法调用时同步抛出，也可以执行本地方法或者Java虚拟机资源访问限制时异步抛出。同样，OutOfMemoryError，另一个VirtualMethodError的子类，可以在对象创建(§12.5)，数组创建(§15.10.1, §10.6)，类初始化(§12.4.2)，和装箱转换(§5.1.7)期间同步或者异步抛出。&lt;/p&gt;

&lt;p&gt;Java SE平台在异步异常抛出前允许一个小的但数量有限的执行。&lt;/p&gt;

&lt;p&gt;异步异常是罕见的，但如果要生成高品质的机器代码，正确理解其语义是必要的。&lt;/p&gt;

&lt;p&gt;上面提到的延迟允许优化代码，以检测和抛出这些异常点是遵守Java编程语义可行的处理。一个简单的实现可能轮循在每个控制转移指令点的异步异常。因为程序大小有限制，这提供了一个检测异步异常的总延时。因为控制转换不会导致异步异常，代码解释器拥有一定的灵活性，在控制转换时重新排列达到更好的性能。Marc Feeley 在 Proc. 1993 发表的论文 Polling Efficiently on Stock Hardware 讨论了函数式编程和计算机架构，哥本哈根，丹麦，第179-187页，建议详细阅读。&lt;/p&gt;

&lt;h2 id=&quot;112-compile-time-checking-of-exceptions&quot;&gt;11.2 Compile-Time Checking of Exceptions&lt;/h2&gt;

&lt;p&gt;Java编程语言要求程序为可能导致异常的执行方法或者构造函数提供检查处理方法，对每个可能的异常检查，方法(§8.4.6)或者构造函数(§8.8.5)中的throws子句必须提到该异常类或者该异常类的一个超类(§11.2.3)。&lt;/p&gt;

&lt;p&gt;编译时检查异常处理设计是为了减少不确当处理异常数量。检查在throws子句中指定的异常类(§11.1.1)是方法或者构造函数实现者和使用者之间约定的一部分。重写方法的throws子句可以不用指定此方将导致抛出任何检查异常，不允许在重写方法中通过throws子句抛出异常(§8.4.8.3)。&lt;/p&gt;

&lt;p&gt;当涉及到多个接口，多个方法的声明可能被一个方法重写。在这种情况下，重写声明必须有一个throws子句覆盖所有的被重写的声明(§9.4.1)。&lt;/p&gt;

&lt;p&gt;非检查异常类(§11.1.1)在编译时不检测。&lt;/p&gt;

&lt;p&gt;未检查异常类中的错误类不校验，因为他们可以发生在程序的很多地方，恢复起来很困难或者不可能。声明这种异常将使程序很混乱，毫无意义。复杂的程序可能希望捕获这些异常并企图从其中的一些条件恢复。&lt;/p&gt;

&lt;p&gt;未检查异常类中的运行时异常类不校验，因为在Java程序语言的设计者们的判断，申报此类异常不会在建立程序正确性方面有显著的帮助。Java程序的许多操作和构造都能导致运行时异常。Java编译器所拥有的信息，以及分析编译器的水平，通常不足以保证运行时异常不发生，即使对程序员来说是很明显的。需要声明这种异常对程序员来简直是悲剧。&lt;/p&gt;

&lt;p&gt;例如，某些代码可能通过构造器执行一个循环的数据结构，不能包含空引用；程序员可以肯定不会发生NullPointerException异常，但对Java编译器来说想要证明它就很困难。想要证明需要建立一个全局的数据结构属性，已经超出了本规范的范围。&lt;/p&gt;

&lt;p&gt;我们说如果一个声明或者表达式可能抛出一个检查异常类 E，根据§11.2.1和§11.2.2的规则，声明或者表达式执行可能导致一个异常类 E 被抛出。&lt;/p&gt;

&lt;p&gt;我们说一个catch子句可以捕获它对应的异常类。单catch子句需要声明该异常类型参数(§14.20)。&lt;/p&gt;

&lt;p&gt;多catch子句用来处理多个异常，每个catch需要指定其对应的异常类型参数(§14.20)。&lt;/p&gt;

&lt;h3 id=&quot;1121-exception-analysis-of-expressions&quot;&gt;11.2.1 Exception Analysis of Expressions&lt;/h3&gt;

&lt;p&gt;一个类实例创建表达式(§15.9)可能抛出异常类 E，仅当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;表达式是一个正确的类实例创建表达式，正确的表达式可能抛出异常 E；或&lt;/li&gt;
  &lt;li&gt;参数列表的一些表达式可能抛出 E；或者&lt;/li&gt;
  &lt;li&gt;E 在被调用的构造器最后作为异常类通过throws子句抛出(§15.12.2.6)；或&lt;/li&gt;
  &lt;li&gt;类实例创建表达式包含一个类体，类体的一些实例初始化块或者实例变量初始化表达式可能抛出 E。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个方法调用表达式(§15.12)可能抛出异常类 E，仅当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法调用是形式，标签符和主要的表达式可能抛出 E；或&lt;/li&gt;
  &lt;li&gt;参数列表的一些表达式可能抛出 E；或&lt;/li&gt;
  &lt;li&gt;E 在被调用的构造器最后作为异常类通过throws子句抛出(§15.12.2.6)；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于每一种表达式，仅当其中一个表达式可能抛出异常类 E，表达式才可能抛出 E。&lt;/p&gt;

&lt;h3 id=&quot;1122-exception-analysis-of-statements&quot;&gt;11.2.2 Exception Analysis of Statements&lt;/h3&gt;

&lt;p&gt;throw语句(§14.18)，其thrown表达式具有静态类型 E，并且是非final或者effectively final表达式参数，可以抛出 E 或者任意可以抛出的异常类。&lt;/p&gt;

&lt;p&gt;例如，声明抛出new java.io.FileNotFoundException()，只能抛出java.io.FileNotFoundException。形式上来说它不是这样的，它能够抛出java.io.FileNotFoundException的子类或者超类。&lt;/p&gt;

&lt;p&gt;throw语句抛出的异常作为catch语句C的一个final和effectively final异常参数，可以抛出异常类 E 仅当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;E 是一个异常类，C 声明的try语句的try块中可以抛出；和&lt;/li&gt;
  &lt;li&gt;E 与 C 的任何可捕获的异常类兼容；和&lt;/li&gt;
  &lt;li&gt;E 不能与 C 里面同一个 try 声明对应的 catch 语句任何可捕获的异常类冲突。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个 try 语句可以抛出异常类 E，仅当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;该 try 块可以抛出 E，或者一个资源初始化表达式（在try-with-resources语句）可以抛出E，或者自动调用资源的close()方法（在try-with-resources语句）可以抛出E，同时 E 与任何该 try 语句对应的的 catch 子句中可捕获的异常类不能冲突，并且没有finally块存在，或者finally块可以正常完成；或&lt;/li&gt;
  &lt;li&gt;try语句的一些catch块可以抛出 E，并且没有finally块存在或者finally块可以正常完成；或&lt;/li&gt;
  &lt;li&gt;finally块存在并且可以抛出E。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个显式的构造函数调用语句(§8.8.7.1)可以抛出异常类 E，仅当：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;构造函数的参数列表的一些表达式可以抛出 E；或&lt;/li&gt;
  &lt;li&gt;被调用的构造函数内部使用throws子句抛出异常类 E。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;任何其他的声明 S 可以抛出异常类 E，仅当 S 直接包含的表达式或者声明可以抛出 E。&lt;/p&gt;

&lt;h3 id=&quot;1123-exception-checking&quot;&gt;11.2.3 Exception Checking&lt;/h3&gt;

&lt;p&gt;这是一个编译时错误，如果一个方法或者构造体可以抛出一些异常类 E，当 E 是一个检查异常类，并且 E 不是方法或者构造体throws子句声明的一些类的子类。&lt;/p&gt;

&lt;p&gt;这是一个编译时错误，如果一个类变量初始化(§8.3.2)，或指定类或接口的静态初始化(§8.7)可以抛出一个检查异常类。&lt;/p&gt;

&lt;p&gt;这是一个编译时错误，如果一个实例变量初始化或者指定类的实例变量初始化可以抛出一个检查异常类，除非异常类或者它的超类在其对应类的每个构造函数中throws子句里显式声明，并且该类至少拥有一个显示声明的构造函数。&lt;/p&gt;

&lt;p&gt;注意，没有编译时抛出异常类是由于匿名类的变量初始化或者实例初始化引起的。在非匿名类中，程序有义务通过在任何显式的构造函数声明中定义一个合适的throws子句去传播初始化抛出的异常类相关的信息。类初始化抛出的检查异常类和匿名类构造函数隐式初始化声明的检查异常类之间存在一定的联系，因为不可能有明确的显式的构造函数声明，Java编译器总是基于初始化可能抛出的检查异常类，为匿名类声明生成一个拥有合适的throws子句构造函数。&lt;/p&gt;

&lt;p&gt;这是一个编译时错误，如果catch子句可以捕获了一个检查异常类 E1，并且try对应的catch子句不可以抛出一个 E1 检查异常类的子类或者父类，除非 E1 是Exception或者Exception的超类。&lt;/p&gt;

&lt;p&gt;这是一个编译时错误，如果一个catch子句可以捕获(§11.2)检查异常类 E1，上述的catch子句可以立即捕获try语句中的 E1 或者 E1 的超类。&lt;/p&gt;

&lt;p&gt;Java编译器鼓励发出警告，当catch子句可以捕获(§11.2)检查异常类 E1，并且try块对应的catch子句可能抛出检查异常类 E1 的子类 E2，上述的catch子句可以捕获try语句中的检查异常类 E3，其中 E2 &amp;lt;:E3 &amp;lt;: E1。&lt;/p&gt;

&lt;p&gt;Example 11.2.3-1. Catching Checked Exceptions&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.io.*;
class StaticallyThrownExceptionsIncludeSubtypes {
	public static void main(String[] args) {
		try {
			throw new FileNotFoundException();
		} catch (IOException ioe) {
			// Legal in Java SE 6 and 7. &quot;catch IOException&quot;
			// catches IOException and any subtype.
		}
		try {
			throw new FileNotFoundException();
			// Statement &quot;can throw&quot; FileNotFoundException.
			// It is not the case that statement &quot;can throw&quot;
			// a subtype or supertype of FileNotFoundException.
		} catch (FileNotFoundException fnfe) {
			// Legal in Java SE 6 and 7.
		} catch (IOException ioe) {
			// Legal in Java SE 6 and 7, but compilers are
			// encouraged to throw warnings as of Java SE 7.
			// All subtypes of IOException that the try block
			// can throw have already been caught.
		}
		try {
			m();
			// Method m's declaration says &quot;throws IOException&quot;.
			// m &quot;can throw&quot; IOException. It is not the case
			// that m &quot;can throw&quot; a subtype or supertype of
			// IOException, e.g. Exception, though Exception or
			// a supertype of Exception can always be caught.
		} catch (FileNotFoundException fnfe) {
			// Legal in Java SE 6 and 7, because the dynamic type
			// of the IOException might be FileNotFoundException.
		} catch (IOException ioe) {
			// Legal in Java SE 6 and 7.
		} catch (Throwable t) {
			// Legal in Java SE 6 and 7.
		}
	}
	static void m() throws IOException {
		throw new FileNotFoundException();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;根据上述原则，在多个catch子句(§14.20)中的每一个catch子句必须捕获try块中抛出并且在前面的catch没有被捕获的一些异常。例如，下面的第二个catch子句可能导致一个编译时错误，因为异常分析确定SubclassOfFoo已经被第一个catch子句捕获过了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try { ... }
catch (Foo f) { ... }
catch (Bar | SubclassOfFoo e) { ... }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;113-run-time-handling-of-an-exception&quot;&gt;11.3 Run-Time Handling of an Exception&lt;/h2&gt;

&lt;p&gt;当一个异常被抛出(§14.18)，控制权从导致异常的代码转移到最近的动态catch子句块，如果有的话，try语句就可以处理该异常。&lt;/p&gt;

&lt;p&gt;一个声明或者表达式被一个catch子句动态隔离，当它出现在try语句的try块中的话catch子句就是其中的一部分，或者当声明或者表达式的调用者被catch子句动态隔离。&lt;/p&gt;

&lt;p&gt;声明或者表达式的调用者取决于它发生在哪里：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果在方法中，那么调用者是一个方法调用表达式(§15.12)，执行方法调用。&lt;/li&gt;
  &lt;li&gt;如果在构造函数或者实例初始化或者实例变量初始化时，那么调用者就是类实例创建表达式(§15.9)或者一个新实例的方法调用，执行创建一个新对象。&lt;/li&gt;
  &lt;li&gt;如果在一个静态的初始化或者一个静态变量初始化时，那么调用者就是使用的类或者接口，以便其初始化(§12.4)。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一个特定的catch子句能否处理一个异常由抛出的对象跟catch子句能捕获的异常类比较决定。catch子句可以处理如果它可捕获的异常类是抛出的异常类或者抛出异常类的父类。&lt;/p&gt;

&lt;p&gt;同样的，一个catch子句将会捕获任何其可捕获的异常类的实例(§15.20.2)。&lt;/p&gt;

&lt;p&gt;当有异常被抛出时，表达式(§15.6)和声明(§14.1)意外中止，控制权转移，直到遇到一个能处理这个异常的catch子句；继续执行catch块。导致异常的代码将不会恢复执行。&lt;/p&gt;

&lt;p&gt;所有的异常（同步或者异步）是精确的：当转换控制发生，在抛出异常之前的所有语句执行和表达式运算都会受到影响。表达式，语句，或其他部分在抛出异常后都不会被执行。&lt;/p&gt;

&lt;p&gt;如果优化代码期望在异常发生点之后执行一些表达式或者语句，这样的代码必须准备从程序的用户可见状态隐藏推测执行。&lt;/p&gt;

&lt;p&gt;如果没有可以处理这个异常的catch子句，那么当前线程（遇到异常的线程）终止。终止前，所有的finally语句将被执行，并且未被捕获的异常根据以下规则处理：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果当前线程有一个未被捕获的异常处理集，那么该处理程序被执行。&lt;/li&gt;
  &lt;li&gt;否则，当前线程的父线程ThreadGroup将调用方法uncaughtException。如果ThreadGroup和它的父类ThreadGroups没有重写uncaughtException方法，那么默认的处理程序uncaughtException方法将被调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在某此情况下可能需要确保一个代码块在另一个代码块之后始终被执行，即使另一个代码块意外中止，可以使用try语句的finally子句(§14.20.2)实现。&lt;/p&gt;

&lt;p&gt;如果try-finally或者try-catch-finally语句的一个try块或catch块意外中断，那么finally子句在异常传播的过程中执行，即使最终没有发现匹配的catch子句。&lt;/p&gt;

&lt;p&gt;如果一个finally子句由于try块的意外中断而执行，并且finally块自身执行时意外中断，那么try块意外中断的异常被丢弃，一个新的意外中断的异常从这里开始传播。&lt;/p&gt;

&lt;p&gt;意外中断和异常捕获的确切规则指定§14中每个语句详细描述以及§15（特别是§15.6）中的异常。&lt;/p&gt;

&lt;p&gt;Example 11.3-1. Throwing and Catching Exceptions&lt;/p&gt;

&lt;p&gt;下面的程序声明了一个异常类TestException。Test类的main方法调用了thrower四次，导致异常三次被抛出。方法中的try语句捕获了thrower抛出的每一个异常。无论thrower调用正常结束或者异常中断，都会打出一条消息，描述做了什么。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class TestException extends Exception {
	TestException() { super(); }
	TestException(String s) { super(s); }
}
class Test {
	public static void main(String[] args) {
		for (String arg : args) {
			try {
				thrower(arg);
				System.out.println(&quot;Test \&quot;&quot; + arg +
				&quot;\&quot; didn't throw an exception&quot;);
			} catch (Exception e) {
				System.out.println(&quot;Test \&quot;&quot; + arg +
				&quot;\&quot; threw a &quot; + e.getClass() +
				&quot;\n with message: &quot; +
				e.getMessage());
			}
		}
	}
	static int thrower(String s) throws TestException {
		try {
			if (s.equals(&quot;divide&quot;)) {
				int i = 0;
				return i/i;
			}
			if (s.equals(&quot;null&quot;)) {
				s = null;
				return s.length();
			}
			if (s.equals(&quot;test&quot;)) {
				throw new TestException(&quot;Test message&quot;);
			}
			return 0;
		} finally {
			System.out.println(&quot;[thrower(\&quot;&quot; + s + &quot;\&quot;) done]&quot;);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入4个参数执行程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;divide null not test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[thrower(&quot;divide&quot;) done]
Test &quot;divide&quot; threw a class java.lang.ArithmeticException
with message: / by zero
[thrower(&quot;null&quot;) done]
Test &quot;null&quot; threw a class java.lang.NullPointerException
with message: null
[thrower(&quot;not&quot;) done]
Test &quot;not&quot; didn't throw an exception
[thrower(&quot;test&quot;) done]
Test &quot;test&quot; threw a class TestException
with message: Test message
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;thrower方法的声明必须有一个throws子句，因为它可以抛出TestException检查异常类(§11.1.1)的实例。如果没有throws子句将会导致一个编译时错误。&lt;/p&gt;

&lt;p&gt;需要注意的是finally在每次thrower调用后都会执行，无论有没有异常抛出，就像每次调用后”[thrower(…) done]”输出。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>git权限管理工具gitolite使用教程</title>
   <link href="http://www.blogways.net/blog/2015/06/09/git-gitolite.html"/>
   <updated>2015-06-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/06/09/git-gitolite</id>
   <content type="html">&lt;h3 id=&quot;一gitolite实现功能&quot;&gt;一、gitolite实现功能&lt;/h3&gt;

&lt;p&gt;1.通过远程连接能够对服务器上仓库进行读写操作；&lt;/p&gt;

&lt;p&gt;2.安全的权限管理，控制特定用户只能访问仓库，并能限制读写权限;&lt;/p&gt;

&lt;p&gt;3.权限控制不只作用于仓库，而同样于仓库中的每个branch和tag name。&lt;/p&gt;

&lt;h3 id=&quot;二gitolite安装&quot;&gt;二、gitolite安装&lt;/h3&gt;
&lt;p&gt;Gitolite 是一款 Perl 语言开发的 Git 服务管理工具，通过公钥对用户进行认证，并能够通过配置文件对写操作进行基于分支和路径的的精细授权。Gitolite 采用的是 SSH 协议并且使用 SSH 公钥认证，以下为安装前提条件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	UNIX/LINUX操作系统
	shell环境
	git 1.6.6+
	perl 5.8.8+
	openssh 5.0+（好像低于这个版本也行）
	gitolite使用的账号（本文用的git）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;以git账号登入主机；&lt;/li&gt;
  &lt;li&gt;确保~/.ssh/authorized_keys为空或不存在；&lt;/li&gt;
  &lt;li&gt;主机上执行git clone  https://github.com/sitaramc/gitolite.git（不能上网可上传实现）；&lt;/li&gt;
  &lt;li&gt;mkdir -p /home/git/bin&lt;/li&gt;
  &lt;li&gt;./gitolite/install -to /home/git/bin/&lt;/li&gt;
  &lt;li&gt;选择一台机器作为client机器（我这里就选择本机），并将这台客户端机器的公钥上传并保存在主机的/home/git/YourName.pub（我这里用的我本机的，起名tangsz.pub）位置&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;~/bin/gitolite setup -pk ~/YourName.pub
8.测试安装是否成功&lt;/p&gt;

    &lt;p&gt;本机(windows要到git Bash下执行)执行ssh git@10.20.16.78显示如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  hello git, this is git@slave2 running gitolite3 v3.6.3-10-g4be7ac5-dt on git 1.8.1.6
 
  R W    gitolite-admin
  R W    testing
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：安装过程中可能出现的错误：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;/gitolite/install: /usr/bin/perl^M: bad interpreter: No such file or directory&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 解决:install 文件转unix格式
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;git describe failed; cannot deduce version number&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 解决：由于主机不能上网，我是把文件copy到主机，然后建立仓库的，这样不行，可以把本地下载的带.git目录的文件直接上传主机。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;WARNING: Can’t exec “/data/git/bin/triggers/post-compile/ssh-authkeys”: No such file or directory at /data/git/bin/lib/Gitolite/Common.pm line 146, &lt;DATA&gt; line 1.&lt;/DATA&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 解决：dos2unix /data/git/bin/triggers/post-compile/*
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ssh git@10.20.16.78 报错：WARNING: Can’t exec “/data/git/sbin/commands/info”: No such file or directory&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 解决：dos2unix /data/git/sbin/commands/info
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三gitolite添加用户和仓库&quot;&gt;三、gitolite添加用户和仓库&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;clone 管理仓库gitolite-admin（我本机操作）：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;git clone git@server-host:gitolite-admin （如：git clone git@10.20.16.78:gitolite-admin.git）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;gitolite-admin有conf和keydir两个子文件夹，keydir文件夹就是管理用户公钥的地方，如果有一位新用户（spdoop）希望申请账户并申请一个新的代码仓库（代码仓库叫做test），那么让他提供他的账号、他用的电脑的公钥给git管理员（可以通过email/qq等方式），然后由git管理员在keydir下创建spdoop.pub文件并将公钥内容复制其中。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;conf/gitolite.conf设置权限文件：&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

 		repo test
  			RW+ = spdoop

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;添加完配置后将本地仓库修改push到服务器仓库，服务会自动创建仓库test（当然这里也可以自己先到主机上建仓库，gitolite管理的仓库都在用户目录repositories下，也可修改配置），spdoop具有读写权限。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果想添加spdoop为管理员，需管理员tangsz修改gitolite.conf&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

 		repo gitolite-admin
 			RW+     =   git tangsz 
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：push过程中可能出现的错误：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. error: cannot run hooks/update: No such file or directory 解决方法： 此问题我是在windows机器传gitolite源码到linux机器上安装出现的，linux、mac不知道会不会出现，找了好久才发现要将update、post-update等文件dos2unix。具体命令，参考如下：

cd ~/.gitolite/hooks/common
dos2unix *
cd ~/.gitolite/hooks/gitolite-admin
dos2unix *
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四gitolite配置实例&quot;&gt;四、gitolite配置实例&lt;/h3&gt;

&lt;p&gt;这里对gitolite详细的权限配置就不做说明，通过一个简单的实例介绍下gitolite的使用：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;添加新的仓库pangu-la-web，管理员tangsz具有读写、强制push操作权限：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;修改gitolite.conf&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	repo pangu-la-web
 			RW+     =   tangsz
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提交本地仓库并push到服务器&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看主仓库已经建立空仓库pangu-la-web&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;本机clone下pangu-la-web仓库（git clone git@10.20.16.78:pangu-la-web）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;添加文件test，push到服务器仓库master分支&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户spdoop添加pangu-la-web中dev开头的分支有读/写/强制更新的权限，test分支（严格匹配）具有读/写权限&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;修改gitolite.conf&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  repo pangu-la-web
      RW+     =   tangsz
      RW+     dev       =   spdoop
      RW      test$     =   spdoop
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;提交并push到服务器仓库&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;spdoop clone pangu-la-web仓库到本地，修改test，执行git push origin master后错误如下（没有权限提交master）：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  remote: FATAL: W refs/heads/master pangu-la-web spdoop DENIED by fallthru
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;spdoop新建分支dev1（git branch dev1） checkout到dev1分支（git checkout dev1），执行git push origin dev1成功&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;spdoop新建分支test（git branch test） checkout到test分支（git checkout test），执行git push origin test成功&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;这里用户spdev试图clone仓库pangu-la-web（git clone git@10.20.16.78:pangu-la-web），出现错误如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    fatal: 'pangu-la-web' does not appear to be a git repository
    fatal: Could not read from remote repository.	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;五外部人员参与现有项目开发条件&quot;&gt;五、外部人员参与现有项目开发条件&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;保证本机电脑安装了git，windows下安装的是msysgit（windows安装后会生成git Bash命令窗口），其中git安装可以参阅本博客git篇；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命令窗口下生成用户公钥（windows下安装msysgit后在git Bash下生成），命令为：ssh-keygen，生成后在用户目录.ssh 下，文件名为id_rsa.pub；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;向项目仓库管理员申请操作某项目权限，将id_rsa.pub文件发给管理员，如开发员tom需要开发项目pangu-la-web，则需要邮件或qq等方式将id_rsa.pub发给管理员tangsz，并申明需要有pangu-la-web项目开发权限；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管理员会根据tom的权限为其赋予pangu-la-web项目特定权限（如只能新建dev开头的分支进行开发，不允许tom操作master分支），然后通过tom可以进行clone代码开发了；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tom接到通知后clone下pangu-la-web代码及可以进行开发了，clone命令为：git clone git@10.20.16.78:pangu-la-web  （windows下在git Bash 窗口执行）；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tom clone完代码后可以自己新建个分支如dev-tom（git branch dev-tom）进行开发，然后git checkout dev-tom，待功能开发完后push到dev-tom分支（git push origin dev-tom)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tom 在分支dev-tom上开发完后就可以通知管理员tom的功能点已经开发完了，申请合并到master分支；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;管理员接到tom通知后做合并处理。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>Java SE 7 Third Edition 规范翻译之－数组</title>
   <link href="http://www.blogways.net/blog/2015/06/01/jls7-3-10.html"/>
   <updated>2015-06-01T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/06/01/jls7-3-10</id>
   <content type="html">&lt;h1 id=&quot;java-se-7-third-edition-规范翻译之数组&quot;&gt;Java SE 7 Third Edition 规范翻译之－数组&lt;/h1&gt;

&lt;p&gt;在 Java 编程语言中，数组是动态创建的对象(§4.3.1)，并且可以分配给 Object 类型的变量。类对象的所有方法可以基于数组调用。&lt;/p&gt;

&lt;p&gt;一个数组对象包含特定数值个变量。这个数值可以是0，但如果这也就意味着数组为空。数组中的变量没有变量名；相反他们通过使用非负整数索引值来访问数组引用的表达式。假设一个数组拥有n个元素，那么我们说这个数组的长度就是n；数组的这些元素使用整数下标引用从0到n-1。&lt;/p&gt;

&lt;p&gt;数组内所有的元素拥有统一的类型，称为数组的元素类型。假设数组的元素类型是T，那么这个类型的数组定义成T[]。&lt;/p&gt;

&lt;p&gt;对于浮点数类型的数组元素始终是浮点数类型值集(§4.2.3)；同样的，对于双精度类型的数组元素始终是双精度类型值集。不允许浮点数类型的数组的元素不是浮点数类型的值集，同样不允许双精度类型的数组的元素不是双精度类型的值集。&lt;/p&gt;

&lt;p&gt;一个数组元素类型的本身可以是数组类型。这种数组元素可以包含子数组的引用。假设开始于任何数组类型，考虑到其元素类型，然后子数组的元素类型，以至类推，最终必须有子数组的元素类型不是数组类型；这个就是原始数组的元素类型，并且这一层的数组结构的元素被称为原始数组。&lt;/p&gt;

&lt;p&gt;在某些情况下，一个数组的元素可以是一个数组：当这个元素的类型是对象或者Cloneable或者java.io.Serializable，那么部分或者所有的元素均可以是数组，因为任何数组对象都可以指定这些类型的变量。&lt;/p&gt;

&lt;h2 id=&quot;101-array-types&quot;&gt;10.1 Array Types&lt;/h2&gt;

&lt;p&gt;数组类型用于声明和映射表达式中(§15.16)。&lt;/p&gt;

&lt;p&gt;数组类型写法遵循一个元素类型后面跟一些空的方括号[]。方括号的数量表示数组的维度。&lt;/p&gt;

&lt;p&gt;数组的长度不是类型的一部分。&lt;/p&gt;

&lt;p&gt;数组元素的类型可以是任意类型，是原始数据类型或者引用类型。特别是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;数组拥有一个接口类型作为允许的元素类型。该数组元素可以是它的值的空引用或者任意实现该接口的类型实例。&lt;/li&gt;
  &lt;li&gt;数组允许一个抽象类做为其元素类型。该数组的元素可以是它的值的空引用或者是抽象类实现子类的实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;数组类型的父类型在§4.10.3规定。
数组类型的父类是Object。
每一个数组都实现了Cloneable和java.io.Serializable接口。&lt;/p&gt;

&lt;h2 id=&quot;102-array-variables&quot;&gt;10.2 Array Variables&lt;/h2&gt;

&lt;p&gt;数组类型的变量是一个对象的引用。声明数组类型的变量但不创建数组对象或者说不给数组元素分配任何内存空间，那么它只创建变量本身，变量包含一个数组引用。然而声明初始化部分(§8.3, §9.3, §14.4.1)可以创建一个数组，数组的引用将成为该变量的初始值。&lt;/p&gt;

&lt;p&gt;Example 10.2-1. Declarations of Array Variables&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int[] ai; // array of int
short[][] as; // array of array of short
short s, // scalar short
aas[][]; // array of array of short
Object[] ao, // array of Object
otherAo; // array of Object
Collection&amp;lt;?&amp;gt;[] ca; // array of Collection of unknown type
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的定义没有创建数组对象。下面举例说明几个创建数组对象的数组变量声明方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception ae[] = new Exception[3];
Object aao[][] = new Exception[2][3];
int[] factorial = { 1, 1, 2, 6, 24, 120, 720, 5040 };
char ac[] = { 'n', 'o', 't', ' ', 'a', ' ',
'S', 't', 'r', 'i', 'n', 'g' };
String[] aas = { &quot;array&quot;, &quot;of&quot;, &quot;String&quot;, };
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;[]可以出现在声明类型开始部分，或者也可以出现在声明的变量部分，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;byte[] rowvector, colvector, matrix[];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等价于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;byte rowvector[], colvector[], matrix[][];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在变量声明(§8.3, §8.4.1, §9.3, §14.14, §14.20)时除了一个可变的参数，在声明开头就要指定变量的数组类型，后面跟着变量标识符以及中括号。&lt;/p&gt;

&lt;p&gt;例如，局部变量声明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a, b[], c[][];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等价于一系列的声明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int a;
int[] b;
int[][] c;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;声明时使用中括号也是C和C++的传统，一般为变量声明的规则。但是Java允许中括号出现在类型或者声明部分，所以局部变量可以这样定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;float[][] f[][], g[][][], h[]; // Yechh!
is equivalent to the series of declarations:
float[][][][] f;
float[][][][][] g;
float[][][] h;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们不推荐在数组变量定义部分使用“混合标记”，即中括号既出现在类型部分又出现在声明部分。&lt;/p&gt;

&lt;p&gt;一旦数组对象被创建，它的长度不会发生变化。为了让数组变量指向一个不同长度的数组，必须要将这个不同长度数组的引用赋给这个变量。&lt;/p&gt;

&lt;p&gt;数组类型的单个变量包含对不同长度数组的引用，因为这个数组的长度不属于其类型的一部分。&lt;/p&gt;

&lt;p&gt;假设一个数组变量v拥有A[]类型，其中A是引用类型，然后v可以持有任意数组类型B[]的一个实例的引用，假设B可以被分配给A(§5.2)。这可能会导致以后的任务运行时异常；详见§10.5。&lt;/p&gt;

&lt;h2 id=&quot;103-array-creation&quot;&gt;10.3 Array Creation&lt;/h2&gt;

&lt;p&gt;创建一个数组通过数组创建表达式(§15.10)或者数组初始化。&lt;/p&gt;

&lt;p&gt;数组创建表达式中指定元素类型，嵌套数组的维度，至少一个嵌套数组的长度。数组的长度可作为最终实例变量的长度。&lt;/p&gt;

&lt;p&gt;数组初始化创建一个数组，并提供所有元素的初始值。&lt;/p&gt;

&lt;h2 id=&quot;104-array-access&quot;&gt;10.4 Array Access&lt;/h2&gt;

&lt;p&gt;数组元素的访问通过数组访问表达式(§15.13)，表达式由数组的引用后跟[]括起来的索引值，如A[i]。&lt;/p&gt;

&lt;p&gt;所有的数组都是从0开始，长度为n的数组可以通过整数0至n-1来索引。&lt;/p&gt;

&lt;p&gt;Example 10.4-1. Array Access&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Gauss {
	public static void main(String[] args) {
		int[] ia = new int[101];
		for (int i = 0; i &amp;lt; ia.length; i++) ia[i] = i;
		int sum = 0;
		for (int e : ia) sum += e;
		System.out.println(sum);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个程序的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;5050
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个程序定义了一个int数组类型的变量ia，即int[]。变量ia被初始化为一个新创建数组对象的引用，由数组创建表达式创建(§15.10)。数组创建表达式指定数组应该有101个元素。数组的长度是可以使用的字段长度，如上所示。程序使用0－100填充数组，最终将这些整数求和，并且打印出结果。&lt;/p&gt;

&lt;p&gt;数组必须被int类型值索引；short,byte,或者char值也可以用作索引值，因为他们可以转换成int类型值。&lt;/p&gt;

&lt;p&gt;企图通过long值索引访问数组将导致编译时错误。&lt;/p&gt;

&lt;p&gt;所有数组访问在运行时检查；企图使用小于0或者大于等于实际数组长度的索引将会抛出ArrayIndexOutOfBoundsException异常。&lt;/p&gt;

&lt;h2 id=&quot;105-array-store-exception&quot;&gt;10.5 Array Store Exception&lt;/h2&gt;

&lt;p&gt;对于一个类型为A[]的数组，其中A即为引用类型，给数组元素赋值将在运行时检查以确保分配给元素的值符合数组元素类型。&lt;/p&gt;

&lt;p&gt;如果分配的值与数组元素的类型不兼容(§5.2)将抛出ArrayStoreException异常。&lt;/p&gt;

&lt;p&gt;如果数组的元素类型不是具体化类型，Java虚拟机将不能执行前面段落描述的存储检查。这就是为什么数组创建表达式禁止使用非具体化元素类型(§15.10)。可以声明一个数组元素类型为非具体化类型的变量，但数组变量创建表达式的结果必将导致一个非检查告警(§5.1.9)。&lt;/p&gt;

&lt;p&gt;Example 10.5-1. ArrayStoreException&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Point { int x, y; }
class ColoredPoint extends Point { int color; }
class Test {
	public static void main(String[] args) {
		ColoredPoint[] cpa = new ColoredPoint[10];
		Point[] pa = cpa;
		System.out.println(pa[1] == null);
		try {
			pa[0] = new Point();
		} catch (ArrayStoreException e) {
			System.out.println(e);
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个程序的输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true
java.lang.ArrayStoreException: Point
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;变量pa为Point[]类型，变量cpa的值是ColoredPoint[]类型的一个引用。一个ColoredPoint对象能转成为一个Point对象；因此cpa的值可以赋给pa。&lt;/p&gt;

&lt;p&gt;参考这个数组pa，例如，测试pa[1]是否为空，不会导致一个运行时类型错误。这是因为数组元素的类型ColoredPoint[]是ColoredPoint，每个ColoredPoint都能代替Point，因为Point是ColoredPoint的父类。&lt;/p&gt;

&lt;p&gt;另一方面，分配数组pa可能导致运行时错误。在编译时，分配到pa的元素被检查以确保分配的值是一个Point。但由于pa指向一个ColoredPoint数组的引用，只有运行时分配该类型的值时该分配才是有效的，更具体的说，即ColoredPoint。Java虚拟机在运行时会检查这样的情况确保分配是有效的；如果不是将抛出一个ArrayStoreException异常。&lt;/p&gt;

&lt;h2 id=&quot;106-array-initializers&quot;&gt;10.6 Array Initializers&lt;/h2&gt;

&lt;p&gt;数组初始化可以在声明时指定(§8.3, §9.3, §14.4)，或者作为一个数组创建表达式的一部分(§15.10)，创建一个数组并提供一些初始值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ArrayInitializer:
{ VariableInitializersopt ,opt }
VariableInitializers:
VariableInitializer
VariableInitializers , VariableInitializer
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下重复§8.3，介绍更详细：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;VariableInitializer:
Expression
ArrayInitializer
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;数组初始化写成一个逗号分隔的表达式列表，使用大括号封装。&lt;/p&gt;

&lt;p&gt;数组初始化时最后一个表达式后面的逗号将被忽略。&lt;/p&gt;

&lt;p&gt;每个变量初始化赋值必须兼容数组的元素类型，否则将会出现一个编译时错误。&lt;/p&gt;

&lt;p&gt;如果数组元素类型初始化时没有指定具体的类型将会出现编译时错误(§4.7)。&lt;/p&gt;

&lt;p&gt;数组的长度等于数组初始化时大括号里面变量的个数。虚拟机将为这个新数组分配这个长度的空间。如果没有足够的空间分配给这个数组，数组初始化意外终止并抛出OutOfMemoryError错误。否则一个一维特定长度的数组将被创建，并且每个数组的元素都被初始化为其默认值(§4.12.5)。&lt;/p&gt;

&lt;p&gt;变量的初始化立即由数组初始化设定的括号按源码从左到右执行。第n个变量初始化指定数组第n-1个元素的值。如果执行变量初始化意外中止，整个数组的初始化也将以同样的原因意外中止。如果所有的变量初始化表达式正常完成，那么数组初始化正常完成，一个有值的新初始化的数组诞生了。&lt;/p&gt;

&lt;p&gt;如果一个数组元素类型为数组类型，则变量初始化时指定元素本身就是一个数组初始化的过程；也就是说，数组初始化是可以嵌套的。在这种情况下，执行嵌套数组初始化构造和通过递归算法初始化一个数组对象，并将其分配给元素。&lt;/p&gt;

&lt;p&gt;Example 10.6-1. Array Initializers&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test {
	public static void main(String[] args) {
		int ia[][] = { {1, 2}, null };
		for (int[] ea : ia) {
			for (int e: ea) {
				System.out.println(e);
			}
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;程序输出：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1
2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;试图索引到数组ia的第二个空引用元素导致NullPointerException异常。&lt;/p&gt;

&lt;h2 id=&quot;107-array-members&quot;&gt;10.7 Array Members&lt;/h2&gt;

&lt;p&gt;数组类型的成员有如下几种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;公共的final字段length，表明数组元素的数量，length 是0或者正整数。&lt;/li&gt;
  &lt;li&gt;公共的方法clone，重写了Object类的clone方法，并且抛出没有检查异常。数组T[] clone方法的返回类型还是T[]。一个多维数组的克隆是浅拷贝，那就是说它只创建了一个新数组，子数组共享。&lt;/li&gt;
  &lt;li&gt;所有的方法继承自Object类；唯一没有继承Object类的方法就是它的clone方法。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在下面的类中数组因此拥有同样的公共字段和方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A&amp;lt;T&amp;gt; implements Cloneable, java.io.Serializable {
	public final int length = X ;
	public T[] clone() {
		try {
			return (T[])super.clone(); // unchecked warning
		} catch (CloneNotSupportedException e) {
			throw new InternalError(e.getMessage());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是在上面的示例中，如果数组真是这样实现的话将会产生一个非检查警告(§5.1.9)&lt;/p&gt;

&lt;p&gt;另一种情况见§9.6.3.4，对象的公共方法和非公共方法的区别，需要特别小心。&lt;/p&gt;

&lt;p&gt;Example 10.7-1. Arrays Are Cloneable&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test1 {
	public static void main(String[] args) {
		int ia1[] = { 1, 2 };
		int ia2[] = ia1.clone();
		System.out.print((ia1 == ia2) + &quot; &quot;);
		ia1[1]++;
		System.out.println(ia2[1]);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;程序执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;表明ia1和ia2变量分别引用了两个不同的数组。&lt;/p&gt;

&lt;p&gt;实际上当一个多维数组被克隆时子数组是共享的，看这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test2 {
	public static void main(String[] args) throws Throwable {
		int ia[][] = { {1,2}, null };
		int ja[][] = ia.clone();
		System.out.print((ia == ja) + &quot; &quot;);
		System.out.println(ia[0] == ja[0] &amp;amp;&amp;amp; ia[1] == ja[1]);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;程序执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果显示ia[0]数组跟ja[0]是同一个数组。&lt;/p&gt;

&lt;p&gt;##10.8 Class Objects for Arrays
每个数组都有一个关联的类对象，跟所有其他的数组共享同样的元素类型。&lt;/p&gt;

&lt;p&gt;Example 10.8-1. Class Object Of Array&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test {
	public static void main(String[] args) {
		int[] ia = new int[3];
		System.out.println(ia.getClass());
		System.out.println(ia.getClass().getSuperclass());
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;程序输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class [I
class java.lang.Object
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里面的字符串”[I”是int类型数组类对象在运行时的类型签名。&lt;/p&gt;

&lt;p&gt;Example 10.8-2. Array Class Objects Are Shared&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Test {
	public static void main(String[] args) {
		int[] ia = new int[3];
		int[] ib = new int[6];
		System.out.println(ia.getClass() == ib.getClass());
		System.out.println(&quot;ia has length=&quot; + ia.length);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个程序输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true
ia has length=3
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该程序使用继承自Object的getClass方法，和length属性。第一个println打印两个数组类对象比较结果，结果说明所有int类型的数组都是int[]的实例。&lt;/p&gt;

&lt;h2 id=&quot;109-an-array-of-characters-is-not-a-string&quot;&gt;10.9 An Array of Characters is Not a String&lt;/h2&gt;

&lt;p&gt;与C语言不同，在Java编程语言中，char数组即不是字符串也不是一个以’\u0000’ (the NUL character)结尾的字符数组。&lt;/p&gt;

&lt;p&gt;一个字符串对象是不可变的，也就是说它的内容不会改变，而char数组元素是可变的。&lt;/p&gt;

&lt;p&gt;在String类中toCharArray方法返回一个包含字符串相同字符序列的字符数组。StringBuffer类实现了可变字符数组的有效方法。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（六）－API 操作</title>
   <link href="http://www.blogways.net/blog/2015/05/07/solr-usage-6.html"/>
   <updated>2015-05-07T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/07/solr-usage-6</id>
   <content type="html">&lt;p&gt;前面几节我们对 Solr 的运行有了个大概的了解，本文将介绍如何通过操作 API 来实现前面 web 控制台演示的那些功能的。&lt;/p&gt;
&lt;h3 id=&quot;创建-java-项目&quot;&gt;创建 Java 项目&lt;/h3&gt;
&lt;p&gt;使用 eclipse 新建一个 Java 项目，导入 apache-tomcat-7.0.42\webapps\solr\WEB-INF\lib 下面所有的 jar 包，再添加一个 junit4.8.1 的 jar 包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-6-1.png&quot; alt=&quot;Solr 工程导入的 jar 包&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;新建一个测试类&quot;&gt;新建一个测试类&lt;/h3&gt;
&lt;p&gt;废话不多说，直接上代码，API 操作还是比较简单的，就不分开说了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;SolrTest.java&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

import org.apache.solr.client.solrj.SolrClient;
import org.apache.solr.client.solrj.SolrQuery;
import org.apache.solr.client.solrj.SolrQuery.ORDER;
import org.apache.solr.client.solrj.SolrServerException;
import org.apache.solr.client.solrj.impl.HttpSolrClient;
import org.apache.solr.client.solrj.response.FacetField;
import org.apache.solr.client.solrj.response.FacetField.Count;
import org.apache.solr.client.solrj.response.QueryResponse;
import org.apache.solr.common.SolrDocument;
import org.apache.solr.common.SolrDocumentList;
import org.apache.solr.common.SolrInputDocument;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

public class SolrTest {

	private static String url = &quot;http://localhost:8080/solr/test&quot;;
	private SolrClient client;

	@Before
	public void init() {
		client = new HttpSolrClient(url);
	}

	@After
	public void destroy() {
		client = null;
	}

	// 单文档插入
	public void addDoc() throws Exception {
		SolrInputDocument doc = new SolrInputDocument();
		doc.addField(&quot;id&quot;, 10000001);
		doc.addField(&quot;name&quot;, &quot;Solr Input Document&quot;);
		doc.addField(&quot;manu&quot;, &quot;this is SolrInputDocument content&quot;);

		client.add(doc);
		client.commit();
	}

	// 批量文档插入
	public void addDocList() throws Exception {
		Collection&amp;lt;SolrInputDocument&amp;gt; docs = new ArrayList&amp;lt;SolrInputDocument&amp;gt;();
		for (int i = 1; i &amp;lt; 11; i++) {
			SolrInputDocument doc = new SolrInputDocument();
			doc.addField(&quot;id&quot;, 1000000 + i);
			doc.addField(&quot;name&quot;, &quot;batch solr document insert &quot; + i);
			doc.addField(&quot;manu&quot;, &quot;batch solr document content insert &quot; + i);
			docs.add(doc);
		}

		client.add(docs);
		client.commit();
	}

	@Test
	// 单个文档对应的 Java Bean 插入
	public void addDocBean() throws Exception {
		Index doc = new Index();
		doc.setId(&quot;100000000&quot;);
		doc.setName(&quot;add bean document&quot;);
		doc.setManu(&quot;index bean manu 中文测试&quot;);
		doc.setCat(new String[] { &quot;a1&quot;, &quot;b2&quot; });

		client.addBean(doc);
		client.commit();
	}

	// 批量文档 Bean 插入
	public void addDocBeanList() throws Exception {
		Collection&amp;lt;Index&amp;gt; docs = new ArrayList&amp;lt;Index&amp;gt;();
		for (int i = 1; i &amp;lt; 11; i++) {
			Index doc = new Index();
			doc.setId(&quot;10000000&quot; + i);
			doc.setName(&quot;add bean document &quot; + i);
			doc.setManu(&quot;bean document manu &quot; + i);
			docs.add(doc);
		}

		client.addBeans(docs);
		client.commit();
	}

	// 根据 id 删除单个文档
	public void remove() throws Exception {
		client.deleteById(&quot;100000000&quot;);
		client.commit();
	}

	// 根据批量 id 删除文档
	public void removeList() throws Exception {
		List&amp;lt;String&amp;gt; ids = new ArrayList&amp;lt;String&amp;gt;();
		for (int i = 1; i &amp;lt; 6; i++) {
			ids.add(&quot;10000000&quot; + i);
		}

		client.deleteById(ids);
		client.commit();
	}

	// 根据查询条件删除文档
	public void removeByQuery() throws Exception {
		client.deleteByQuery(&quot;id:100000007&quot;);
		client.commit();
	}

	// 查询操作
	public void queryAll() throws Exception {
		SolrQuery query = new SolrQuery();
		query.set(&quot;q&quot;, &quot;*:*&quot;);
		query.setStart(0);
		query.setRows(Integer.MAX_VALUE);
		// query.set(&quot;start&quot;, 0);
		// query.set(&quot;row&quot;, Integer.MAX_VALUE);
		query.set(&quot;id&quot;, &quot;id desc&quot;);
		query.set(&quot;fl&quot;, &quot;*, score&quot;);

		QueryResponse response = client.query(query);

		SolrDocumentList docs = response.getResults();

		for (SolrDocument doc : docs) {
			log(doc);
		}
	}

	// 一些附属操作
	public void otherMethod() throws Exception {
		client.getBinder();
		client.optimize(); // 合并索引文件，可以优化索引、提供性能，但需要一定的时间
		client.ping(); // ping服务器是否连接成功
		client.rollback();
		client.commit();
	}

	// query 基本用法测试
	public void queryCase() {
		// AND 并且
		SolrQuery params = new SolrQuery(&quot;name:apple AND manu:inc&quot;);

		// OR 或者
		params.setQuery(&quot;name:apple OR manu:apache&quot;);
		// 空格 等同于 OR
		params.setQuery(&quot;name:server manu:dell&quot;);

		// params.setQuery(&quot;name:solr - manu:inc&quot;);
		// params.setQuery(&quot;name:server + manu:dell&quot;);

		// 查询name包含solr apple
		params.setQuery(&quot;name:solr,apple&quot;);
		// manu不包含inc
		params.setQuery(&quot;name:solr,apple NOT manu:inc&quot;);

		// 50 &amp;lt;= price &amp;lt;= 200
		params.setQuery(&quot;price:[50 TO 200]&quot;);
		params.setQuery(&quot;popularity:[5 TO 6]&quot;);

		// 50 &amp;lt;= price &amp;lt;= 200 AND 5 &amp;lt;= popularity &amp;lt;= 6
		params.setQuery(&quot;price:[50 TO 200] AND popularity:[5 TO 6]&quot;);
		params.setQuery(&quot;price:[50 TO 200] OR popularity:[5 TO 6]&quot;);

		// 过滤器查询，可以提高性能 filter 类似多个条件组合，如and
		// params.addFilterQuery(&quot;id:VA902B&quot;);
		// params.addFilterQuery(&quot;price:[50 TO 200]&quot;);
		// params.addFilterQuery(&quot;popularity:[* TO 5]&quot;);
		// params.addFilterQuery(&quot;weight:*&quot;);
		// 0 &amp;lt; popularity &amp;lt; 6 没有等于
		// params.addFilterQuery(&quot;popularity:{0 TO 6}&quot;);

		// 排序
		params.addSort(&quot;id&quot;, ORDER.asc);

		// 分页：start开始页，rows每页显示记录条数
		// params.add(&quot;start&quot;, &quot;0&quot;);
		// params.add(&quot;rows&quot;, &quot;200&quot;);
		// params.setStart(0);
		// params.setRows(200);

		// 设置高亮
		params.setHighlight(true); // 开启高亮组件
		params.addHighlightField(&quot;name&quot;);// 高亮字段
		params.setHighlightSimplePre(&quot;&amp;lt;font color='red'&amp;gt;&quot;);// 标记，高亮关键字前缀
		params.setHighlightSimplePost(&quot;&amp;lt;/font&amp;gt;&quot;);// 后缀
		params.setHighlightSnippets(1);// 结果分片数，默认为1
		params.setHighlightFragsize(1000);// 每个分片的最大长度，默认为100

		// 分片信息
		params.setFacet(true).setFacetMinCount(1).setFacetLimit(5)// 段
				.addFacetField(&quot;name&quot;)// 分片字段
				.addFacetField(&quot;inStock&quot;);

		// params.setQueryType(&quot;&quot;);

		try {
			QueryResponse response = client.query(params);

			/*
			 * List&amp;lt;Index&amp;gt; indexs = response.getBeans(Index.class); for (int i =
			 * 0; i &amp;lt; indexs.size(); i++) { fail(indexs.get(i)); }
			 */

			// 输出查询结果集
			SolrDocumentList list = response.getResults();
			log(&quot;query result nums: &quot; + list.getNumFound());
			for (int i = 0; i &amp;lt; list.size(); i++) {
				log(list.get(i));
			}

			// 输出分片信息
			List&amp;lt;FacetField&amp;gt; facets = response.getFacetFields();
			for (FacetField facet : facets) {
				log(facet);
				List&amp;lt;Count&amp;gt; facetCounts = facet.getValues();
				for (FacetField.Count count : facetCounts) {
					System.out.println(count.getName() + &quot;: &quot;
							+ count.getCount());
				}
			}
		} catch (SolrServerException e) {
			e.printStackTrace();
		}
	}

	// 分片查询， 可以统计关键字及出现的次数、或是做自动补全提示
	public void facetQueryCase() {
		SolrQuery params = new SolrQuery(&quot;*:*&quot;);

		// 排序
		params.addSort(&quot;id&quot;, ORDER.asc);

		params.setStart(0);
		params.setRows(200);

		// Facet为solr中的层次分类查询
		// 分片信息
		params.setFacet(true).setQuery(&quot;*:*&quot;).setFacetMinCount(1)
				.setFacetLimit(5)	// 段
				// .setFacetPrefix(&quot;electronics&quot;, &quot;cat&quot;)
				.setFacetPrefix(&quot;cor&quot;)	// 查询manu、name中关键字前缀是cor的
				.addFacetField(&quot;manu&quot;).addFacetField(&quot;name&quot;);	// 分片字段

		try {
			QueryResponse response = client.query(params);

			// 输出查询结果集
			SolrDocumentList list = response.getResults();
			log(&quot;Query result nums: &quot; + list.getNumFound());

			for (int i = 0; i &amp;lt; list.size(); i++) {
				log(list.get(i));
			}

			log(&quot;All facet filed result: &quot;);
			// 输出分片信息
			List&amp;lt;FacetField&amp;gt; facets = response.getFacetFields();
			for (FacetField facet : facets) {
				log(facet);
				List&amp;lt;Count&amp;gt; facetCounts = facet.getValues();
				for (FacetField.Count count : facetCounts) {
					// 关键字 - 出现次数
					log(count.getName() + &quot;: &quot; + count.getCount());
				}
			}

			log(&quot;Search facet [name] filed result: &quot;);
			// 输出分片信息
			FacetField facetField = response.getFacetField(&quot;name&quot;);
			List&amp;lt;Count&amp;gt; facetFields = facetField.getValues();
			for (Count count : facetFields) {
				// 关键字 - 出现次数
				log(count.getName() + &quot;: &quot; + count.getCount());
			}
		} catch (SolrServerException e) {
			e.printStackTrace();
		}
	}

	private void log(Object obj) {
		System.out.println(obj);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;里面用到一个 java bean &lt;code class=&quot;highlighter-rouge&quot;&gt;Index.java&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import org.apache.solr.client.solrj.beans.Field;

public class Index {  
    @Field  
    private String id;  
    @Field
    private String name;  
    @Field  
    private String manu;  
    @Field  
    private String[] cat;  
    @Field  
    private String[] features;  
    @Field  
    private float price;  
    @Field  
    private int popularity;  
    @Field  
    private boolean inStock;  
      
    public String getId() {  
        return id;  
    }  
      
    @Field  
    public void setId(String id) {  
        this.id = id;  
    }  
   
    public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getManu() {
		return manu;
	}

	public void setManu(String manu) {
		this.manu = manu;
	}

	public String[] getCat() {
		return cat;
	}

	public void setCat(String[] cat) {
		this.cat = cat;
	}

	public String[] getFeatures() {
		return features;
	}

	public void setFeatures(String[] features) {
		this.features = features;
	}

	public float getPrice() {
		return price;
	}

	public void setPrice(float price) {
		this.price = price;
	}

	public int getPopularity() {
		return popularity;
	}

	public void setPopularity(int popularity) {
		this.popularity = popularity;
	}

	public boolean isInStock() {
		return inStock;
	}

	public void setInStock(boolean inStock) {
		this.inStock = inStock;
	}

	public String toString() {  
        return this.id + &quot;#&quot; + this.name + &quot;#&quot; + this.manu + &quot;#&quot; + this.cat;  
    }  
}  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（五）－中文分词</title>
   <link href="http://www.blogways.net/blog/2015/05/06/solr-usage-5.html"/>
   <updated>2015-05-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/06/solr-usage-5</id>
   <content type="html">&lt;p&gt;上一节我们在演示查询的时候只使用一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;title:step&lt;/code&gt; 就查出了所有 title 包含 step 的记录，感觉有点类似数据库的 like 功能，主要是分词的匹配的原因，实际上分词匹配功能要远强于 sql 的 like 功能。既然分词这么重要在国内使用那肯定离不开中文分词，本文介绍如何配置使用（smartcn）&lt;/p&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;solr5.0 默认的分词器是一元分词器，这个本来就是对英文进行分词的，英文大部分就是典型的根据空格进行分词，而中文如果按照这个规则，那么显然是要有很多的冗余词被分出来，一些没有用的虚词，数词，都会被分出来，影响效率不说，关键是分词效果不好，所以可以利用 solr 的同步发行包 smartcn 进行中文切词，smartcn 的分词准确率不错，但就是不能自己定义新的词库，不过 smartcn 是跟 solr 同步的，所以不需要额外的下载，只需在 solr 的例子中拷贝进去即可，下面给出路径图和安装 solr5.0 的 smartcn 分词过程&lt;/p&gt;

&lt;p&gt;无论安装那种分词器，大部分都有2个步骤&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;拷贝jar包到solr的lib中&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 将 `solr-5.0.0\server\solr\test\contrib\analysis-extras\lucene-libs\lucene-analyzers-smartcn-5.0.0.jar` 拷贝到 `solr-5.0.0\server\solr\test\contrib\analysis-extras\lib` 目录下
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改相关配置&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;solr-500serversolrtestconfsolrconfigxml&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0\server\solr\test\conf\solrconfig.xml&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- annotating for smartcn, replaced by the blow config
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/extraction/lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-cell-\d.*\.jar&quot; /&amp;gt;

  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/clustering/lib/&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-clustering-\d.*\.jar&quot; /&amp;gt;

  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/langid/lib/&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-langid-\d.*\.jar&quot; /&amp;gt;

  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/velocity/lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;
  &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-velocity-\d.*\.jar&quot; /&amp;gt;
  --&amp;gt;
  
&amp;lt;!-- smartcn config, instead of the previous code --&amp;gt;
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\analysis-extras\lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\extraction\lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-cell-\d.*\.jar&quot; /&amp;gt;  
  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\clustering\lib\&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-clustering-\d.*\.jar&quot; /&amp;gt;  
  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\langid\lib\&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-langid-\d.*\.jar&quot; /&amp;gt;  
  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\contrib\velocity\lib&quot; regex=&quot;.*\.jar&quot; /&amp;gt;  
&amp;lt;lib dir=&quot;E:\tools\solr-5.0.0\server\solr\test\dist\&quot; regex=&quot;solr-velocity-\d.*\.jar&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;solr-500serversolrtestconfschemaxml&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0\server\solr\test\conf\schema.xml&lt;/code&gt;&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;!-- Smartcn --&amp;gt;
&amp;lt;fieldType name=&quot;text_smartcn&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;0&quot;&amp;gt;  
  &amp;lt;analyzer type=&quot;index&quot;&amp;gt;  
    &amp;lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseSentenceTokenizerFactory&quot;/&amp;gt;  
    &amp;lt;filter class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseWordTokenFilterFactory&quot;/&amp;gt;  
		&amp;lt;/analyzer&amp;gt;  
  &amp;lt;analyzer type=&quot;query&quot;&amp;gt;  
     &amp;lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseSentenceTokenizerFactory&quot;/&amp;gt;  
    &amp;lt;filter class=&quot;org.apache.lucene.analysis.cn.smart.SmartChineseWordTokenFilterFactory&quot;/&amp;gt;  
  &amp;lt;/analyzer&amp;gt;  
&amp;lt;/fieldType&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将需要使用中文分词的字段类型改成 &lt;code class=&quot;highlighter-rouge&quot;&gt;text_smartcn&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;field name=&quot;goods_name&quot; type=&quot;text_smartcn&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后来验证下中文分词安装是否成功&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-5-1.png&quot; alt=&quot;Web 控制台 中文分词测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;除了中文分词，另外还有一个拼音分词，这个网上可以搜到，需要下载一个 jar 包，其他配置、使用都跟上面类似，有兴趣的可以自己去试下。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（四）－企业应用</title>
   <link href="http://www.blogways.net/blog/2015/05/05/solr-usage-4.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/solr-usage-4</id>
   <content type="html">&lt;p&gt;通过前面几节的了解，我们对 solr 有了一些了解，对一些基本概念、语法也有了初步的认识，那么很多没有接触过搜索引擎的小伙伴可能会问，这东西到底有什么用，在自己的项目中能发挥什么作用，结合我们自己的项目，简要做个演示。&lt;/p&gt;
&lt;h3 id=&quot;需求分析&quot;&gt;需求分析&lt;/h3&gt;
&lt;p&gt;相信很多人都用过类似淘宝或者京东的产品搜索功能，输入想要查找的商品，点搜索很快列出一堆你想要的东东，我们的产品也想实现这个功能。&lt;/p&gt;

&lt;p&gt;我们都知道数据库的瓶颈主要在 IO 这块，虽然通过分库分表能分担一部分负载，但当网站访问量比较大的时候，不应该也不可能搜索一次都去执行一次数据库 IO 操作，这个时候 Solr 也就派上用途了，我们可以通过将产品相关数据刷到 Solr 的搜索实例中，通过 Solr 应用服务器对外提供 Rest 查询接口，定时去更新数据，刷新搜索索引，这样就大大降低了查询数据库服务器的压力。&lt;/p&gt;

&lt;h3 id=&quot;数据导入&quot;&gt;数据导入&lt;/h3&gt;
&lt;p&gt;那么问题来了，如果将数据库相关数据导入搜索实例中呢？前面我们使用了 &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/post&lt;/code&gt; 将 json 文档直接导入搜索实例，接下来我们看下如何将 mysql 中表数据导入到搜索实例中。&lt;/p&gt;

&lt;h4 id=&quot;使用dihdataimporthandler从数据库导入数据&quot;&gt;&lt;em&gt;使用DIH(DataImportHandler)从数据库导入数据&lt;/em&gt;&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;首先数据库准备一张表&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; CREATE TABLE `comment` (
     `id` INT(11) NULL DEFAULT NULL,
     `writetime` VARCHAR(50) NULL DEFAULT NULL,
     `title` VARCHAR(500) NULL DEFAULT NULL
 )
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;往表里面插入几条测试数据&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10001, '2015-04-11', 'Step 1: Set up a personal account');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10002, '2015-04-12', 'Step 2: Choose your plan');
 INSERT INT3 `test`.`comment` (`id`, `writetime`, `title`) VALUES (10003, '2015-04-13', 'Step 3: Go to your dashboard');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10004, '2015-04-14', 'There were problems creating your account.');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10005, '2015-04-15', 'You will occasionally receive account related emails. We promise not to share your email with anyone.');
 INSERT INTO `test`.`comment` (`id`, `writetime`, `title`) VALUES (10006, '2015-04-16', 'Use at least one lowercase letter, one numeral, and seven characters.');
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;导入相关jar包
 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0/server/solr/test/conf/solrconfig.xml&lt;/code&gt; 加入如下代码&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-dataimporthandler-.*\.jar&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置handler
 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0/server/solr/test/conf/solrconfig.xml&lt;/code&gt; 加入如下代码&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;requestHandler name=&quot;/dataimport&quot; class=&quot;solr.DataImportHandler&quot;&amp;gt;	
     &amp;lt;lst name=&quot;defaults&quot;&amp;gt;	
       &amp;lt;str name=&quot;config&quot;&amp;gt;db-data-config.xml&amp;lt;/str&amp;gt;	
     &amp;lt;/lst&amp;gt;	
 &amp;lt;/requestHandler&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置数据源,源数据与索引的隐射关系
 在 &lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0/server/solr/test/conf/下新建db-data-config.xml&lt;/code&gt; ,配置如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;dataConfig&amp;gt;
    &amp;lt;dataSource type=&quot;JdbcDataSource&quot; 
               driver=&quot;com.mysql.jdbc.Driver&quot;
               url=&quot;jdbc:mysql://localhost/test&quot; 
               user=&quot;root&quot; 
               password=&quot;root&quot;/&amp;gt;
    &amp;lt;document&amp;gt;
     &amp;lt;entity name=&quot;comment&quot; 
     query=&quot;SELECT id, DATE_FORMAT(writetime, '%Y-%m-%dT%TZ') as 'writetime', title from comment&quot;
     deltaImportQuery=&quot;SELECT id, DATE_FORMAT(writetime, '%Y-%m-%dT%TZ') as 'writetime', title from comment where id='${dih.delta.id}'&quot;
     deltaQuery=&quot;SELECT id FROM comment WHERE DATE(updatetime) &amp;gt;= '${dih.last_index_time}' OR DATE(writetime) &amp;gt;= '${dih.last_index_time}'&quot;&amp;gt;       
        &amp;lt;field column=&quot;id&quot; name=&quot;id&quot;/&amp;gt;      
        &amp;lt;field column=&quot;writetime&quot; name=&quot;writetime&quot;/&amp;gt;
        &amp;lt;field column=&quot;title&quot; name=&quot;title&quot;/&amp;gt;           
     &amp;lt;/entity&amp;gt;      
   &amp;lt;/document&amp;gt;
 &amp;lt;/dataConfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：查询 sql 可以是多表关联查询，只要查询字段跟下面的 field 对应起来就可以。另外 field 对应的name值必须在 config 目录下的 schema.xml 文件中存在。如上述的 writetime 不存在，则在schema.xml中添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&amp;lt;field name=&quot;writetime&quot; type=&quot;tdate&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;indexed 表示需不需要建立索引，以便之后对这个 field 进行查询；&lt;/p&gt;

&lt;p&gt;stored 表示需不需要随索引同时存储这个 field 本身的内容，以便查询时直接从结果中获取该内容，一般大数据（比如文件内容本身）不会和索引一起保存，节省资源，防止索引过大。 索引本身和被索引的内容要分清，不理解的话，倒排索引：&lt;code class=&quot;highlighter-rouge&quot;&gt;http://zh.wikipedia.org/wiki/&lt;/code&gt;倒排索引&lt;/p&gt;

&lt;p&gt;6.Reload test 搜索实例，利用图形界面执行dataimport&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-4-1.png&quot; alt=&quot;Web 控制台 dataimport&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为这个文件我已经导过了，所以上面显示是 reload，第一次使用时有一点点差别。导完数据以后我们查询验证下 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080/solr/test/select?q=title%3Astep&amp;amp;wt=json&amp;amp;indent=true&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;返回结果：&lt;/em&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;responseHeader&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;QTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;params&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;indent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;title:step&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;wt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;response&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;numFound&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;docs&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10002&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Step 2: Choose your plan&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;writetime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2015-04-10T00:00:00Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_version_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1498574060831899648&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10001&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Step 1: Set up a personal account&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;writetime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2015-04-10T00:00:00Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_version_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1498574060739624960&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;10003&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Step 3: Go to your dashboard&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;writetime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2015-04-10T00:00:00Z&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_version_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1498574060832948224&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里面我们使用的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;title:step&lt;/code&gt; 将 title 包含 step 的三条记录都查了出来。&lt;/p&gt;

&lt;h4 id=&quot;编程的方式来自定义导入这个编程部分再讲&quot;&gt;&lt;em&gt;编程的方式来自定义导入（这个编程部分再讲）&lt;/em&gt;&lt;/h4&gt;

&lt;p&gt;当然除了数据库数据，Solr 还能导入 csv,json,word,pdf，这部分有兴趣可以自己去试验下。&lt;/p&gt;

&lt;p&gt;至此，一个简单的 Solr 的应用演示算是完成了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 入库速度和分片的关系</title>
   <link href="http://www.blogways.net/blog/2015/05/05/mongodb-sharding-io-rate.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/mongodb-sharding-io-rate</id>
   <content type="html">&lt;h2 id=&quot;一背景&quot;&gt;一、背景&lt;/h2&gt;
&lt;p&gt;实时采集主机的日志文件，发送到 node.js 处理程序( 暂时叫做 &lt;strong&gt;load&lt;/strong&gt; )，经过一些数据处理后插入到 MongoDB 持久存储。由于采集的主机数量较多，导致了如下问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每秒需要入库的数据量很大，单个 MongoDB 无法满足这些数据的入库要求，导致插入的拥堵，导致 MongoDB 中的不是实时的数据；&lt;/li&gt;
  &lt;li&gt;MongoDB 缓存到内存中的热数据量太多，单台主机无法满足如此大的内存需求；&lt;/li&gt;
  &lt;li&gt;MongoDB 持久化存储到本地磁盘的数据非常大( 有些表一天的数据量有上千万条 )，需要的存储空间很大，单台无法满足要求。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;考虑到&lt;strong&gt;纵向扩展&lt;/strong&gt;的代价较高，决定采用 MongoDB 的分片机制来实现，需要探究的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;单个 MongoDB 实例的入库速率极限是多少；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;load&lt;/strong&gt;( 处理接收到的日子文件，并入库到MongoDB )的数量与入库速率的关系；&lt;/li&gt;
  &lt;li&gt;分片的片数与入库速率的关系；&lt;/li&gt;
  &lt;li&gt;单台主机( 8核心，16G )启动&lt;strong&gt;load&lt;/strong&gt;和 MongoDB 实例的最合适个数；&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二测试单个mongodb入库极限&quot;&gt;二、测试单个MongoDB入库极限&lt;/h2&gt;
&lt;p&gt;启动一个 MongoDB 实例，分别测试启动多个&lt;strong&gt;load&lt;/strong&gt;时，MongoDB的入库速率( 10min中入库的记录条数 )，发往&lt;strong&gt;load&lt;/strong&gt;的日子数量充足；&lt;/p&gt;

&lt;p&gt;MongoDB 实例启动：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --dbpath /data/mongodb/db --logpath /data/mongodb/logs/mongod.log --nojournal --fork 具体命令吃处不在讲解，详见[MongoDB 安装与分布式部署](http://www.blogways.net/blog/2015/05/04/mongodb-install-and-distribution-deploy.html)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;测试结果&quot;&gt;测试结果&lt;/h3&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;load 个数&lt;/th&gt;&lt;th&gt;十分钟入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;222902&lt;/td&gt;&lt;td&gt;372&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;260933&lt;/td&gt;&lt;td&gt;435&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;259581&lt;/td&gt;&lt;td&gt;433&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;260966&lt;/td&gt;&lt;td&gt;435&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;针对当前&lt;strong&gt;load&lt;/strong&gt; 应用处理程序，单个 MongoDB 实例的入库极限速度为：&lt;code class=&quot;highlighter-rouge&quot;&gt;435 条/sec&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;注意&quot;&gt;注意&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;测试中还记录并且计算了其它时间长度的入库速度，有一些差异，但都在误差的范围内；&lt;/li&gt;
  &lt;li&gt;针对不同的处理入库逻辑，测出的入库极限速度都不同，本内容的所有数据都是基于自己的&lt;strong&gt;load&lt;/strong&gt;，仅供参考。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三分片数与入库速率的关系-python-&quot;&gt;三、分片数与入库速率的关系( python )&lt;/h2&gt;
&lt;p&gt;考虑到日志的抓去、&lt;strong&gt;load&lt;/strong&gt;的处理和数据入库中间存在很多的不确定性，因而首先只选择测试每秒钟插入记录数来表面存在的关系。&lt;/p&gt;

&lt;h3 id=&quot;测试方案&quot;&gt;测试方案&lt;/h3&gt;
&lt;p&gt;分别在 3 台不同的主机上部署3个配置服务器(Config Server)，在其中的一台上面部署 3 个查询路由(Query Router)，最后在另一台主机上( 不包含在部署Config Server 和 Query Router主机内 )，分别启动1、2、3、4个分片(按照 &lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;字段，&lt;strong&gt;&lt;em&gt;Hash 分片&lt;/em&gt;&lt;/strong&gt;)；&lt;/p&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby&lt;/code&gt;语言编写插入记录程序( 需要pymongo插件 )，部分代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/env python&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;pymongo&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MongoClient&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;datetime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;random&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 启动的3个查询路由&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;db1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'10.20.16.78:27017'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;db2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'10.20.16.78:27018'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;db3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MongoClient&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'10.20.16.78:27019'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;randint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db1&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rand&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        	&lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db2&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;db3&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        	&lt;span class=&quot;s&quot;&gt;&quot;host&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        	&lt;span class=&quot;c&quot;&gt;# 生成插入的对象&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	    &lt;span class=&quot;n&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;objInsert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert_one&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;obj&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;300000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;上面的每个脚本表示插入&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;300000&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;条记录到分片表中，此处为测试分三片时候的入库速率；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;配置&quot;&gt;配置&lt;/h3&gt;
&lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;test.objInsert&lt;/code&gt;表按照&lt;code class=&quot;highlighter-rouge&quot;&gt;host&lt;/code&gt;字段哈希分片：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sh.shardCollection('test.objInsert', {'host': 'hashed'}) 启动`python`脚本向数据库插入数据，记录10s、1min的插入速率。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;测试数据&quot;&gt;测试数据&lt;/h3&gt;
&lt;p&gt;应该很多次测试，此处只贴出一次结果：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;分片 片数&lt;/th&gt;&lt;th&gt;10s入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1 (不分片)&lt;/td&gt;&lt;td&gt;120263&lt;/td&gt;&lt;td&gt;12026&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;148543&lt;/td&gt;&lt;td&gt;14854&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;185022&lt;/td&gt;&lt;td&gt;18502&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;绘制的平滑标记散点连线图，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-rate-result.png&quot; alt=&quot;sharding-rate-result&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;结论-1&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;由上图可得到一个大概的猜想：&lt;strong&gt;&lt;em&gt;入库速率与分片片数呈线性关系！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;注意-1&quot;&gt;注意&lt;/h3&gt;
&lt;p&gt;由于主机数、主机内存等愿意的限制，没法启动太多的&lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt;脚本用于数据插入，实际测试用用的两台机器来插入测试；&lt;/p&gt;

&lt;p&gt;测试主机还有其它程序占用CPU等，没法长时间处于&lt;code class=&quot;highlighter-rouge&quot;&gt;python&lt;/code&gt;脚步执行状态，测试只记录 10s 中的数据；还有可能涉及到其它原因，长时间插入会出现速率波动；&lt;/p&gt;

&lt;h2 id=&quot;四入库速度与load数量的关系&quot;&gt;四、入库速度与load数量的关系&lt;/h2&gt;
&lt;p&gt;由于 node.js 连接 MongoDB 的所有数据库操作都是异步调用的，所以很多操作只能在回调函数中进行，或通过其它方式将其转换为同步操作( 如：&lt;code class=&quot;highlighter-rouge&quot;&gt;async&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;EventProxy&lt;/code&gt; )。&lt;/p&gt;

&lt;p&gt;在测试的初期，发现有时候&lt;strong&gt;load&lt;/strong&gt;占用的内存会不断的升高，有时候甚至会导致&lt;strong&gt;load&lt;/strong&gt;程序崩溃，后来实验发现，是因为MongoDB 的入库速率达到了瓶颈，而又有不断的数据插入，导致回掉函数无法立即执行并积压在内存中，是的占用内存越来越高，最后程序崩溃。&lt;/p&gt;

&lt;p&gt;根据上述原因，可以通过load的内存占用来侧面反应&lt;strong&gt;load&lt;/strong&gt;和MongoDB的工作状态：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;内存占用过高，&lt;strong&gt;load&lt;/strong&gt;对接收到的日志处理不过来，或MongoDB的入库速率到达极限；&lt;/li&gt;
  &lt;li&gt;内存占用正常或稍微偏高( 10 ~ 100M之内 )，&lt;strong&gt;load&lt;/strong&gt;和 MongoDB都处在比较理想的工作状态；&lt;/li&gt;
  &lt;li&gt;内存占用偏低，&lt;strong&gt;load&lt;/strong&gt;或 MongoDB的性能部分处于闲置状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在做本项测试的时候，需要保证 MongoDB的出来能力能满足所有&lt;strong&gt;load&lt;/strong&gt;个数的限制，观察不同个数时的入库记录条数；因而在必要的时候需要启动多个分片；&lt;/p&gt;

&lt;h3 id=&quot;测试方案-1&quot;&gt;测试方案&lt;/h3&gt;
&lt;p&gt;分别启动1、2、3、4个&lt;strong&gt;load&lt;/strong&gt;，并启动相应的分片数( 使得每个&lt;strong&gt;load&lt;/strong&gt;的内存占用正常 )，启动3个配置服务器；考虑到多个&lt;strong&gt;load&lt;/strong&gt;的情况，传递过来的日子数据通过&lt;code class=&quot;highlighter-rouge&quot;&gt;nginx&lt;/code&gt;按 &lt;strong&gt;响应时间&lt;/strong&gt; 做负载均衡处理。&lt;/p&gt;

&lt;h3 id=&quot;测试数据-1&quot;&gt;测试数据&lt;/h3&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;load 个数&lt;/th&gt;&lt;th&gt;10min入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;227079&lt;/td&gt;&lt;td&gt;379&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;447980&lt;/td&gt;&lt;td&gt;747&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;614332&lt;/td&gt;&lt;td&gt;1024&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;782492&lt;/td&gt;&lt;td&gt;1304&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;绘制的平滑标记散点连线图，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-rate-load-num.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;多次测量的过程中，&lt;strong&gt;load&lt;/strong&gt;的内存占用都在100 ~ 250 M之间，CPU 占用率100%左右( 完全占用一个物理CPU核心 )。&lt;/p&gt;

&lt;h3 id=&quot;结论-2&quot;&gt;结论&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;由上图可发现，&lt;strong&gt;load&lt;/strong&gt;个数和入库速率所呈现的基本是一条直线，因而得到结论&lt;strong&gt;load&lt;/strong&gt;的个数与入库速率成线性关系；&lt;/li&gt;
  &lt;li&gt;由于&lt;strong&gt;load&lt;/strong&gt;在正常工作情况下内存占用补不超过300M，这相对于一台主机的16G的内存来说很小，因而一台机器能启动的&lt;strong&gt;load&lt;/strong&gt;的个数取决于其核心数，还要留一些用作它用，因而8核心CPU主机，启动 &lt;strong&gt;4 ~ 7&lt;/strong&gt;个&lt;strong&gt;load&lt;/strong&gt;是比较合适的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注意-2&quot;&gt;注意&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在测试4个&lt;strong&gt;load&lt;/strong&gt;的时候，开始使用了3个配置服务器，4个分片，结果每个&lt;strong&gt;load&lt;/strong&gt;的内存占用都高达600M以上，说明分4片没法满足4个&lt;strong&gt;load&lt;/strong&gt;的入库请求；&lt;/li&gt;
  &lt;li&gt;然后使用3个配置服务器，6个分片，&lt;strong&gt;load&lt;/strong&gt;的内存占用在400M以上，同样6个分片也无法满足要求；&lt;/li&gt;
  &lt;li&gt;最后在启用8个分片后，内存占用降到了100M多一点，说明此时的MongoDB的处理入库速度完全够4个&lt;strong&gt;load&lt;/strong&gt;使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;五分片数与入库速率的关系-load-&quot;&gt;五、分片数与入库速率的关系( load )&lt;/h2&gt;
&lt;p&gt;有测试四的注意可知，4个&lt;strong&gt;load&lt;/strong&gt;，3个配置服务器即可完成测试不分片、分2、3、4片时的入库速率。&lt;/p&gt;

&lt;h3 id=&quot;测试数据-2&quot;&gt;测试数据&lt;/h3&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th&gt;分片 片数&lt;/th&gt;&lt;th&gt;20min入库数&lt;/th&gt;&lt;th&gt;入库速率( 条/sec )&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;不分片&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;435&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;854605&lt;/td&gt;&lt;td&gt;712&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;1127365&lt;/td&gt;&lt;td&gt;940&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;14220( 2min )&lt;/td&gt;&lt;td&gt;1185&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;绘制的平滑标记散点连线图，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-rate-result-load.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;每个&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod&lt;/code&gt;进程( 分片实例 )的CPU占用在繁忙的时候会接近100%，有时候甚至超过100%；&lt;/p&gt;

&lt;h3 id=&quot;结论-3&quot;&gt;结论&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;由上图可知，分片的片数与入库速率亦是成线性关系；&lt;/li&gt;
  &lt;li&gt;由于CPU会超过100%的考虑，单台8核心的服务器，最多启动6个分片；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;注意-3&quot;&gt;注意&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;单台主机的MongoDB 分片的片数选择主要考虑 CPU 的核心数；&lt;/li&gt;
  &lt;li&gt;MongoDB 分片进程会讲插入的数据都保存到内存中，直到内存完全被耗光，后续的数据会持久化到磁盘空间，内存中只会保存热数据和索引。&lt;/li&gt;
  &lt;li&gt;如果主机内存吃紧的话，启动分片实例的时候最好带&lt;code class=&quot;highlighter-rouge&quot;&gt;--nojurounal&lt;/code&gt;启动。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;六总结&quot;&gt;六、总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;load&lt;/strong&gt; 的个数和入库速率成线性关系；&lt;/li&gt;
  &lt;li&gt;MongoDB 分片的片数和入库速率成线性关系；&lt;/li&gt;
  &lt;li&gt;单台主机启动&lt;strong&gt;load&lt;/strong&gt;的个数主要考虑因素是 CPU 核心数，最多启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;n - 2 (n 为 cpu 核心数)&lt;/code&gt;个；&lt;/li&gt;
  &lt;li&gt;单台主机启动MongoDB 分片实例的个数，参考因素为 CPU 核心数，最多启动 &lt;code class=&quot;highlighter-rouge&quot;&gt;n - 2 (n 为 cpu 核心数)&lt;/code&gt;个；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;
&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;后续修改中。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 分片介绍</title>
   <link href="http://www.blogways.net/blog/2015/05/05/mongodb-sharding-introduction-by-docs.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/mongodb-sharding-introduction-by-docs</id>
   <content type="html">&lt;h2 id=&quot;一分片介绍&quot;&gt;一、分片介绍&lt;/h2&gt;
&lt;p&gt;分片是一个遍及多台机器存储数据的方法，MongoDB 使用分片来实现对大数据集合部署与高吞吐量操纵的支持。&lt;/p&gt;

&lt;h3 id=&quot;分片的目的&quot;&gt;分片的目的&lt;/h3&gt;
&lt;p&gt;对一个单一数据库系统服务来说，大数据集合和高吞吐量的应用程序将会是一个非常严峻的考验。高的查询速率会“吃光”服务器的所有CPU，更大的数据集合超出一个单一机器的存储空间。最后，工作集合的大小比系统内存容量( 磁盘驱动的I/O性能 )大。&lt;/p&gt;

&lt;p&gt;解决上诉问题的方式有两个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;纵向扩展 ( vertical scaling )&lt;/li&gt;
  &lt;li&gt;分片 ( sharding )&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;Vertical scaling&lt;/strong&gt;，增加更多的CPU数和存储资源来增加容纳量，但是扩展存在限制：更多核心数的CPU和更多RAM的高性能系统比更小的系统昂贵，而且其 CPU 和 RAM 的增加与得到的性能不是曾比例的。另外，云服务提供商可能只允许用户提供更小的例子。因此，纵向扩展存在一个性能的最大极限。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Sharding&lt;/strong&gt;，或者说是水平扩展，相反地将大数据集合拆分并将数据分布到多个服务器，或分片上。每个分片都是一个独立的数据库，所有的分片组成一个逻辑数据库。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharded-collection.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分片地址扩展到支持高吞吐率和大数据集合的难点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;分片降低了每个分片处理操作的数量，随着集群的增长，每个分片将会处理更少的操作。其结果是，一个集群能够&lt;em&gt;水平地&lt;/em&gt;增加容纳量和高吞吐量。例如：插入数据时，应用程序只需要访问负责该记录的碎片。&lt;/li&gt;
  &lt;li&gt;分片减少了每个服务器需要存储的数据量，随着集群的增长，每个分片将会保存更少的数据。例如：一个数据库有 1TB 的数据，分4个分片后，每个分片只要保存 256GB 的数据；如果有40个分片的话，每个分片只需要保存 25GB 的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二mongodb-分片&quot;&gt;二、MongoDB 分片&lt;/h2&gt;
&lt;p&gt;MongoDB 支持通过配置一个分片集群来支持分片。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharded-cluster-production-architecture.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分片集群由分片、查询路由和配置服务器三个组件构成：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Shards&lt;/strong&gt; 用于保存数据。为了提供高可用性和数据一致性，在一个生产环境分片集群中，每个分片都有一个复制集( Replica Set )。关于复制集更多的信息，见&lt;a href=&quot;http://docs.mongodb.org/manual/core/replication/&quot; title=&quot;http://docs.mongodb.org/manual/core/replication/&quot;&gt;Replica Sets&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Query Routers&lt;/strong&gt;，或者说&lt;code class=&quot;highlighter-rouge&quot;&gt;mongos&lt;/code&gt;实例，客户端应用程序操作的接口，直接操作合适的分片或分片集。查询路由处理并将操作定位到分片，然后将结果返回给客户端。一个分片集群能够包含多个查询路由( Query Router )，用以分担客户端请求的负载。一个客户端和一个查询路由一一对应，更多的分片集群需要很多的查询路由。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Config Server&lt;/strong&gt; 保存集群的元数据( metadata )，包含集群数据集到分片的映射，查询路由通过元数据将操作定位到指定的分片上。生产环境下，拥有确切的 &lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;个配置服务器。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;数据分割&quot;&gt;数据分割&lt;/h3&gt;
&lt;p&gt;MongoDB 在集合的水平上分割数据和分片，通过一个分片键( shard key )来分割分片。&lt;/p&gt;

&lt;h4 id=&quot;分片键-shard-keys-&quot;&gt;分片键( Shard Keys )&lt;/h4&gt;
&lt;p&gt;为了将一个集合分片，需要选择一个分片关键字。一个分片关键字是一个索引字段，或存在于每个集合文档中的一个复合索引字段。MongoDB 按分片字段将集合划分为块( chunks )，然后讲所有的块均匀的分布到所有分片上。为了划分集合为区块，MongoDB 提供了&lt;strong&gt;&lt;em&gt;范围分片(Range Based Sharding)&lt;/em&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;em&gt;哈希分片(Hash Based Sharding)&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h4 id=&quot;范围分片-range-based-sharding-&quot;&gt;范围分片( Range Based Sharding )&lt;/h4&gt;
&lt;p&gt;在&lt;em&gt;范围分片&lt;/em&gt;中，MongoDB 通过范围划分字段值提供的范围分割，将数据集合划分为不同的范围边界。就像一个数字分片字段：将负无穷到正无穷的所有数形象化为一条线，每个分片字段的值都落在该线上的某个点上。此线段被 MongoDB 划分为的更小的，没有重叠的范围叫做块( chunks )，一个块是某最小值到某最大值之间值的范围。&lt;/p&gt;

&lt;p&gt;已知的一个范围分割系统，分片字段值“相近”的文档分布在同一个块上，因此也在同一个分片上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-range-based.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;哈希分片-hash-based-sharding-&quot;&gt;哈希分片( Hash Based Sharding )&lt;/h4&gt;
&lt;p&gt;在&lt;em&gt;哈希分片&lt;/em&gt;中，MongoDB 计算一个字段值的哈希值，然后使用此哈希值创建一个区块。&lt;/p&gt;

&lt;p&gt;如果使用哈希分割，分片字段值“相近”的两个文档可能不在同一个区块中，这确保了一个集合在集群中更大限度的随机分布。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/sharding-hash-based.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;范围分片和哈希分片的性能差异&quot;&gt;范围分片和哈希分片的性能差异&lt;/h4&gt;
&lt;p&gt;基于范围的分片方式提供了更高效的范围查询，给定一个片键的范围，分发路由可以很简单地确定哪个数据块存储了请求需要的数据，并将请求转发到相应的分片中。&lt;/p&gt;

&lt;p&gt;不过，基于范围的分片会导致数据在不同分片上的不均衡，有时候，带来的消极作用会大于查询性能的积极作用。比如，如果片键所在的字段是线性增长的，一定时间内的所有请求都会落到某个固定的数据块中，最终导致分布在同一个分片中。在这种情况下，一小部分分片承载了集群大部分的数据，系统并不能很好地进行扩展。&lt;/p&gt;

&lt;p&gt;与此相比，基于哈希的分片方式以范围查询性能的损失为代价，保证了集群中数据的均衡。哈希值的随机性使数据随机分布在每个数据块中，因此也随机分布在不同分片中。但是也正由于随机性，一个范围查询很难确定应该请求哪些分片，通常为了返回需要的结果，需要请求所有分片。&lt;/p&gt;

&lt;h4 id=&quot;使用标记自定义集群中数据的分布&quot;&gt;使用标记自定义集群中数据的分布&lt;/h4&gt;
&lt;p&gt;MongoDB允许管理员使用 &lt;strong&gt;Tag Aware Sharding&lt;/strong&gt; 直接决定集群的均衡策略。管理员使用标记与片键的范围做绑定，并将标记与分片直接绑定，之后，均衡器会将满足标记的数据直接分发到与之绑定的分片上，并且确保之后满足标记的数据一直存储在相应的分片上。&lt;/p&gt;

&lt;p&gt;标记是控制均衡器行为和数据块分布的首要条件，一般来讲，在拥有多个数据中心时，才会使用标记自定义集群中数据块的分布，以提高不同地域之间数据访问的效率。&lt;/p&gt;

&lt;p&gt;参考 &lt;strong&gt;&lt;a href=&quot;http://docs.mongodb.org/manual/core/tag-aware-sharding/&quot; title=&quot;http://docs.mongodb.org/manual/core/tag-aware-sharding/&quot;&gt;Tag Aware Sharding&lt;/a&gt;&lt;/strong&gt; 获得更多相关信息。&lt;/p&gt;

&lt;h4 id=&quot;数据分布均衡的维护&quot;&gt;数据分布均衡的维护&lt;/h4&gt;
&lt;p&gt;新数据的加入或者新分片的加入可能会导致集群中数据的不均衡，即表现为有些分片保存的数据块数目显著地大于其他分片保存的数据块数。&lt;/p&gt;

&lt;p&gt;MongoBD使用两个过程维护集群中数据的均衡：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;分裂；&lt;/p&gt;

    &lt;p&gt;分裂是防止某个数据块过大而进行的一个后台任务。当一个数据块的大小超过&lt;a href=&quot;http://docs.mongodb.org/manual/core/sharding-chunk-splitting/#sharding-chunk-size&quot; title=&quot;http://docs.mongodb.org/manual/core/sharding-chunk-splitting/#sharding-chunk-size&quot;&gt;设定的数据块大小&lt;/a&gt;时，MongoDB会将其一分为二，插入与更新触发分裂过程。分裂改变了元信息。但是效率很高，进行分裂时，MongoDB 不会迁移任何数据，对集群性能也没有影响。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/post/sharding-splitting.png&quot; alt=&quot;sharding-splitting&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;均衡器。&lt;/p&gt;

    &lt;p&gt;均衡器是一个管理区块迁移的后台进程，均衡器在一个集群中所有的查询路由上运行。&lt;/p&gt;

    &lt;p&gt;当集群中数据的不均衡发生时，均衡器会将数据块从数据块数目最多的分片迁移到数据块最少的分片上，举例来讲：如果集合 &lt;strong&gt;users&lt;/strong&gt; 在 &lt;em&gt;shard1&lt;/em&gt; 上有100个数据块，在 &lt;em&gt;shard2&lt;/em&gt; 上有50个数据块，均衡器会将数据块从 &lt;em&gt;shard1&lt;/em&gt; 一直向 &lt;em&gt;shard2&lt;/em&gt; 迁移，一直到数据均衡为止。&lt;/p&gt;

    &lt;p&gt;分片管理在后台管理从 &lt;em&gt;源分片&lt;/em&gt; 到 &lt;em&gt;目标分片&lt;/em&gt; 的数据块迁移，在迁移过程中，&lt;em&gt;目标分片&lt;/em&gt;首先会接收源分片在迁移数据块上的所有数据，之后，目标分片应用在上一迁移步骤之间发生在源分片上的迁移数据块的更改，最后，存储在&lt;em&gt;配置服务器&lt;/em&gt; 上的元信息被更新。&lt;/p&gt;

    &lt;p&gt;如果迁移中发生错误，源分片上的数据不会被修改，迁移会停止。在迁移成功结束之后MongoDB才会在源分片上将数据删除。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/images/post/sharding-migrating.png&quot; alt=&quot;sharding-migrating&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;在集群中增加或者删除分片&quot;&gt;在集群中增加或者删除分片&lt;/h4&gt;
&lt;p&gt;在集群中增加分片时，由于新的分片上并没有数据块，会造成数据的不均衡。此时MongoDB会立即开始向新分片迁移数据，集群达到数据均衡的状态需要花费一些时间。&lt;/p&gt;

&lt;p&gt;当删除一个分片时，均衡器需要将被删除的分片上的数据全部迁移到其他分片上，在全部迁移结束且元信息更新完毕之后，你可以安全地将这个分片移除。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JAXB使用教程一:简介与基本用法</title>
   <link href="http://www.blogways.net/blog/2015/05/05/jaxb-tutorial-1.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/jaxb-tutorial-1</id>
   <content type="html">&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;

&lt;p&gt;JAXB（Java Architecture for XML Binding简称JAXB）允许Java开发人员将Java类映射为XML表示方式。JAXB提供两种主要特性：将一个Java对象序列化为XML，以及反向操作，将XML解析成Java对象。换句话说，JAXB允许以XML格式存储和读取数据，而不需要程序的类结构实现特定的读取XML和保存XML的代码！&lt;/p&gt;

&lt;p&gt;JAXB 已经是 Java SE平台的一部分，Java EE平台API之一，也是Java Web服务开发包(JWSDP)的一部分。&lt;/p&gt;

&lt;p&gt;JAXB在Java SE平台上，对应版本分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Java SE 8: JAXB 2.2.8&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java SE 7: JAXB 2.2.3 (JSR 222, maintenance release 2)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Java SE 6: JAXB 2.0 (JSR 222)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;二jaxb和domsaxjdomdom4j对比&quot;&gt;二、JAXB和Dom/SAX/JDOM/Dom4J对比&lt;/h2&gt;

&lt;p&gt;其实，JAXB不能直接拿来和Dom/SAX/Dom4j进行比较。他们的设计理念不同。后者提供的API都是解析XML的底层API，而前者设计的目的是将XML文件中的元素及属性和JAVA对象建立绑定关系，可以自动相互转换。&lt;/p&gt;

&lt;p&gt;JAXB没有提供解析XML的新方法，它是调用后者(Dom/SAX/JDOM/Dom4J)来解析XML的。（JAXB默认是调用SAX来实现XML解析的）&lt;/p&gt;

&lt;p&gt;如果，你仅仅是想把XML的内容转换成Java对象，那么JAXB比起后者更容易实现，它可以让你少些一些代码。特别是，当XML的结构非常复杂时，他的代码量比后者要少很多。&lt;/p&gt;

&lt;p&gt;当然，他们之间的取舍，主要还是以你的使用目的所决定。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;另外，关于DOM和SAX的更多信息，可以看看我的另一篇博文:&lt;a href=&quot;javax-xml-parsers.html&quot;&gt;javax.xml.parsers使用简介及源码探究:DOM与SAX&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;下面，我们就来看看，如何在xml文件和java对象间，使用JAXB进行转换。&lt;/p&gt;

&lt;h2 id=&quot;三编组marshal&quot;&gt;三、编组(marshal)&lt;/h2&gt;

&lt;p&gt;将Java对象，转换为Xml文件，我们称之为编组(marshal).&lt;/p&gt;

&lt;p&gt;转换代码很简单：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main( String[] args )
{
    try
    {

        /* 初始化java对象 */
        Person person = new Person();
        person.setFirstName(&quot;net&quot;);
        person.setLastName(&quot;blogways&quot;);
        person.setCity(&quot;NanJing&quot;);
        person.setPostalCode(210000);
        person.setBirthday(LocalDate.of(2013, 10, 11));

        /* 初始化 jaxb marshaler */
        JAXBContext jaxbContext = JAXBContext.newInstance( Person.class );
        Marshaller jaxbMarshaller = jaxbContext.createMarshaller();

        /* 设置为格式化输出 */
        jaxbMarshaller.setProperty( Marshaller.JAXB_FORMATTED_OUTPUT, true );

        /* 将java对象 编组 为xml (输出到文件或标准输出) */
        jaxbMarshaller.marshal( person, new File( &quot;person.xml&quot; ) );
        jaxbMarshaller.marshal( person, System.out );
    }
    catch( JAXBException e )
    {
        e.printStackTrace();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而在&lt;code class=&quot;highlighter-rouge&quot;&gt;Person.java&lt;/code&gt;中，你只需要通过注释，就可以告诉程序，要转换为什么格式的Xml文件。&lt;/p&gt;

&lt;p&gt;比如, &lt;strong&gt;Person.java：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package net.blogways.jaxb.example.model;

import java.time.LocalDate;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement( name = &quot;Person&quot; )
public class Person {
    private String firstName;
    private String lastName;
    private Integer postalCode;
    private String city;
    private LocalDate birthday;
    
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    
    public String getLastName() {
        return lastName;
    }
    
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    
    public Integer getPostalCode() {
        return postalCode;
    }

    public void setPostalCode(Integer postalCode) {
        this.postalCode = postalCode;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public LocalDate getBirthday() {
        return birthday;
    }

    public void setBirthday(LocalDate birthday) {
        this.birthday = birthday;
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;@XmlRootElement 定义了根节点的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;是不是很简单？！&lt;/p&gt;

&lt;p&gt;另外，需要说明的是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Person.java&lt;/code&gt;中，你可以通过更多的&lt;a href=&quot;#5&quot;&gt;注释&lt;/a&gt;，来定义编组后的xml格式。&lt;/li&gt;
  &lt;li&gt;在一个复杂的项目中，XML文件结构可能很复杂。这时，不需要手工编写对应的Java类文件，我们可以通过工具从xml schema文件获得java类文件，甚至可以从xml文件中转换得到java类文件。这些我们在后续的文章中介绍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;四反编组un-marshal&quot;&gt;四、反编组(Un-marshal)&lt;/h2&gt;

&lt;p&gt;将Xml文件的内容，转换为Java对象，我们称之为反编组(un-marshal).&lt;/p&gt;

&lt;p&gt;反编组，也很简单。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
	try
    {

        File file = new File( &quot;list.xml&quot; );
        JAXBContext jaxbContext = JAXBContext.newInstance( Persons.class );

        Unmarshaller jaxbUnmarshaller = jaxbContext.createUnmarshaller();
        
        Persons persons = (Persons)jaxbUnmarshaller.unmarshal( file );
        System.out.println( persons );

    }
    catch( JAXBException e )
    {
        e.printStackTrace();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;转换的对应关系，都在Persons.java里面。这里为了示例更简单清晰，我们只加了一行注释&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlRootElement&lt;/code&gt;,代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package net.blogways.jaxb.example.model;

import java.util.List;

import javax.xml.bind.annotation.XmlRootElement;

@XmlRootElement( name = &quot;Persons&quot; )
public class Persons {

    private List&amp;lt;Person&amp;gt; persons;

    public List&amp;lt;Person&amp;gt; getPersons() {
        return persons;
    }

    public void setPersons(List&amp;lt;Person&amp;gt; persons) {
        this.persons = persons;
    }
    
    @Override
    public String toString()
    {
        StringBuffer str = new StringBuffer();
        for( Person person : this.persons )
        {
            str.append( person.toString() );
            str.append(&quot;\n&quot;);
        }
        return str.toString();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;list.xml内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Persons&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;persons&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;city&amp;gt;&lt;/span&gt;NanJing&lt;span class=&quot;nt&quot;&gt;&amp;lt;/city&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;firstName&amp;gt;&lt;/span&gt;Li&lt;span class=&quot;nt&quot;&gt;&amp;lt;/firstName&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;lastName&amp;gt;&lt;/span&gt;si&lt;span class=&quot;nt&quot;&gt;&amp;lt;/lastName&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;postalCode&amp;gt;&lt;/span&gt;210000&lt;span class=&quot;nt&quot;&gt;&amp;lt;/postalCode&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/persons&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;persons&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;city&amp;gt;&lt;/span&gt;NanJing&lt;span class=&quot;nt&quot;&gt;&amp;lt;/city&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;firstName&amp;gt;&lt;/span&gt;zhang&lt;span class=&quot;nt&quot;&gt;&amp;lt;/firstName&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;lastName&amp;gt;&lt;/span&gt;san&lt;span class=&quot;nt&quot;&gt;&amp;lt;/lastName&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;postalCode&amp;gt;&lt;/span&gt;210000&lt;span class=&quot;nt&quot;&gt;&amp;lt;/postalCode&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/persons&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Persons&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;五注释&quot;&gt;五、注释&lt;/h2&gt;

&lt;p&gt;在本文前面部分，为了简化示例。我们仅使用了JAXB中的&lt;code class=&quot;highlighter-rouge&quot;&gt;@XmlRootElement&lt;/code&gt;注解来编组和反编组XML。&lt;/p&gt;

&lt;p&gt;我们在下面列出了最重要的一些注解:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlAccessorOrder&lt;/code&gt;: 本注解控制类里的字段和属性在XML中出现的顺序。更多信息请看: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAccessorOrder.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlAccessOrder.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlAccessorType&lt;/code&gt;: 表示一个元素是否可以被序列化。它可以和 &lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.bind.annotation.XMLAccessType&lt;/code&gt;一起使用。 更多信息请看: &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAccessorType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlAccessorType.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlAnyAttribute&lt;/code&gt;: 映射一个元素到通配符（wildcard ）属性的Map。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAnyAttribute.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlAnyAttribute.html&lt;/a&gt; .&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlAnyElement&lt;/code&gt;: 在没有映射被预定义时，作为反编组操作的一个缺省。 更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAnyElement.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlAnyElement.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlAttribute&lt;/code&gt;: 本注解是最基础和最常使用的一个。它映射一个Java元素(property, attribute, field) 到一个XML节点属性. 本教程中多个例子中用到了它。 更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlAttribute.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlAttribute.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElement&lt;/code&gt;: 使用name映射一个Java元素到XML节点。 更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElement.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlElement.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElementRef&lt;/code&gt;: 使用type (不同于上者, name被用来做映射)映射一个Java元素到一个XML节点 . 更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElementRef.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlElementRef.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElementRefs&lt;/code&gt;: 标记一个指向XmlElement 和JAXBElement所注解的类。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElementRefs.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlElementRefs.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElements&lt;/code&gt;: 这是一个包含多个XMLElement 注解的容器。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElements.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlElements.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlElementWrapper&lt;/code&gt;: 它生成一个围绕XML结构的包装器，旨在和集合一起使用，本教程中我们看到了有不同的方式来处理集合。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlElementWrapper.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlElementWrapper.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlEnum&lt;/code&gt;: 提供emum到XML的映射。它和XmlEnumValue一起工作。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlEnum.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlEnum.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlEnumValue&lt;/code&gt;:映射一个enum常量到一个XML元素。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlEnumValue.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlEnumValue.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlID&lt;/code&gt;: 映射一个属性到XML id。更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlID.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlID.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlList&lt;/code&gt;: 另一种在JAXB中处理list的方式。更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlList.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlList.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlMimeType&lt;/code&gt;: 控制被注解的属性的表现形式。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlMimeType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlMimeType.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlMixed&lt;/code&gt;: 被注解的元素包含混合的内容。内容可以是文本或未知的（unknown）。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlMixed.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlMixed.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlRootElement&lt;/code&gt;: 这可能是JAXB中使用最多的注解了。它用于映射一个类到XML元素。它基本上是每一个JAXB的入口点。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlRootElement.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlRootElement.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSchema&lt;/code&gt;: 映射一个package到XML命名空间。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlSchema.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlSchema.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSchemaType&lt;/code&gt;: 映射一个Java类型到一个内置的simple schema。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlSchemaType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlSchemaType.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlSeeAlso&lt;/code&gt;: 告诉JAXB在绑定被注解类时，去绑定其他类。这是必须的，因为Java很难列出一个类的所有子类，使用这种机制，你可以告诉JAXB在处理一个特定类的时候哪一个子类（或其他类）应该被绑定。更多信息请看 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlSeeAlso.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlSeeAlso.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlType&lt;/code&gt;: 用于map一个类或enum到XML Schema中的一个type。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlType.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlType.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;XmlValue&lt;/code&gt;: 允许map一个类到一个包含simpleContent 的XML Schema复杂类型或一个XML Schema的简单类型。更多信息请看&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/XmlValue.html&quot;&gt;https://docs.oracle.com/javase/8/docs/…/XmlValue.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这是一个很长的列表，但是并不是所有的JAXB的注解。要查看JAXB的所有注解的列表，请查看package 的 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/package-summary.html&quot;&gt;summary&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;六适配器adapters&quot;&gt;六、适配器(Adapters)&lt;/h2&gt;

&lt;p&gt;细心的读者，可能发现在前面编组的例子中，&lt;code class=&quot;highlighter-rouge&quot;&gt;birthday&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;LocalDate&lt;/code&gt;类型，作为复杂类型，不能很好地被编组和反编组。这时需要一个适配器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DateAdapter.java:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package net.blogways.jaxb.example.adapter;

import java.time.LocalDate;
import javax.xml.bind.annotation.adapters.XmlAdapter;

public class DateAdapter extends XmlAdapter&amp;lt;String, LocalDate&amp;gt;
{

    public LocalDate unmarshal( String date ) throws Exception
    {
        return LocalDate.parse( date );
    }

    public String marshal( LocalDate date ) throws Exception
    {
        return date.toString();
    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改Person.java，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;@XmlJavaTypeAdapter&lt;/code&gt;注释，如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@XmlJavaTypeAdapter( DateAdapter.class )
public void setBirthday(LocalDate birthday) {
	this.birthday = birthday;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再次运行本文前面部分的编组程序，标准输出如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;Person&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;birthday&amp;gt;&lt;/span&gt;2013-10-11&lt;span class=&quot;nt&quot;&gt;&amp;lt;/birthday&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;city&amp;gt;&lt;/span&gt;NanJing&lt;span class=&quot;nt&quot;&gt;&amp;lt;/city&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;firstName&amp;gt;&lt;/span&gt;net&lt;span class=&quot;nt&quot;&gt;&amp;lt;/firstName&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;lastName&amp;gt;&lt;/span&gt;blogways&lt;span class=&quot;nt&quot;&gt;&amp;lt;/lastName&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;postalCode&amp;gt;&lt;/span&gt;210000&lt;span class=&quot;nt&quot;&gt;&amp;lt;/postalCode&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/Person&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完美了，日期也可以显示出来了！&lt;/p&gt;

&lt;h2 id=&quot;七总结&quot;&gt;七、总结&lt;/h2&gt;

&lt;p&gt;好了，至此，你已经掌握了基本的JAXB的使用方法。可以编组、反编组、编写适配器，并且对相关注释也有了一个基本的了解，至少，你知道可以去哪查询都有哪些注释了。：）&lt;/p&gt;

&lt;p&gt;后面，我们将会继续介绍关于JAXB的一些复杂的应用。比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;介绍如何通过XML Schema文件来校验XML文件格式的正确与否&lt;/li&gt;
  &lt;li&gt;介绍JAXBContext.newInstance的逻辑&lt;/li&gt;
  &lt;li&gt;介绍对XML文件中名字空间的操作&lt;/li&gt;
  &lt;li&gt;介绍对XML文件中processing instruction的操作&lt;/li&gt;
  &lt;li&gt;介绍一些和JAXB有关的常见工具的使用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本文，所使用的示例完整代码，可以在本系列文章完结时提供。&lt;/p&gt;

&lt;h2 id=&quot;八参考文献&quot;&gt;八、参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh/JAXB&quot;&gt;http://zh.wikipedia.org/zh/JAXB&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding&quot;&gt;http://en.wikipedia.org/wiki/Java_Architecture_for_XML_Binding&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/7709928/jaxb-vs-dom-and-sax&quot;&gt;http://stackoverflow.com/questions/7709928/jaxb-vs-dom-and-sax&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/607141/what-is-jaxb-and-why-would-i-use-it&quot;&gt;http://stackoverflow.com/questions/607141/what-is-jaxb-and-why-would-i-use-it&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/2014/12/jaxb-tutorial-xml-binding.html&quot;&gt;http://www.javacodegeeks.com/2014/12/jaxb-tutorial-xml-binding.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/zh-hans/2015/04/%E7%94%A8%E4%BA%8Ejava%E5%92%8Cxml%E7%BB%91%E5%AE%9A%E7%9A%84jaxb%E6%95%99%E7%A8%8B.html&quot;&gt;http://www.javacodegeeks.com/zh-hans/2015/04/%E7%94%A8%E4%BA%8Ejava%E5%92%8Cxml%E7%BB%91%E5%AE%9A%E7%9A%84jaxb%E6%95%99%E7%A8%8B.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>javax.xml.parsers使用简介及源码探究:DOM与SAX</title>
   <link href="http://www.blogways.net/blog/2015/05/05/javax-xml-parsers.html"/>
   <updated>2015-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/05/javax-xml-parsers</id>
   <content type="html">&lt;h2 id=&quot;一简介&quot;&gt;一、简介&lt;/h2&gt;

&lt;p&gt;Java SE 平台提供的 XML 处理主要包括两个功能：JAXP（XML 处理，Java Architecture XML Processing）和 JAXB（XML 绑定，Java Architecture XML Binding）。&lt;/p&gt;

&lt;h3 id=&quot;11-关于jaxb&quot;&gt;1.1 关于JAXB&lt;/h3&gt;

&lt;p&gt;JAXB 则是负责将 XML 文件和 Java 对象绑定，在新版 JDK 中，被大量的使用在 Web 服务技术中。&lt;/p&gt;

&lt;h3 id=&quot;12-关于jaxp&quot;&gt;1.2 关于JAXP&lt;/h3&gt;

&lt;p&gt;JAXP 包括 SAX 框架 —— 遍历元素，做出处理；DOM 框架 —— 构造 XML 文件的树形表示；StAX 框架 —— 拖拽方式的解析；XSLT 框架 —— 将 XML 数据转换成其他格式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SAX 框架（Simple API for XML）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;SAX 全称 Simple API for XML，该框架使用了事件处理机制来处理 XML 文件。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DOM 框架（Document Object Model）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;DOM 框架的全称是 Document Object Model。顾名思义，这个框架会建立一个对象模型。针对每个节点，以及节点之间的关系在内存中生成一个树形结构。这个特点与 SAX 框架截然相反。需要注意的是，DOM 框架提供的对象树模型与我们通常理解的 XML 文件结构树模型是有一定的区别的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;StAX 框架（Streaming API for XML）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;SAX 框架的缺点是不能记录正在处理元素的上下文。但是优点是运行时占内存空间比较小，效率高。DOM 框架由于在处理 XML 时需要为其构造一棵树，所以特点正好相反。StAX 框架出现于 Java SE 6 中，它的设计目标就是要结合 SAX 框架和 DOM 框架的优点。既要求运行时效率，也要求保持元素的上下文状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;XSLT 数据转换框架（The Extensible Stylesheet Language Transformations APIs）&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;一般来说 XML 文件格式被认为是一种很好的数据交换格式。于是 Java SE 6 SDK 基于以上介绍的三种 XML 处理机制，提供了一个 XML 转换框架。XSLT 框架负责进行转换 —— 包括将 XML 文件转换成其他形式如 HTML，和将其他形式的文件转换成 XML 文件。更进一步说，这个框架可以接受 DOM 作为其输入和输出；可以接受 SAX 解析器作为输入或者产生 SAX 事件作为输出；可以接受 I/O Stream 作为输入和输出；当然也支持用户自定义形式的输入和输出。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;JDK中&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers&lt;/code&gt;包下是SAX和DOM的实现。下面，我们将简单介绍该包的使用。&lt;/p&gt;

&lt;h2 id=&quot;二对比sax与dom&quot;&gt;二、对比(SAX与DOM)&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;DOM思想：将整个XML加载内存中，形成文档对象，所以对XML操作都对内存中文档对象进行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SAX思想：一边解析，一边处理，一边释放内存资源。不允许在内存中保留大规模XML数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;DOM和SAX的区别：
    &lt;ul&gt;
      &lt;li&gt;DOM：支持回写，会将整个XML载入内存，以树形结构方式存储；XML比较复杂的时候，或者当你需要随机处理文档中数据的时候不建议使用&lt;/li&gt;
      &lt;li&gt;SAX：相比DOM是一种更为轻量级的方案；无法在读取过程中修改XML数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;解析速度： SAX &amp;gt; StAX &amp;gt; DOM&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三使用示例&quot;&gt;三、使用示例&lt;/h2&gt;

&lt;h3 id=&quot;31-staffsxml&quot;&gt;3.1 staffs.xml&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;company&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;staff&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;firstname&amp;gt;&lt;/span&gt;yong&lt;span class=&quot;nt&quot;&gt;&amp;lt;/firstname&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;lastname&amp;gt;&lt;/span&gt;mook kim&lt;span class=&quot;nt&quot;&gt;&amp;lt;/lastname&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;nickname&amp;gt;&lt;/span&gt;mkyong&lt;span class=&quot;nt&quot;&gt;&amp;lt;/nickname&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;salary&amp;gt;&lt;/span&gt;100000&lt;span class=&quot;nt&quot;&gt;&amp;lt;/salary&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/staff&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;staff&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;firstname&amp;gt;&lt;/span&gt;low&lt;span class=&quot;nt&quot;&gt;&amp;lt;/firstname&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;lastname&amp;gt;&lt;/span&gt;yin fong&lt;span class=&quot;nt&quot;&gt;&amp;lt;/lastname&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;nickname&amp;gt;&lt;/span&gt;fong fong&lt;span class=&quot;nt&quot;&gt;&amp;lt;/nickname&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;salary&amp;gt;&lt;/span&gt;200000&lt;span class=&quot;nt&quot;&gt;&amp;lt;/salary&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/staff&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/company&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;32-dom的使用示例&quot;&gt;3.2 DOM的使用示例&lt;/h3&gt;

&lt;p&gt;DOM的使用，分为两步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;将XML文件解析为Document对象&lt;/li&gt;
  &lt;li&gt;对Document对象进行处理&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;解析代码，主体如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
	
	DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

	DocumentBuilder builder = factory.newDocumentBuilder();

	Document document = builder.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));
	
	forEachNode(document);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其中，对Document对象的处理方法如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static void forEachNode(Document doc) {
	NodeList nodeList =  doc.getDocumentElement().getChildNodes();
	
	for(int i=0; i&amp;lt;nodeList.getLength(); ++i) {
		Node staff = nodeList.item(i);
		if (staff instanceof Element) {
			NodeList props = staff.getChildNodes();
			
			for (int j=0; j&amp;lt;props.getLength(); ++j) {
				Node prop = props.item(j) ;
				if (prop instanceof Element) {
					String content = prop.getLastChild().getTextContent().trim();
					switch(prop.getNodeName()) {
					case &quot;firstname&quot;: 
						System.out.println(&quot;firstname:&quot;+content);
						break;
					case &quot;lastname&quot;:
						System.out.println(&quot;lastname:&quot;+content);
						break;
					case &quot;nickname&quot;:
						System.out.println(&quot;nickname:&quot;+content);
						break;
					case &quot;salary&quot;:
						System.out.println(&quot;salary:&quot;+content);
						break;
					}
				}
			}
			
			System.out.println();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;33-sax的使用示例&quot;&gt;3.3 SAX的使用示例&lt;/h3&gt;

&lt;p&gt;SAX的使用，在于需要自定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;org.xml.sax.ContentHandler&lt;/code&gt;处理器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解析的主体代码如下：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) throws Exception {
	
	SAXParserFactory spf = SAXParserFactory.newInstance();
    spf.setNamespaceAware( true );
    
    XMLReader xmlReader = spf.newSAXParser().getXMLReader();
    
    xmlReader.setContentHandler(new StaffHandler());
    
    xmlReader.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;自定义的处理器 StaffHandler:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class StaffHandler extends DefaultHandler {

    boolean bfname = false;
    boolean blname = false;
    boolean bnname = false;
    boolean bsalary = false;
 
    public void startElement (String uri, String localName,
            String qName, Attributes attributes) throws SAXException {

        System.out.println(&quot;Start Element :&quot; + qName);
 
        if (qName.equalsIgnoreCase(&quot;FIRSTNAME&quot;)) {
            bfname = true;
        }
 
        if (qName.equalsIgnoreCase(&quot;LASTNAME&quot;)) {
            blname = true;
        }
 
        if (qName.equalsIgnoreCase(&quot;NICKNAME&quot;)) {
            bnname = true;
        }
 
        if (qName.equalsIgnoreCase(&quot;SALARY&quot;)) {
            bsalary = true;
        }
 
    }
 
    public void endElement(String uri, String localName,
        String qName) throws SAXException {
 
        System.out.println(&quot;End Element :&quot; + qName);
 
    }
 
    public void characters(char ch[], int start, int length) throws SAXException {
 
        if (bfname) {
            System.out.println(&quot;First Name : &quot; + new String(ch, start, length));
            bfname = false;
        }
 
        if (blname) {
            System.out.println(&quot;Last Name : &quot; + new String(ch, start, length));
            blname = false;
        }
 
        if (bnname) {
            System.out.println(&quot;Nick Name : &quot; + new String(ch, start, length));
            bnname = false;
        }
 
        if (bsalary) {
            System.out.println(&quot;Salary : &quot; + new String(ch, start, length));
            bsalary = false;
        }
 
    }
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四关于-saxparserfactory-和-documentbuilderfactory&quot;&gt;四、关于 SAXParserFactory 和 DocumentBuilderFactory&lt;/h2&gt;

&lt;h3 id=&quot;41-相似的代码相同的设计模式&quot;&gt;4.1 相似的代码，相同的设计模式&lt;/h3&gt;

&lt;p&gt;对比前面的代码，可以发现两者主体部分代码，十分相似，使用了相同的设计模式。&lt;/p&gt;

&lt;p&gt;再看一下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DOM:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取工厂实例
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();

//由工厂实例，获得DocumentBuilder
DocumentBuilder builder = factory.newDocumentBuilder();

//解析ing
Document document = builder.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;SAX:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//获取工厂实例
SAXParserFactory spf = SAXParserFactory.newInstance();
spf.setNamespaceAware( true );

//由工厂实例，获得XMLReader
XMLReader xmlReader = spf.newSAXParser().getXMLReader();
    
xmlReader.setContentHandler(...);

//解析ing 
xmlReader.parse(new InputSource(new FileInputStream(&quot;staffs.xml&quot;)));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里，我想探讨一下两者的工厂实例是如何获取的。&lt;/p&gt;

&lt;p&gt;查了下jdk 1.8 源码。&lt;/p&gt;

&lt;h3 id=&quot;42-两者工厂实例的相同实现&quot;&gt;4.2 两者工厂实例的相同实现&lt;/h3&gt;

&lt;p&gt;两者工厂实例，都是由&lt;code class=&quot;highlighter-rouge&quot;&gt;FactoryFinder.find&lt;/code&gt;方法实现&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;javax.xml.parsers.DocumentBuilderFactory:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static DocumentBuilderFactory newInstance() {
    return FactoryFinder.find(
            /* The default property name according to the JAXP spec */
            DocumentBuilderFactory.class, // &quot;javax.xml.parsers.DocumentBuilderFactory&quot;
            /* The fallback implementation class name */
            &quot;com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;javax.xml.parsers.SAXParserFactory:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static SAXParserFactory newInstance() {
    return FactoryFinder.find(
            /* The default property name according to the JAXP spec */
            SAXParserFactory.class,
            /* The fallback implementation class name */
            &quot;com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;43-factoryfinderfind-的逻辑&quot;&gt;4.3 FactoryFinder.find 的逻辑&lt;/h3&gt;

&lt;p&gt;继续阅读源码，获知&lt;code class=&quot;highlighter-rouge&quot;&gt;FactoryFinder.find&lt;/code&gt;的逻辑包括两个部分：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;查找定位工厂类&lt;/li&gt;
  &lt;li&gt;根据查到的工厂类，生成最终实例&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如何查找定位工厂类？按下面顺序，使用找到的第一个：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用系统属性。对DocumentBuilderFactory而言，是&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/code&gt;；对SAXParserFactory而言，是&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers.SAXParserFactory&lt;/code&gt;。所以，你可以在启动java时，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;-Djavax.xml.parsers.DocumentBuilderFactory=...&lt;/code&gt;来设置DocmentBuilder的工厂类，SAXParser类似。&lt;/li&gt;
  &lt;li&gt;读取JRE目录下的属性文件 “lib/jaxp.properties”，其中属性名分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers.SAXParserFactory&lt;/code&gt;。&lt;/li&gt;
  &lt;li&gt;使用jar包的&lt;code class=&quot;highlighter-rouge&quot;&gt;Service Provider&lt;/code&gt;机制，加载工厂类。也就是说，查找所有加载的jar包中&lt;code class=&quot;highlighter-rouge&quot;&gt;META-INF/services&lt;/code&gt;目录下的配置文件，文件名分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers.DocumentBuilderFactory&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;javax.xml.parsers.SAXParserFactory&lt;/code&gt;。文件的内容就是该jar包内提供的类实例。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;xercesImple-2.x.x.jar&lt;/code&gt;提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.xerces.jaxp.SAXParserFactoryImpl&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;使用系统默认的工厂类。分别为：&lt;code class=&quot;highlighter-rouge&quot;&gt;com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;com.sun.org.apache.xerces.internal.jaxp.SAXParserFactoryImpl&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五总结&quot;&gt;五、总结&lt;/h2&gt;

&lt;p&gt;好了，至此，你已经掌握了JDK中自带的DOM和SAX的基本使用方法了。&lt;/p&gt;

&lt;p&gt;本文，所使用的示例代码，可以从&lt;a href=&quot;/attachment/src-jaxp20150504.zip&quot;&gt;这里&lt;/a&gt;获取。&lt;/p&gt;

&lt;h2 id=&quot;八参考文献&quot;&gt;八、参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.ibm.com/developerworks/cn/java/j-lo-jse67/&quot;&gt;https://www.ibm.com/developerworks/cn/java/j-lo-jse67/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cnblogs.com/evanliu/p/3665113.html&quot;&gt;http://www.cnblogs.com/evanliu/p/3665113.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.mkyong.com/java/how-to-read-xml-file-in-java-sax-parser/&quot;&gt;http://www.mkyong.com/java/how-to-read-xml-file-in-java-sax-parser/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.javacodegeeks.com/2013/05/parsing-xml-using-dom-sax-and-stax-parser-in-java.html&quot;&gt;http://www.javacodegeeks.com/2013/05/parsing-xml-using-dom-sax-and-stax-parser-in-java.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Solr 应用（三）－查询数据</title>
   <link href="http://www.blogways.net/blog/2015/05/04/solr-usage-3.html"/>
   <updated>2015-05-04T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/04/solr-usage-3</id>
   <content type="html">&lt;p&gt;前两节主要介绍了一些基本的概念以及简单的查询演示，大家可能有一些大概的印象了，这个时候想要进一步了解一下，尤其是那个 web 控制台查询操作的时候太混乱了，每个条件都代表什么意思都不知道，这节主要介绍查询数据相关的一些概念以及运算、语法。&lt;/p&gt;
&lt;h3 id=&quot;常用查询参数说明&quot;&gt;常用查询参数说明&lt;/h3&gt;

&lt;table class=&quot;table table-bordered table-striped table-condensed&quot;&gt;
	&lt;thead&gt;
		&lt;th width=&quot;20%&quot;&gt;Field&amp;lt;/td&amp;gt;
		&lt;th width=&quot;80%&quot;&gt;Description&amp;lt;/td&amp;gt;
	&amp;lt;/thead&amp;gt;
	&lt;tr&gt;
        &lt;td&gt;Request-handler(qt)&lt;/td&gt;
		&lt;td&gt;指定请求的查询处理。如果没有指定一个查询处理，Solr进程将以标准的查询处理响应。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;q&lt;/td&gt;
		&lt;td&gt;查询字符串，这个是必须的。如果查询所有*:* ，根据指定字段查询（Name:张三 AND Address:北京）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;fq&lt;/td&gt;
		&lt;td&gt;（filter query）过虑查询，作用：在q查询符合结果中同时是fq查询符合的，例如：q=Name:张三&amp;amp;fq=CreateDate:[20081001 TO 20091031],找关键字mm，并且CreateDate是20081001&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;fl&lt;/td&gt;
		&lt;td&gt;指定返回那些字段内容，用逗号或空格分隔多个。&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;start&lt;/td&gt;
		&lt;td&gt;返回第一条记录在完整找到结果中的偏移位置，0开始，一般分页用。&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;rows&lt;/td&gt;
		&lt;td&gt;指定返回结果最多有多少条记录，配合start来实现分页。&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;sort&lt;/td&gt;
		&lt;td&gt;排序，格式：sort=&lt;field name=&quot;&quot;&gt;+&amp;lt;desc|asc&amp;gt;[,&lt;field name=&quot;&quot;&gt;+&amp;lt;desc|asc&amp;gt;]… 。示例：（score desc, price asc）表示先 “score” 降序, 再 “price” 升序，默认是相关性降序。 &amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
	&lt;tr&gt;
        &lt;td&gt;wt&lt;/td&gt;
		&lt;td&gt;(writer type)指定输出格式，可以有 xml, json, php, phps。 &lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;indent&lt;/td&gt;
		&lt;td&gt;是否需要将请求响应的结果以缩进的方式显示出来，使结果更具可读性，类似格式化显示 xml、json 等功能&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;debugQuery&lt;/td&gt;
		&lt;td&gt;是否需要显示调试信息，包括每个文档返回的“解释信息”，以便理解和管理程序的执行过程&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;dismax&lt;/td&gt;
		&lt;td&gt;是否启用 Dismax 查询解析器&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;edismax&lt;/td&gt;
		&lt;td&gt;是否启用扩展查询解析器&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;fl&lt;/td&gt;
		&lt;td&gt;表示索引显示那些field( *表示所有field,如果想查询指定字段用逗号或空格隔开（如：Name,SKU,ShortDescription或Name SKU ShortDescription【注：字段是严格区分大小写的】）) &lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;q.op&lt;/td&gt;
		&lt;td&gt;表示q 中 查询语句的 各条件的逻辑操作 AND(与) OR(或)&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;hl&lt;/td&gt;
		&lt;td&gt;是否高亮 ,如hl=true&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;hl.fl&lt;/td&gt;
		&lt;td&gt;高亮field ,hl.fl=Name,SKU&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;hl.snippets&lt;/td&gt;
		&lt;td&gt;默认是1,这里设置为3个片段&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;hl.simple.pre&lt;/td&gt;
		&lt;td&gt;高亮前面的格式&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;hl.simple.post&lt;/td&gt;
		&lt;td&gt;高亮后面的格式&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;facet&lt;/td&gt;
		&lt;td&gt;是否启动统计&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;facet.field&lt;/td&gt;
		&lt;td&gt;统计field&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;spatial&lt;/td&gt;
		&lt;td&gt;是否启用位置数据，该功能在地理或者空间搜索中使用&lt;/td&gt;
    &lt;/tr&gt;
	&lt;tr&gt;
        &lt;td&gt;spellcheck&lt;/td&gt;
		&lt;td&gt;是否启用拼写检查，提供在线的模糊匹配或者专业术语匹配等建议&lt;/td&gt;
    &lt;/tr&gt;
&amp;lt;/table&amp;gt;

### Solr运算符

	(1) “:” 指定字段查指定值，如返回所有值*:*
	
	(2) “?” 表示单个任意字符的通配
	
	(3) “*” 表示多个任意字符的通配（不能在检索的项开始使用*或者?符号）
	
	(4) “~” 表示模糊检索，如检索拼写类似于”roam”的项这样写：roam~将找到形如foam和roams的单词；roam~0.8，检索返回相似度在0.8以上的记录。
	
	(5) 邻近检索，如检索相隔10个单词的”apache”和”jakarta”，”jakarta apache”~10
	
	(6) “^” 控制相关度检索，如检索jakarta apache，同时希望去让”jakarta”的相关度更加好，那么在其后加上”^”符号和增量值，即jakarta^4 apache
	
	(7) 布尔操作符AND、||
	
	(8) 布尔操作符OR、&amp;amp;&amp;amp;
	
	(9) 布尔操作符NOT、!、- （排除操作符不能单独与项使用构成查询）

	(10) “+” 存在操作符，要求符号”+”后的项必须在文档相应的域中存在

	(11) ( ) 用于构成子查询

	(12) [] 包含范围检索，如检索某时间段记录，包含头尾，date:[200707 TO 200710]

	(13) {} 不包含范围检索，如检索某时间段记录，不包含头尾，date:{200707 TO 200710}

	(14) / 转义操作符，特殊字符包括+ - &amp;amp;&amp;amp; || ! ( ) { } [ ] ^ ” ~ * ? : /

 *注：①“+”和”-“表示对单个查询单元的修饰，and 、or 、 not 是对两个查询单元是否做交集或者做差集还是取反的操作的符号*

　　 比如:AB:china +AB:america ,表示的是AB:china忽略不计可有可无，必须满足第二个条件才是对的,而不是你所认为的必须满足这两个搜索条件

　　 如果输入:AB:china AND AB:america ,解析出来的结果是两个条件同时满足，即+AB:china AND +AB:america或+AB:china +AB:america

　　 总而言之，查询语法：  修饰符 字段名:查询关键词 AND/OR/NOT 修饰符 字段名:查询关键词

### Solr查询语法

	(1) 最普通的查询，比如查询姓张的人（ Name:张）,如果是精准性搜索相当于SQL SERVER中的LIKE搜索这需要带引号（&quot;&quot;）,比如查询含有北京的（Address:&quot;北京&quot;）	

	(2) 多条件查询，注：如果是针对单个字段进行搜索的可以用（Name:搜索条件加运算符(OR、AND、NOT) Name：搜索条件）,比如模糊查询（ Name:张 OR Name:李 ）单个字段多条件搜索不建议这样写，一般建议是在单个字段里进行条件筛选，如（ Name:张 OR 李），多个字段查询（Name:张 + Address:北京 ）	

	(3) 排序，比如根据姓名升序（Name asc）,降序（Name desc）

本文参考了 `http://blog.csdn.net/cgddm/article/details/44303203` 这篇文章中的 `Solr查询数据` 部分来写的，参数部分增加了一些官方文档里面多出来参数
&lt;/field&gt;&lt;/field&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/th&gt;&lt;/th&gt;&lt;/thead&gt;&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 安装与分布式部署</title>
   <link href="http://www.blogways.net/blog/2015/05/04/mongodb-install-and-distribution-deploy.html"/>
   <updated>2015-05-04T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/05/04/mongodb-install-and-distribution-deploy</id>
   <content type="html">&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;p&gt;NoSQL数据库与传统的关系型数据库相比，它具有操作简单、完全免费、源码公开、随时下载等特点，并可以用于各种商业目的。这使NoSQL产品广泛应用于各种大型门户网站和专业网站，大大降低了运营成本。&lt;/p&gt;

&lt;p&gt;MongoDB的文档模型自由灵活，可以让你在开发过程中畅顺无比。对于大数据量、高并发、弱事务的互联网应用，MongoDB可以应对自如。MongoDB内置的水平扩展机制提供了从百万到十亿级别的数据量处理能力，完全可以满足Web2.0和移动互联网的数据存储需求，其开箱即用的特性也大大降低了中小型网站的运维成本。&lt;/p&gt;

&lt;h2 id=&quot;二安装mongodb&quot;&gt;二、安装MongoDB&lt;/h2&gt;
&lt;p&gt;到官网下载对应的版本&lt;a href=&quot;http://www.mongodb.org/downloads&quot;&gt;http://www.mongodb.org/downloads&lt;/a&gt;，下载完成后解压即可使用。也可以下载源码自己编译&lt;a href=&quot;https://github.com/mongodb/mongo&quot;&gt;https://github.com/mongodb/mongo&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载编译好的文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/tools
wget -c https://fastdl.mongodb.org/osx/mongodb-osx-x86_64-3.0.2.tgz
# 等待下载完成
tar zxf mongodb-osx-x86_64-3.0.2
ln -s mongodb-osx-x86_64-3.0.2 mongodb
echo &quot;export MONGODB_HOME=~/tools/mongodb&quot; &amp;gt;&amp;gt; ~/.bash_profile &amp;amp;&amp;amp; source ~/.bash_profile 命令行启动 MongoDB 后台驻留程序：

mongod --dbpath /data/mongodb/db --logpath /data/mongodb/logs/mongod.log --nojournal --fork --port 27037 后台mongodb 主流程序，监听本机 27037 号端口，数据库文件保存在`/data/mongodb/db`目录下，日志文件输出到`/data/mongodb/logs/mongod.log`文件下，并禁用`journaling`( 启用 journaling 后，会将数据库相关操作等以日志的形式保存下来，会占用较大的硬盘空间和虚拟内存，64位mongodb，默认开启；32位版本默认关闭 )。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;mongo&lt;/code&gt; 连接 MongoDB 服务：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#mongo --help 可以查看mongo命令介绍
mongo test # 连接本地，27017端口的test数据库
mongo 192.168.20.1/test # 连接192.168.20.1主机，27017端口的数据库test
mongo 192.168.20.1:66666/test #连接192.168.20.1主角，66666端口的数据库test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三常用命令&quot;&gt;三、常用命令&lt;/h3&gt;
&lt;p&gt;一般数据操作都有一些常用的客户端命令( 此处为：mongo shell )，MongoDB 的基本存储单元是集合 (collection)，想到于关系数据库mysql、oracle或sql server的表；&lt;/p&gt;
&lt;h4 id=&quot;查询数据库&quot;&gt;查询数据库&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; show dbs    # or show databases
admin   (empty)
local   0.078GB
test    0.078GB #### 切换数据库
&amp;gt; use test
switched to db test #### 查看数据集合
&amp;gt; show collections
system.indexes
users #### 集合操作 集合的基本操作命令如下所示：

db.&amp;lt;collectionName&amp;gt;.&amp;lt;operate&amp;gt;(&amp;lt;argument&amp;gt;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;常用的集合操作有：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;查找记录 ( find )
查询记录数 ( count )
插入记录 ( insert )
删除记录 ( remove )
更新尽量 ( update ) 这所有的集合操作接受的参数都是通过 JSON 	的形式传递的：

#查询所有记录
db.users.find()
# 查找 users 集合中，姓名为 小王的记录
db.users.find({name: '小王'}) 因为MongoDB是 NoSQL 数据库，因此不需要预定义表结构，直接通过 insert 插入数据即可。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四分布式部署&quot;&gt;四、分布式部署&lt;/h3&gt;
&lt;p&gt;本机部署3个shard、1个mongos和3个 configsvr；&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Shard1：27037&lt;/li&gt;
  &lt;li&gt;Shard2：27038&lt;/li&gt;
  &lt;li&gt;Shard3：27039&lt;/li&gt;
  &lt;li&gt;Mongos：27017&lt;/li&gt;
  &lt;li&gt;Config1：27027&lt;/li&gt;
  &lt;li&gt;Config2：27028&lt;/li&gt;
  &lt;li&gt;COnfig3：27029&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;/data/mongodb&lt;/code&gt;目录下创建文件夹&lt;code class=&quot;highlighter-rouge&quot;&gt;shard0001&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;shard0002&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;shard0003&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;config0001&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;config0002&lt;/code&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;config0003&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;logs&lt;/code&gt;，分别用以保持分片数据、配置服务器数据和日志文件&lt;/p&gt;
&lt;h4 id=&quot;启动配置服务器&quot;&gt;启动配置服务器&lt;/h4&gt;
&lt;p&gt;首先启动3个配置服务器，测试环境使用一个配置服务器也可以，但是生产环境必须是3个，MongoDB最多支持3个配置服务器；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --configsvr --port 27027 --dbpath /data/mongodb/config0001 --logpath /data/mongodb/logs/config0001.log --fork
mongod --configsvr --port 27028 --dbpath /data/mongodb/config0001 --logpath /data/mongodb/logs/config0001.log --fork
mongod --configsvr --port 27029 --dbpath /data/mongodb/config0001 --logpath /data/mongodb/logs/config0001.log --fork 运行上诉命令将启动3个配置服务器，其中的参数介绍：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--configsvr&lt;/code&gt;，指定启动的是分配操作的配置服务器，该参数仅仅指定了默认的端口号( 27019 )和默认数据存放位置( /data/configdb )，并没有其它的任何用途，可以显示指定以覆盖默认设置&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--port [端口号]&lt;/code&gt;，指定该配置服务器监听的端口号，如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;--configsvr&lt;/code&gt;参数则默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;27019&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--dbpath [数据存放路径]&lt;/code&gt;，指定配置服务器存放文件目录，如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;--configsvr&lt;/code&gt;参数则默认为&lt;code class=&quot;highlighter-rouge&quot;&gt;/data/configdb&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--logpath [日志存放路径]&lt;/code&gt;，指定配置服务器的日志存放地；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--fork&lt;/code&gt;，指定该配置服务器位后台驻留程序；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;启动路由服务器&quot;&gt;启动路由服务器&lt;/h4&gt;
&lt;p&gt;路由服务器可以根据需求启动一个或多个，启动个数没有限制，作为MongoDB集群的访问点，提供与未分配中&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod&lt;/code&gt;类似的功能，是MongoDB集群对外的“接口”；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongos --port 27017 --configdb localhost:27027,localhost:27028,localhost:27029 logpath /data/mongodb/logs/mongos.log --fork 命令、参数介绍：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mongos&lt;/code&gt;，此处启动的命令是&lt;strong&gt;&lt;em&gt;mongos&lt;/em&gt;&lt;/strong&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--configdb&lt;/code&gt;，指定配置服务器的主机/IP地址 + 端口号，只能是3个或1个，多个之间通过 &lt;strong&gt;&lt;em&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;分割；&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;启动分片&quot;&gt;启动分片&lt;/h4&gt;
&lt;p&gt;分片实例其实就是通过命令&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod&lt;/code&gt;启动的 MongoDB 实例；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --port 27037 --dbpath /data/mongodb/shard0001 --logpath /data/mongodb/logs/shard0001.log --fork
mongod --port 27038 --dbpath /data/mongodb/shard0002 --logpath /data/mongodb/logs/shard0002.log --fork
mongod --port 27039 --dbpath /data/mongodb/shard0003 --logpath /data/mongodb/logs/shard0003.log --fork 至此所有分布式启动的后台程序都已启动完毕，后面就是分片操作了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;mongo-shell-分片&quot;&gt;Mongo Shell 分片&lt;/h4&gt;
&lt;p&gt;在按照上诉顺序启动完所有MongoDB 实例后，打开一个命令行参数，想前面说的那样，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;mongo&lt;/code&gt;命令连接路由服务器；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongo localhost:27017/admin
# or
$ mongo admin
MongoDB shell version: 2.6.7
connecting to: admin
mongos&amp;gt; 添加分片，MongoDB 会将启动的分片的信息保持到配置服务器上；

mongos&amp;gt; sh.addShard('localhost:27037')
{ &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; sh.addShard('localhost:27038')
{ &quot;shardAdded&quot; : &quot;shard0001&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; sh.addShard('localhost:27039')
{ &quot;shardAdded&quot; : &quot;shard0002&quot;, &quot;ok&quot; : 1 } 通过`sh.status()` 查看分片结果：

mongos&amp;gt; sh.status()
--- Sharding Status --- 
  sharding version: {
	&quot;_id&quot; : 1,
	&quot;version&quot; : 4,
	&quot;minCompatibleVersion&quot; : 4,
	&quot;currentVersion&quot; : 5,
	&quot;clusterId&quot; : ObjectId(&quot;55471025f722cd42a930ecee&quot;)
}
  shards:
	{  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;localhost:27037&quot; }
	{  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;localhost:27038&quot; }
	{  &quot;_id&quot; : &quot;shard0002&quot;,  &quot;host&quot; : &quot;localhost:27039&quot; }
  databases:
	{  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }
	{  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; } 启动数据库分片；

# 格式 : sh.enableSharding(&amp;lt;databaseName&amp;gt;)
mongos&amp;gt; sh.enableSharding('test')
{ &quot;ok&quot; : 1 } 当启动数据库*** test ***的分片过后，再通过`sh.status()`命令查看，可发现相应的改变：

# ... 前面相同
  databases:
	{  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }
	{  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; } 发现在***databases***一项中，对应的多了一向分片的*** test ***数据库，其中：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_id&lt;/code&gt;，表示分片的数据库名，此处为&lt;em&gt;** test **&lt;/em&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;partitioned&lt;/code&gt;，表示是否启动分片，为 &lt;em&gt;** true **&lt;/em&gt;表示启用分片；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;primary&lt;/code&gt;，表示数据库存放的“主片”，一旦主片存放满了，或达到了分片设置的阈值，才会将数据存放到其它片，否则将一直存放于该主片上。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此 MongoDB 的分布式部署完成。&lt;/p&gt;

&lt;h3 id=&quot;五集合分片&quot;&gt;五、集合分片&lt;/h3&gt;
&lt;p&gt;在集合分片之前，说明单片( 不分片 )的局限性：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;单台主机的硬盘资源限制，一台主机的硬盘空间是一定的，当存放数据量达到硬盘的容量极限后，就只能为主机增加硬盘空间；&lt;/li&gt;
  &lt;li&gt;入库速度的限制，如果某个功能实现每分每秒有大量的数据插入 (如：日志收集、网页抓取等)，单台主机入库的速度存在则极限( 后面会介绍 )，一旦入库请求操作此极限，入库速度会急剧下降；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;由此，分片的好处就不言而喻了，它可以进行水平扩展，一旦现行的设备无法满足需求之后，只需要添加分片即可，添加之后 MongoDB 会根据设置&lt;strong&gt;&lt;em&gt;自动平衡&lt;/em&gt;&lt;/strong&gt;数据( 将数据移动到新插入的分片中 )；&lt;/p&gt;

&lt;p&gt;还有就是如果集合分片之后，入库将会是分布式方式入库，&lt;em&gt;**mongos **&lt;/em&gt;会将所有的入库请求，根据设置分配到各个分片上，降低耽搁分片入库的极限，使得一些对入库要求很高的的程序能稳定运行；&lt;/p&gt;

&lt;p&gt;有得必有失，分片增加的入库速度，相应的查询更新速度就有所降低，如果不合理的查询( 没有提供分配字段 )，将导致遍历整个数据集合，这里的不合理查询一般都是查询条件中不包含分片的字段，MongoDB 则无法定位查询在哪个分配上进行，进而导致遍历整个集合。&lt;/p&gt;

&lt;h4 id=&quot;range-分片&quot;&gt;Range 分片&lt;/h4&gt;
&lt;p&gt;根据给定的列( 如：age )，按分片数的范围分片，如此处分为三片，则分配范围：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;minKey ~ 30			30 ~ 60			60 ~ maxKey 
shard0001         shard0002        shard0003 年龄在`minKey ~ 30`之间的信息，将会保存在分片***shard0001***上，`30 ~ 60`的则会保持在***shard0002***上，依次类推。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;分片方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# sh.shardCollection('&amp;lt;database&amp;gt;.&amp;lt;collection&amp;gt;', {'colName' : 1/-1})
sh.shardCollection('test.users', {'age': 1})
{ &quot;collectionsharded&quot; : &quot;test.users&quot;, &quot;ok&quot; : 1 } 可以通过`db.users.stats()`来查看分片过后集合的状态信息，因为是按范围分布的，相同范围之内的存放于同一个分片中，要提升入库速度的话，必须选择合适的分片依据，防止同一时间段内入口同一范围的数据；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以通过设置多个分片健来解决，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sh.shardCollections('test.users', {'age': 1, 'name': 1}) 所以合理选择分片Key很重要
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;hash-分片&quot;&gt;Hash 分片&lt;/h4&gt;
&lt;p&gt;顾名思义，Hash 分片就是将数据根据分配字段 Hash 分布到各个片中，好处是即使同一时刻分配字段连续递增，入库结果基本也是均衡分配的；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	             Hash Function
	 _________________|_____________________
    |                 |                     |
shard0001         shard0002             shard0003 入库记录会经过***mongos***的Hash 函数的处理，将不同的记录分发到各个分片中入库。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;分片方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# sh.shardCollection('&amp;lt;database&amp;gt;.&amp;lt;collection&amp;gt;', {'age': 'hashed'})
mongos&amp;gt; sh.shardCollection('test.info', {'phone': 'hashed'})
{ &quot;collectionsharded&quot; : &quot;test.info&quot;, &quot;ok&quot; : 1 } 分片信息`db.info.stats()`：

mongos&amp;gt; db.info.stats()
{
	&quot;sharded&quot; : true,
	&quot;systemFlags&quot; : 1,
	&quot;userFlags&quot; : 1,
	&quot;ns&quot; : &quot;test.info&quot;,
	&quot;count&quot; : 0,
	&quot;numExtents&quot; : 3,
	&quot;size&quot; : 0,
	&quot;storageSize&quot; : 24576,
	&quot;totalIndexSize&quot; : 49056,
	&quot;indexSizes&quot; : {
		&quot;_id_&quot; : 24528,
		&quot;phone_hashed&quot; : 24528
	},
	&quot;avgObjSize&quot; : 0,
	&quot;nindexes&quot; : 2,
	&quot;nchunks&quot; : 6,
	&quot;shards&quot; : {
		&quot;shard0000&quot; : {
			&quot;ns&quot; : &quot;test.info&quot;,
			&quot;count&quot; : 0,
			&quot;size&quot; : 0,
			&quot;storageSize&quot; : 8192,
			&quot;numExtents&quot; : 1,
			&quot;nindexes&quot; : 2,
			&quot;lastExtentSize&quot; : 8192,
			&quot;paddingFactor&quot; : 1,
			&quot;systemFlags&quot; : 1,
			&quot;userFlags&quot; : 1,
			&quot;totalIndexSize&quot; : 16352,
			&quot;indexSizes&quot; : {
				&quot;_id_&quot; : 8176,
				&quot;phone_hashed&quot; : 8176
			},
			&quot;ok&quot; : 1
		},
		&quot;shard0001&quot; : {
			...
		},
		&quot;shard0002&quot; : {
			...
		}
	},
	&quot;ok&quot; : 1
} 现在再去插入一些记录看下，所有的记录分别被插入到了不同的分当中去了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;分片部分完成，后续还有 MongoDB 分片等的，根据官方文档的详细介绍。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（二）－初次应用体验</title>
   <link href="http://www.blogways.net/blog/2015/04/30/solr-usage-2.html"/>
   <updated>2015-04-30T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/30/solr-usage-2</id>
   <content type="html">&lt;h2 id=&quot;solr-初次应用体验&quot;&gt;Solr 初次应用体验&lt;/h2&gt;
&lt;p&gt;前一节主要介绍了 Solr5.0 的简介以及安装部署，本次主要介绍如何使用 Solr 做一些简单的搜索任务&lt;/p&gt;
&lt;h3 id=&quot;创建搜索实例&quot;&gt;创建搜索实例&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;命令创建实例&quot;&gt;命令创建实例&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bin/solr create -c test
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;查看创建可选参数&quot;&gt;查看创建可选参数&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bin/solr create -help
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;Web 控制台创建&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Core Admin / Add Core
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-2-1.png&quot; alt=&quot;Web 控制台创建索引&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里我们创建一个 test 测试实例&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;导入测试文档&quot;&gt;导入测试文档&lt;/h3&gt;
&lt;p&gt;导入一些 solr 自带的 json 测试文档数据&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bin/post -c test example/exampledocs/*.json
SimplePostTool version 5.0.0
Posting files to [base] url http://localhost:8983/solr/gettingstarted/update...
Entering auto mode. File endings considered are
xml,json,csv,pdf,doc,docx,ppt,pptx,xls,xlsx,odt,odp,ods,ott,otp,ots,rtf,htm,html,txt,log
POSTing file books.json (application/json) to [base]
1 files indexed.
COMMITting Solr index changes to http://localhost:8983/solr/gettingstarted/update...
Time spent: 0:00:00.450
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;web-控制台搜索体验&quot;&gt;Web 控制台搜索体验&lt;/h3&gt;
&lt;p&gt;例如：查询作者为 &lt;code class=&quot;highlighter-rouge&quot;&gt;Rick Riordan&lt;/code&gt; 所有的书&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-2-2.png&quot; alt=&quot;Web 控制台 query 测试&quot; /&gt;&lt;/p&gt;

&lt;p&gt;http://localhost:8983/solr/test/select?q=author%3A%22Rick+Riordan%22&amp;amp;wt=json&amp;amp;indent=true&lt;/p&gt;

&lt;p&gt;返回结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;responseHeader&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;status&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;QTime&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;params&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;indent&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;q&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;author:\&quot;Rick Riordan\&quot;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;wt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;json&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;response&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;numFound&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;start&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;docs&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;978-0641723445&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;book&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hardcover&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;The Lightning Thief&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Rick Riordan&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;series_t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Percy Jackson and the Olympians&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sequence_i&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;genre_s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fantasy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;inStock&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;price&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;12.5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;pages_i&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;384&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_version_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1497865383114178560&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
      &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;978-1423103349&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;cat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;book&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
          &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;paperback&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;name&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;The Sea of Monsters&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;author&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Rick Riordan&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;series_t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Percy Jackson and the Olympians&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;sequence_i&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;genre_s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fantasy&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;inStock&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;price&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:[&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;6.49&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;pages_i&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;304&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;_version_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1497865383259930624&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，这个只是简单的查询示例，可以只输入一部分查询，或者按价钱区间来查询（例：查询 10-20 这个价钱区间的书就可以写成 &lt;code class=&quot;highlighter-rouge&quot;&gt;price:[ 10 TO 20 ]&lt;/code&gt;），也可以组合条件查询，当然也可以限制查询结果只返回需要的字段，或者高亮显示匹配部分等等。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Solr 应用（一）－初次体验</title>
   <link href="http://www.blogways.net/blog/2015/04/29/solr-usage-1.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/solr-usage-1</id>
   <content type="html">&lt;h2 id=&quot;solr-的简介以及安装&quot;&gt;Solr 的简介以及安装&lt;/h2&gt;
&lt;p&gt;我们要学习一个新东西的时候总是仍不住会问，这是个什么东西，干什么用的，能帮我们解决什么问题，然后才是如何应用，如何优化等等。本次我们要讨论的是 Solr，它是一个开源的企业级搜索服务器，可以说是 Apache Lucene 搜索引擎的企业级应用的实现。下面几节将简单介绍下 solr 的应用（使用 Solr5.0 版本）。&lt;/p&gt;
&lt;h3 id=&quot;solr-简介&quot;&gt;Solr 简介&lt;/h3&gt;
&lt;p&gt;Solr 是一个高性能，采用 java5 开发，基于 Lucene 的全文搜索服务器。提供了比Lucene更为丰富的查询语言，同时实现了可配置、可扩展并对查询性能进行了优化，并且提供了一个完善的功能管理界面，拥有强大的全文检索功能，高亮显示检索结果，动态集群，数据库接口和电子文档（Word ，PDF 等）的处理。而且Solr 具有高度的可扩展，支持分布搜索和索引的复制。是一款非常优秀的全文搜索引擎。&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;h4 id=&quot;环境参数&quot;&gt;环境参数&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Jdk1.7+（下载地址 http://www.oracle.com/technetwork/java/javase/downloads/index.html）
Tomcat7（Solr5.0 自带 Jetty 服务器，可以直接启动）
Solr5.0（下载地址 http://lucene.apache.org/solr/）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;安装步骤&quot;&gt;安装步骤&lt;/h4&gt;

&lt;hr /&gt;
&lt;h5 id=&quot;linux&quot;&gt;Linux&lt;/h5&gt;
&lt;p&gt;这里直接使用自带的 Jetty 服务器测试&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接解压 Solr&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ cd ~/
  $ tar zxf solr-5.0.0.tgz
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动 Solr&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr start
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脚本帮助&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr -help
  $ bin/solr start -help
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;前台启动 Solr&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr start -f
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定端口启动&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr start -p 8984
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;停止 Solr&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr stop -p 8983
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;启动一个特殊示例配置的 Solr&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr -e techproducts
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;检查 Solr 运行状态&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ bin/solr status
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，Solr 就算成功启动了，可以去 web 控制台验证下 &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8983/solr/&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h5 id=&quot;windows&quot;&gt;Windows&lt;/h5&gt;
&lt;p&gt;这里我们用自己的服务器 Tomcat7 来部署运行&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;解压 Solr &amp;amp;&amp;amp; 部署&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在目录 &lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0/server/webapps&lt;/code&gt; 目录下面有个 solr.war 包，把这个拷贝到 tomcat webapp 目录下，启动 tomcat，自动解压 solr 工程&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;修改 web.xml&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &amp;lt;env-entry&amp;gt;
     &amp;lt;env-entry-name&amp;gt;solr/home&amp;lt;/env-entry-name&amp;gt;
     &amp;lt;env-entry-value&amp;gt;E:\tools\solr-5.0.0\server\solr&amp;lt;/env-entry-value&amp;gt;
     &amp;lt;env-entry-type&amp;gt;java.lang.String&amp;lt;/env-entry-type&amp;gt;
  &amp;lt;/env-entry&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;env-entry-value&lt;/code&gt; 节点值改成 solr 的目录&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加 jar 包&lt;/p&gt;

    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0\server\lib\ext&lt;/code&gt; 目录下所有的 jar 包拷贝到 &lt;code class=&quot;highlighter-rouge&quot;&gt;apache-tomcat-7.0.42\webapps\solr\WEB-INF\lib&lt;/code&gt; 下面&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;添加 log4j 配置&lt;/p&gt;

    &lt;p&gt;将 &lt;code class=&quot;highlighter-rouge&quot;&gt;solr-5.0.0\server\resources\log4j.properties&lt;/code&gt; 拷贝到 &lt;code class=&quot;highlighter-rouge&quot;&gt;apache-tomcat-7.0.42\webapps\solr\WEB-INF\classes&lt;/code&gt; 目录下（classes 目录需要手动创建）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;启动 tomcat，打开控制台可以看到跟上面效果一样的&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;web-控制台&quot;&gt;Web 控制台&lt;/h4&gt;
&lt;p&gt;搞了半天，看下控制台长什么样子~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/solr-1-1.png&quot; alt=&quot;Solr5.0 Web 控制台&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Redis实现TOP500排行功能( 列表和有序集合 )</title>
   <link href="http://www.blogways.net/blog/2015/04/29/rank-by-redis.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/rank-by-redis</id>
   <content type="html">&lt;h2 id=&quot;一背景介绍&quot;&gt;一、背景介绍&lt;/h2&gt;
&lt;p&gt;通过 node.js 将系统产生的日志入库到 mongodb，并统计最大耗时的TOP500，因为 node.js 操作 mongodb 都是通过异步调用的回调函数来完成的，所以在获取表中记录数的时候操作起来特别的烦琐，还有一个原因就是启动多个 node.js 实例来入库数据的时候，并发请求太多，可能多个 node.js 删除的时同一条记录，导致在实际测试过程中，统计表中的记录条数不是 500，而可能时几十、几百万条数据。&lt;/p&gt;

&lt;h2 id=&quot;二数据结构&quot;&gt;二、数据结构&lt;/h2&gt;
&lt;p&gt;通过采集系统的日志文件发送到 node.js，经过分析过后的数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var obj = {
	&quot;MAX&quot; : 123214,
	&quot;MIN&quot; : 234,
	&quot;AVERAGE&quot; : 3245,
	...
} 根据 MAX 或 MIN 排序；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三实现&quot;&gt;三、实现&lt;/h2&gt;
&lt;p&gt;TOP500 统计有两个阶段：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;表中记录数不满 500 条时，在此阶段任何新插入的数据都是TOP500，直接插入数据即可&lt;/li&gt;
  &lt;li&gt;表中数据大于 500 条时，在此阶段若插入一条数据，就需要删除一条数据；&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述第二阶段时，一般数据库的操作方式就是找到并删除 &lt;code class=&quot;highlighter-rouge&quot;&gt;MAX 最小&lt;/code&gt;( &lt;strong&gt;当按MAX排行时，只要比表中最小的大，就是TOP500&lt;/strong&gt; )或&lt;code class=&quot;highlighter-rouge&quot;&gt;MIN 最大&lt;/code&gt;( &lt;strong&gt;当按MIN排行时，只要比表中最大的大，就是TOP500&lt;/strong&gt; )的一条记录，然后将新纪录插入数据库即可。&lt;/p&gt;

&lt;h3 id=&quot;有序集合-sorted-sets-&quot;&gt;有序集合( Sorted sets )&lt;/h3&gt;
&lt;p&gt;在 node.js 中连接 redis 的所有操作都是异步回调的，而在判断表中记录数的时候需要等待结果，然后才能进行后续的操作，此处需要同步等待，因而使用 async 来实现：&lt;/p&gt;

&lt;p&gt;因为有序集合会将插入的数据的值自动排序，所有表中第一条、或最后一条记录即是最小、最大值，操作不复杂，使用起来也很方便；操作有两种实现方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;手动判断数据个数，在表中记录不满500条时插入数据，超过500条之后根据排行榜功能返回表中第一条或最后一条记录，与当前值比较判断是否插入并删除取出的数据；&lt;/li&gt;
  &lt;li&gt;不管表中有多少条数据，先讲记录插入到表中，然后删除500条之后的记录、或倒数500条之前的记录；&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;实现方式一&quot;&gt;实现方式一&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var env = process.env.NODE_ENV || 'development',
	config = require('../../config/config')[env];
	logger = require('../../log').logger,
	redis = require('redis'),
	client = redis.createClient(config.redis.port,config.redis.host),
	async = require('async');

...  省略中间代码  ...

var value = obj[field];
async.auto({
	step1: function (callback) {
		client.zcard(['test'], callback);
	},
	step2: ['step1', function (callback, result) {
		if (result.step1 &amp;lt; 500) {
			client.zadd(['test', value, JSON.stringify(obj)], function (err, rest){
				if (err) {
					logger.error(err);
				} else {
					callback('redis insert successfully!')
				}
			})
		} else {
			if (type == 'max') {
				client.zrange(['test', 0, 0, 'withscores'], callback)
			} else {
				client.zrange(['test', -1, -1, 'withscores'], callback)
			}
		}
	}],
	step3: ['step2', function (callback, result) {
		if ( (type == 'max' &amp;amp;&amp;amp; value &amp;gt; result.step2[1]) || 
				(type == 'min' &amp;amp;&amp;amp; obj.MIN &amp;lt; result.step2[1]) ) {
			client.rem(['test', result.step2[0]], redis.print);
			client.zadd(['test', value, JSON.stringify(obj)], redis.print);
		}
	}]
}, function(err, results) {
	client.quit();
}); 这种方法很符合传统的思路，比较容易理解，但是很明显操作比较多，还使用了一些插件、判断等，效率应该不是很高。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;实现方式二&quot;&gt;实现方式二&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var env = process.env.NODE_ENV || 'development',
	config = require('../../config/config')[env];
	logger = require('../../log').logger,
	redis = require('redis'),
	client = redis.createClient(config.redis.port,config.redis.host);
	
...  省略中间代码  ...

var value = obj[field];
client.zadd(['test', value, JSON.stringify(obj)], redis.print);
if (type == 'MAX') {
	client.zremrangebyrank(['test', 0, -500], redis.print);
} else {
	client.zremrangebyrank(['test', 500, -1], redis.print);
} 第二种实现方式代码量很少，所有的实现都是调用的 redis 提供的接口方法来实现，因而运行效率比方式一要高很多，比较推荐此种方式。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为按 MAX 字段统计排行榜时，要保留MAX最大的TOP500，而表按照数值升序排序的，所以需要保留表中后500跳记录( 删除表中后500条之前的数据，即第一条记录到倒数第500条之间的数据：&lt;code class=&quot;highlighter-rouge&quot;&gt;zremrangebyrank(['test', 0, -500], redis.print)&lt;/code&gt; );&lt;/p&gt;

&lt;p&gt;同理，按照 MIN 字段统计排行榜时，只需要删除500条之后的数据( 升序排序，则第一条到第500条即为TOP500，&lt;code class=&quot;highlighter-rouge&quot;&gt;zremrangebyrank(['test', 500, -1], redis.print)&lt;/code&gt; )。&lt;/p&gt;

&lt;h3 id=&quot;使用到的方法介绍&quot;&gt;使用到的方法介绍&lt;/h3&gt;
&lt;p&gt;redis 对 node.js 的所有接口方法都有两个参数，第一个为一个数组( &lt;code class=&quot;highlighter-rouge&quot;&gt;[]&lt;/code&gt; )，数组中的参数即为在&lt;code class=&quot;highlighter-rouge&quot;&gt;redis-cli&lt;/code&gt;客户端执行命令时的参数，第二个参数为一个回调函数，通常为 &lt;code class=&quot;highlighter-rouge&quot;&gt;function (err, result){ ... }&lt;/code&gt;，方法执行的结果保存在 result 中。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;client.zcard([ tabname ], callback)&lt;/code&gt;：同客户端命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;ZCARD&lt;/code&gt;，得到的有序集合成员的数量；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;client.zadd([ tabname, value, key ], callback)&lt;/code&gt;：同客户端命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;ZADD&lt;/code&gt;，添加一个或多个成员到有序集合，或者如果它已经存在更新其数据值；添加多个记录：&lt;code class=&quot;highlighter-rouge&quot;&gt;client.zadd(['test', 1, 'a1', 2, 'a2'.....], callback)&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;client.zrange([ tabname, start stop, 'withscores' ], callback)&lt;/code&gt;：同客户端命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;ZRANGE&lt;/code&gt;，由索引返回一个成员范围的有序集合，如果有&lt;code class=&quot;highlighter-rouge&quot;&gt;withscores&lt;/code&gt;参数，则对于 key 的值也会返回，如：&lt;code class=&quot;highlighter-rouge&quot;&gt;[ 'a1', '1' ]&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;client.rem([ tabname, key], callback)&lt;/code&gt;：同客户端命令&lt;code class=&quot;highlighter-rouge&quot;&gt;ZREM&lt;/code&gt;，从有序集合中删除一个或多个成员；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;client.zremrangebyrank([ tabname, start, stop ], callback)&lt;/code&gt;，同客户端命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;ZREMRANGEBYRANK&lt;/code&gt;，在给定的索引之内删除所有成员的有序集合，下标从 0 开始，-1 表示最后一条记录，-500 表示倒数第500条记录。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;列表&quot;&gt;列表&lt;/h3&gt;
&lt;p&gt;因为列表只有一个key，不存在 value的说法，因而通过 Lists 来实现的时候，需要将比较字段通过一些处理，并放到转换为字符串的前面，如在按照如下对象的 MAX 字段统计时：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var obj = {
	&quot;MAX&quot; : 123214,
	&quot;MIN&quot; : 234,
	&quot;AVERAGE&quot; : 3245,
	...
} 转化成的字符串需为：`&quot;{\&quot;KEY\&quot;:\&quot;00000000002.342424\&quot;,\&quot;MAX\&quot;:2.342424,\&quot;MIN\&quot;:0.023212,\&quot;AVERAGE\&quot;:0.065464, ....}&quot;`，因为没有 value的说法，所以只能按照字符串的ASCII的方式来比较，所以比较字段需要将位数统一。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;redis 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令能按照指定的顺序排序( desc，降序；asc，升序 )，同时可以截取排序结果并保存为一个单独的表( 或覆盖原来的表 )，如此则可以使用有序集合实现方式二的思想来实现：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;按 MAX 统计排行榜时，按降序排序，则前500条记录即为TOP500；&lt;/li&gt;
  &lt;li&gt;按 MIN 统计排行榜时，按升序排序，则钱500条记录即为TOP500；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var env = process.env.NODE_ENV || 'development',
	config = require('../../config/config')[env];
	logger = require('../../log').logger,
	redis = require('redis'),
	client = redis.createClient(config.redis.port,config.redis.host);
	
...  省略中间代码  ...

var value = obj[field],
	adesc = type == &quot;max&quot; ? &quot;desc&quot; : &quot;asc&quot;,
	tmpstr = JSON.stringify(obj),
	tmpval = Array((11-(''+Math.floor(value)).length+1)).join(0)+value, //整数部分统一到 11 位
	multi = client.multi();
	
var str = tmpstr.replace('{','{&quot;KEY&quot;:&quot;'+tmpval+'&quot;,'); // 将 KEY 部分添加到 字符串中
multi.rpush([tabname, str], redis.print);
multi.sort([tabname, 'limit', 0, count, adesc, 'alpha', 'store', tabname], redis.print);
multi.exec(function(err,rest){
	if(err){
		logger.error(err);
	}else{
		logger.debug(rest);
	}
}); 代码也很简洁，不过实际效率情况的高低就不得而知了，其中需要注意的就是要将统计字段取出做等长处理( `MAX: 1.23` 和 `MAX: 11.3`，前者比后者小，但是转换为字符串之后，前者比后者大，将它们的整数位等长到11位或更多后，可以解决这个问题)；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种实现方式的思路：将新的记录插入到表中，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;命令排序，并截取前500条记录覆盖原来的表，虽然每次都有排序，但是实际情况没有想象中那么糟糕，因为每次插入数据钱的数据都是排序好了的，插入一条数据的排序花销可能不是很大( 具体要看redis的排序实现方式：如果是通过快速排序来实现的话，效率会很低；如果是通过冒泡方式来实现的话效率会高不少 )。&lt;/p&gt;

&lt;p&gt;这种方法只是一种探究，基本不会使用到生产环境中，推荐使用有序集合的实现方式二。&lt;/p&gt;

&lt;p&gt;使用的方法说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi = client.multi();&lt;/code&gt;，顾名思义，相当于一个client的命令序列，先将要执行的命令放入其中，带启动时顺序执行；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpush([tabname, key], callback);&lt;/code&gt;，同客户端命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;RPUSH&lt;/code&gt;，添加一个或多个值到列表右端( 尾部 )；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sort([tabname, 'limit', start, stop, 'asc'/'desc', 'alpha', 'store', tabname1], callback)&lt;/code&gt;：同客户端命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;sort&lt;/code&gt;，将表 &lt;code class=&quot;highlighter-rouge&quot;&gt;tabname&lt;/code&gt;的key 按字母( 默认会将key 转换为 double类型再做排序 )的升序或降序排列，并截取下标&lt;code class=&quot;highlighter-rouge&quot;&gt;start&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;之间的元素，保存到 &lt;code class=&quot;highlighter-rouge&quot;&gt;tabname1&lt;/code&gt;表中；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;multi.exec(callback)&lt;/code&gt;，按先后顺序运行&lt;code class=&quot;highlighter-rouge&quot;&gt;multi&lt;/code&gt;中的命令；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大概的通过 Redis 实现排行榜的就是这样，如果有什么好的想法也可以跟我联系，一起交流进步！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[5] 之 自定义组件</title>
   <link href="http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-5.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-5</id>
   <content type="html">&lt;h2 id=&quot;一custom-source&quot;&gt;一、Custom Source&lt;/h2&gt;
&lt;p&gt;实现 Source 接口即可定义Custom Sources，在启动Flume Agent的时候，用户自定义源的类及其依赖必须包括在agent 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;classpath&lt;/code&gt;中。Custom Source 的类型是它的全限定性类名。&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;FQCN ( 全限定性类名，如：org.example.MyCustomSource )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;replicating&lt;/code&gt; 或 &lt;code&gt;multiplexing&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例：&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = org.example.MyCustomSource
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自定义-source&quot;&gt;自定义 Source&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建工程：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mvn archetype:create -DgroupId=org.apache.flume -DartifactId=flume-ng-db-source -DpackageName=com.ai.flume -Dversion=1.0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt; 添加依赖：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;/dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
    		&amp;lt;groupId&amp;gt;org.apache.flume&amp;lt;/groupId&amp;gt;
 	    &amp;lt;artifactId&amp;gt;flume-ng-core&amp;lt;/artifactId&amp;gt;
			&amp;lt;version&amp;gt;1.5.2&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
         &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
     	&amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
         &amp;lt;version&amp;gt;5.1.35&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
     &amp;lt;dependency&amp;gt;
 			&amp;lt;groupId&amp;gt;com.oracle&amp;lt;/groupId&amp;gt;
 		&amp;lt;artifactId&amp;gt;ojdbc14&amp;lt;/artifactId&amp;gt;
 			&amp;lt;version&amp;gt;10.2.0.1.0&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个类，继承 &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractSource&lt;/code&gt;，并实现接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;Configurable&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;PollableSource&lt;/code&gt;，如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; package com.ai.flume.source;
	
 public class FlumeNGDBSource extends AbstractSource implements Configurable, PollableSource {
     private static final Logger logger = LoggerFactory.getLogger(FlumeNGDBSource.class);
		
     public void configure(Context context) {
         // 处理配置文件( 如：conf/example.conf )中的属性
     }
		
     @Override
     public synchronized void start() {
         // Source 启动时的初始化、开启进程等
     }
		
     public Status process() throws EventDeliveryException {
         // Source 真正的工作进程
         // 获取data，封装到event中，发送到channel
     }
		
     @Override
     public synchronized void stop() {
 			// Source 结束时的变量释放、进程结束等
 		}
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置文件创建和使用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private String sqlType;
 private String sqlHost;
 private int sqlPort;
 private String Db;
 private String sqlUser;
 private String sqlPwd;
 private String sql;

 ...  省略中间代码  ...

 public void configure(Context context) {
     // 在此方法中，通过context.getString(&quot;property&quot;, defaultValue)
     // context.getInteger(&quot;property&quot;, defaultValue)来读取配置文件
 	    sqlType = context.getString(&quot;sql-type&quot;, &quot;oracle&quot;);
 	sqlHost = context.getString(&quot;sql-host&quot;, &quot;localhost&quot;);
     sqlPort = context.getInteger(&quot;sql-port&quot;, 3306);
 	    sqlDb = context.getString(&quot;sql-db&quot;, &quot;test&quot;);
 	sqlUser = context.getString(&quot;sql-user&quot;, null);
     sqlPwd = context.getString(&quot;sql-pwd&quot;, null);
 	    sql = context.getString(&quot;sql&quot;, &quot;select * from info;&quot;);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;上述文件的配置文件可以如下设置，&lt;code class=&quot;highlighter-rouge&quot;&gt;mydb.conf&lt;/code&gt;：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; a1.sources = r1
 a1.channels = c1
 a1.sources.r1.type = com.ai.flume.FlumeNGDBSource
 a1.sources.r1.sql-type = mysql
 a1.sources.r1.sql-host = 127.0.0.1
 # 这里的SQL不需要加双引号或单引号
 a1.sources.r1.sql = select * from users;
 # 使用默认端口 3306，默认数据库 test，默认没有用户和密码
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据封装为 Event，并发送到 Channel：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private ChannelProcessor channelProcessor = null;
 // 用于存放需要发送的队列
 // 从数据库中取出，然后放到队列中
 private LinkedBlockingQueue&amp;lt;String&amp;gt; queue = null;

 ...  省略中间代码  ...
	
 public Status process() throws EventDeliveryException {
 	Status status = Status.READY;
 	// 获取连接Channel的对象
 	    channelProcessor = getChannelProcessor();
    
     try {
     	// 取出一条要发送的数据
 	    String line = queue.take();
 	    // 通过logger以INFO的级别输出到Source的日志文件中
 	        logger.info(line);
 	        // 调用EventBuilder.withBody(String body, Charset set)，
 	        // 将要发送的数据封装为一个 event
         Event e = EventBuilder.withBody(line, Charset.forName(&quot;UTF8&quot;));
     	// 将封装后的 event发送到连接的 Channel
     	channelProcessor.processEvent(e);
 	} catch (Exception e) {
 		// 出现错误，返回Status.BACKOFF，告诉Source 发送失败
 		// 当自定义 Sink 的时候，这里需要注意，详见后面
 	        status = Status.BACKOFF;
        
         logger.error(&quot;flume-ng mysql source error!&quot;, e);
     	throw new EventDeliveryException(e);
 	}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

 	    return status;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; }	      到这基本自定义 Source已经完成了，其它要做的就是通过代码实现数据的生成或抓取，然后放到上述的`queue`当中。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Timer&lt;/code&gt;定时从数据库中取数据放到&lt;code class=&quot;highlighter-rouge&quot;&gt;queue&lt;/code&gt;中：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private Timer scannerTimer;
	
 ...  省略中间代码  ...

 @Override
 public synchronized void start() {
 	super.start();
 	queue = new LinkedBlockingQueue&amp;lt;String&amp;gt;();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

 	    scannerTimer = new Timer(“FlumeNG_Scanner_Timer_Thread”, true);
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     scannerTimer.scheduleAtFixedRate(new TimerTask() {
        
         @Override
     	public void run() {
             // 调用操作数据库方法，执行sql，返回数据
             list = ibd.selectAll(sql);
            
             if (list.size() &amp;lt;= 0) {
 	                try {
 	                Thread.sleep(10);
     	        } catch (InterruptedException e) {
         	        logger.error(&quot;[ Error ]:&quot;, e);
                 }
         	}
         	String res = &quot;&quot;;
             for (int i = 0; i &amp;lt; list.size(); i++) {
                 if (&quot;&quot; == res) {
                     res += list.get(i);
                 } else {
                     res += &quot;&amp;amp;data=&quot; + list.get(i);						}
             }
             // 将结果缓存到queue当中
             queue.offer(res);
         }
     }, 0, runSpeed); // runSpeed为配置文件当中的查询间隔
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stop&lt;/code&gt;方法：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @Override
 	public synchronized void stop() {
     super.stop();
     // 关闭与Channel的连接
 	    channelProcessor.close();
     // 结束数据获取线程
     if (scannerTimer != null) {
     	try {
 	        scannerTimer.cancel();
 	        } catch (Exception e) {

         } finally {
     	    scannerTimer = null;
 	    }
 	    }
 	queue = null;
 }  至此，自定义Source已经完成。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;jar&lt;/code&gt;包：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mvn clean package  在上面命令运行成功后，复制 `target/flume-ng-db-source-1.0.jar`到`$FLUME_HOME/lib`目录即可。

 cp target/flume-ng-db-source-1.0.jar $FLUME_HOME/lib
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二custom-sink&quot;&gt;二、Custom Sink&lt;/h2&gt;
&lt;p&gt;实现 Sink 接口即可定义Custom Sink，在启动Flume Agent的时候，用户自定义Sink的类及其依赖必须包括在agent 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;classpath&lt;/code&gt;中。Custom Sink 的类型是它的全限定性类名。&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;FQCN ( 全限定性类名，如：org.example.MyCustomSink )&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;replicating&lt;/code&gt; 或 &lt;code&gt;multiplexing&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例：&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = org.example.MyCustomSink
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;自定义-sink&quot;&gt;自定义 Sink&lt;/h3&gt;
&lt;p&gt;此 Sink从 Channel 获取 events，然后通过HTTP POST发送到远程的主机端口上。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;同样的，通过maven创建工程：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mvn archetype:create -DgroupId=org.apache.flume -DartifactId=flume-ng-http-source -DpackageName=com.ai.flume -Dversion=1.0
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑 &lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt; 添加依赖：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;/dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
    		&amp;lt;groupId&amp;gt;org.apache.flume&amp;lt;/groupId&amp;gt;
 	    &amp;lt;artifactId&amp;gt;flume-ng-core&amp;lt;/artifactId&amp;gt;
 	    &amp;lt;version&amp;gt;1.5.2&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
 &amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建一个类，继承 &lt;code class=&quot;highlighter-rouge&quot;&gt;AbstractSource&lt;/code&gt;，并实现接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;Configurable&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;PollableSource&lt;/code&gt;，如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; package com.ai.flume.source;
	
 public class FlumeNGHttpSink extends AbstractSink implements Configurable {
     private static final Logger logger = LoggerFactory.getLogger(FlumeNGHttpSink.class);
		
     public void configure(Context context) {
         // 处理配置文件( 如：conf/example.conf )中的属性
     }
		
     public Status process() throws EventDeliveryException {
         // Source 真正的工作进程
         // 获取data，封装到event中，发送到channel
     }
		
     public String post(String url, String param) {
         // http发送post请求
     }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置文件创建和使用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private String url;
 private String host;
 private String type;

 ...  省略中间代码  ...

 public void configure(Context context) {
     // 在此方法中，通过context.getString(&quot;property&quot;, defaultValue)
     // context.getInteger(&quot;property&quot;, defaultValue)来读取配置文件
 	    url = context.getString(&quot;node-url&quot;, &quot;http://127.0.0.1:5000/receive&quot;);
 	    host = context.getString(&quot;node-host&quot;, &quot;127.0.0.1&quot;);
     type = context.getString(&quot;node-type&quot;, &quot;TuxState&quot;);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;上述文件的配置文件可以如下设置，&lt;code class=&quot;highlighter-rouge&quot;&gt;mydb.conf&lt;/code&gt;：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; a1.sources = r1
 a1.channels = c1
 a1.sources.r1.type = com.ai.flume.FlumeNGHttpSink
 a1.sources.r1.node-url = http://localhost:3000/receive
 a1.sources.r1.node-host = 127.0.0.1
 a1.sources.r1.node-type = TuxState
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;从 Channel 获取 Event，并取出其中包含的数据：&lt;/p&gt;

 	public Status process() throws EventDeliveryException {
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 	// TODO(ai) Auto-generated method stub
 	Status status = Status.READY;
    	
     Channel channel = getChannel();
     Transaction txn = null;   

     try {
 	        txn = channel.getTransaction();
 	    txn.begin(); 	// 开始从Channel获取Event的事务处理
        	
     	Event e = channel.take();	// 从Channel取一个Event
     	if (null != e) {
             String line = EventHelper.dumpEvent(e);
             logger.info(line);
         	// 取出 Event 中包含的内容，然后转换为需要的类型，此处为String
             byte[] body = e.getBody(); 
             String data = new String(body);
     	    //logger.info(data);
 	        String str = &quot;localhost=&quot; + host + &quot;&amp;amp;type=&quot; + type + &quot;&amp;amp;data=&quot; + data;
             //将配置文件的信息和数据组合成post方法的param，调用编写的post方法发送到目的地
 	            logger.info(post(url, str));
         } else {
     	    status = Status.BACKOFF;
 	    }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

 	        txn.commit();
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     } catch (Exception e) {
     	// 前面提及过，在处理这的时候需要注意
     	// 若发送错误的原因是数据处理的问题，则可能会出现死循环
     	// 出错，而不执行txn.commit()，则出错的Event并不会从 Channel中删除
     	// 下一次获取的仍然是出错的 Event
 	        logger.error(&quot;can't process events, drop it!&quot;, e);
         if (txn != null) {
         	txn.commit();   //出现BUG，丢弃当前Event，防止出现死循环
     	}
 	    throw new EventDeliveryException(e);
 	    } finally {
         if (null != txn) {
         	txn.close();
     	}
 	}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

 	    return status;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; }	      HTTP的post方法此处不再给出，到这基本自定义 Sink已经完成了。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;生成&lt;code class=&quot;highlighter-rouge&quot;&gt;jar&lt;/code&gt;包：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; mvn clean package  在上面命令运行成功后，复制 `target/flume-ng-http-sink-1.0.jar`到`$FLUME_HOME/lib`目录即可。

 cp target/flume-ng-http-sink-1.0.jar $FLUME_HOME/lib
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;三custom-channel&quot;&gt;三、Custom Channel&lt;/h2&gt;

&lt;p&gt;…&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[4] 之 Channel</title>
   <link href="http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-4.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-4</id>
   <content type="html">&lt;h2 id=&quot;一常用channel介绍&quot;&gt;一、常用Channel介绍&lt;/h2&gt;
&lt;p&gt;Channels 是一个 Agent上存储 events 的仓库，Source 向其中添加 events，而 Sink从中取走移除 events。&lt;/p&gt;

&lt;p&gt;此处介绍的 Channel 有：Memory Channel、File Channel 和 Spillable Memory Channel。&lt;/p&gt;

&lt;h3 id=&quot;memory-channel&quot;&gt;Memory Channel&lt;/h3&gt;
&lt;p&gt;Source 添加的 events 都暂存在内存队列中，它非常适合那些需要更高吞吐量的数据流，但代价是一旦一个 agent 失败后，其中存储的events数据将会丢失。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;memory&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;capacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;存储在 Channel 当中的最大 events 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;transactionCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;同时刻从Source 获取，或发送到 Sink 的最大 events 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keep-alive&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;3&lt;/td&gt;&lt;td&gt;添加或删除一个 event 超时的秒数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacityBufferPercentage&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;p&gt;详情见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#memory-channel&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#memory-channel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实例 &lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = memory
a1.channels.c1.capacity = 10000
a1.channels.c1.transactionCapacity = 10000
a1.channels.c1.byteCapacityBufferPercentage = 20
a1.channels.c1.byteCapacity = 800000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;file-channel&quot;&gt;File Channel&lt;/h3&gt;
&lt;p&gt;必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;file&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hostname&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batch-size&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;一次同时发送的 event 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;connect-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次握手请求时允许的时长。( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;request-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次过后，后续请求允许的时长 ( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ireset-connection-interval&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = file
a1.channels.c1.checkpointDir = /mnt/flume/checkpoint
a1.channels.c1.dataDirs = /mnt/flume/data
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;spillable-memory-channel&quot;&gt;Spillable Memory Channel&lt;/h3&gt;
&lt;p&gt;Logs Sink 属于 INFO 级别的，通常用作测试或调试目的，其属性：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;SPILLABLEMEMORY&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;memoryCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;10000&lt;/td&gt;&lt;td&gt;存储在内存队列中的最大 events 数，设置为 &lt;code&gt;0&lt;/code&gt;，则禁用缓存到内存队列&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;overflowCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100000000&lt;/td&gt;&lt;td&gt;存储在本地磁盘的最大 events 数，设置为 &lt;code&gt;0&lt;/code&gt;，则禁用缓存到本地文件&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;overflowTimeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;3&lt;/td&gt;&lt;td&gt;当内存队列溢出后，启用本地磁盘缓存的超时时间&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacityBufferPercentage&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;见描述&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;byteCapacity&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;avgEventSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;500&lt;/td&gt;&lt;td&gt;估计将要缓存到 Channel 当中的 events 的平均大小 (单位：字节)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;&amp;lt;file channel properties&amp;gt;&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;见描述&lt;/td&gt;&lt;td&gt;&lt;i&gt;&lt;b&gt;详见表后的链接&lt;/b&gt;&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;详情见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#spillable-memory-channel&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#spillable-memory-channel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;memoryCapacity&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;byteCapacity&lt;/code&gt;被设置为 0，则 Flume 理解为内存队列已经满了。&lt;/p&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agnet a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = SPILLABLEMEMORY
a1.channels.c1.memoryCapacity = 10000
a1.channels.c1.overflowCapacity = 1000000
a1.channels.c1.byteCapacity = 800000
a1.channels.c1.checkpointDir = /mnt/flume/checkpoint
a1.channels.c1.dataDirs = /mnt/flume/data
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;禁用缓存 events 到内存队列，&lt;code class=&quot;highlighter-rouge&quot;&gt;memoryCapacity&lt;/code&gt;属性设为 0，则此 Channel 就像一个 File Channel：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.channels.c1.type = SPILLABLEMEMORY
a1.channels.c1.memoryCapacity = 0
a1.channels.c1.overflowCapacity = 1000000
a1.channels.c1.checkpointDir = /mnt/flume/checkpoint
a1.channels.c1.dataDirs = /mnt/flume/data 禁用缓存 events 到本地磁盘，`overflowCapacity`属性设为 0，则此 Channel 就像一个纯粹的 Memory Channel：

a1.channels = c1
a1.channels.c1.type = SPILLABLEMEMORY
a1.channels.c1.memoryCapacity = 100000
a1.channels.c1.overflowCapacity = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[3] 之 Sink</title>
   <link href="http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-3.html"/>
   <updated>2015-04-29T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/29/Apache-Flume-NG-Introduction-3</id>
   <content type="html">&lt;h2 id=&quot;一常用sink介绍&quot;&gt;一、常用Sink介绍&lt;/h2&gt;

&lt;p&gt;此处介绍的 Sinks 有：HDFS Sink、Logger Sink、Avro/Thrift Sink、HBase Sink。&lt;/p&gt;

&lt;h3 id=&quot;avro-sink&quot;&gt;Avro Sink&lt;/h3&gt;

&lt;p&gt;Avro Sink 为 Flume 的层次连接提供了一半的支持( 另一半为 Avro Source )，发送到此 Sink 的 Flume 被转换为 Avro 事件，然后被发送到对应的主机：端口上。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;avro&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hostname&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batch-size&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;一次同时发送的 event 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;connect-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次握手请求时允许的时长。( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;request-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次过后，后续请求允许的时长 ( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ireset-connection-interval&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;compression-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;可选项为“none”或“deflate”，compression-type必须符合匹配AvroSource的compression-type&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;compression-level&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;6&lt;/td&gt;&lt;td&gt;压缩 event 的压缩级别，0 为不压缩，1 - 9 为压缩，数字越大则压缩率越大。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ssl&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置为&lt;code&gt;true&lt;/code&gt;启用SSL加密，同时可以选择性设置“truststore”，“truststore-password”，“truststore-type”，并且指定是否打开“trust-all-certs”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;trust-all-certs&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;如果设置为 &lt;code&gt;true&lt;/code&gt;，则远程服务( Avro Source )的 SSL 服务证书将不会进行校验，因而生产环境不能设置为 &lt;code&gt;true&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;truststore&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java truststore文件的路径，需要启用SSL加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;truststore-password&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java truststore的密码，需要启用SSl加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;truststore-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;JKS&lt;/td&gt;&lt;td&gt;Java truststore的类型，可选项为：“JSK” 或其它支持的Java truststore 类型&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;exclude-protocols&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;SSLv2Hello SSLv3&lt;/td&gt;&lt;td&gt;Space-separated list of SSL/TLS protocols to exclude&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;maxIoWorkers&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;2 * 当前机器上可用的处理器数&lt;/td&gt;&lt;td&gt;I/O 处理线程的最大数，在 &lt;code&gt;NettyAvroRpcClient&lt;/code&gt; 和 &lt;code&gt;NioClientSocketChannelFactory&lt;/code&gt; 上被加载。&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例 &lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = avro
a1.sinks.k1.channel = c1
a1.sinks.k1.hostname = 10.10.10.10
a1.sinks.k1.port = 4545
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;thrift-sink&quot;&gt;Thrift Sink&lt;/h3&gt;
&lt;p&gt;Thrift Sink 为 Flume 的层次连接提供了一半的支持( 另一半为 Thrift Source )，发送到此 Sink 的 Flume 被转换为 Thrift 事件，然后被发送到对应的主机：端口上。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;thrift&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hostname&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;绑定的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batch-size&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;一次同时发送的 event 数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;connect-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次握手请求时允许的时长。( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;request-timeout&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20000&lt;/td&gt;&lt;td&gt;第一次过后，后续请求允许的时长 ( ms )&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ireset-connection-interval&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = thrift
a1.sinks.k1.channel = c1
a1.sinks.k1.hostname = 10.10.10.10
a1.sinks.k1.port = 4545
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hdfs-sink&quot;&gt;HDFS Sink&lt;/h3&gt;
&lt;p&gt;HDFS Sink 将 events 写入到 Hadoop 分布式文件系统( HDFS )当中，目前它支持创建文本文件和二进制序列化文件( SequenceFile )，这两种文件类型都支持压缩文件。数据库文件能够周期性地，在运行时间、数据大小或event数量的基础上轮转( 关闭当前文件，并创建一个新文件 )。It also buckets/partitions data by attributes like timestamp or machine where the event originated. The HDFS directory path may contain formatting escape sequences that will replaced by the HDFS sink to generate a directory/file name to store the events. 使用 HDFS Sink 需要安装 hadoop，如此 Flume 便能够通过 hadoop jars 连接 HDFS 集群，注意，Hadoop 的版本必须支持&lt;code class=&quot;highlighter-rouge&quot;&gt;sync()&lt;/code&gt;调用。&lt;/p&gt;

&lt;p&gt;下面是支持的转义序列：&lt;/p&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;20%&quot;&gt;别名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%{host}&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%t&lt;/td&gt;&lt;td&gt;Unix 时间的秒数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%a&lt;/td&gt;&lt;td&gt;本地的星期缩写名称 (Mon, Tue, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%A&lt;/td&gt;&lt;td&gt;本地的星期完整名称 (Monday, Tuesday, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%b&lt;/td&gt;&lt;td&gt;本地的月份缩写名称 (Jan, Feb, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%B&lt;/td&gt;&lt;td&gt;本地的月份完整名称 (January, February, ...)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%c&lt;/td&gt;&lt;td&gt;本地的日期和时间 (Thu Mar 3 23:05:25 2005)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%d&lt;/td&gt;&lt;td&gt;某月中的某天 (01)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%D&lt;/td&gt;&lt;td&gt;日期，与 &lt;code&gt;%m/%d/%y&lt;/code&gt; 一样&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%H&lt;/td&gt;&lt;td&gt;24 小时制的小时，&lt;b&gt;&lt;i&gt;补齐两位&lt;/i&gt;&lt;/b&gt; (00..23)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%I&lt;/td&gt;&lt;td&gt;12 小时制的小时，&lt;b&gt;&lt;i&gt;补齐两位&lt;/i&gt;&lt;/b&gt; (01..12)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%j&lt;/td&gt;&lt;td&gt;某年中的某天 (001..366)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%k&lt;/td&gt;&lt;td&gt;24 小时制的小时，&lt;b&gt;&lt;i&gt;不补齐两位&lt;/i&gt;&lt;/b&gt; ( 0..23)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%m&lt;/td&gt;&lt;td&gt;月份 (01..12)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%M&lt;/td&gt;&lt;td&gt;分钟数 (00..59)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%p&lt;/td&gt;&lt;td&gt;本地上午或下午 (am, pm)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%s&lt;/td&gt;&lt;td&gt;从 &lt;code&gt;1970-01-01 00:00:00 UTC&lt;/code&gt; 到现在的秒数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%S&lt;/td&gt;&lt;td&gt;秒数 (00..59)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%y&lt;/td&gt;&lt;td&gt;年份的后两位数字 (00..99)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%Y&lt;/td&gt;&lt;td&gt;年份 (2015)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;20%&quot;&gt;%z&lt;/td&gt;&lt;td&gt;+hhmm numeric timezone (for example, -0400)&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;正在读取的文件的文件名会以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.tmp&lt;/code&gt; 结尾，一旦文件被关闭，则扩展部分会被移除，这使排除目录中部分完成的文件称为可能。其config属性如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：对于所有与时间相关的转义系列，一个包含 “timestamp” 的header必须在 event 的所有headers中存在( 除非 &lt;code class=&quot;highlighter-rouge&quot;&gt;hdfs.useLocalTimeStamp&lt;/code&gt; 被设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt; )。设置自动添加的一种方式是使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;TimestampInterceptor&lt;/code&gt;。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;hdfs&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.path&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;HDFS 目录路径 (如 &lt;code&gt;hdfs://namenode/flume/webdata/&lt;/code&gt;)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.filePrefix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;FlumeData&lt;/td&gt;&lt;td&gt;在 HDFS 目录中，Flume 创建的文件的前缀&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.fileSuffix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;文件的后缀 (如 &lt;code&gt;.avro&lt;/code&gt; - 注意：时间不是自动添加的)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.inUsePrefix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Flume 正在写入的临时文件的的前缀&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;hdfs.inUseSuffix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;code&gt;.tmp&lt;/code&gt;&lt;/td&gt;&lt;td&gt;Flume 正在写入的临时文件的后缀&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;更多属性配置详见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#hdfs-sink&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#hdfs-sink&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = hdfs
a1.sinks.k1.channel = c1
a1.sinks.k1.hdfs.path = /flume/events/%y-%m-%d/%H%M/%S
a1.sinks.k1.hdfs.filePrefix = events-
a1.sinks.k1.hdfs.round = true
a1.sinks.k1.hdfs.roundValue = 10
a1.sinks.k1.hdfs.roundUnit = minute
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的配置将时间戳四舍五入到最近的10分钟，如：一个 event 的时间戳是 &lt;code class=&quot;highlighter-rouge&quot;&gt;11:54:34 AM, June 12, 2012&lt;/code&gt;，那么映射到 hdfs 路径则为 &lt;code class=&quot;highlighter-rouge&quot;&gt;/flume/events/2012-06-12/1150/00&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;hbase-sink&quot;&gt;HBase Sink&lt;/h3&gt;
&lt;p&gt;具体介绍等，详见：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#hbasesink&quot;&gt;http://flume.apache.org/FlumeUserGuide.html#hbasesink&lt;/a&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;hbase&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;table&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;HBase 中写入数据的表&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;columnFamily&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;HBase 中写入数据列簇&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;zookeeperQuorum&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;The quorum spec. This is the value for the property hbase.zookeeper.quorum in hbase-site.xml&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;znodeParent&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;/hbase&lt;/td&gt;&lt;td&gt;The base path for the znode for the -ROOT- region. Value of zookeeper.znode.parent in hbase-site.xml&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batchSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;每次事务处理写入的 event数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;coalesceIncrements&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;是否添加一个保存文件 &lt;code&gt;basename&lt;/code&gt; 的Header&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;serializer&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;org.apache.flume.sink.hbase.SimpleHbaseEventSerializer&lt;/td&gt;&lt;td&gt;Default increment column = “iCol”, payload column = “pCol”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;serializer.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Properties to be passed to the serializer.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;kerberosPrincipal&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Kerberos user principal for accessing secure HBase&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;kerberosKeytab&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Kerberos keytab for accessing secure HBase&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent agent-1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = hbase
a1.sinks.k1.table = foo_table
a1.sinks.k1.columnFamily = bar_cf
a1.sinks.k1.serializer = org.apache.flume.sink.hbase.RegexHbaseEventSerializer
a1.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;logger-sink&quot;&gt;Logger Sink&lt;/h3&gt;
&lt;p&gt;Logs Sink 属于 INFO 级别的，通常用作测试或调试目的，其属性：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;logger&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agnet a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.channels = c1
a1.sinks = k1
a1.sinks.k1.type = logger
a1.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Spring NoSuchBeanDefinitionException</title>
   <link href="http://www.blogways.net/blog/2015/04/28/spring-exception.html"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/28/spring-exception</id>
   <content type="html">&lt;p&gt;对于 Java 开发的 web 项目，Spring 成了小伙伴们的首选，几乎成了 JavaEE 的标配，在开发、测试的过程中免不了会碰到很多相关的错误，其中比较常见的一个错误就是  NoSuchBeanDefinitionException，下面来讨论一下常见的几种情况， 本文着重介绍 bootstrap 项目注解实例化 Bean，至于 xml 配置部分逻辑性比较好查，应该更容易定位问题，在这里就不介绍了。&lt;/p&gt;
&lt;h3 id=&quot;1-概述&quot;&gt;1. 概述&lt;/h3&gt;

&lt;p&gt;在这篇文章中，我们讨论一下 Spring &lt;code class=&quot;highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt; 在试图创建一个未在 Spring 上下文中定义的 Bean 时抛出的常见的异常 &lt;code class=&quot;highlighter-rouge&quot;&gt;org.springframework.beans.factory.NoSuchBeanDefinitionException&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们将在这里讨论下导致这个问题的可能的原因以及可用的解决方案。&lt;/p&gt;

&lt;h3 id=&quot;2-cause-no-qualifying-bean-of-type--found-for-dependency&quot;&gt;2. Cause: No qualifying bean of type […] found for dependency&lt;/h3&gt;

&lt;p&gt;导致这个异常的最常见的原因是企图注入一个未被定义的 bean。例如－在 BeanA 中注入 BeanB：
	@Component
	public class BeanA {&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    @Autowired
    private BeanB dependency;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但如果 BeanB 没有在 Spring 的上下文中定义依赖关系，bootstrap 进程会终止并抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;NoSuchBeanDefinitionException&lt;/code&gt; 异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type [org.baeldung.packageB.BeanB] found for dependency: 
expected at least 1 bean which qualifies as autowire candidate for this dependency. 
Dependency annotations: {@org.springframework.beans.factory.annotation.Autowired(required=true)}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Spring 已经明确指出：“至少需要一个 bean 作为 autowire 依赖注入”&lt;/p&gt;

&lt;p&gt;一个原因 BeanB 可能不在上下文中，需要 bean 在 classpath 扫描时自动加载，并且被成功注解为其中的一个 bean (@Component, @Repository, @Service, @Controller, etc)，那么很可能 BeanB 所在的包没有被 Spring 扫描到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package org.baeldung.packageB;
@Component
public class BeanB { ...}
While the classpath scanning may be configured as follows:

@Configuration
@ComponentScan(&quot;org.baeldung.packageA&quot;)
public class ContextWithJavaConfig {
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果 bean 所在的目录没有配置扫描，那么 BeanB 也就不会定义在当前的 Spring 上下文中。&lt;/p&gt;

&lt;h3 id=&quot;3-cause-no-qualifying-bean-of-type--is-defined&quot;&gt;3. Cause: No qualifying bean of type […] is defined&lt;/h3&gt;

&lt;p&gt;另外一种情况就是上下文中存在重复的 bean 定义，不唯一。例如，假如有一个接口 &lt;code class=&quot;highlighter-rouge&quot;&gt;IBeanB&lt;/code&gt; 被两个 bean (&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanB1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanB2&lt;/code&gt;) 实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Component
public class BeanB1 implements IBeanB {
    //
}
@Component
public class BeanB2 implements IBeanB {
    //
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当 BeanA 依赖注入这个接口时，Spring 不知道到底注入哪个实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Component
public class BeanA {

    @Autowired
    private IBeanB dependency;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果是 &lt;code class=&quot;highlighter-rouge&quot;&gt;BeanFactory&lt;/code&gt; 再次抛出了异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: 
No qualifying bean of type [org.baeldung.packageB.IBeanB] is defined: 
expected single matching bean but found 2: beanB1,beanB2
Similarly, Spring clearly indicates the reason for the wiring failure: “expected single matching bean but found 2″.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是注意，这次抛出的异常不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;NoSuchBeanDefinitionException&lt;/code&gt;，而是它的子类 &lt;code class=&quot;highlighter-rouge&quot;&gt;NoUniqueBeanDefinitionException&lt;/code&gt;。这个新的异常在 Spring 3.2.1 有介绍，具体的原因就是在上下文中存在重复的 bean 定义。&lt;/p&gt;

&lt;p&gt;如果不做指定，就会报如下的异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No qualifying bean of type [org.baeldung.packageB.IBeanB] is defined: 
expected single matching bean but found 2: beanB1,beanB2
One solution to this problem is to use the @Qualifier annotation to specify exactly the name of the bean we want to wire:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;-&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Component
public class BeanA {

    @Autowired
    @Qualifier(&quot;beanB2&quot;)
    private IBeanB dependency;
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过指定 &lt;code class=&quot;highlighter-rouge&quot;&gt;Qualifier&lt;/code&gt; 具体的注入 bean，Spring 将能决定使用哪个实现类来注入。&lt;/p&gt;

&lt;h3 id=&quot;4-cause-no-bean-named--is-defined&quot;&gt;4. Cause: No Bean Named […] is defined&lt;/h3&gt;

&lt;p&gt;当 Spring 的上下文中不存在指定名称的 bean 时同样会抛出 &lt;code class=&quot;highlighter-rouge&quot;&gt;NoSuchBeanDefinitionException&lt;/code&gt; 异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Component
public class BeanA implements InitializingBean {

    @Autowired
    private ApplicationContext context;

    @Override
    public void afterPropertiesSet() {
        context.getBean(&quot;someBeanName&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这个例子中，不存在 &lt;code class=&quot;highlighter-rouge&quot;&gt;someBeanName&lt;/code&gt; 名称定义的 bean 将会导致下面的异常：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: 
No bean named 'someBeanName' is defined
Again, Spring clearly and concisely indicates the reason for the failure: “No bean named X is defined“.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;5-cause-proxied-beans&quot;&gt;5. Cause: Proxied Beans&lt;/h3&gt;

&lt;p&gt;当上下文中一个 bean 使用 JDK 的动态代理机制代理时，那么这个代理类不需要扩展目标 bean （然而它将实现相同的接口）&lt;/p&gt;

&lt;p&gt;正因为如此，如果一个接口被注入，它将被正确接入。然而如果一个 bean 被实际类注入，Spring  将找不到匹配的类的 bean 定义，由于代理类实际上不扩展该类。&lt;/p&gt;

&lt;p&gt;一个很常见的代理是 Spring 的事务支持，即被 &lt;code class=&quot;highlighter-rouge&quot;&gt;@Transactional&lt;/code&gt; 注解的 bean。&lt;/p&gt;

&lt;p&gt;例如，如果 ServiceA 注入 ServiceB，两个服务都有事务，通过类定义注入将无法工作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service
@Transactional
public class ServiceA implements IServiceA{

    @Autowired
    private ServiceB serviceB;
    ...
}

@Service
@Transactional
public class ServiceB implements IServiceB{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同样的两个服务，这次通过接口注入就 OK：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service
@Transactional
public class ServiceA implements IServiceA{

    @Autowired
    private IServiceB serviceB;
    ...
}

@Service
@Transactional
public class ServiceB implements IServiceB{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;6-结论&quot;&gt;6. 结论&lt;/h3&gt;

&lt;p&gt;本文讨论了几种可能导致 &lt;code class=&quot;highlighter-rouge&quot;&gt;NoSuchBeanDefinitionException&lt;/code&gt; 的情况，重点是如何在实践中解决这些异常。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[2] 之 Source</title>
   <link href="http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-2.html"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-2</id>
   <content type="html">&lt;h2 id=&quot;一常用sources介绍&quot;&gt;一、常用Sources介绍&lt;/h2&gt;

&lt;p&gt;此处介绍的 Sources 有：Avro Source、Thrift Source、Exec Source、Spooling Directory Source。&lt;/p&gt;

&lt;h3 id=&quot;avro-source&quot;&gt;Avro Source&lt;/h3&gt;

&lt;p&gt;监听 Avro 端口，接收外部 Avro 客户端发来的 Event 是流，当和另一个Agent (Event流上，前面一个) 的 Avro Sink 连接配对时，能够将两个 Agent 连接形成一个Event 链。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;avro&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bind&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;threads&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;能生成的工作线程的最大数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;compression-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;none&lt;/td&gt;&lt;td&gt;可选项为“none”或“deflate”，compression-type必须符合匹配AvroSource的compression-type&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ssl&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置为&lt;code&gt;true&lt;/code&gt;启用SSL加密，同时必须制定一个“keystore”和一个“keystore-password”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keystore&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java keystore文件的路径，需要启用SSL加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keystore-password&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Java keystore的密码，需要启用SSl加密&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;keystore-type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;JKS&lt;/td&gt;&lt;td&gt;Java keystore的类型，可选项为：“JSK” 和 “PKCS12”&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;exclude-protocols&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;SSLv3&lt;/td&gt;&lt;td&gt;Space-separated list of SSL/TLS protocols to exclude. SSLv3 will always be excluded in addition to the protocols specified.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ipFilter&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置为&lt;code&gt;true&lt;/code&gt;启用ip过滤&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ipFilter.rules&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;通过此配置，定义ip过滤的表达式规则&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例 &lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = avro
a1.sources.r1.bind = localhost
a1.sources.r1.port = 4141
a1.sources.r1.ipFilter = true
a1.sources.r1.ipFilter.rules = allow:ip:127.*,allow:name:localhost,deny:ip:*

a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ipFilter.rules&lt;/code&gt;定义格式如下 ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;allow or deny&amp;gt;:&amp;lt;ip or name for computer name&amp;gt;:&amp;lt;pattern&amp;gt; 或

allow/deny:ip/name:pattern
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;thrift-source&quot;&gt;Thrift Source&lt;/h3&gt;
&lt;p&gt;监听 Thrift 端口，接收外部 Thrift 客户端发来的 Event 是流，当和另一个Agent (Event流上，前面一个) 的 Thrift Sink 连接配对时，能够将两个 Agent 连接形成一个Event 链。其必须的属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;thrift&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bind&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的主机名或者 IP 地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听的端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;threads&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;能生成的工作线程的最大数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = thrift
a1.sources.r1.channels = c1
a1.sources.r1.bind = 0.0.0.0
a1.sources.r1.port = 4141
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;exec-source&quot;&gt;Exec Source&lt;/h3&gt;
&lt;p&gt;Exec Source 运行一个给定的 Unix 命令，此命令需要在启动后，进程能不断的产生数据到标准输出( 除非将 &lt;code class=&quot;highlighter-rouge&quot;&gt;logStdErr&lt;/code&gt; 设置为 &lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，否则标准错误输出stderr将会被抛弃 )。如果 Unix 命令进程意外退出了，Exec Source 也会退出，不会再产生数据。这意味着配置如 &lt;code class=&quot;highlighter-rouge&quot;&gt;cat [named pipe]&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;tail -F [file]&lt;/code&gt; 命令的时候将会产生期望的结果，而使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt; 命令的时候不会，前面两个命令会产生数据流，但是后面一个任务只会产生一个单一的 Event，然后马上退出。其config属性如下：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;exec&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;command&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;需要执行的命令&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;shell&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;调用来运行命令的shell，如：&lt;code&gt;/bin/sh -c&lt;/code&gt;，Required only for commands relying on shell features like wildcards, back ticks, pipes etc.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;restartThrottle&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;10000&lt;/td&gt;&lt;td&gt;重启之前的等待时间(ms
)&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;resstart&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置是否重启命令，如果命令进程死了&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;logStdErr&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;设置是否命令的标准错误输出会被发送&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batchSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;20&lt;/td&gt;&lt;td&gt;同时读取和发送的最大行数&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;replicating&lt;/td&gt;&lt;td&gt;replicating 或 multiplexing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：可以使用Exec Source 模仿Flume 0.9x ( flume-og )中的 Tail Source，只要使用 Unix 命令&lt;code class=&quot;highlighter-rouge&quot;&gt;tail -F /full/path/to/your/file&lt;/code&gt;，在此情况下，参数 &lt;code class=&quot;highlighter-rouge&quot;&gt;-F&lt;/code&gt;比 &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;要更好，因为它会根据文件轮询。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = exec
a1.sources.r1.command = tail -F /var/log/secure
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt;配置来执行&lt;code class=&quot;highlighter-rouge&quot;&gt;command&lt;/code&gt;，通过一个命令行脚本( 如 Bash 或 PowerShell )，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agent_foo.sources.tailsource-1.type = exec
agent_foo.sources.tailsource-1.shell = /bin/bash -c
agent_foo.sources.tailsource-1.command = for i in /path/*.txt; do cat $i; done
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;spooling-directory-source&quot;&gt;Spooling Directory Source&lt;/h3&gt;
&lt;p&gt;SpoolDir Source 支持从磁盘“spooling”文件夹读取数据文件，此源会监控指定的文件夹的新增文件，一旦有新文件出现，SpoolDir Source 会将其解析为 Event发送，这个 Event 解析逻辑时插件化的。在一个文件被全部读入到 Channel 之后， 该文件会被重命名标记完成( 或选择性的删除 )。&lt;/p&gt;

&lt;p&gt;不同于 Exec Source，这个源是可靠的，即使 Flume 进程重启或是被杀掉都不会丢失数据。作为可靠性的交换，只有不变的且命名唯一的文件才能被放入源监控的目录，Flume 会检测这些问题条件，如果违反了，Flume 会报错：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果一个文件在移动到 SpoolDir Source 监控目录下之后被更改过，Flume 会在日志文件中输出错误信息，并停止 Flume 进程；&lt;/li&gt;
  &lt;li&gt;如果一个文件名在一段时间后被重复使用，Flume 会在日志文件中输出错误信息，并停止 Flume 进程。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了避免上述问题，比较好的方法是：在日志文件被移动到监控目录时，给日志文件用唯一标示符来命名( 例如：时间戳，timestamp )；&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;spooldir&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;spoolDir&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;源监控的目录路径&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;fileSuffix&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;.COMPLETED&lt;/td&gt;&lt;td&gt;文件被读入完成后添加的标示符后缀&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deletePolicy&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;never&lt;/td&gt;&lt;td&gt;是否删除完成读入的文件，可选项：&lt;code&gt;never&lt;/code&gt; 或 &lt;code&gt;immediate&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;fileHeader&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;是否添加一个保存文件绝对路径的 Header&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;fileHeaderKey&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;file&lt;/td&gt;&lt;td&gt;当给 event header 添加绝对路径名的时候使用&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;basenameHeader&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;false&lt;/td&gt;&lt;td&gt;是否添加一个保存文件 &lt;code&gt;basename&lt;/code&gt; 的Header&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;basenameHeaderKey&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;basename&lt;/td&gt;&lt;td&gt;当给 event header 添加 &lt;code&gt;basename&lt;/code&gt; 的时候使用&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ignorePattern&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;^$&lt;/td&gt;&lt;td&gt;忽略正则表达式指定的文件&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;trackerDir&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;.flumespool&lt;/td&gt;&lt;td&gt;保存跟进程文件相关元数据的目录，如果此路径不是一个绝对路径，就会解释为一个相对于 &lt;code&gt;spoolDir&lt;/code&gt; 的路径。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;consumeOrder&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;oldest&lt;/td&gt;&lt;td&gt;监控目录下的文件被读取的顺序，可选项为：&lt;code&gt;oldest&lt;/code&gt;、&lt;code&gt;youngest&lt;/code&gt;、&lt;code&gt;random&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;maxBackoff&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;4000 ( ms )&lt;/td&gt;&lt;td&gt;当 Channel 满了之后，连续尝试往 Channel 传送数据的最大时间间隔。SpoolDir Source 开始会启动一个很低的 &lt;code&gt;maxBackoff&lt;/code&gt;，一旦 Channel 抛出一个 &lt;code&gt;ChannelException&lt;/code&gt; 的时候，就会增加此 &lt;code&gt;maxBackoff&lt;/code&gt; 值，直到达到指定的最大值。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;batchSize&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100&lt;/td&gt;&lt;td&gt;数据被传送到 Channel 的粒度。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;inputCharset&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;UTF-8&lt;/td&gt;&lt;td&gt;将输入当做文本文档解析时候使用的字符集，即监控文件的字符集&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;decodeErrorPolicy&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;code&gt;FAIL&lt;/code&gt;&lt;/td&gt;&lt;td&gt;当发现一个无法解析字符集的输入文件时，需要做的处理：&lt;code&gt;FAIL&lt;/code&gt;，抛出一个异常并标记解析失败；&lt;code&gt;REPLACE&lt;/code&gt;，使用 “replacement character” 字符重复解析错误解析字符，例如 Unicode U+FFFD；&lt;code&gt;IGNORE&lt;/code&gt;，删除无法解析的字符串序列。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;code&gt;LINE&lt;/code&gt;&lt;/td&gt;&lt;td&gt;指定将文件解析为 Event 的解析器，默认解析每行为一个 Event，指定的限定性类名必须实现接口 &lt;code&gt;EventDeserializer.Builder&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;Varies per event deserializer.&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bufferMaxLines&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;该选项已经被忽略&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bufferMaxLineLength&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;5000&lt;/td&gt;&lt;td&gt;(Deprecated) 提交缓存中一行的最大长度，使用 &lt;code&gt;deserializer.maxLineLength&lt;/code&gt; 代替。&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;replicating&lt;/td&gt;&lt;td&gt;replicating 或 multiplexing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agent agent-1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;agent-1.channels = ch-1
agent-1.sources = src-1

agent-1.sources.src-1.type = spooldir
agent-1.sources.src-1.channels = ch-1
agent-1.sources.src-1.spoolDir = /var/log/apache/flumeSpool
agent-1.sources.src-1.fileHeader = true
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;netcat-source&quot;&gt;NetCat Source&lt;/h3&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;channels&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;组件类型名称必须是&lt;code&gt;netcat&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;bind&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听主机名或ip地址&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;port&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;监听端口号&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;max-line-length&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;512&lt;/td&gt;&lt;td&gt;每个 event 内容的最大行数 ( 单位：字节 )&amp;lt;/code&amp;gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;ack-every-event&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;true&lt;/td&gt;&lt;td&gt;每接收到一个 event 则回发一个 OK&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.type&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;replicating&lt;/td&gt;&lt;td&gt;replicating 或 multiplexing&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;selector.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;依赖selector.type的值&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;Space-separated list of interceptors&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;interceptors.*&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;实例，&lt;code class=&quot;highlighter-rouge&quot;&gt;Agnet a1&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1
a1.channels = c1
a1.sources.r1.type = netcat
a1.sources.r1.bind = 0.0.0.0
a1.sources.r1.bind = 6666
a1.sources.r1.channels = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二event-deserializers&quot;&gt;二、Event Deserializers&lt;/h2&gt;
&lt;p&gt;以下是 Flume 附带的 Event 解析器：Line、Avro、BlobDeserializer。&lt;/p&gt;

&lt;h3 id=&quot;line&quot;&gt;Line&lt;/h3&gt;
&lt;p&gt;此 deserializer 对应文本输入的每一行生成一个 event。&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.maxLineLength&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;2048&lt;/td&gt;&lt;td&gt;单个 event 能包含字符的最大数，如果一行超过了这个长度，将会被截断，该行中截断后剩余的字符会出现在后续的 event 中&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.outputCharset&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;UTF-8&lt;/td&gt;&lt;td&gt;发送到 Channel 的每个 event 的编码字符集&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;avro&quot;&gt;AVRO&lt;/h3&gt;
&lt;p&gt;详情见&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#avro&quot; title=&quot;http://flume.apache.org/FlumeUserGuide.html#avro&quot;&gt;AVRO Deserializer&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.schemaType&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;HASH&lt;/td&gt;&lt;td&gt;How the schema is represented. By default, or when the value HASH is specified, the Avro schema is hashed and the hash is stored in every event in the event header “flume.avro.schema.hash”. If LITERAL is specified, the JSON-encoded schema itself is stored in every event in the event header “flume.avro.schema.literal”. Using LITERAL mode is relatively inefficient compared to HASH mode.&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;h3 id=&quot;blobdeserializer&quot;&gt;BlobDeserializer&lt;/h3&gt;
&lt;p&gt;详情见&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html#blobdeserializer&quot; title=&quot;http://flume.apache.org/FlumeUserGuide.html#blobdeserializer&quot;&gt;Blob Deserializer&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;属性名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;默认值&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;-&lt;/td&gt;&lt;td&gt;这个类的全限定性类名： &lt;code&gt;org.apache.flume.sink.solr.morphline.BlobDeserializer$Builder&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td width=&quot;15%&quot;&gt;deserializer.maxBlobLength&lt;/td&gt;&lt;td width=&quot;10%&quot;&gt;100000000&lt;/td&gt;&lt;td&gt;一个给定请求读取和缓存的最大字节数&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Flume-NG 介绍[1] 之 配置安装</title>
   <link href="http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-1.html"/>
   <updated>2015-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2015/04/28/Apache-Flume-NG-Introduction-1</id>
   <content type="html">&lt;h2 id=&quot;一介绍&quot;&gt;一、介绍&lt;/h2&gt;

&lt;h3 id=&quot;11-概要&quot;&gt;1.1 概要&lt;/h3&gt;

&lt;p&gt;Flume 是 Cloudera 提供的日志收集系统，具有分布式、高可靠、高可用性等特点，对海量日志采集、聚合和传输，Flume 支持在日志系统中定制各类数据发送方，同时，Flume提供对数据进行简单处理，并写到各种数据接受方的能力。&lt;/p&gt;

&lt;p&gt;Flume 包括 0.9.x 和 1.x 两个版本，分别为 Flume-OG ( Flume Original Generation ) 和 Flume-NG ( Flume Next Generation )，Flume-OG 是一个分布式日志收集系统，有 Mater 概念，依赖于 zookeeper，其架构图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/flume-og-construction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Agent 用于采集数据，agent 是 flume 中产生数据流的地方，同时，agent 会将产生的数据流传输到 collector。对应的，collector 用于对数据进行聚合，往往会产生一个更大的流。&lt;/p&gt;

&lt;p&gt;而 Flume-NG，它摒弃了 Master和zookeeper，collector也没有了，web配置台也没有了，只剩下 source，sink和channel，此时一个agent的概念&lt;strong&gt;包括source，channel和sink&lt;/strong&gt;，完全由一个分布式系统变成了传输工具。不同机器之间的数据传输不再是OG那样由agent到collector，而是由一个agent端的sink流向另一个agent的source，其架构图如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/flume-ng-construction.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;agent的source端，直接抓取数据或接收从前一个 agent 传送过来的数据，并将其转发到&lt;strong&gt;一个或多个&lt;/strong&gt; channel 进行缓存；&lt;/p&gt;

&lt;p&gt;agent的 sink 端，从 channel 获取一个Event ( Flume-NG 的最小传输单元 )，然后传送到序列化端、下一个或多个agent 的source端。&lt;/p&gt;

&lt;p&gt;Event 就像上图中箭头所示方向流动， chennel 的功能就像一个队列，暂时保存所有的 Event，为了保证传输一定成功，在 Event 送到目的地之前，会先缓存数据，待数据真正到达目的地后，删除自己缓存的数据。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;官方网站：&lt;a href=&quot;http://flume.apache.org/&quot;&gt;http://flume.apache.org/&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;用户文档：&lt;a href=&quot;http://flume.apache.org/FlumeUserGuide.html&quot;&gt;http://flume.apache.org/FlumeUserGuide.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;开发文档：&lt;a href=&quot;http://flume.apache.org/FlumeDeveloperGuide.html&quot;&gt;http://flume.apache.org/FlumeDeveloperGuide.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-系统要求&quot;&gt;1.2 系统要求&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Flume 使用 java 编写，其需要运行在 Java1.6 或更高版本之上；( 推荐 Java1.7 )&lt;/li&gt;
  &lt;li&gt;保证有足够的内存空间让 Flume 的 source、 channel和 sink 使用；&lt;/li&gt;
  &lt;li&gt;Flume 的 channel 和 sinks 组件会有文件缓存到物理硬盘中，需要足够的硬盘空间；&lt;/li&gt;
  &lt;li&gt;Flume 会读取文件或目录，需要 agent 相关的文件目录的 &lt;strong&gt;&lt;em&gt;读写&lt;/em&gt;&lt;/strong&gt; 权限。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二基本组件&quot;&gt;二、基本组件&lt;/h2&gt;

&lt;h3 id=&quot;21-agent-之-source&quot;&gt;2.1 Agent 之 Source&lt;/h3&gt;

&lt;p&gt;source 可以接收外部源发送过来的数据，不同的 source，可以接受不同的数据格式，如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;目录池数据源(Spooling Directory Source)，可以监控指定文件夹中的新文件变化，如果目录中有文件产生，就会立刻读取其内容；&lt;/li&gt;
  &lt;li&gt;命令行数据源(Exec Source)，可以运行指定的shell命令(如：&lt;code class=&quot;highlighter-rouge&quot;&gt;tail -f [ file ]&lt;/code&gt; )等，将产生的标准输出(或标准错误输出，需要配置)封装到 Event 中，向指定的 channel 发送；&lt;/li&gt;
  &lt;li&gt;自定义源(Custom Source)，用户自定义的源，会重点介绍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-agent-之-channel&quot;&gt;2.2 Agent 之 Channel&lt;/h3&gt;

&lt;p&gt;channel 是一个存储地，接收 source 的输出，直到有 sink 消费掉 channel 中的数据。channel 中的数据直到进入到下一个channel中或者进入终端才会被删除。当 sink 写入失败后，可以自动重启，不会造成数据丢失，因此很可靠，常用的有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Memory Channel，将从 source 得到的 Event 都缓存到内存当中，存取速度快、高效，但是一旦 agent 崩了，缓存的数据无法恢复，可靠性不是太好；&lt;/li&gt;
  &lt;li&gt;File Channel，跟Memory Channel相对的，此处将得到的 Event 都缓存到本地磁盘的文件当中，存取访问速度没有内存高效，但是可靠性强，一旦 agent 进程死掉重启后，所有缓存的 Event 可以全部恢复；&lt;/li&gt;
  &lt;li&gt;Spillable Memory Channel， 前面两者的结合使用，首先发过来的 Event 都缓存到内存当中，一旦内存空间不够用了，就缓存到本地文件中，主要应用于内存空间不足，而硬盘空间充足的情况。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-agent-之-sink&quot;&gt;2.3 Agent 之 Sink&lt;/h3&gt;

&lt;p&gt;sink 会消费 channel 中的数据，然后送给外部源或者其他 source。如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;HDFS Sink/HBase Sink，根据配置将 Event 所包含的信息保存到本地 HDFS/HBase 中；&lt;/li&gt;
  &lt;li&gt;Logger Sink，顾名思义，将接收到的信息日志输出，主要用于测试和调试；&lt;/li&gt;
  &lt;li&gt;Avro Sink，说句实话，百度得知 Avro 是一个 Apache 的数据序列化的系统，具体是什么不需要关注，只需要知道 Avro Sink 是将接收到的数据转换为 Avro， 然后发送到下一个 Agent 的 Avro Source，多用于Agent 与 Agent之间的数据连接；&lt;/li&gt;
  &lt;li&gt;用户自定义(Custom Sink)，重点介绍。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;三安装与运行&quot;&gt;三、安装与运行&lt;/h2&gt;

&lt;p&gt;到官方网站下载，&lt;a href=&quot;http://flume.apache.org/download.html&quot;&gt;http://flume.apache.org/download.html&lt;/a&gt;，下载完成解压完成即可使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/tools
wget -c http://mirrors.hust.edu.cn/apache/flume/1.5.2/apache-flume-1.5.2-bin.tar.gz
# 等待下载完成
tar -xvf apache-flume-1.5.2-bin.tar.gz
ln -s apache-flume-1.5.2-bin flume-ng ( 将 ~/tools/flume-ng加入到环境变量FLUME_HOME中 )   ====&amp;gt;  个人习惯，可不做
cd flume-ng
bin/flume-ng help  # 查看flume-ng命令
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或通过编译源码的方式安装：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ~/tools
wget - http://mirrors.hust.edu.cn/apache/flume/1.5.2/apache-flume-1.5.2-src.tar.gz
tar -xf apache-flume-1.5.2-src.tar.gz
cd apache-flume-1.5.2-src
# 跳过测试
mvn clean install -DskipTests
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;30-配置文件说明&quot;&gt;3.0 配置文件说明&lt;/h3&gt;
&lt;p&gt;Flume 的 Agent的各个部件都是通过配置文件来实现的，Agent、Sources、Channels和Sinks的定义，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources = r1 r2
a1.sinks = k1 k2
a1.channels = c1 c2 其中`a1`是定义的 Agent 的名字，也是启动命令时`--name &amp;lt;agent&amp;gt;`中的`&amp;lt;agent&amp;gt;`为 `a1`；上代码Sources、Channels和 Sinks分别定义了两个分别为r1, r2, c1, c2, k1, k2；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;定义每个Sources的类型，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sources.r1.type = avro
a1.sources.r1.bind = localhost
a1.sources.r1.port = 33333

a1.sources.r2.type = netcat
a1.sources.r2.bind = localhost
a1.sources.r2.port = 44444 其中 `Source r1`定义为 Avro Source，监听 `http://localhost:33333`，`Source r2`定义为 NetCat Source；定义Channels 和 Sinks的方式跟 Sources类似；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为Sources 和 Sinks 绑定 Channels，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 为sink绑定时，为channels
a1.sources.r1.channels = c1
a1.sources.r2.channels = c2
# 为sink绑定时，为channel
a1.sinks.k1.channel = c1
a1.sinks.k2.channel = c2 注意：其中 Sources绑定 Channels时，为 `&amp;lt;agent&amp;gt;.sources.&amp;lt;source&amp;gt;`***`.channels`***；而 Sinks则为 `&amp;lt;agent&amp;gt;.sinks.&amp;lt;sink&amp;gt;`***`.channel`***。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;31-启动-agent&quot;&gt;3.1 启动 Agent&lt;/h3&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;flume-ng/conf&lt;/code&gt; 目录下新建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;mytest.conf&lt;/code&gt;做一个测试，内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 定义了一个agent( a1 ), 一个source( r1 ), 一个channel( c1 ), 一个sink( k1 )
a1.sources = r1
a1.sinks = k1
a1.channels = c1
# 定义source( r1 )为Netcat Source，监控localhost:44444
a1.sources.r1.type = netcat
a1.sources.r1.bind = localhost
a1.sources.r1.port = 44444

# 定义sink( k1 )为Logger Sink，将接收的数据显示到命令行
a1.sinks.k1.type = logger

# 用内存作为 channel 的缓存
a1.channels.c1.type = memory
a1.channels.c1.capacity = 1000
a1.channels.c1.transactionCapacity = 100

# 将source 和 sink 绑定到 channel
a1.sources.r1.channels = c1
a1.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;~/tools/flume-ng&lt;/code&gt; 目录下执行如下命令启动 Agent ：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bin/flume-ng agent -n a1 -c conf -f conf/mytest.conf -Dflume.root.logger=INFO,console
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bin/flume-ng agent --name a1 --conf conf --conf-file conf/mytest.conf -Dflume.root.logger=INFO,console
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-n&lt;/code&gt; 指定 Agent 名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-c&lt;/code&gt; 指定配置文件目录&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 指定配置文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Dflume.root.logger=INFO,console&lt;/code&gt; 设置日志等级&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-Dflume.root.logger=INFO,console&lt;/code&gt; 表示在控制台输出日志，用作测试或调试，真是生产缓存不用；&lt;/li&gt;
  &lt;li&gt;使用logger，&lt;code class=&quot;highlighter-rouge&quot;&gt;flume-ng/conf&lt;/code&gt; 目录下必须有 &lt;code class=&quot;highlighter-rouge&quot;&gt;log4j.properties&lt;/code&gt; 项，否则会报错；&lt;/li&gt;
  &lt;li&gt;在实际运行中，有时候就算 conf 目录下有 &lt;code class=&quot;highlighter-rouge&quot;&gt;log4j.properties&lt;/code&gt; 运行还是报错，如果你用的时第二条启动命令的话，换第一条启动命令试试；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在 Agent 成功启动后，新打开一个命令行，输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;telnet localhost 44444&lt;/code&gt;,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ telnet localhost 44444
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Hello World!
OK 控制台输出：

2015-04-28 11:50:23,091 (lifecycleSupervisor-1-0) [INFO - org.apache.flume.source.NetcatSource.start(NetcatSource.java:150)] Source starting
2015-04-28 11:50:23,150 (lifecycleSupervisor-1-0) [INFO - org.apache.flume.source.NetcatSource.start(NetcatSource.java:164)] Created serverSocket:sun.nio.ch.ServerSocketChannelImpl[/127.0.0.1:44444]
2015-04-28 11:51:57,185 (SinkRunner-PollingRunner-DefaultSinkProcessor) [INFO - org.apache.flume.sink.LoggerSink.process(LoggerSink.java:70)] Event: { headers:{} body: 48 65 6C 6C 6F 20 57 6F 72 6C 64 21 0D          Hello World!. } 如果显示如上所示，则 Flume-NG 安装成功。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;32-第三方插件&quot;&gt;3.2 第三方插件&lt;/h3&gt;

&lt;h4 id=&quot;pluginsd-目录&quot;&gt;plugins.d 目录&lt;/h4&gt;

&lt;p&gt;plugins.d 目录位于 &lt;code class=&quot;highlighter-rouge&quot;&gt;$FLUME_HOME/plugins.d&lt;/code&gt;，在flume-ng 启动的时候，flume-ng 启动脚本会遍历 plugins.d 目录中的插件，当通过 java 启动的时候将它们嵌入到合适的路径，其目录结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;plugins.d
|-	lib 		插件的jar包
|-	libext		插件依赖的jar包
|-	native		必须的本地库，如：*.so文件

如：
plugins.d/
plugins.d/custom-source-1/
plugins.d/custom-source-1/lib/my-source.jar
plugins.d/custom-source-1/libext/spring-core-2.5.6.jar
plugins.d/custom-source-2/
plugins.d/custom-source-2/lib/custom.jar
plugins.d/custom-source-2/native/gettext.so
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四数据获取&quot;&gt;四、数据获取&lt;/h2&gt;

&lt;p&gt;Flume 支持大量从外部源获取数据的机制。&lt;/p&gt;

&lt;h3 id=&quot;41-rpc&quot;&gt;4.1 RPC&lt;/h3&gt;

&lt;p&gt;一个Flume中部署的 Avro 客户端，能够通过 avro RPC 机制，将一个指定的文件发送给 Flume 的 Avro Source：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ bin/flume-ng avro-client -H localhost -p 41414 -F /usr/logs/log.10 上面所示命令将会把 `/usr/logs/log.10` 文件的内容发送到 Flume Source 监听的端口上。 ### 4.2 Executing commands
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有就是前面提及过的 Exec Source，通过执行一个指定的命令，将输出结果中的一行( 文本后跟回车&lt;code class=&quot;highlighter-rouge&quot;&gt;\r&lt;/code&gt;或换行符&lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt;，或两者同时出现 )，作为数据发送出去。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：Flume 不支持 tail 作为一个Source，但可以通过在 exec source 中使用 tail 命令将文件转换为数据流。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;43-network-streams&quot;&gt;4.3 Network streams&lt;/h3&gt;

&lt;p&gt;Flume 支持下面的机制从常用的日志数据流类型中读取数据，例如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Avro&lt;/li&gt;
  &lt;li&gt;Thrift&lt;/li&gt;
  &lt;li&gt;Syslog&lt;/li&gt;
  &lt;li&gt;Netcat&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面可以启动一个 avro-client 客户端生产数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bin/flume-ng avro-client -c conf -H localhost -p 41414 -F /etc/passwd -Dflume.root.logger=DEBUG,console
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五配置多-agent-数据流动&quot;&gt;五、配置多 Agent 数据流动&lt;/h2&gt;

&lt;p&gt;通过 Agent 的Avro Source 和Avro Sink 可以实现多个 Agent 之间的数据传输，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/multi-flow-by-avro.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;agent foo 的配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# agent foo
foo.sources = r1
foo.channels = c1
foo.sinks = k1

foo.sources.r1.type = netcat
foo.sources.r1.bind = localhost
foo.sources.r1.port = 44444

foo.channels.c1.type = memory
foo.channels.c1.capacity = 1000
foo.channels.c1.transactionCapacity = 100

foo.sinks.k1.type = avro
foo.sinks.k1.hostname = localhost
foo.sinks.k1.port = 44445

foo.sources.r1.channels = c1
foo.sinks.k1.channel = c1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;agent bar 的配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# agent bar
bar.sources = r1
bar.channels = c1
bar.sinks = k1

bar.sources.r1.type = avro
bar.sources.r1.bind = localhost
bar.sources.r1.port = 44445

bar.channels.c1.type = memory
bar.channels.c1.capacity = 1000
bar.channels.c1.transactionCapacity = 100

bar.sinks.k1.type = logger

bar.sources.r1.channels = c1
bar.sinks.k1.channel = c1 注意：Avro Source 中指定ip地址的是`&amp;lt;agent&amp;gt;.sources.&amp;lt;source&amp;gt;.bind = ip`，而 Avro Sink 则为`&amp;lt;agent&amp;gt;.sinks.&amp;lt;sink&amp;gt;.hostname = ip`!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;52-合并-agent&quot;&gt;5.2 合并 Agent&lt;/h3&gt;
&lt;p&gt;在日志收集当中，一个非常常见的情况是：大量的客户端将产生的日志数据发送到少量的收集 Agent 上，这些 Agent 再将接收到的日志存储到链接的存储系统上。如：&lt;/p&gt;

&lt;p&gt;将数百台web servers 产生的日志发送到12个 Agent 上，然后写入到 HDFS 集群中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/consolidation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图所示可以通过在 Flume 中配置3个使用 Avro Sink 的Agent，将3个节点都连接到一个 Avro Source的Agent( 同样的也可以使用 Thrift Sources/Sinks/Client来实现 )。图示 Agent4 收集接收到的 events，缓存到一个单一的 channel中，最后通过一个 sink将其中的数据发送到目的地( 如图所示的 HDFS )&lt;/p&gt;

&lt;h3 id=&quot;53-多路-agent&quot;&gt;5.3 多路 Agent&lt;/h3&gt;
&lt;p&gt;Flume 支持多路传输 event到一个或多个目的地。能够通过定义一个多选器( 能够通过路由，复制或选择的将一个Event发送到一个或多个 channels上 )来实现，其 Agent 结构如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/multiplexing.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这种模式，有两种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一种是用来复制（Replication），Replication方式可以将最前端的数据源复制多份，分别传递到多个channel中，每个channel接收到的数据都是相同的，配置格式如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  # List the sources, sinks and channels for the agent
  replicatAgent.sources = r1
  replicatAgent.sinks = k1 k2 k3
  replicatAgent.channels = c1 c2 c3
	
  replicatAgent.sources.r1.type = netcat
  replicatAgent.sources.r1.bind = localhost
  replicatAgent.sources.r1.port = 44444
  replicatAgent.sources.r1.selector.type = replicating
	
  replicatAgent.sinks.k1.type = HDFS
  #...
	
  replicatAgent.sinks.k2.type = JMS
  #...
	
  replicatAgent.sinks.k3.type = avro
  #...

  # set channel for sinks
  replicatAgent.sinks.k1.channel = c1
  replicatAgent.sinks.k2.channel = c2
  replicatAgent.sinks.k3.channel = c3
	
  # set list of channels for source (separated by space)
  replicatAgent.sources.r1.channels = c1 c2 c3 上面指定了 selector 的 type 的值为 replication，使用的Replication方式，`Source r1`会将数据分别存储到 `Channel c1 c2 c3`，这三个 channel 里面存储的数据是相同的，然后数据被传递到 `Sink k1 k2 k3`。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一种是用来分流（Multiplexing），selector可以根据header的值来确定数据传递到哪一个channel，配置格式，如下所示：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  multiplexAgent.sources = r1
  multiplexAgent.sinks = k1 k2 k3
  multiplexAgent.channels = c1 c2 c3

  # Mapping for multiplexing selector
  multiplexAgent.sources.r1.selector.type = multiplexing
  multiplexAgent.sources.r1.selector.header = state
  multiplexAgent.sources.r1.selector.mapping.CZ = c1
  multiplexAgent.sources.r1.selector.mapping.US = c1 c3
  multiplexAgent.sources.r1.selector.mapping.TW = c3
  #...

  multiplexAgent.sources.r1.selector.default = c2
	
  #... 其余配置不再给出
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;54-load_balance&quot;&gt;5.4 load_balance&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/flume-load-balance-agents.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Load balancing Sink Processor能够实现load balance功能，上图Agent1是一个路由节点，负责将Channel暂存的Event均衡到对应的多个Sink组件上，而每个Sink组件分别连接到一个独立的Agent上，示例配置，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sinkgroups = g1
a1.sinkgroups.g1.sinks = k1 k2 k3
a1.sinkgroups.g1.processor.type = load_balance
a1.sinkgroups.g1.processor.backoff = true
a1.sinkgroups.g1.processor.selector = round_robin
a1.sinkgroups.g1.processor.selector.maxTimeOut=10000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;55-failover&quot;&gt;5.5 failover&lt;/h3&gt;

&lt;p&gt;Failover Sink Processor能够实现failover功能，具体流程类似load balance，但是内部处理机制与load balance完全不同：Failover Sink Processor维护一个优先级Sink组件列表，只要有一个Sink组件可用，Event就被传递到下一个组件。如果一个Sink能够成功处理Event，则会加入到一个Pool中，否则会被移出Pool并计算失败次数，设置一个惩罚因子，示例配置如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a1.sinkgroups = g1
a1.sinkgroups.g1.sinks = k1 k2 k3
a1.sinkgroups.g1.processor.type = failover
a1.sinkgroups.g1.processor.priority.k1 = 5
a1.sinkgroups.g1.processor.priority.k2 = 7
a1.sinkgroups.g1.processor.priority.k3 = 6
a1.sinkgroups.g1.processor.maxpenalty = 20000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;未完待续。。。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>使用Jenkins搭建博客和Java源码管理的集成环境</title>
   <link href="http://www.blogways.net/blog/2014/10/08/Jenkins-Blogways-Maven.html"/>
   <updated>2014-10-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/10/08/Jenkins-Blogways-Maven</id>
   <content type="html">&lt;h2 id=&quot;一-概述&quot;&gt;一、 概述&lt;/h2&gt;

&lt;p&gt;在搭建博客系统的集成环境时，需要用到的有Jenkins、git和jekyll运行环境，本博客有相关的安装教程：&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;Jenkins安装&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.blogways.net/blog/2013/04/17/jenkins-git-maven-junit.html
http://www.blogways.net/blog/2013/04/23/jenkins-git-maven-junit-2.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;git服务器部署及使用&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://wanzhou.github.io/blog/2013/04/13/git.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、&lt;strong&gt;&lt;em&gt;Windows和MAC OS X下安装jekyll&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.blogways.net/categories/jekyll/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是关于博客系统的运行环境搭建，由于我是在服务器上搭建集成环境，本身并没有ruby环境，需要自己去安装，因而说一下ruby和gem的安装。&lt;/p&gt;

&lt;h2 id=&quot;二-rubygem安装&quot;&gt;二、 ruby、gem安装&lt;/h2&gt;

&lt;p&gt;因为jekyll是的ruby语言编写的，需要ruby运行环境！&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;安装ruby&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先，去ruby官网下载离线安装包，我下载的是&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby-2.1.3.tar.gz&lt;/code&gt;，然后运行如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd ruby-2.1.3.tar.gz目录 (如：cd /Users/xxx/Downloads)
tar -xzvf ruby-2.1.3.tar.gz
cd ruby-2.1.3
./configure --prefix=安装ruby的目录 (如：/Users/xxx/App/ruby)
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装好以后，修改操作系统的PATH路径，一般是修改&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bashrc&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bash_profile&lt;/code&gt;文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;RUBY_HOME=/Users/xxx/App/ruby  (安装ruby的目录)
export RUBY_HOME
PTAH=$RUBY_HOME/bin:$PATH
export PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;安装ruby&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同样，首先下载rubygem安装文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://rubygems.org/pages/download/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中有很多种安装文件，按照自己的需求去下载，我下载的是&lt;code class=&quot;highlighter-rouge&quot;&gt;rubygems-2.4.1.tgz&lt;/code&gt;，然后运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd rubygems-2.4.1.tgz目录
tar -xzvf rubygems-2.4.1.tgz
cd rubygems-2.4.1
ruby setup.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到此，ruby和gem安装完成了，后面需要安装jekyll时，只要运行命令&lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&quot;三-博客集成系统核心实现&quot;&gt;三、 博客集成系统核心实现&lt;/h2&gt;

&lt;p&gt;1、jenkins任务创建，详情可以参考前面给出的网站。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;新建一个jenkins任务，按如下设置，并确定！&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/blogtest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置源码管理，第一个框中填仓库路径(远程仓库和本地仓库都可以)，如：&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/git/blogtestgit&lt;/code&gt;；第二个框填构建的分支，一般为&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;，可以直接填master也可以像下图所示填写：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/jkgit.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;填写触发条件，此处为每天的12时和20时触发，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/blog-trigger.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;编写构建步骤，&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/blog-build.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、最主要的就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute shell&lt;/code&gt;来实现博客系统的创建和发布：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash /home/spdev/tools/jenkins.shell.scripts/deployjekyll.sh $WORKSPACE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/blogtest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在该&lt;code class=&quot;highlighter-rouge&quot;&gt;.sh&lt;/code&gt;文件中的命令如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll_pid=$(ps aux | grep 'jekyll' | grep -v 'grep' | awk '{print $2}')

[ -z &quot;$jekyll_pid&quot; ] 

if [ &quot;$(echo $?)&quot; == &quot;1&quot; ] ; then
    echo &quot;-------------------------------------&quot;
	kill -9 $jekyll_pid
    echo &quot;-- Log: -- Kill Previous Jekyll Serve successfully! --&quot;
	echo &quot;-------------------------------------&quot;
fi

BUILD_ID=dontKillMe /usr/bin/jekyll serve --detach &amp;amp;

if [ &quot;$(echo $?)&quot; != &quot;0&quot; ] ; then
	echo &quot;-------------------------------------&quot;
    echo &quot;-- Log: -- An Exception Has Happened In The Source ! --&quot;
    echo &quot;-------------------------------------&quot;
    exit 1
else
	echo &quot;-------------------------------------&quot;
	echo &quot;-- Log: -- Update The Blogways ! --&quot;
	echo &quot;-------------------------------------&quot;
	exit 0
fi
exit 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1、首先，判断包含&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll&lt;/code&gt;的进程( 即博客的发布经常 )是否存在，若存在则结束此进程；&lt;/p&gt;

&lt;p&gt;2、然后，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve --detach&lt;/code&gt;，生成新的博客文件，并发布到&lt;code class=&quot;highlighter-rouge&quot;&gt;4000&lt;/code&gt;端口，如果是在服务器上运行，那么就能在相应的端口访问博客，如&lt;code class=&quot;highlighter-rouge&quot;&gt;http://192.168.11.34:4000/&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000/&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;3、最后，监听上条语句，即&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve --detach&lt;/code&gt;执行成功与否，若执行成功，则说明此处生成并发布新博客成功，以&lt;code class=&quot;highlighter-rouge&quot;&gt;exit 0&lt;/code&gt;正常退出，告诉jenkins此次构建成功；否则说明生成或发布失败，以&lt;code class=&quot;highlighter-rouge&quot;&gt;exit 1&lt;/code&gt;异常退出，告诉jenkins此次构建失败。&lt;/p&gt;

&lt;h2 id=&quot;四-java源码编译测试集成系统&quot;&gt;四、 Java源码编译测试集成系统&lt;/h2&gt;

&lt;p&gt;java源码的编译、测试及发布等，都是通过maven来实现的，因此需要maven环境，关于maven的使用可以参考：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://www.blogways.net/blog/2013/04/23/maven.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jenkins提供了maven插件，一般都是默认安装的，java源码开发的集成系统的核心实现跟博客稍有区别，它及可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute shell&lt;/code&gt;来实现，也可以通过jenkins的maven插件来实现。&lt;/p&gt;

&lt;p&gt;1、&lt;strong&gt;&lt;em&gt;Execute shell&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果没有特殊的要求，一条语句就能完成：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如下图所示，图示显示的设置等同于&lt;code class=&quot;highlighter-rouge&quot;&gt;mvn package&lt;/code&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/maven-package.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;运行该命令后，会自动的完成编译、测试、打包、安装(安装到本地mavne库)等操作，如有任何一个阶段运行失败，就会结束运行，并告诉jenkins运行失败，jenkins会处理信息，按照设置的邮箱发送给最近代码提交者，代码有BUG。&lt;/p&gt;

&lt;p&gt;2、&lt;strong&gt;&lt;em&gt;maven插件&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;只需要在&lt;code class=&quot;highlighter-rouge&quot;&gt;配置 -&amp;gt; Build -&amp;gt; Goals and options&lt;/code&gt;项中，添加&lt;code class=&quot;highlighter-rouge&quot;&gt;install&lt;/code&gt;即可完成跟&lt;code class=&quot;highlighter-rouge&quot;&gt;Execute shell&lt;/code&gt;相同的功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash /home/spdev/tools/jenkins.shell.scripts/mavenjava.sh $WORKSPACE
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>在Chrome Extension中使用RequireJS</title>
   <link href="http://www.blogways.net/blog/2014/09/24/requirejs-in-chrome-extensions.html"/>
   <updated>2014-09-24T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/09/24/requirejs-in-chrome-extensions</id>
   <content type="html">&lt;p&gt;RequireJS，谁用谁知道。&lt;/p&gt;

&lt;p&gt;在浏览器环境下使用&lt;code class=&quot;highlighter-rouge&quot;&gt;requireJS&lt;/code&gt;，其加载js文件的方式，采用的是通过创建&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt;节点，及设置其&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;属性来实现。但在chrome extensions中，这项做法被认为是不安全的，而被默认禁止，这样就导致了&lt;code class=&quot;highlighter-rouge&quot;&gt;RequireJS&lt;/code&gt;无法生效。&lt;/p&gt;

&lt;p&gt;要想解决这个问题，有两个方案。&lt;/p&gt;

&lt;h2 id=&quot;方案一使用cajon替代requirejs&quot;&gt;方案一：使用cajon替代requirejs&lt;/h2&gt;

&lt;h3 id=&quot;1-关于cajon的简介&quot;&gt;1. 关于cajon的简介&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/requirejs/cajon&quot;&gt;cajon&lt;/a&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;RequireJS&lt;/code&gt;是相同的&lt;a href=&quot;https://github.com/jrburke&quot;&gt;作者&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;cajon的工作原理：基于&lt;code class=&quot;highlighter-rouge&quot;&gt;RequireJS&lt;/code&gt;，而重写了&lt;code class=&quot;highlighter-rouge&quot;&gt;requirejs.load&lt;/code&gt;方法。重写的&lt;code class=&quot;highlighter-rouge&quot;&gt;requirejs.load&lt;/code&gt;方法，默认判断逻辑，依赖相同网站的js文件，则通过异步&lt;code class=&quot;highlighter-rouge&quot;&gt;XHR&lt;/code&gt;请求方式获取，并通过&lt;code class=&quot;highlighter-rouge&quot;&gt;eval&lt;/code&gt;方法使之生效。如果依赖的是其他网站js文件，则仍用原来加载方式（生成一个&lt;code class=&quot;highlighter-rouge&quot;&gt;script&lt;/code&gt;标签）进行加载。&lt;/p&gt;

&lt;p&gt;cajon还支持自定义哪种规则的依赖文件，需要采用&lt;code class=&quot;highlighter-rouge&quot;&gt;XHR+eval&lt;/code&gt;方式加载。&lt;/p&gt;

&lt;h3 id=&quot;2-具体解决方案&quot;&gt;2. 具体解决方案&lt;/h3&gt;

&lt;p&gt;直接将原来&lt;code class=&quot;highlighter-rouge&quot;&gt;require.js&lt;/code&gt;文件替换为&lt;code class=&quot;highlighter-rouge&quot;&gt;cajon.js&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;p&gt;原来使用&lt;code class=&quot;highlighter-rouge&quot;&gt;requirejs&lt;/code&gt;的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script data-main=&quot;js/main&quot; src=&quot;js/require/require.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;cajon.js&lt;/code&gt;替换为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script data-main=&quot;js/main&quot; src=&quot;js/require/cajon.js&quot; type=&quot;text/javascript&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ok了，是不是很简单？！&lt;/p&gt;

&lt;h2 id=&quot;方案二设置content-security-policy参数&quot;&gt;方案二：设置content security policy参数&lt;/h2&gt;

&lt;h3 id=&quot;1-关于content-security-policy的简介&quot;&gt;1. 关于content security policy的简介&lt;/h3&gt;

&lt;p&gt;这个，可以看看我的另外一篇博文，原文见：www.blogways.net。&lt;/p&gt;

&lt;h3 id=&quot;2-具体解决方案-1&quot;&gt;2. 具体解决方案&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;manifest.json&lt;/code&gt;文件中添加如下代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;content_security_policy&quot;: &quot;script-src 'self' 'unsafe-eval'; object-src 'self'&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是的，这样就搞定了！这里，关键参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe-eval&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;试试吧！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java项目代码编写规范</title>
   <link href="http://www.blogways.net/blog/2014/09/17/checkStyle.html"/>
   <updated>2014-09-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/09/17/checkStyle</id>
   <content type="html">&lt;h2 id=&quot;一checkclipse插件安装&quot;&gt;一、Checkclipse插件安装&lt;/h2&gt;

&lt;p&gt;Checkclipse是一个Eclipse插件，它集成了Checkstyle的样式检查器的编码准则到Eclipse中。所有的Java风格的违规行为将被立即报告错误标记。可以为每个项目单独配置编码准则。&lt;/p&gt;

&lt;p&gt;1、下载checkclipse jar 包文件&lt;a href=&quot;http://sourceforge.jp/projects/sfnet_checkclipse/&quot; title=&quot;checkclipse.jar&quot;&gt;http://sourceforge.jp/projects/sfnet_checkclipse/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、安装Checkclipse&lt;/p&gt;

&lt;p&gt;这里我通过Help-&amp;gt;Software Updates-&amp;gt;Find and Insta方式安装了好几次没有成功，最终选择下载插件jar包方式安装，我下载的是上面链接打开后列表中的de.mvmsoft.checkclipse_3.0.0.b201310301757.jar，下载后将jar包放到Eclipse安装目录plugins目录下，重新启动Eclipse在Windows—&amp;gt;preferences下找到checkclipse，如图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/checkclipse.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;二-配置eclipse-java-google-stylexml&quot;&gt;二、 配置eclipse-java-google-style.xml&lt;/h2&gt;

&lt;p&gt;这里eclipse-java-google-style.xml对Google原始Eclipse Formatter文件进行了部分修改，所以大家不要下载Google原始文件，就用本文提供的eclipse-java-google-style.xml。&lt;/p&gt;

&lt;p&gt;1、eclipse-java-google-style.xml内容：&lt;a href=&quot;/xml/eclipse-java-google-style.xml&quot; title=&quot;eclipse-java-google-style.xml&quot;&gt;eclipse-java-google-style.xml&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、配置eclipse-java-google-style.xml到Eclipse中&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eclipse-java-google-style.xml.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;三-配置java默认生成模板&quot;&gt;三、 配置Java默认生成模板&lt;/h2&gt;

&lt;p&gt;1、在Windows-&amp;gt;preferences-&amp;gt;Java-&amp;gt;Code Style-&amp;gt;Code Templates下新增文件默认生成模板：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/JavaFileTemplate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、新建Java类时选择Generater comments&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/testTemplate.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四-checkstyle文件编写及配置&quot;&gt;四、 checkStyle文件编写及配置&lt;/h2&gt;

&lt;h3 id=&quot;1checkstyle文件编写&quot;&gt;1、checkStyle文件编写&lt;/h3&gt;

&lt;p&gt;这里提供已经编写好的文件，内容&lt;a href=&quot;/xml/checkstyle.xml&quot; title=&quot;checkstyle.xml&quot;&gt;checkstyle.xml&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2checkstyle文件配置&quot;&gt;2、checkStyle文件配置&lt;/h3&gt;

&lt;p&gt;a、Checkclipse配置&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/checkclispeSet.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选Set Project Dir as Checkjstyle Basedir，CheckStyle Configuration File选择上面编写的checkStyle.xml文件&lt;/p&gt;

&lt;p&gt;b、选择你要进行checkstyle的项目文件，选择Project-&amp;gt;properties&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/CheckProject.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;勾选Enable CheckStyle、Set Project ClassLoader。&lt;/p&gt;

&lt;p&gt;c、ok，可以进行Java代码编写了，此时如果没有按照checkStyle.xml里配置的规范要求编写代码，Eclipse中将给出错误提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/CheckStyleTest.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;四-checkstyle-maven-插件使用&quot;&gt;四、 checkStyle Maven 插件使用&lt;/h2&gt;

&lt;p&gt;checkStyle的maven插件名为maven-checkstyle-plugin，用于执行CheckStyle task，以下列出具体使用方法：&lt;/p&gt;

&lt;h3 id=&quot;1maven-pom-文件配置&quot;&gt;1、maven pom 文件配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;build&amp;gt;
  &amp;lt;plugins&amp;gt;
	  &amp;lt;plugin&amp;gt;
	    &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
	    &amp;lt;artifactId&amp;gt;maven-checkstyle-plugin&amp;lt;/artifactId&amp;gt;
	    &amp;lt;version&amp;gt;2.10&amp;lt;/version&amp;gt;
	    &amp;lt;configuration&amp;gt;
	        &amp;lt;configLocation&amp;gt;D:\codingStandards\checkstyle.xml&amp;lt;/configLocation&amp;gt;
	    &amp;lt;/configuration&amp;gt;
	    &amp;lt;executions&amp;gt;
	        &amp;lt;execution&amp;gt;
	            &amp;lt;id&amp;gt;checkstyle&amp;lt;/id&amp;gt;
	            &amp;lt;phase&amp;gt;validate&amp;lt;/phase&amp;gt;
	            &amp;lt;goals&amp;gt;
	                &amp;lt;goal&amp;gt;check&amp;lt;/goal&amp;gt;
	            &amp;lt;/goals&amp;gt;
	            &amp;lt;configuration&amp;gt;
	                &amp;lt;failOnViolation&amp;gt;true&amp;lt;/failOnViolation&amp;gt;
	            &amp;lt;/configuration&amp;gt;
	        &amp;lt;/execution&amp;gt;
	    &amp;lt;/executions&amp;gt;
	  &amp;lt;/plugin&amp;gt;
   &amp;lt;/plugins&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&amp;lt;/build&amp;gt;&lt;/p&gt;

&lt;p&gt;其中D:\codingStandards\checkstyle.xml即为上面我们编写的checkstyle规范文件&lt;/p&gt;

&lt;h3 id=&quot;2运行checkstyle检查&quot;&gt;2、运行checkstyle检查&lt;/h3&gt;

&lt;p&gt;命令行下执行mvn checkstyle:checkstyle 或直接通过Eclipse插件中 Maven test等执行方法，我用的Maven test&lt;/p&gt;

&lt;h3 id=&quot;3检查checkstyle结果&quot;&gt;3、检查checkstyle结果&lt;/h3&gt;

&lt;p&gt;运行maven命令后可以在console里查看checkstyle运行结果。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[INFO] BUILD FAILURE
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 22.926s
[INFO] Finished at: Thu Sep 18 09:28:04 CST 2014
[INFO] Final Memory: 5M/9M
[INFO] ------------------------------------------------------------------------
[ERROR] Failed to execute goal org.apache.maven.plugins:maven-checkstyle-plugin:2.10:check 

(checkstyle) on project maven-script-test: You have 1 Checkstyle violation. -&amp;gt; [Help 1]
[ERROR] 
[ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch.
[ERROR] Re-run Maven using the -X switch to enable full debug logging.
[ERROR] 
[ERROR] For more information about the errors and possible solutions, please read the following articles:
[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;checkstye的详细结果信息被存放在target/checkstyle-result.xml中。下面是具体信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;checkstyle&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;version=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;5.6&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;file&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;D:\workspace\maven-script-test\src\main\java\javassisttest\Test1.java&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;error&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;line=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;22&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;severity=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;error&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;message=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Line is longer than 120 characters (found 124).&quot;&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;source=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;

&lt;span class=&quot;err&quot;&gt;com.puppycrawl.tools.checkstyle.checks.sizes.LineLengthCheck&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;file&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;D:\workspace\maven-script-test\src\main\java\mveltest\GetNameTest.java&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;file&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;D:\workspace\maven-script-test\src\main\java\mveltest\MvelTest.java&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;error&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;line=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;9&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;severity=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;warning&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;message=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Wrong order for &amp;amp;apos;org.mvel2.MVEL&amp;amp;apos; import.&quot;&lt;/span&gt;  &lt;span class=&quot;na&quot;&gt;source=&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;&quot;com.puppycrawl.tools.checkstyle.checks.imports.ImportOrderCheck&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/file&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/checkstyle&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从中我们可以看出 Test1.java 22行有一个行字符数超过120的错误，MvelTest.java 9行有个提示。&lt;/p&gt;

&lt;h3 id=&quot;4对指定文件不检查&quot;&gt;4、对指定文件不检查&lt;/h3&gt;

&lt;p&gt;对上面例子中行超过了120字符。如果我们不想修复这个错误怎么办那？可以将其suppress掉。
方法是建立一个checkstyle-suppressions.xml文件。其中加入下述内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE suppressions PUBLIC
        &quot;-//Puppy Crawl//DTD Suppressions 1.0//EN&quot;
        &quot;http://www.puppycrawl.com/dtds/suppressions_1_0.dtd&quot;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;suppressions&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;suppress&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;checks=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;LineLengthCheck&quot;&lt;/span&gt;
              &lt;span class=&quot;na&quot;&gt;files=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Test1.java&quot;&lt;/span&gt;
              &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/suppressions&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在pom文件&lt;configuration&gt;节点内checkstyle.xml配置下面加入checkstyle-suppressions.xml配置，如：&lt;/configuration&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;configuration&amp;gt;
    &amp;lt;configLocation&amp;gt;D:\codingStandards\checkstyle.xml&amp;lt;/configLocation&amp;gt;
    &amp;lt;suppressionsLocation&amp;gt;D:\codingStandards\checkstyle-suppressions.xml&amp;lt;/suppressionsLocation&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在再运行看看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[INFO] --- maven-surefire-plugin:2.10:test (default-test) @ maven-script-test ---
[INFO] Surefire report directory: D:\workspace\maven-script-test\target\surefire-reports

-------------------------------------------------------
 T E S T S
-------------------------------------------------------

Results :

Tests run: 0, Failures: 0, Errors: 0, Skipped: 0

[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 3.956s
[INFO] Finished at: Thu Sep 18 10:08:12 CST 2014
[INFO] Final Memory: 6M/11M
[INFO] ------------------------------------------------------------------------
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;OK！运行没有异常了，刚刚的行限制被跳过了。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>java 动态脚本之groovy、mvel and javascript</title>
   <link href="http://www.blogways.net/blog/2014/09/15/groovy-mvel-javascript.html"/>
   <updated>2014-09-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/09/15/groovy-mvel-javascript</id>
   <content type="html">&lt;h2 id=&quot;一groovy&quot;&gt;一、groovy&lt;/h2&gt;

&lt;h3 id=&quot;-groovy介绍&quot;&gt;. groovy介绍&lt;/h3&gt;
&lt;p&gt;Groovy 是 用于Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。&lt;/p&gt;

&lt;p&gt;Groovy是JVM的一个替代语言（替代是指可以用 Groovy 在Java平台上进行 Java 编程），使用方式基本与使用 Java代码的方式相同，该语言特别适合与Spring的动态语言支持一起使用，设计时充分考虑了Java集成，这使 Groovy 与 Java 代码的互操作很容易。（注意：不是指Groovy替代java，而是指Groovy和java很好的结合编程。&lt;/p&gt;

&lt;h3 id=&quot;-groovy语法&quot;&gt;. groovy语法&lt;/h3&gt;

&lt;p&gt;groovy语法和java语法类似，具体请参阅&lt;a href=&quot;http://beta.groovy-lang.org/docs/groovy-2.3.1/html/documentation/&quot; title=&quot;官方文档&quot;&gt;http://beta.groovy-lang.org/docs/groovy-2.3.1/html/documentation/&lt;/a&gt;，这里不做介绍。&lt;/p&gt;

&lt;h3 id=&quot;-java中使用groovy&quot;&gt;. java中使用groovy&lt;/h3&gt;

&lt;p&gt;Java中调用Groovy情况：&lt;/p&gt;

&lt;p&gt;1、Eval&lt;/p&gt;

&lt;p&gt;Eval很容易的通过me方法执行一段逻辑，但是Eval不支持多行逻辑，并且没有对执行的script脚本缓存，效率非常低。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;Eval begin:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).
				format(new Date()));
for (int i = 0; i &amp;lt; 1000; i++) {
	Eval.xy(i, i + 1, &quot;x*y&quot;);
}
System.out.println(&quot;Eval end:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).
                format(new Date()));

输出：
	Eval begin:2014-09-17 14:36:43:218
	Eval end:  2014-09-17 14:36:52:203
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、GroovyShell:&lt;/p&gt;

&lt;p&gt;GroovyShell支持简单脚本及Groovy文件的解析执行， GroovyShell支持script脚本的缓存，执行效率相对Eval高多了（下面例子100000次循环比Eval1000次循环还快），但要注意GroovyShell中shell.parse解析脚本程序不能放在大循环中或被频繁的调用，否则会大大降低性能，并且还有PermGen space异常风险。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;GroovyShell begin:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
       
Binding binding = new Binding();
GroovyShell shell = new GroovyShell(binding);    
Script  script = shell.parse(&quot;def mul(x, y) { return x * y }\n mul(x1, y1)&quot;);  
for (int i = 0; i &amp;lt; 100000; i++) {               
    binding.setProperty(&quot;x1&quot;, i);
    binding.setProperty(&quot;y1&quot;, i + 1);
    script.run();
}
System.out.println(&quot;GroovyShell end:&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
	GroovyShell begin:2014-09-17 15:50:04:945
	GroovyShell end:2014-09-17 15:50:06:389
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、GroovyClassLoader:适用于复杂逻辑的整个groovy文件，这里引入了Groovy2.0新增的静态编译，效率有进一步提升。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;GroovyClassLoader begin &quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
        
GroovyClassLoader loader = new GroovyClassLoader();
Class groovyClass = loader.parseClass(new File(&quot;src/extendTest/Test.groovy&quot;));
   
GroovyObject object = (GroovyObject) groovyClass.newInstance();
for (int i = 0; i &amp;lt; 100000; i++) {  
    object.invokeMethod(&quot;num&quot;, new int[]{i, i + 1});
}

System.out.println(&quot;GroovyClassLoader end&quot; + new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
	GroovyClassLoader begin 2014-09-17 16:23:06:156
	GroovyClassLoader end   2014-09-17 16:23:06:411
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、GroovyScriptEngine：GroovyScriptEngine类似GroovyShell，但存在互关联的多个脚本时，使用GroovyScriptEngine会更好些，但是GroovyScriptEngine效率也不理想。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;SimpleScript begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
for (int i = 0; i &amp;lt; 100000; i++) {
    binding1.setVariable(&quot;x&quot;, i);
    binding1.setVariable(&quot;y&quot;, i + 1);
    engine.run(&quot;src/extendTest/SimpleScript.groovy&quot;, binding1);
}
System.out.println(&quot;SimpleScript end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
	SimpleScript begin:2014-09-17 18:48:48:506
	SimpleScript end:2014-09-17 18:49:13:796
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5、Bean Scripting Framework：Bean Scripting Framework是一组Java Classes提供了在Java应用程序内对脚本语言的支持，通过脚本语言可以访问java的对象和方法，Groovy的BSF引擎是继承org.codehaus.groovy.bsf.GroovyEngine，其效率也达不到GroovyClassLoader效率，这里不做实例分析。&lt;/p&gt;

&lt;p&gt;6、JSR 223是Java 6提供的一种从Java内部执行脚本编写语言的方便、标准的方式，并提供从脚本内部访问Java 资源和类的功能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;JSR 223 begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine1 = factory.getEngineByName(&quot;groovy&quot;);
String testScript = &quot;def num(int[] a) {return  a[0] * a[1]}&quot;;  
engine1.eval(testScript);  
Invocable inv = (Invocable) engine1; 
for (int i = 0; i &amp;lt; 100000; i++) {
    inv.invokeFunction(&quot;num&quot;,  new int[]{i, i + 1});  
}

System.out.println(&quot;JSR 223 end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：

	JSR 223 begin:2014-09-17 18:55:10:665
	JSR 223 end:2014-09-17 18:55:10:716
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上一个简单的乘法运算测试发现JSR 223的效率比GroovyClassLoader要高。怀疑是不是GroovyClassLoader加载Groovy文件及编译文件耗时比较长，将开始打印日志移至for循环上面一行，同时将JSR 223测试代码打印日志也移至for循环上面一行，测试后发现JSR 223效率任然高于GroovyClassLoader，于是将JSR 223测试程序改读取Groovy文件，并使用Groovy静态编译，效率降低，稍高于GroovyClassLoader方式（GroovyClassLoader不读取文件方式高于GroovyClassLoader读取文件，稍低于JSR 223不读取文件方式）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine1 = factory.getEngineByName(&quot;groovy&quot;);
//String testScript = &quot;def num(int[] a) {return  a[0] * a[1]}&quot;;  
engine1.eval(new FileReader(&quot;D:/workspace/extendTest/src/extendTest/Test.groovy&quot;));
//engine1.eval(testScript);  
Invocable inv = (Invocable) engine1; 
System.out.println(&quot;JSR 223 begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
for (int i = 0; i &amp;lt; 100000; i++) {
    inv.invokeFunction(&quot;num&quot;,  new int[]{i, i + 1});  
}

System.out.println(&quot;JSR 223 end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
	JSR 223 begin:2014-09-17 18:49:13:847
	JSR 223 end:2014-09-17 18:49:13:969
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：虽然JSR 223调用方式性能大大提升，但是其性能与java相比还相差很多，以上简单的乘法运算，用java实现，100000次循环仅仅需5毫秒，所以对于实时性要求很高的功能，Groovy并不合适。&lt;/p&gt;

&lt;h2 id=&quot;二mvel&quot;&gt;二、MVEL&lt;/h2&gt;

&lt;h3 id=&quot;-mvel介绍&quot;&gt;. MVEL介绍&lt;/h3&gt;

&lt;p&gt;MVEL为 MVFLEX Expression Language（MVFLEX表达式语言）的缩写，它是一种动态/静态的可嵌入的表达式语言和为Java平台提供Runtime（运行时）的语言。最初是作为一个应用程序框架实用程序的语言开始，该项目现已发展完全独立。MVEL通常用于执行用户（程序员）通过配置XML文件或注释等定义的基本逻辑。它也可以用来解析简单的JavaBean表达式。Runtime（运行时）允许MVEL表达式通过解释执行或者预编译生成字节码后执行。&lt;/p&gt;

&lt;h3 id=&quot;-mvel语法&quot;&gt;. MVEL语法&lt;/h3&gt;

&lt;p&gt;MVEL语法具体请参阅 &lt;a href=&quot;http://mvel.codehaus.org/Language+Guide+for+2.0&quot; title=&quot;MVEL&quot;&gt;http://mvel.codehaus.org/Language+Guide+for+2.0&lt;/a&gt;，这里不做介绍。&lt;/p&gt;

&lt;h3 id=&quot;-java中使用mvel&quot;&gt;. java中使用MVEL&lt;/h3&gt;

&lt;p&gt;Java中调用MVEL情况：&lt;/p&gt;

&lt;p&gt;1、解释执行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;interpreted begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));
    
Map&amp;lt;String, Object&amp;gt; params = new HashMap&amp;lt;String, Object&amp;gt;();  
  
for (int i = 0; i &amp;lt; 100000; i++) {
    params.put(&quot;x&quot;, i);  
    params.put(&quot;y&quot;, i + 1);  
    MVEL.eval(&quot;x*y&quot;, params);  
}
System.out.println(&quot;interpreted end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
	
	interpreted  begin:2014-09-18 10:54:01:162
	interpreted  end:2014-09-18 10:54:01:879
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、编译后执行（加快执行）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.out.println(&quot;compiled begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

ExpressionCompiler compiler = new ExpressionCompiler(&quot;x * y&quot;);  
CompiledExpression exp = compiler.compile();  
Map&amp;lt;String, Object&amp;gt; params1 = new HashMap&amp;lt;String, Object&amp;gt;();  
          
for (int i = 0; i &amp;lt; 100000; i++) {
    params.put(&quot;x&quot;, i);  
    params.put(&quot;y&quot;, i + 1);  
    MVEL.executeExpression(exp, params);  
   
}
System.out.println(&quot;compiled end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

输出：
	
	compiled begin:2014-09-18 10:57:50:471
	compiled end:2014-09-18 10:57:50:632
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上执行结果看出，编译后执行效率明显高于解释执行。&lt;/p&gt;

&lt;h2 id=&quot;三groovymveljavascript-调用性能分析&quot;&gt;三、Groovy、MVEL、javascript 调用性能分析&lt;/h2&gt;

&lt;p&gt;1、java中调用javascript测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName(&quot;javascript&quot;); 

String str = &quot;function num (x,y) { return x*y }&quot;;   
try {
    engine.eval(str);
} catch (ScriptException e) {
    e.printStackTrace();
}   
Invocable invoke = (Invocable) engine;
System.out.println(&quot;javascript begin:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date()));

try {
    for (int i = 0; i &amp;lt; 100000; i++) {
        invoke.invokeFunction(&quot;num&quot;, i, i + 1);
    }
} catch (ScriptException e) {
    e.printStackTrace();
} catch (NoSuchMethodException e) {
    e.printStackTrace();
}
System.out.println(&quot;javascript end:&quot;+ new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;).format(new Date())); 

输出：
	
	javascript begin:2014-09-18 11:28:11:661
	javascript end:2014-09-18 11:28:16:348
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、性能分析&lt;/p&gt;

&lt;p&gt;从以上对Java中调用Groovy、MVEL、javascript实现的一个简单的乘法运算100000次循环的结果来看：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Groovy JSR 223调用方式：51毫秒
MVEL编译后执行：161毫秒
javascript调用：4秒多
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;MVEL官网给出性能报告显示MVEL性能高于Groovy，不知道其什么数据测试场景，看官网报告测试的Groovy版本是1.5.7，低于本文测试的Groovy2.0版，从Groovy1.6开始才开始引入Cache功能，并且到了2.0才加入静态编译，所以MVEL官网的测试报告我觉得已经不能够正确说明Groovy的实际性能，至少从本文例子中看出Groovy2.0性能是明显优于MVEL2.2的。&lt;/p&gt;

&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;

&lt;p&gt;动态语言给我们实际编程中带来很多方便，比如常用的规则引擎，然而性能与功能不能同时得到满足，从本文测试中看出无论是Groovy还是MVEL都是实现动态逻辑配置的不错选择，但是遇到高实时性需求时，可能两者就不是特别适合，因为两者的性能与Java本身相比还是有数倍的差距。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[14] -- AJAX（2）</title>
   <link href="http://www.blogways.net/blog/2014/08/27/jQuery-source-analysis-ajax(2).html"/>
   <updated>2014-08-27T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/27/jQuery-source-analysis-ajax(2)</id>
   <content type="html">&lt;h2 id=&quot;四ajax示例&quot;&gt;四、Ajax示例&lt;/h2&gt;

&lt;p&gt;前面已经对ajax的源码结构和API有了一些介绍，下面就介绍一些ajax方法的应用；&lt;/p&gt;

&lt;p&gt;前面已经介绍过了，Ajax中最最核心的方法就是&lt;code class=&quot;highlighter-rouge&quot;&gt;$.ajax( url, options )&lt;/code&gt;，其它的方法都是在这个方法的基础上修改options参数实现的，下面来看一下ajax支持的options参数：&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;

	&lt;tr&gt;&lt;th width=&quot;15%&quot;&gt;参数名&lt;/th&gt;&lt;th width=&quot;10%&quot;&gt;类型&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;url&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;发送请求的地址(默认值: 当前页地址)。&lt;/td&gt;&lt;/tr&gt;

	&lt;tr&gt;&lt;td&gt;type&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;请求方式 (&quot;POST&quot; 或 &quot;GET&quot;)， 默认为 &quot;GET&quot;。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;global&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;是否触发全局 AJAX 事件(默认: true)。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 。可用于控制不同的Ajax事件&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;processData&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;(默认: true) 默认情况下，发送的数据将被转换为对象(技术上讲并非字符串) 以配合默认内容类型 &quot;application/x-www-form-urlencoded&quot;。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;async&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。
注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;contentType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;发送信息至服务器时内容编码类型(默认值: &quot;application/x-www-form-urlencoded&quot;)&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;timeout&lt;/td&gt;&lt;td&gt;Number&lt;/td&gt;&lt;td&gt;设置请求超时时间（毫秒），此设置将覆盖全局设置&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;data&lt;/td&gt;&lt;td&gt;Object&amp;lt;/br&amp;gt;String&lt;/td&gt;&lt;td&gt;发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[&quot;bar1&quot;, &quot;bar2&quot;]} 转换为 '&amp;amp;foo=bar1&amp;amp;foo=bar2'。&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;dataType&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息返回 responseXML 或 responseText，并作为回调函数参数传递，可用值:&amp;lt;/br&amp;gt;&quot;xml&quot;: 返回 XML 文档，可用 jQuery 处理；&amp;lt;/br&amp;gt;&quot;html&quot;: 返回纯文本 HTML 信息；包含 script 元素；&amp;lt;/br&amp;gt;&quot;script&quot;: 返回纯文本 JavaScript 代码。不会自动缓存结果。；&amp;lt;/br&amp;gt;&quot;json&quot;: 返回 JSON 数据 ；&amp;lt;/br&amp;gt;&quot;jsonp&quot;: JSONP 格式，使用 JSONP 形式调用函数时，如 &quot;myurl?callback=?&quot; jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;username&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;用于响应 HTTP 访问认证请求的用户名&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;password&lt;/td&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;用于响应 HTTP 访问认证请求的密码&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;cache&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;dataType 为 script 和 jsonp 时默认为 false；设置为 false 将不缓存此页面&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;traditional&lt;/td&gt;&lt;td&gt;Boolean&lt;/td&gt;&lt;td&gt;如果你想要用传统的方式来序列化数据，那么就设置为 true&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;beforeSend&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头；&amp;lt;/br&amp;gt;beforeSend(XMLHttpRequest) &lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;complete&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;请求完成后回调函数 (请求成功或失败时均调用)。参数： XMLHttpRequest 对象，成功信息字符串；&amp;lt;/br&amp;gt;complete(XMLHttpRequest, textStatus)&lt;/td&gt;&lt;/tr&gt;
	
	&lt;tr&gt;&lt;td&gt;error&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;请求失败时将调用此方法。这个方法有三个参数：XMLHttpRequest 对象，错误信息，（可能）捕获的错误对象；&amp;lt;/br&amp;gt;
error(XMLHttpRequest, textStatus, errorThrown)&lt;/td&gt;&lt;/tr&gt;

	&lt;tr&gt;&lt;td&gt;success&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;请求成功后回调函数。这个方法有两个参数：服务器返回数据，返回状态&amp;lt;/br&amp;gt;
success(data, textStatus) &lt;/td&gt;&lt;/tr&gt;

	&lt;tr&gt;&lt;td&gt;xhr&lt;/td&gt;&lt;td&gt;Function&lt;/td&gt;&lt;td&gt;需要返回一个 XMLHttpRequest 对象，默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.load( url, data, callback )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;button&amp;gt;Load HTML one!&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;Load HTML two!&amp;lt;/button&amp;gt;
&amp;lt;button&amp;gt;Load HTML three!&amp;lt;/button&amp;gt;
&amp;lt;div id='ajax_content'&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;js:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('button').click(function(){
	var val = $(this).text();
	$('#ajax_content').load(
	    '/echo/html/',{
	        html: &quot;&amp;lt;p&amp;gt;&quot; + val + &quot;&amp;lt;/p&amp;gt;&quot;
	    },function(text){
	    	console.log(text)
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码功能很简单，向&lt;code class=&quot;highlighter-rouge&quot;&gt;/echo/html/&lt;/code&gt;发送一个ajax请求；请求数据为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素包装的按钮的文本内容；回调函数callback仅仅接收一个参数text(即请求返回的文本内容)，将其显示到控制台console上，该回调函数会在加载完响应之后执行。&lt;/p&gt;

&lt;p&gt;当单击某个按钮过后，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素里面的内容会是下面的某一个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;Load HTML one!&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Load HTML two!&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;Load HTML three!&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面介绍过，&lt;code class=&quot;highlighter-rouge&quot;&gt;.load()&lt;/code&gt;方法的功能是，将请求url响应直接插入到匹配元素中。可以直接将上面代码复制到&lt;a href=&quot;http://jsfiddle.net&quot; title=&quot;JSFiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;上进行测试！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.getJSON( url, data, callback )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;$.getJSON()&lt;/code&gt;之前，首先说一下JSON(JavaScript Object Notation，JavaScript对象表示法)，&lt;/p&gt;

&lt;p&gt;JavaScript对象是由一些“key-value”对组成的，可以使用“{}”来定义，而数组则可以使用“[]”来定义，JSON就是将这两种语法组合起来，通过字面量的方式来表示数据，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;key1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;value1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;key2': [
		&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;array_elem1&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;,
		&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;array_elem2&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;,
		&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;array_elem3&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
	&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如是的JSON有很强的表达能力，能使用很少的空间大小来表示很多的数据，JSON规定了，所有的对象键及其键值都必须包含在双引号(““)中，而且函数不是有效的JSON值。&lt;/p&gt;

&lt;p&gt;现在有如下一个a.json文件，其内容如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[
	{
    	&quot;name&quot;    : &quot;Tom&quot;,
    	&quot;birthday&quot;: &quot;1991-01-23&quot;,
    	&quot;hobbies&quot;: [&quot;篮球&quot;,&quot;羽毛球&quot;,&quot;看电影&quot;]
	},
	{
	    &quot;name&quot;    : &quot;Jhon&quot;,
	    &quot;birthday&quot;: &quot;1987-09-06&quot;,
	    &quot;hobbies&quot;: [&quot;网球&quot;,&quot;看书&quot;,&quot;听音乐&quot;]
	},
	{
	    &quot;name&quot;    : &quot;James&quot;,
	    &quot;birthday&quot;: &quot;1989-10-23&quot;,
	    &quot;hobbies&quot;: [&quot;篮球&quot;,&quot;旅游&quot;,&quot;看书&quot;,&quot;玩游戏&quot;]
	}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在页面加载时，将这些信息显示到页面中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.getJSON('a.json', function(data){
	var html = '';
	$.each(data, function( index, item ){
		html += '&amp;lt;div class=&quot;item&quot;&amp;gt;';
		html += '&amp;lt;h2&amp;gt;' + item.name + '&amp;lt;/h2&amp;gt;';
		html += '&amp;lt;div class=&quot;birthday&quot;&amp;gt;' + item.birthday + '&amp;lt;/div&amp;gt;';
		html += '&amp;lt;ul&amp;gt;';
		for(var i in item.hobbies){
			html += '&amp;lt;li&amp;gt;' + item.hobbies[i] + '&amp;lt;/li&amp;gt;';
		}
		html += '&amp;lt;/ul&amp;gt;';
		html += '&amp;lt;/div&amp;gt;';
	});
	$('#content').html(html);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id=&quot;content&quot;&amp;gt;
	&amp;lt;div class=&quot;item&quot;&amp;gt;
	&amp;lt;h2&amp;gt;Tom&amp;lt;/h2&amp;gt;
	&amp;lt;div class=&quot;birthday&quot;&amp;gt;1991-01-23&amp;lt;/div&amp;gt;
	&amp;lt;ul&amp;gt;
		&amp;lt;li&amp;gt;篮球&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;羽毛球&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;看电影&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;item&quot;&amp;gt;
	&amp;lt;h2&amp;gt;Jhon&amp;lt;/h2&amp;gt;
	&amp;lt;div class=&quot;birthday&quot;&amp;gt;1987-09-06&amp;lt;/div&amp;gt;
	&amp;lt;ul&amp;gt;
		&amp;lt;li&amp;gt;网球&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;看书&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;听音乐&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div class=&quot;item&quot;&amp;gt;
	&amp;lt;h2&amp;gt;James&amp;lt;/h2&amp;gt;
	&amp;lt;div class=&quot;birthday&quot;&amp;gt;1989-10-23&amp;lt;/div&amp;gt;
	&amp;lt;ul&amp;gt;
		&amp;lt;li&amp;gt;篮球&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;旅游&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;看书&amp;lt;/li&amp;gt;
		&amp;lt;li&amp;gt;玩游戏&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.getScript( url, callback )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;a.js文件，其内容如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var data = [
	{
    	&quot;name&quot;    : &quot;Tom&quot;,
    	&quot;birthday&quot;: &quot;1991-01-23&quot;,
    	&quot;hobbies&quot;: [&quot;篮球&quot;,&quot;羽毛球&quot;,&quot;看电影&quot;]
	},
	{
	    &quot;name&quot;    : &quot;Jhon&quot;,
	    &quot;birthday&quot;: &quot;1987-09-06&quot;,
	    &quot;hobbies&quot;: [&quot;网球&quot;,&quot;看书&quot;,&quot;听音乐&quot;]
	},
	{
	    &quot;name&quot;    : &quot;James&quot;,
	    &quot;birthday&quot;: &quot;1989-10-23&quot;,
	    &quot;hobbies&quot;: [&quot;篮球&quot;,&quot;旅游&quot;,&quot;看书&quot;,&quot;玩游戏&quot;]
	}
];
var html = '';
$.each(data, function( index, item ){
	html += '&amp;lt;div class=&quot;item&quot;&amp;gt;';
	html += '&amp;lt;h2&amp;gt;' + item.name + '&amp;lt;/h2&amp;gt;';
	html += '&amp;lt;div class=&quot;birthday&quot;&amp;gt;' + item.birthday + '&amp;lt;/div&amp;gt;';
	html += '&amp;lt;ul&amp;gt;';
	for(var i in item.hobbies){
		html += '&amp;lt;li&amp;gt;' + item.hobbies[i] + '&amp;lt;/li&amp;gt;';
	}
	html += '&amp;lt;/ul&amp;gt;';
	html += '&amp;lt;/div&amp;gt;';
});
$('#content').html(html);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;页面的script代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.getScript('/a.js',function(){
	console.log('ajax get script done!');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面上面的ajax请求script成功之后，会直接执行响应的a.js文件，结果跟&lt;code class=&quot;highlighter-rouge&quot;&gt;$.getJSON&lt;/code&gt;的结果显示一样。&lt;/p&gt;

&lt;p&gt;前面也介绍过&lt;code class=&quot;highlighter-rouge&quot;&gt;$.getJSON&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;$.geScript&lt;/code&gt;两个方法，调用最底层的ajax方法，然后为其指定了optioins，就成了这两个方法。&lt;/p&gt;

&lt;p&gt;上面两个方法使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$.get&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;$.ajax&lt;/code&gt;来实现的话，其请求操作如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// $.get
$.get( 'a.json', function(data){...}, 'json' );
$.get( 'b.js', underfined, function(){
	console.log('ajax get script done!');
}, 'script' );

// $.ajax
$.ajax({
	url: 'a.json',
	type: 'get',
	dataType: 'json',
	data: null,
	success: function(data){...}
});

$.ajax({
	url: 'b.js',
	type: 'get',
	dataType: 'script',
	data: null,
	success: function(){
		console.log('ajax get script done!');
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.get()、$.post()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;$.get()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;$.post()&lt;/code&gt;的源码中，可以看出它们都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;$.ajax()&lt;/code&gt;方法来实现的，唯一不同的是type(请求方式)不同，其它的都是一样的。&lt;/p&gt;

&lt;p&gt;实际上get和post请求最大的区别是get请求把查询字符串放到url中，作为url的一部分；而post请求则不是，但是在jQuery的实现中，这种方式是没有体现出来的，都是直接通过传递一个data参数，在jQuery的底层实现中会将其转换成各自不同的实现，而我们是不需要去管它是怎么实现的。&lt;/p&gt;

&lt;p&gt;jQuery中get和post的原型前面也介绍过，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.get( url, data, callback )

$.post( url, data, callback )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出其调用方式是一样的，只不过具体使用哪一种请求方式：(1)遵照服务器端代码的约定；(2)传输数据量–get方法对传输的数据量有更严格的限制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;序列化表单&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;向服务器发送数据常常会涉及到用户填写的表单，查询量较小的时候，可以手动的设置查询字符串，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.get( 'c.html', {'name': $('input[name='name']').val()}, function(data){
	console.log(data);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是当涉及到的表单数量较多的时候，手动的去序列化就不现实了，在这种情况下就可以使用jQuery提供的辅助方法&lt;code class=&quot;highlighter-rouge&quot;&gt;.serialize()&lt;/code&gt;，该方法作用于一个jQuery对象，将匹配的DOM元素转换层能够随Ajax请求传递的查询字符串，例如前面的可以一般化为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('form').submit(function(event){
	event.preventDefault();
	var formValues = $(this).serialize();
	$.get( 'c.html', formValues, function(){
		$('#content').html(data);
	});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面我们举例说明这个序列化的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// html
&amp;lt;form action='#'&amp;gt;
	姓名：&amp;lt;input type='text' name='name'&amp;gt;&amp;lt;/br&amp;gt;
	年龄：&amp;lt;input type='text' name='age'&amp;gt;&amp;lt;/br&amp;gt;
	密码：&amp;lt;input type='password' name='password'&amp;gt;&amp;lt;/br&amp;gt;
	&amp;lt;input type='submit'/&amp;gt;
&amp;lt;/form&amp;gt;

// js
$('form').submit(function(evnet){
	event.preventDefault();
	var va = $(this).serialize();
	$('#content').html(data);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当用户填写&lt;code class=&quot;highlighter-rouge&quot;&gt;tom，20，tom123456&lt;/code&gt;，然后单击提交，就会看到控制台输出了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;name=tom&amp;amp;age=20&amp;amp;password=tom123456
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.ajaxStart / .ajaxStop&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面我么说的一直都是在处理事件的响应，其实很多的时候，在调用ajax之前或调用过程中也需要处理一些事件，比如说：为了增强用户体验，在发送请求之间在页面显示一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Loading&lt;/code&gt;，在请求成功之后再将&lt;code class=&quot;highlighter-rouge&quot;&gt;Loading&lt;/code&gt;去掉，再显示请求结果。&lt;/p&gt;

&lt;p&gt;jQuery为我们提供了实现这样功能的函数，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;.ajaxStart()&lt;/code&gt;是在ajax尚未进行其它ajax时调用该函数，而&lt;code class=&quot;highlighter-rouge&quot;&gt;.ajaxStop()&lt;/code&gt;是在最后一次请求结束之后再调用。jQuery提供的这些功能函数是全局性的，无论代码注册的位置在哪，只要满足了执行的条件，它都会运行。&lt;/p&gt;

&lt;p&gt;例如实现上面说的&lt;code class=&quot;highlighter-rouge&quot;&gt;Loading&lt;/code&gt;，先在html需要的位置插入一个显示加载中的显示元素，如&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div id='loading'&amp;gt;Loading&amp;lt;/div&amp;gt;&lt;/code&gt;，并将其设置为默认不显示，即添加一个样式style，&lt;code class=&quot;highlighter-rouge&quot;&gt;display: none;&lt;/code&gt;，则html如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div id='loading' style='display: none;'&amp;gt;
	Loading!
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在js代码中需要的地方添加&lt;code class=&quot;highlighter-rouge&quot;&gt;.ajaxStart&lt;/code&gt;即可，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ajaxStart(function(){
	$('#loading').show();
}).ajaxStop(function(){
	$('#loading').hide();
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面一篇介绍列出了所有jQuery提供的监听这些事件的方法，可以用来完成各种需要的操作，感兴趣的可以去尝试一下。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;ajax中的Deferred对象&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;$.get/post&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;.load&lt;/code&gt;等快捷的Ajax方法来说，并没有提供错误回调函数，只是提供了一个请求成功的回调函数，因此在错误发生的时候的处理函数需要通过其它方式来完成，比如说前面介绍过的Deferred延迟对象，它可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.done()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;.fail()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;.always()&lt;/code&gt;来为ajax请求添加相应的事件回调函数即可。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.get( 'c.html', formValues, function(){
	$('#content').html(data);
}).fail(function(jqXHR){
	$('#content')
		.html('An error occurred:' + jqXHR.status)
		.append(jqXHR.responseText);
}).always(function(){
	console.log('ajax stop!');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多的相关内容可以参考前面关于Deferred对象的讲解。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;修改默认选项&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$.ajaxSetup()&lt;/code&gt;方法可以修改调用Ajax方法是，每个选项的默认值，接受与&lt;code class=&quot;highlighter-rouge&quot;&gt;$.ajax()&lt;/code&gt;相同的对象参数选项，如本文开头的表格所示，之后的所有Ajax请求都将使用传递给该函数的选项，除非用户显示的指定同名参数(将会覆盖默认设置)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 修改默认选项
$.ajaxSetup({
	url: 'd.html',
	type: 'post',
	dataType: 'html'
});

// 再次调用ajax
$.ajax({
	type: 'get',
	success: function(data){
		$('#content').html(data);
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面修改默认选项时，为ajax方法指定了默认的url(&lt;code class=&quot;highlighter-rouge&quot;&gt;d.html&lt;/code&gt;)和dataType，后面调用时不需要在明确指定，如果再设置了与前面同名的选项，会覆盖前面的，就像这里的type，默认是post方式，而此处显示的指定了get方式，那么在本次的ajax请求会使用get方式去请求，如果下次没有显示指定请求方式，仍然会使用post方式去请求。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;部分加载页面&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面介绍过的&lt;code class=&quot;highlighter-rouge&quot;&gt;.load()&lt;/code&gt;方法，会将指定的文档&lt;strong&gt;全部&lt;/strong&gt;添加到匹配元素中，而实际上可能只需要添加一部分。比如在加载一个html文档时，需要的只是这个html文档当中的&lt;code class=&quot;highlighter-rouge&quot;&gt;class＝'part'&lt;/code&gt;的元素，不需要去遍历查找，直接传递url时附带一个jQuery选择符表达式即可，jQuery会帮我们完成必要的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('#content').load('c.html .part');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际的操作语句就只有一句，非常的简洁，感兴趣的可以去试试看，你会发现与jQuery选择符表达式无关的信息都被剔除掉了，只将需要的信息加载到了匹配元素中。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[13] -- AJAX（1）</title>
   <link href="http://www.blogways.net/blog/2014/08/26/jQuery-source-analysis-ajax(1).html"/>
   <updated>2014-08-26T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/26/jQuery-source-analysis-ajax(1)</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;AJAX，异步JavaScript和XML，涉及到如下技术：&lt;/p&gt;

&lt;p&gt;(1)异步JavaScript，由于JavaScript中引入的回调函数的概念，所有后台的JavaScript代码中，后面的任务&lt;strong&gt;不需要&lt;/strong&gt;在等待前面的任务执行完，每个任务执行完毕后不是去执行另一个任务，而是执行其绑定的一个或多个回调函数，因而程序的执行顺序与任务的排列顺序是不一致的、异步的。&lt;/p&gt;

&lt;p&gt;一般耗时较长的任务都是使用异步操作，以避免浏览器长时间执行某一无意义的任务(如死循环等)失去响应。&lt;/p&gt;

&lt;p&gt;(2)XMLHTTPRequest，在不中断浏览器其他任务的情况下，向服务器发送请求&lt;/p&gt;

&lt;p&gt;(3)向服务器请求的数据类型，及预期服务器返回的数据类型。&lt;/p&gt;

&lt;h2 id=&quot;二源码结构&quot;&gt;二、源码结构&lt;/h2&gt;

&lt;p&gt;首先，看一下jQuery源码中，Ajax这块的方法及函数的扩展实现，总体结构如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.parseJSON = function( data ) {};
jQuery.parseXML = function( data ) {};
jQuery.parseHTML = function( data, context, keepScripts ) {};

function addToPrefiltersOrTransports( structure ) {};
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {};
function ajaxHandleResponses( s, jqXHR, responses ) {};
function ajaxConvert( s, response, jqXHR, isSuccess ) {};

jQuery.extend({
	ajaxSettings: {...},
	ajaxSetup: function( target, settings ) {},
	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),
	// 主要的方法
	ajax: function( url, options ) {},
	
	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, &quot;json&quot; );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, &quot;script&quot; );
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的这些源码中，首先直接通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.funcName&lt;/code&gt;扩展jQuery全局函数，将jQuery提供的3个字符串转换为相应JSON、XML或HTML的API；&lt;/p&gt;

&lt;p&gt;接着定义了一些ajax内部使用的函数，用于后面实现功能时调用；然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;将一些功能函数扩展到jQuery全局对象中去，这些函数的功能后面会有介绍，此处不详细说明。其中最主要的一个方法就是&lt;code class=&quot;highlighter-rouge&quot;&gt;ajax( url, options )&lt;/code&gt;，ajax模块中的所有其他的ajax功能函数都是在此函数的基础上来实现的，就拿getJSON和getScript来说，它们的源代码很简单，就一行代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// getJSON
return jQuery.get( url, data, callback, &quot;json&quot; );
// getScript
return jQuery.get( url, undefined, callback, &quot;script&quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，它们都是调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.get()&lt;/code&gt;方法，它们本质上就是一个get请求，只不过认为的为其指定了&lt;strong&gt;&lt;em&gt;预期回的数据类型&lt;/em&gt;&lt;/strong&gt;( “json”和”script” )，那么这个get方法又是怎么实现的呢，下面请看get/post方法的实现源码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.each( [ &quot;get&quot;, &quot;post&quot; ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}
		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里使用&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.each()&lt;/code&gt;遍历一个数组&lt;code class=&quot;highlighter-rouge&quot;&gt;[ &quot;get&quot;, &quot;post&quot;]&lt;/code&gt;，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery[ method ] = function...&lt;/code&gt;，将get/post方法扩展到了jQuery的全局对象中，然后来看一这两个方法的原型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery[ method ] = function( url, data, callback, type ) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后是其实现的代码，从中可以看出这两个方法实现的实质也是调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;ajax( url, options )&lt;/code&gt;方法，只不过是将其中的一些事先确定的参数传递给ajax方法而已。&lt;/p&gt;

&lt;p&gt;接下来我们来看一下jQuery提供的一些默认的ajax设置，都保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.ajaxSettings&lt;/code&gt;对象中，其对象结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ajaxSettings: {
	url: ajaxLocation,
	type: &quot;GET&quot;,
	isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
	global: true,
	processData: true,
	async: true,
	contentType: &quot;application/x-www-form-urlencoded; charset=UTF-8&quot;,
	accepts: {
		&quot;*&quot;: allTypes,
		text: &quot;text/plain&quot;,
		html: &quot;text/html&quot;,
		xml: &quot;application/xml, text/xml&quot;,
		json: &quot;application/json, text/javascript&quot;
	},
	contents: {
		xml: /xml/,
		html: /html/,
		json: /json/
	},
	responseFields: {
		xml: &quot;responseXML&quot;,
		text: &quot;responseText&quot;,
		json: &quot;responseJSON&quot;
	},
	// 数据转换
	converters: {
		&quot;* text&quot;: String,
		&quot;text html&quot;: true,
		&quot;text json&quot;: jQuery.parseJSON,
		&quot;text xml&quot;: jQuery.parseXML
	},
	flatOptions: {
		url: true,
		context: true
	}
},
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;列出了ajax默认的一些设置，如果用户使用的ajax请求参数，都基本确定无需要很大的更改，则可以根据自己的需求更改这些默认的ajax设置，就不需要每次在使用ajax请求时都要指定这些参数，而用于修改ajax默认请求参数的方法源码如下，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ajaxSetup: function( target, settings ) {
	return settings ?
		// 根据默认设置，构建一个行的settings对象，
		// 然后将修改的参数扩展到默认设置里面
		ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :
		// 扩展ajaxSettings
		ajaxExtend( jQuery.ajaxSettings, target );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;ajaxExtend()&lt;/code&gt;是一个ajax请求参数options的特殊扩展方法，只是将用户自定义的设置扩展到了jQuery的默认设置中去，当然同名的会发生覆盖，其基本功能跟&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;方法类似，感兴趣的可以到前面的讲解中去看一下相关介绍，可以看一个解析YAML的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.ajaxSetup({
	accepts: {
		yaml: 'application/x-yaml, text/yaml'
	},
	contents: {
		yaml: /yaml/
	},
	converters: {
		'text yaml': function(text){
			alert(text);
			return '';
		}
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样就完成了一个ajax参数默认值的修改，一旦修改之后，后面的所有ajax都将会受到该次修改的影响：后面只要请求的数据类型是一个yaml文件，那么就会按照上面定义的这些参数来运行及转换，调用方式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.ajax({
	url: 'helloworld.yaml'
	dataType: 'yaml'
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中的converters的&lt;code class=&quot;highlighter-rouge&quot;&gt;'text yaml'&lt;/code&gt;是告诉jQuery，这个转换函数以text格式接受数据，然后以yaml格式重新解析，后面指定的就是起解析函数，此处的转换只是将内容通过警示框输出。&lt;/p&gt;

&lt;p&gt;然后来看一下jQuery中ajax提供的一些监听方法，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 通过jQuery.each方法遍历数组中需要添加监听的名称，
// 使用jQuery.fn[ type ]将这些监听方法扩展到jQuery的实例对象中去，
// 在其具体实现中，通过调用当前匹配元素(jQuery实例对象)的on方法，
// 将指定的事件处理程序绑定到特定的ajax事件上
jQuery.each( [ &quot;ajaxStart&quot;, &quot;ajaxStop&quot;, &quot;ajaxComplete&quot;, 
							&quot;ajaxError&quot;, &quot;ajaxSuccess&quot;, &quot;ajaxSend&quot; ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从中可以看出，ajax一共提供了6个ajax事件监听，分别为：ajaxStart、ajaxStop、ajaxComplete、ajaxError、ajaxSuccess和ajaxSend，这些监听方法的功能介绍后面再做说明。&lt;/p&gt;

&lt;p&gt;后面通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;.seriallize()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.seriallizeArray()&lt;/code&gt;方法扩展到jQuery的实例对象中去，其代码实现不在做讲解，感兴趣的可以自己看看。&lt;/p&gt;

&lt;p&gt;前面讲解到了ajaxSetup方法扩展一个yaml文件的ajax请求，下面来看一下jQuery源码中关于script的ajax请求的扩展，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 增加script数据类型
jQuery.ajaxSetup({
	accepts: {
		script: &quot;text/javascript, application/javascript, 
						application/ecmascript, application/x-ecmascript&quot;
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		&quot;text script&quot;: function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是跟我们举得例子基本是一样的吧，这里accepts中的属性会添加发送到服务器的头部信息，声明我们的脚本可以理解的特定的MIME类型，此处为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;text/javascript, application/javascript, application/ecmascript, application/x-ecmascript&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当请求的为这些MIME类型时，将其理解为script；&lt;/p&gt;

&lt;p&gt;而contents属性处理数据交换的另一方，它提供一个与响应的MIME类型进行匹配的正则表达式，以尝试自动检测这个元数据当中的数据类型，此处表示会匹配script、javascript或ecmascript；&lt;/p&gt;

&lt;p&gt;最后的converters中包含解析返回数据的函数，此处是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.globalEval()&lt;/code&gt;方法在全局上下文中执行给定的JavaScript字符串，并返回此JavaScript字符串。&lt;/p&gt;

&lt;p&gt;接下来的源码结构，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 定义script的预过滤器
jQuery.ajaxPrefilter( &quot;script&quot;, function( s ) {...});

// 扩展script的传输机制
jQuery.ajaxTransport( &quot;script&quot;, function(s) {...});
// 默认的json设置
jQuery.ajaxSetup({
	jsonp: &quot;callback&quot;,
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + &quot;_&quot; + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

jQuery.ajaxPrefilter( &quot;json jsonp&quot;, function( s, originalSettings, jqXHR ) {...});

// 通过ajax请求，将指定url响应的元素加入到匹配元素中
jQuery.fn.load = function( url, params, callback ) {};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.ajaxPrefilter()&lt;/code&gt;函数可以添加&lt;strong&gt;预过滤器&lt;/strong&gt;(即一些回调函数)，在发送ajax请求之前对请求进行过滤。预过滤器会在&lt;code class=&quot;highlighter-rouge&quot;&gt;$.ajax()&lt;/code&gt;修改或者使用它的任何选项之前调用，因此通过预过滤器可以修改这些选项或者基于新的、自定义的选项发送ajax请求。&lt;/p&gt;

&lt;p&gt;在定义了特定功能的预过滤器之后，就不需要我们在ajax请求中，明确的去定义数据类型。&lt;/p&gt;

&lt;h2 id=&quot;三ajax方法&quot;&gt;三、Ajax方法&lt;/h2&gt;

&lt;p&gt;在看完ajax模块的源码结构之后，下面是对ajax中提供的一些方法做了一下总结：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;发送请求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajax( url, options )&lt;/td&gt;&lt;td&gt;使用传入的options生成一次ajax请求&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.load( url, params, callback )&lt;/td&gt;&lt;td&gt;根据url生成一次ajax请求，将响应放到匹配的元素中&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.get( url, data, callback, type )&lt;/td&gt;&lt;td&gt;使用get方法向指定url发送一次ajax请求&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.post( url, data, callback, type )&lt;/td&gt;&lt;td&gt;使用post方法向指定url发送一次ajax请求&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.getJSON( url, data, callback )&lt;/td&gt;&lt;td&gt;向url发送一次ajax请求，&lt;b&gt;解析&lt;/b&gt;预期返回的JSON数据&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.getScript( url, callback )&lt;/td&gt;&lt;td&gt;向url发送一次ajax请求，&lt;b&gt;执行&lt;/b&gt;预期返回的JavaScript代码&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;监听请求&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxStart( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务开始，但没有其它Ajax事务活动时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxStop( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务结束，但没有其它Ajax事务仍然在活动时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxComplete( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，完成时执行的处理程序(无论执行失败还是成功都执行)&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxError( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，发生错误时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxSuccess( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，成功完成时执行的处理程序&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.ajaxSend( fn )&lt;/td&gt;&lt;td&gt;绑定当任意Ajax事务执行过程中，开始执行时执行的处理程序&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;配置信息&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxSettings&lt;/td&gt;&lt;td&gt;jQuery提供的ajax默认设置选项&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxSetup&lt;/td&gt;&lt;td&gt;为后续的ajax事务设置默认选项&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxPrefilter( prefilters )&lt;/td&gt;&lt;td&gt;在$.ajax()处理每个请求之前，会对每个Ajax请求选项做预过滤&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.ajaxTransport( transports )&lt;/td&gt;&lt;td&gt;为Ajax定义一个新的传输机制&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;辅助方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;Ajax方法&lt;/th&gt;&lt;th&gt;说   明&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.seriallize()&lt;/td&gt;&lt;td&gt;将表单控件的值序列化为一个查询字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;.seriallizeArray()&lt;/td&gt;&lt;td&gt;将表单空间的值序列化为一个JSON字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.param( obj )&lt;/td&gt;&lt;td&gt;将obj对象转换为一个查询字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.globalEval( code )&lt;/td&gt;&lt;td&gt;在全部上下文中执行给定是JavaScript字符串&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.parseJSON( json )&lt;/td&gt;&lt;td&gt;将给定的json字符串转换为JavaScript对象&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.parseXML( xml )&lt;/td&gt;&lt;td&gt;将给定的xml字符串转换为XML文档&lt;/td&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;$.parseHTML( html )&lt;/td&gt;&lt;td&gt;将给定的html字符串转换为DOM元素&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[12] -- 特性属性操作</title>
   <link href="http://www.blogways.net/blog/2014/08/25/jQuery-source-analysis-attribute.html"/>
   <updated>2014-08-25T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/25/jQuery-source-analysis-attribute</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;属性操作主要分为attr特性和prop属性操作，而一般使用的方法就三个：&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.val()&lt;/code&gt;。其中&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr()&lt;/code&gt;用于操作attr特性，而&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop()&lt;/code&gt;主要用于操作prop属性，最后&lt;code class=&quot;highlighter-rouge&quot;&gt;.val()&lt;/code&gt;则是用于操作元素的value属性值。&lt;/p&gt;

&lt;p&gt;提到attr特性和prop属性，很多人都会很疑惑，它们之间有什么不同呢？&lt;/p&gt;

&lt;p&gt;(1)&lt;strong&gt;&lt;em&gt;attr特性&lt;/em&gt;&lt;/strong&gt;，直接写在标签上的属性，可以通过浏览器原生的API：setAttribute、getAttribute进行设置、读取，如下所示的id，type，checked都是attr特性：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input id='incb' type='checkbox' checked='checked'/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;attr特性，主要是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;name＝'value'&lt;/code&gt;的形式，通过NameNodeMap保存在元素节点当中，其自身作为&lt;code class=&quot;highlighter-rouge&quot;&gt;Node.ATTRIBUTE_NODE(2)&lt;/code&gt;节点，上述的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt;元素对应的jQuery对象结构，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/attr.png&quot; alt=&quot;attr 特性值 NameNodeMap&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看到attr特性在元素节点中是以NameNodeMap类型保持的。&lt;/p&gt;

&lt;p&gt;(2)&lt;strong&gt;&lt;em&gt;prop属性&lt;/em&gt;&lt;/strong&gt;，prop属性和attr特性最明显的差异修饰保持方式和访问设置方式，attr要通过一些元素的API来访问设置，但是prop属性则是直接通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;号来进行访问和设置属性；prop属性是作为元素节点的实例对象属性来存储的。&lt;/p&gt;

&lt;p&gt;就像上面attr特性值中的图片所示，其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;checked: true&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;accept:&quot;&quot;&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;autofocus: false&lt;/code&gt;等都是prop属性值，因为作为元素节点的属性，可以直接访问：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var $incb = $('#incb');
$incb.accept = 'Test prop value!';
console.log($incb.accept);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果会显示&lt;code class=&quot;highlighter-rouge&quot;&gt;Test prop value!&lt;/code&gt;，可见上面通过对&lt;code class=&quot;highlighter-rouge&quot;&gt;.accept = '...'&lt;/code&gt;直接赋值用于设置了prop属性，而通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.accept&lt;/code&gt;直接返回了设置的prop属性。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;.val()&lt;/code&gt;则是操作的是元素的value属性。&lt;/p&gt;

&lt;h2 id=&quot;二源码分析&quot;&gt;二、源码分析&lt;/h2&gt;

&lt;p&gt;首先，看一下通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;扩展到jQuery实例对象中的&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop()&lt;/code&gt;方法，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;attr: function( name, value ) {
	return access( this, jQuery.attr, name, value, arguments.length &amp;gt; 1 );
}

prop: function( name, value ) {
	return access( this, jQuery.prop, name, value, arguments.length &amp;gt; 1 );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由上面的源码可以看出，jQuery实例对象中的两个方法都是调用了access，在参数传递方面除了在第二个参数不同之外，其余都是一样的，那么让我们来看一下access函数是何方神圣，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		length = elems.length,
		bulk = key == null;

	// 传递的过来的key值是个对象，递归调用处理多值
	if ( jQuery.type( key ) === &quot;object&quot; ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// 传递的value值有意义，处理单值
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			// key值不为空，即传递过来的key值有意义
			if ( raw ) {
				// 如果传递过来的value不是一个函数，
				// 则直接使用key和value值，调用传递过来的函数fn
				fn.call( elems, value );
				fn = null;

			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) { 	// 运行fn
			for ( ; i &amp;lt; length; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}
	// chainable 为 arguments.length &amp;gt; 1 的结果
	return chainable ? 	 // 返回操作以后的数据
		elems :
		bulk ?
			fn.call( elems ) :
			length ? fn( elems[0], key ) : emptyGet;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从中可以看出，access方法没有太多代码，仅仅只是讲传递过来的参数做一定的修改，修改完成之后执行指定的函数(第二个参数所指定的函数)，而主要的参数修改，就是将多值参数分解为单值操作，然后分别执行相应的函数。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop()&lt;/code&gt;方法在为access传递的第二个参数，分别传值为&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.attr&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.prop&lt;/code&gt;，由此可见，attr特性与prop属性的get/set方法具体实现应该在这两个传值函数当中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;attr: function( elem, name, value )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;attr: function( elem, name, value ) {
	var hooks, ret,
		nType = elem.nodeType;

	// 忽略文本、注释和属性节点的attr特性操作(get/set)
	if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
		return;
	}

	// 当不支持浏览器原生的getAttribute时，
	// 调用prop属性设置方法来实现
	if ( typeof elem.getAttribute === strundefined ) {
		return jQuery.prop( elem, name, value );
	}

	// 所有的attr特性名都是小写
	if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
		name = name.toLowerCase();  // 将特性名转换为小写样式
		hooks = jQuery.attrHooks[ name ] || // 如果hook已被定义，则直接抓取
			( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
	}

	if ( value !== undefined ) {  // 特性值已定义

		if ( value === null ) {  // 特性值为空，这删除对应属性
			jQuery.removeAttr( elem, name );

		} else if ( hooks &amp;amp;&amp;amp; &quot;set&quot; in hooks &amp;amp;&amp;amp; 
						(ret = hooks.set( elem, value, name )) !== undefined ) {
			return ret;

		} else {
			elem.setAttribute( name, value + &quot;&quot; );
			return value;
		}
	// 如果有对应的hooks，且其中包含get方法，则调用hooks的get方法
	} else if ( hooks &amp;amp;&amp;amp; &quot;get&quot; in hooks &amp;amp;&amp;amp; (ret = hooks.get( elem, name )) !== null ) {
		return ret;

	} else {
		ret = jQuery.find.attr( elem, name );
		// 不存在对应特性返回undefined
		return ret == null ?
			undefined :
			ret;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由源码可知，通过对参数的一些判断和修正，实现来对&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr()&lt;/code&gt;方法的重载，首先，value值是否定义，来判别是get/set，value的类型(可以是function)，或者传入一个key-value值对象，都能实现类似&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;中的函数重载：&lt;/p&gt;

&lt;p&gt;(1)&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr( key )&lt;/code&gt;，get方法，取得指定key值(特性名)对应的特性值；&lt;/p&gt;

&lt;p&gt;(2)&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr( key, value )&lt;/code&gt;，set方法，设置指定key值所示特性对应的特征值；&lt;/p&gt;

&lt;p&gt;(3)&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr( key, fn )&lt;/code&gt;，set方法，设置对应key特性的特性值，为调用fn之后的返回结果(每个匹配元素单独调用)；&lt;/p&gt;

&lt;p&gt;(4)&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr( obj )&lt;/code&gt;，set方法，根据传入的key-value对象设置特性&lt;/p&gt;

&lt;p&gt;(5)&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr( key, null )&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;.removeAttr(key)&lt;/code&gt;，删除指定key值对应的特性&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;prop: function( elem, name, value )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;prop: function( elem, name, value ) {
	var ret, hooks, notxml,
		nType = elem.nodeType;

	// 忽略文本、注释和属性节点的attr特性操作(get/set)
	if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
		return;
	}

	notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

	if ( notxml ) {
		// 修正属性名和的绑定的hooks
		name = jQuery.propFix[ name ] || name;
		hooks = jQuery.propHooks[ name ];
	}
	// 与attr一样，通过判断是否传递value，来鉴别get/set，
	// 属性的设置与获取都是通过hooks来实现
	if ( value !== undefined ) { 	// value值已定义，相当于set
		return hooks &amp;amp;&amp;amp; &quot;set&quot; in hooks 
					&amp;amp;&amp;amp; (ret = hooks.set( elem, value, name )) !== undefined ?
			ret :
			( elem[ name ] = value );

	} else {	// value未定义，相当于get
		return hooks &amp;amp;&amp;amp; &quot;get&quot; in hooks &amp;amp;&amp;amp; (ret = hooks.get( elem, name )) !== null ?
			ret :
			elem[ name ];
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从源代码可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;.attr()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop()&lt;/code&gt;中并没有给出最底层调用原生API的实现，多数都是通过调用对应的hooks来实现对特性与属性的设置，由于笔者对于这个hooks也有些迷惑，还在学习中，此处不在说明。&lt;/p&gt;

&lt;p&gt;虽然具体底层实现没有给出，但是源码中可以看出，通过判断value参数值是否定义，用于判断实现get/set方法。&lt;/p&gt;

&lt;p&gt;(1)&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop( key )&lt;/code&gt;，get方法，取得指定key值(属性名名)对应的属性值；&lt;/p&gt;

&lt;p&gt;(2)&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop( key, value )&lt;/code&gt;，set方法，设置指定key值所示属性对应的属性值；&lt;/p&gt;

&lt;p&gt;(3)&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop( key, fn )&lt;/code&gt;，set方法，设置对应key属性的属性值，为调用fn之后的返回结果(每个匹配元素单独调用)；&lt;/p&gt;

&lt;p&gt;(4)&lt;code class=&quot;highlighter-rouge&quot;&gt;.prop( obj )&lt;/code&gt;，set方法，根据传入的key-value对象设置属性&lt;/p&gt;

&lt;p&gt;(5)&lt;code class=&quot;highlighter-rouge&quot;&gt;.removeProp(key)&lt;/code&gt;，删除指定key值对应的属性&lt;/p&gt;

&lt;h3 id=&quot;附加&quot;&gt;附加&lt;/h3&gt;

&lt;p&gt;要说attr特性和prop属性的实际应用，其中attr特性中使用的最多的要算class特性来，而在一些表单元素中使用最多的属性则是value属性来，面对这些常用的特性与属性，jQuery专门为之提供来操作的API，方便开发。&lt;/p&gt;

&lt;h4 id=&quot;addclassremoveclasstoggleclasshasclass&quot;&gt;addClass、removeClass、toggleClass、hasClass&lt;/h4&gt;

&lt;p&gt;其中的元素的class特性无意是使用率最高的，因为在CSS层叠样式表中，用匹配符来设计样式时，基本都是使用的class，因而class成为来最常要使用的特性。&lt;/p&gt;

&lt;p&gt;由于class包含很多通过空白分隔的若干个特性值，对于某些class特性值的修改非常的不容易，以前需要去编写循环操作，jQuery考虑到这些，专门提供来这几个方法来加快开发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;addClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为每个匹配的元素添加传入的类class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;removeClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从每个匹配的元素中，删除传入的类class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;toggleClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;为每个匹配的元素执行后面的操作：如果传入的类class在匹配元素中已经存在，则删除此class；如果匹配的元素中不存在传入的类class，则在匹配的元素中添加类class&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;hasClass( class )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果所有的匹配元素中，至少有一个元素包含类class则返回true，否则返回false&lt;/p&gt;

&lt;h4 id=&quot;valval-value-&quot;&gt;val()、val( value )&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.val()&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;返回所有匹配元素中，第一个匹配元素的value属性值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.val( val )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置所有匹配元素的value属性值为传入的val值&lt;/p&gt;

&lt;h2 id=&quot;三示例&quot;&gt;三、示例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;attr特性操作&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;html:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input id ='ic' class='hover highlight other' type='button' value='提交' /&amp;gt;
&amp;lt;input id ='ic1' class='myclass' type='button' value='重置' /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var $inbtn = $('#ic');

$inbtn.attr('class'); 	// 去的'class'特性值，'hover highlight other'

$inbtn.attr('type', 'input');  	// 将'type'设置为'input'，即按钮变成来输入框

$inbtn.attr('class', null); 	// 删除'class'属性，及所有'class'特性值

// 将上面两部操作合并到一个对象，一次性实现
$inbtn.attr({'type': 'input','class': null});

$inbtn.removeAttr('class');  // 完成与$inbtn.attr('class', null)一样的操作
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;prop属性操作&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;首先看一下一些prop属性，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/prop.png&quot; alt=&quot;部分prop 属性&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先要说一下的是，很多特性都有一个与之想对应的属性，就拿上面&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;input&amp;gt;&lt;/code&gt;元素的value特性来说，像html中那样编写，它明明是一个特性，但是在图中可以看出，在元素的属性中，也有一个与之对应的属性value。&lt;/p&gt;

&lt;p&gt;它们之间的修改是关联的，修改来属性，特性值也会跟着改变，同样修改来特性值，属性值也会跟着改变。&lt;/p&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$inbtn.prop('value');  // 返回属性value的值，此处为'提交'

$inbtn.prop('value', '修改');  // 将'value'属性修改为'修改'

$inbtn.prop('value', null );  // 删除'value'属性及其属性值

// 将上面两步操作合并到了一个对象中，一次性实现，结果是删除来'value'属性，
// 因为最后一个操作是删除'value'属性及其属性值，所以前面对'value'值的修改不会体现出来
$inbtn.prop({'value': '修改', 'value': null });

$inbtn.removeProp('value');  	// 实现与$inbtn.prop('value', null )一样的操作
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery操作class&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$inbtn.addClass('hello world other');  // 为&amp;lt;input&amp;gt;元素添加三个类hello, world, other
// 如果添加来已存在的类，会默认忽略，
// 修改后的类为hover, highlight, other, hello, world

$inbtn.removeClass('hover other');   // 删除&amp;lt;input&amp;gt;元素的两个类hover, other
// 修改后的类为highlight

$inbtn.toggleClass('hightlight bold'); 
// 修改后的类hover, other, bold

$inbtn.hasClass('myclass'); 	// 返回false，$inbtn只包含第一个&amp;lt;input&amp;gt;元素，没有myclass类

$('input').hasClass('myclass'); 	// 返回true，$('input')包含两个&amp;lt;input&amp;gt;元素，
// 第二个包含myclass类
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.val()、.val( val )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$inbtn.val(); 	// 返回属性value的值，此处为'提交'

$inbtn.val('修改');  // 实现跟$inbtn.prop('value', '修改')一样的操作
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[11] -- 选择符表达式</title>
   <link href="http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-selector-expr.html"/>
   <updated>2014-08-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-selector-expr</id>
   <content type="html">&lt;h2 id=&quot;测试用html&quot;&gt;测试用html：&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;
	&amp;lt;span class='article'&amp;gt;
		&amp;lt;h2&amp;gt;测试标题一&amp;lt;/h2&amp;gt;
		&amp;lt;p id='p1'&amp;gt;段落一，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
		&amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
	&amp;lt;/span&amp;gt;
	&amp;lt;div class='article'&amp;gt;
		&amp;lt;h2&amp;gt;测试标题二&amp;lt;/h2&amp;gt;
		&amp;lt;p id='p2'&amp;gt;段落二，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
		&amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;span class='article'&amp;gt;
		&amp;lt;h2&amp;gt;测试标题三&amp;lt;/h2&amp;gt;
		&amp;lt;p id='p3'&amp;gt;段落三，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
		&amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
	&amp;lt;/div&amp;gt;
	&amp;lt;span class='article'&amp;gt;
		&amp;lt;h2&amp;gt;测试标题四&amp;lt;/h2&amp;gt;
		&amp;lt;p id='p4'&amp;gt;段落四，测试段落，仅供测试之用！！！&amp;lt;a href='#'&amp;gt;linkage&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;
		&amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
	&amp;lt;/div&amp;gt;
	... // 后面省略的全部为&amp;lt;div class='article'&amp;gt;...&amp;lt;/div&amp;gt;元素
	&amp;lt;input type='button' class='article'&amp;gt;提交&amp;lt;/input&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;一简单的css选择符&quot;&gt;一、简单的CSS选择符&lt;/h2&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;*&lt;/td&gt;&lt;td&gt;匹配所有元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;#id&lt;/td&gt;&lt;td&gt;匹配带有给定id的元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;element&lt;/td&gt;&lt;td&gt;给定元素类型的所有元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;.class&lt;/td&gt;&lt;td&gt;匹配给定类的所有元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a, b&lt;/td&gt;&lt;td&gt;与a或b匹配的元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a b&lt;/td&gt;&lt;td&gt;a的所有后代元素中，与b匹配的元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a &amp;gt; b&lt;/td&gt;&lt;td&gt;作为a子元素的所以b元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a + b&lt;/td&gt;&lt;td&gt;a之后的第一个与b匹配的兄弟元素&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;a - b&lt;/td&gt;&lt;td&gt;a之后的所有兄弟元素中与b匹配的元素&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;测试代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('*') 	// 匹配上面html文档中的所有元素

$('#p1') 	// 匹配html文档中id='p1'的元素，即为段落一的&amp;lt;p&amp;gt;元素

$('p') 	  // 匹配html文档中所有的&amp;lt;p&amp;gt;元素，即所有的段落

$('.article') 	// 匹配所有class='article'的元素

$('h2,a')   // 匹配所有的&amp;lt;h2&amp;gt;或&amp;lt;a&amp;gt;元素

$('div a')  // 匹配&amp;lt;div&amp;gt;元素所有后代中的，所有的&amp;lt;a&amp;gt;元素，此处为html中所有的&amp;lt;a&amp;gt;元素

$('div &amp;gt; a')  // 匹配&amp;lt;div&amp;gt;元素的子元素中的&amp;lt;a&amp;gt;元素，此处为所有&amp;lt;a href='#'&amp;gt;read more!&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;h2 id=&quot;二同辈元素间定位&quot;&gt;二、同辈元素间定位&lt;/h2&gt;

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:nth-child(index)&lt;/td&gt;
	&lt;td&gt;匹配父元素的第index个子元素(从1开始计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:nth-child(even)&lt;/td&gt;
	&lt;td&gt;匹配父元素的下标(索引)为&lt;b&gt;&lt;i&gt;偶数的&amp;lt;/b&amp;gt;&lt;/i&gt;子元素(从1开始计数)&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
	
&lt;tr&gt;&lt;td&gt;:nth-child(odd)&lt;/td&gt;
	&lt;td&gt;匹配父元素的下标(索引)为&lt;b&gt;&lt;i&gt;奇数的&amp;lt;/b&amp;gt;&lt;/i&gt;子元素(从1开始计数)&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
	
&lt;tr&gt;&lt;td&gt;:nth-child(formula)&lt;/td&gt;
	&lt;td&gt;匹配父元素的第n个子元素(从1开始计数)，formula(公式)格式为an+b，a和b为整数&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:nth-last-child()&lt;/td&gt;
	&lt;td&gt;与:nth-child()相同(从最后一个元素，由1开始向前计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:first-child&lt;/td&gt;
	&lt;td&gt;匹配父元素的第一个子元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:last-child&lt;/td&gt;
	&lt;td&gt;匹配父元素的最后一个子元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:only-child&lt;/td&gt;
	&lt;td&gt;匹配父元素唯一一个子元素，若有多个元素，匹配为空&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:nth-of-type()&lt;/td&gt;
	&lt;td&gt;与:nth-child()的功能相同，只是此方法只计相同元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:nth-last-of-type()&lt;/td&gt;
	&lt;td&gt;与:nth-of-type()的功能相同，但是计数从最后一个元素开始&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:first-of-type&lt;/td&gt;
	&lt;td&gt;同名的元素中的第一个元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:last-of-type&lt;/td&gt;
	&lt;td&gt;同名元素中的最后一个元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:only-of-type&lt;/td&gt;
	&lt;td&gt;没有同名的同辈元素的元素&lt;/td&gt;&lt;/tr&gt;
	
&amp;lt;/table&amp;gt;

测试代码：

	$('.article:nth-child(1)') 	 // 匹配第一个class='article'元素，
	// 无论&lt;div&gt;,&lt;span&gt;,&lt;input /&gt;都行，(以后简称.article元素)
	
	$('.article:nth-child(even)') 	  // 匹配偶数位置(2,4,6,8...)的.article元素
	
	$('.article:nth-child(odd)')   // 匹配奇数位置(1,3,5,7...)的.article元素
	
	$('.article:nth-child(2n+1)')   // 匹配奇数位置(1,3,5,7...)的.article元素
	// 即当n为0,1,2,3...时，表达式2n+1的值即为匹配元素
	
	$('.article:nth-last-child(2)')  // 匹配倒数第2个.article元素
	
	$('.article:first-child')  // 匹配第一个.article元素
	
	$('.article:last-child')  // 匹配最后一个.article元素
	
	$('.article:only-child')  // 因为匹配元素中不止一个.article元素，匹配为空
	
	$('.article:nth-of-type(2)')  // 匹配同类元素中的第二个元素，
	// 首先会找到含有class＝'article'所有元素，然后根据元素名称分类，
	// 最后匹配不同分类中的第二个元素(如果存在的话)
	// 此处匹配段落二和段落四所在的元素
	
	$('.article:nth-last-of-type(1)') 	// 分别匹配同类元素中倒数第一个元素
	// 此处匹配段落二和段落四，还有最后一个&lt;input /&gt;元素
	
	$('.article:first-of-type')  // 分别匹配同类元素中的第一个元素
	// 此处匹配段落一、段落二所在元素，和最后一个&lt;input /&gt;元素
	
	$('.article:last-of-type')  // 分别匹配同来元素中的最后一个元素
	// 雨nth-last-of-type(1)匹配结果相同
	
	$('.article:only-of-type')  // 匹配当前jQuery对象元素中，没有同名同辈元素的元素
	// 如当前jQuery对象元素中，仅仅包含一个&lt;input class=&quot;article&quot; /&gt;...&amp;lt;/input&amp;gt;元素，
	// 那么此元素即为匹配元素
	// 此处匹配最后一个&lt;input /&gt;元素
	
&amp;lt;/br&amp;gt;

===

## 三、匹配元素间定位 ##

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:first&lt;/td&gt;
	&lt;td&gt;结果集中的第一个元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:last&lt;/td&gt;
	&lt;td&gt;结果集中的最后一个元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:not(selector)&lt;/td&gt;
	&lt;td&gt;结果集中与selector不匹配的所有元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:even&lt;/td&gt;
	&lt;td&gt;结果集中的偶数元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:odd&lt;/td&gt;
	&lt;td&gt;结果集中的奇数元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:eq(index)&lt;/td&gt;
	&lt;td&gt;结果集中下标(索引)为index的元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:gt(index)&lt;/td&gt;
	&lt;td&gt;结果集中位于给定下标(索引)之后的所有元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:lt(index)&lt;/td&gt;
	&lt;td&gt;结果集中位于给定下标(索引)之前的所有元素(从0开始计数)&lt;/td&gt;&lt;/tr&gt;
	
&lt;/table&gt;

测试代码：

	:first  :last  与 :first-child  :last-child结果一样

由于匹配元素间定位计数都是从0开始，而同辈元素间匹配是从1开始，

	:even 与 :nth-child(odd) 结果一样；
	:odd 与 nth-child(even) 结果一样
	
相同的或者类似的此处不再介绍，

	$('.article:not(div,span)')  // 匹配jQuery包含class＝'article'的不为&lt;dib&gt;和&lt;span&gt;的元素
	// 此处匹配最后一个&lt;input /&gt;元素
	
	$('.article:eq(0)')  //  匹配第一个.article元素，:eq(index)功能与nth-child(index)一样，
	// 只不过:eq(index)从下标从0开始计数
	
	$('.article:gt(3)')  // 匹配从第4个.article元素之后的所有元素(不包括第四个)
	
	$('.article:lt(3)')   // 匹配从第4个.article元素之前的所有元素(不包括第四个)，
	// 此处匹配前三个.article元素

&amp;lt;/br&amp;gt;

===

## 四、属性匹配 ##

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;[attr]&lt;/td&gt;
	&lt;td&gt;匹配带有属性attr的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性的值为val的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr!='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性值不为val的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr^='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性值以val开头的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr$='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性值以val结尾的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr*='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性值包含字符串val的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr~='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性值是多个空格分开的字符串，其中一个为val的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;[attr|='val']&lt;/td&gt;
	&lt;td&gt;匹配attr属性值为val，或者以val开头后面跟一个连接符(-)的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;/table&gt;

测试代码：

	$('article &amp;gt; [href]')  // 匹配包含class＝'article'元素的子元素中，带有href属性的元素
	// 此处为所有的a元素，如果在&lt;p&gt;元素中也包含a元素，将不会匹配在内
	
	$('article [href]')  // 匹配包含class＝'article'元素所有后代元素中，带有href属性的元素
	// 与上面一个一样，匹配所有a元素，包含在&lt;p&gt;元素中的&lt;a href=&quot;&quot;&gt;元素
	
	$('.article [href='#']')   // 匹配包含class＝'article'元素所有后代元素中，带有href属性的元素
	// 且属性值为'#'的元素
	
	[href!='www.baidu.com']  // 匹配属性href不为‘www.baidu.com’的元素
	
	[href^='www']  // 匹配所有包含属性href，且href属性值以‘www’开头的元素
	
	[href$='com']  // 匹配所有包含属性href，且href属性值以‘com’结尾的元素
	
	[href*='baidu']  // 匹配所有包含属性href，且href属性值中包含‘baidu’的元素
	
	[class~='hover']  // 匹配class='hover article blsf sflsj'的元素
	
	[class|='my']   // 匹配class='my'或class='my-xxx'的元素
	

&amp;lt;/br&amp;gt;

===

## 五、表单匹配 ##

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:input&lt;/td&gt;
	&lt;td&gt;匹配所有&amp;lt;input&amp;gt;、&amp;lt;select&amp;gt;、&amp;lt;textarea&amp;gt;、&amp;lt;button&amp;gt;的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:text&lt;/td&gt;
	&lt;td&gt;匹配type='text'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:password&lt;/td&gt;
	&lt;td&gt;匹配type='password'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:file&lt;/td&gt;
	&lt;td&gt;匹配type='file'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:radio&lt;/td&gt;
	&lt;td&gt;匹配type='radio'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:checkbox&lt;/td&gt;
	&lt;td&gt;匹配type='checkbox'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:submit&lt;/td&gt;
	&lt;td&gt;匹配type='submit'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:image&lt;/td&gt;
	&lt;td&gt;匹配type='image'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:reset&lt;/td&gt;
	&lt;td&gt;匹配type='reset'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:button&lt;/td&gt;
	&lt;td&gt;匹配type='button'的&amp;lt;input&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:enabled&lt;/td&gt;
	&lt;td&gt;匹配启用的表单元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:disabled&lt;/td&gt;
	&lt;td&gt;匹配禁用的表单元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:checked&lt;/td&gt;
	&lt;td&gt;匹配选中的复选框和单选按钮元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:selected&lt;/td&gt;
	&lt;td&gt;匹配选中的&amp;lt;option&amp;gt;元素&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;

&amp;lt;/br&amp;gt;

===

## 六、自定义选择符 ##

&lt;table width=&quot;100%&quot;&gt;
&lt;tr&gt;&lt;th width=&quot;40%&quot;&gt;选择符&lt;/th&gt;&lt;th&gt;匹配&lt;/th&gt;&lt;/tr&gt;

&lt;tr&gt;&lt;td&gt;:root&lt;/td&gt;
	&lt;td&gt;文档的根节点&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:header&lt;/td&gt;
	&lt;td&gt;标题元素(如&amp;lt;h1&amp;gt;、&amp;lt;h2&amp;gt;等)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:animated&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，其动画正在播放的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:contains(text)&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，包含给定文本text的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:empty&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，不包含子节点的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:has(selector)&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，后代元素中有和selector匹配的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:parent&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，包含子节点的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:hidden&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，隐藏的元素，包括通过css隐藏的元素和&amp;lt;input type='hidden' /&amp;gt;&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:visible&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，显示的元素(即与:hidden相反的元素)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:focus&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，获得焦点的元素&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:lang(language)&lt;/td&gt;
	&lt;td&gt;匹配当前jQuery对象元素中，具有指定语言代码的元素(即指定了lang属性，或在&amp;lt;meta&amp;gt;标签中申明的)&lt;/td&gt;&lt;/tr&gt;
	
&lt;tr&gt;&lt;td&gt;:target&lt;/td&gt;
	&lt;td&gt;匹配URI标识符指向的目标元素&lt;/td&gt;&lt;/tr&gt;

&lt;/table&gt;

&amp;lt;/br&amp;gt;

===

**未完待续。。。**

&lt;/a&gt;&lt;/p&gt;&lt;/p&gt;&lt;/span&gt;&lt;/dib&gt;&lt;/span&gt;&lt;/div&gt;&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[10] -- CSS样式应用</title>
   <link href="http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-css.html"/>
   <updated>2014-08-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/22/jQuery-source-analysis-css</id>
   <content type="html">&lt;h2 id=&quot;一css样式&quot;&gt;一、CSS样式&lt;/h2&gt;

&lt;p&gt;首先，看一下jQuery中提供的修改CSS样式的方法：(1)&lt;code class=&quot;highlighter-rouge&quot;&gt;.css( key )&lt;/code&gt;；(2)&lt;code class=&quot;highlighter-rouge&quot;&gt;.css( key, value )&lt;/code&gt;；(3)&lt;code class=&quot;highlighter-rouge&quot;&gt;.css( obj )&lt;/code&gt;，都是用来修改html的样式的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;css( key )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;取得css属性key的值，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.css('background-color');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;取得匹配元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;background-color&lt;/code&gt;元素的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.css(['background-color', 'font-size']);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;取得匹配元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;background-color&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;font-size&lt;/code&gt;属性的值。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;css( key, value )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;设置css属性key的只为传入的value，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.css( 'background-color', '#0000ff' );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将匹配元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;background-color&lt;/code&gt;背景颜色设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;#0000ff&lt;/code&gt;蓝色。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;css( obj )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;根据传入的key-value参数设置css属性值，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.css({
	background-color: '#0000ff',
	font-size: 15px,
	float: left;
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;闯入参数为一个&lt;strong&gt;属性 - 值&lt;/strong&gt;一一对应的css属性对象，jQuery会为其一一对应的设置对应的css值。&lt;/p&gt;

&lt;p&gt;利用两个按钮，调整某段落文字的大小：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// html
&amp;lt;p class='p1'&amp;gt;段落一，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;p class='p2'&amp;gt;段落二，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;button id='bigger'&amp;gt;变大&amp;lt;/button&amp;gt;
&amp;lt;button id='smaller'&amp;gt;变小&amp;lt;/button&amp;gt;

// script
var $p = $('p');
$('button').on('click', functiono(){
    var num = parseFloat($p.css('font-size'));
    var tmp = this.id == 'bigger' ? num * 1.1 : num / 1.1; 
    $p.css('font-size',num);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这段代码很简单，不难，此处不再说明。&lt;/p&gt;

&lt;h2 id=&quot;二效果方法&quot;&gt;二、效果方法&lt;/h2&gt;
&lt;h3 id=&quot;1预定义效果&quot;&gt;1、预定义效果&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;显示和隐藏元素&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基本的&lt;code class=&quot;highlighter-rouge&quot;&gt;.hide()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.show()&lt;/code&gt;不带任何参数，跟使用&lt;code class=&quot;highlighter-rouge&quot;&gt;.css('display', 'none')&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;.css('display', 'block等其它')&lt;/code&gt;类似，用于显示和隐藏匹配元素，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// html
&amp;lt;p class='p1'&amp;gt;段落一，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;p class='p2' style='display: none;'&amp;gt;段落二，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;
&amp;lt;p class='p3'&amp;gt;段落三，测试文字！！修改CSS样式！&amp;lt;/p&amp;gt;

// script
$('.p1').hide();	// 隐藏段落一
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的script代码，运行后会隐藏段落一，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.p1').show();	// 显示段落二
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在段落二的html代码中，通过style属性为其指定了一个内联的CSS属性&lt;code class=&quot;highlighter-rouge&quot;&gt;display&lt;/code&gt;，并将其设置为none，那么默认情况下，段落二将不会显示出来（默认是隐藏状态），在调用了上面的代码之后，段落二将会显示到界面上。&lt;/p&gt;

&lt;p&gt;当为&lt;code class=&quot;highlighter-rouge&quot;&gt;.show()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.hide()&lt;/code&gt;传递参数时，就会产生像动画一样的，持续性效果。对于jQuery提供的任何效果方法，都可以为其指定两种预设的速度参数：slow和fast。&lt;/p&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;.show('slow')&lt;/code&gt;会在600毫秒(0.6秒)内完成显示隐藏元素的效果，而传递参数为&lt;code class=&quot;highlighter-rouge&quot;&gt;'fast'&lt;/code&gt;时的时间为200毫秒(0.2秒)，而如果不显示的指定速度的参数，jQuery会默认在400毫秒(0.4秒)内完成执行的效果。&lt;/p&gt;

&lt;p&gt;而如果想要指定自己需要的运行速度参数，直接传递一个数值参数即可：&lt;code class=&quot;highlighter-rouge&quot;&gt;.hide(999)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;当然jQuery在隐藏显示元素中，不仅仅只为我们提供了这两个方法，还有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;toggle()&lt;/code&gt;方法，这个方法会显示或隐藏匹配的元素：当隐藏的元素调用此方法后会显示出来，而显示的元素调用此方法后会被隐藏。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('&amp;lt;button&amp;gt;toggle&amp;lt;/button&amp;gt;')
	.appendTo('body')
	.click(function(){
		$('p').toggle('fast');
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素后面添加一个按钮，绑定一个单击事件，点击显示或隐藏所有段落。&lt;/p&gt;

&lt;p&gt;而上面介绍的3个方法在接受一个数值作为显示、隐藏元素速度的同时，还可以传递第二个参数，作为一个回调函数，即当完成了显示、隐藏的任务后，调用该回调函数，原型入下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.show('fast', function(){...});
.hide('slow', function(){...});
.toggle(1000, function(){...});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;淡入、淡出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery除了提供简单的隐藏显示的方法之外，还提供了另一些不同持续效果的隐藏显示方法，这里要将的是淡入和淡出。&lt;/p&gt;

&lt;p&gt;跟前面的隐藏显示元素一样，提供了三个方法，都能接收数值作为速度参数，同样也可以接收一个函数作为回调函数，原型如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.fadeIn([speed], [callback])
.fadeOut([speed], [callback])
.fadeToggle([speed], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其使用方法跟前面一样，不再详细给出。&lt;/p&gt;

&lt;p&gt;其中还涉及到一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.fadeTo(speed, opacity, [callback])&lt;/code&gt;，这个方法可以调整匹配元素的不透明度，感兴趣的可以尝试一下。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('&amp;lt;button&amp;gt;fadeTo&amp;lt;/button&amp;gt;')
	.appendTo('body')
	.click(function(){
		$('p').fadeTo(1000, 0.2);
	});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码，通过想html中添加一个带事件click处理程序的按钮，在其单击事件中，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.fadeTo&lt;/code&gt;改变所有段落的不透明度(在1秒内，将不透明度由1 -&amp;gt; 0.2)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;滑入、滑出&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;滑入和滑出是jQuery提供的另一种显示、隐藏元素的方法，接收的参数跟前面两种方法完全一样，只是其持续效果不同，原型如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.slideDown([speed], [callback])
.slideUp([speed], [callback])
.slideToggle([speed], [callback])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用方法不在给出！&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[9] -- DOM操作方法应用</title>
   <link href="http://www.blogways.net/blog/2014/08/21/jQuery-source-analysis-dom.html"/>
   <updated>2014-08-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/21/jQuery-source-analysis-dom</id>
   <content type="html">&lt;h2 id=&quot;一插入新元素&quot;&gt;一、插入新元素&lt;/h2&gt;

&lt;p&gt;首先，操作DOM要分为两类，(1)操作属性；(2)操作元素；而此处暂时只分析操作DOM树中的元素。&lt;/p&gt;

&lt;p&gt;在学习jQuery以来，我们使用最多的要数&lt;code class=&quot;highlighter-rouge&quot;&gt;$()&lt;/code&gt;了，通过传递document判断文档是否加载完成，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(....);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过传递一个CSS选择符来选择DOM树中的元素，生成一个包含所选元素的jQuery对象，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div') 	// 选择DOM树中所有类名为“div”的元素，即class='div'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在再向大家介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;$()&lt;/code&gt;的另一个用法，就是创建新的DOM元素，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就像上面代码所示，只要为&lt;code class=&quot;highlighter-rouge&quot;&gt;$()&lt;/code&gt;传递一个html的字符串，jQuery将会创建一个对应的DOM元素，当然这仅仅是创建了一个DOM元素，没有添加到DOM中，因而无法显示出来！&lt;/p&gt;

&lt;p&gt;而jQuery中将创建元素插入到DOM树的方法有八个，它们分别是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.append   / .prepend   / .after       / .before
.appendTo / .prependTo / .insertAfter / .insertBefore
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它们的功能都是插入元素，但是其插入方式有比较大的差异。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.append( content )和.appendTo( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;append，在所以匹配元素的&lt;strong&gt;内部&lt;/strong&gt;的&lt;strong&gt;末尾&lt;/strong&gt;插入content，匹配元素就是调用此方法的jQuery对象中所包含的DOM元素，&lt;/p&gt;

&lt;p&gt;appendTo，将匹配的元素插入到selector选择器匹配的元素的&lt;strong&gt;内部&lt;/strong&gt;的&lt;strong&gt;末尾&lt;/strong&gt;中，当前这里匹配的元素跟上面的是一样的，可能唯一有些区别的是，这里的匹配元素可以使用上面所说的方法创建的jQuery对象。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('body').append('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;');

$('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;').appendTo('body');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面所示两行代码，虽然书写方式不同，但是其含义与实现的功能都是一样的，就是将html代码，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;body&amp;gt;&lt;/code&gt;元素的末尾，而实际上也真是这样，可以将代码复制到&lt;a href=&quot;http://jsfiddle.net/&quot; title=&quot;JSFiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;进行测试，看是否将元素插入到了DOM树中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.prepend( content )和.prependTo( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个函数与前面的append与appendTo类似，只不过这两个函数是将元素插入匹配元素&lt;strong&gt;内部&lt;/strong&gt;的&lt;strong&gt;开始&lt;/strong&gt;，而不是末尾，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('body').prepend('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;');

$('&amp;lt;div class=&quot;create by jquery&quot;&amp;gt;create by jquery&amp;lt;/div&amp;gt;').prependTo('body');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行结果就不再过多的描述了，感兴趣的可以去&lt;a href=&quot;http://jsfiddle.net/&quot; title=&quot;JSFiddle.net&quot;&gt;JSFiddle.net&lt;/a&gt;进行测试！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.after( content )和.insertAfter( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;after，在每个匹配元素&lt;em&gt;外部&lt;/em&gt;的后面插入content，&lt;/p&gt;

&lt;p&gt;insertAfter，将匹配的元素插入到selector选择符匹配的元素的&lt;strong&gt;外部&lt;/strong&gt;的后面，&lt;/p&gt;

&lt;p&gt;这里要说一下的是，这里的&lt;strong&gt;外部&lt;/strong&gt;和前面的&lt;strong&gt;内部&lt;/strong&gt;，将的是元素的外部或内部，其内在含义就是：&lt;/p&gt;

&lt;p&gt;(1)、在内部插入元素，表示将插入的元素作为自己的内容插入，即对某个&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素调用内部插入元素方法，那么结果就是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div&amp;gt;（原来的内容）+（添加的内容）&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原来的内容加上新添加的内容作为行的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素的内容。&lt;/p&gt;

&lt;p&gt;(2)、在外部插入元素，表示将新插入的元素灬内容作为自动的兄弟结点，例如对class为div的元素进行&lt;strong&gt;外部&lt;/strong&gt;插入一个class为after的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，结果就如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class='div'&amp;gt; content  &amp;lt;/div&amp;gt;
&amp;lt;div class='after'&amp;gt; content 1 &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.before( content )和.insertBefore( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这两个方法与after和insertAfter类似，都是将内容插入到匹配元素&lt;strong&gt;外部&lt;/strong&gt;，而不同的是这两个方法是将内容插入匹配元素的&lt;strong&gt;外部&lt;/strong&gt;的&lt;strong&gt;前面&lt;/strong&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div').before('&amp;lt;div class=&quot;before&quot;&amp;gt; content &amp;lt;/div&amp;gt;');

$('&amp;lt;div class=&quot;before&quot;&amp;gt; content &amp;lt;/div&amp;gt;').insertBefore('.div');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两行代码的含义是一样的，将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div class='before'&amp;gt; content &amp;lt;/div&amp;gt;&lt;/code&gt;作为所以包含class为div的元素兄长结点插入，即将该html插入到匹配结点之前，结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class='before'&amp;gt; content &amp;lt;/div&amp;gt;
&amp;lt;div class='div'&amp;gt; content &amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二移动元素&quot;&gt;二、移动元素&lt;/h2&gt;

&lt;p&gt;用于测试的html文档：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'div'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'span'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;span&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;a&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'p'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;p&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面通过&lt;code class=&quot;highlighter-rouge&quot;&gt;$()&lt;/code&gt;创建DOM元素，然后通过8个方法将其添加到DOM树中，其中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.appendTo / .prependTo / .insertAfter / .insertBefore
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这四个方法调用对象为jQuery实例对象，即这四个方法运行的上下文环境是一个jQuery对象实例，而接收的参数为一个CSS选择符，因而它们能完成一项感觉跟它们完全没关系的功能。&lt;/p&gt;

&lt;p&gt;它们可以作为插入节点元素的方法，但是这四个方法同样可以移动DOM中元素节点的位置；&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.a').appendTo('body');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上面的jQuery代码过后，可以看到如下的html：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'div'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'span'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;span&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'p'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;p&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;a&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;.appendTo&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.prependTo&lt;/code&gt;继承了它们是在匹配元素&lt;strong&gt;内部&lt;/strong&gt;操作的，那么由此可见&lt;code class=&quot;highlighter-rouge&quot;&gt;insertAfter&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;insertBefore&lt;/code&gt;将会是在匹配元素&lt;strong&gt;外部&lt;/strong&gt;操作的，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.a').insertAfter('body');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'div'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;span&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'span'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;span&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;p&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'p'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;p&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;a&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'a'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;ni&quot;&gt;&amp;amp;lt;&lt;/span&gt;a&lt;span class=&quot;ni&quot;&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有了这四个方法，就可以根据需求在DOM树中，将需要的节点移动到另一个位置。&lt;/p&gt;

&lt;h2 id=&quot;三包装元素&quot;&gt;三、包装元素&lt;/h2&gt;

&lt;p&gt;有时候，需要给很多个段落（即，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素的内容）编号时，有人可能会想用循环为每个元素编号，或者高大上一点通过each遍历来实现，在学习jQuery之前我可能跟你一样，在学了jQuery之后，再也不需要那么麻烦了，jQuery想到了这一块，为我们提供了相应的方法，首先来看下一下效果吧，html如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;body&amp;gt;
	&amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jQuery中提供了相应的包装元素的方法：&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrap( content )&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrapAll( content )&lt;/code&gt;以及&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrapInner( content )&lt;/code&gt;方法；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;wrap( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的每个元素包装在content中，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;wrapAll( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的每个元素作为一个党员包装在content中，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;wrapInner( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的每个元素&lt;strong&gt;内部的内容&lt;/strong&gt;包装在content中。&lt;/p&gt;

&lt;p&gt;有了这3个方法，相信实现起来不难了吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('p').wrapAll('&amp;lt;ol&amp;gt;&amp;lt;/ol&amp;gt;')
	  .wrap('&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;')
	  .wrapInner('&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先用一对闭合的&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ol&amp;gt;&amp;lt;/ol&amp;gt;&lt;/code&gt;（&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;元素用于有序编号，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;元素用于无序编号），通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrapAll()&lt;/code&gt;方法，将所有的段落均包含在内，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
	&amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
	&amp;lt;p&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因为调用&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrapAll()&lt;/code&gt;方法返回的，是一个包装&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;元素之后的对所有段落元素的引用的jQuery对象，可以继续对其调用jQuery实例方法，&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrap()&lt;/code&gt;将匹配的每一个元素包装在参数所给的内容中，则结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这就完成了对所有段落的有序编号，只有两行代码，比自己写循环要简单非常非常的多，使用起来也非常的方便。&lt;/p&gt;

&lt;p&gt;在看到了两个包装方法的应用后，再来看下最后一个&lt;code class=&quot;highlighter-rouge&quot;&gt;.wrapInner()&lt;/code&gt;，将匹配元素每个元素&lt;strong&gt;内部的内容&lt;/strong&gt;包装在所给参数值，其含义很明显了，就是将段落的内容保存到常熟中，其运行结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// &amp;lt;i&amp;gt;：倾斜
&amp;lt;ol&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落四，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;&amp;lt;p&amp;gt;&amp;lt;i&amp;gt;段落五，这仅仅是一些测试文字！&amp;lt;/i&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四替换&quot;&gt;四、替换&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;b&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在jQuery的DOM操作方法中，jQuery为我们提供了两个替换方面的方法：&lt;code class=&quot;highlighter-rouge&quot;&gt;.replaceWith( content )&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;.replaceAll( selector )&lt;/code&gt;。还有两个设置匹配元素值的方法，也可以类似的看成是替换：&lt;code class=&quot;highlighter-rouge&quot;&gt;html()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;text()&lt;/code&gt;方法，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;replaceWith( content )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将匹配的元素替换为content，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('p').replaceWith('by replaceWith ! ');

// 结果
by replaceWith ! 
by replaceWith ! 
by replaceWith ! 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;replaceAll( selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将selector选择符匹配的元素替换为匹配的元素，&lt;/p&gt;

&lt;p&gt;这里要说一下的就是，这里有两个匹配的元素，前面一个是selector（即参数）所选中的匹配元素，后面的一个是调用此方法的jQuery对象中包含的元素，即运行此方法上下文所包含的元素。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;').replaceAll('p');

// 结果
&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;html( [content] )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;函数参数content可省略，省略后调用此方法，会返回所有匹配元素中&lt;strong&gt;第一个元素&lt;/strong&gt;的HTML内容；若不省略content，会将每个匹配的元素的HTML内容读设置为content。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('p').html();  // &amp;lt;p&amp;gt;段落一，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;

$('p').first().html('&amp;lt;h2&amp;gt;设置HTML&amp;lt;/h2&amp;gt;');

// 结果
&amp;lt;p&amp;gt;&amp;lt;h2&amp;gt;设置HTML&amp;lt;/h2&amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落二，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;段落三，这仅仅是一些测试文字！&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;text( [content] )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;跟&lt;code class=&quot;highlighter-rouge&quot;&gt;html()&lt;/code&gt;一样，省略content，则会返回&lt;strong&gt;所有匹配元素&lt;/strong&gt;的文本内容，返回一个字符串；若不省略content，则设置每个匹配元素的文本内容为传入值content。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('p').text();
// 段落一，这仅仅是一些测试文字！段落二，这仅仅是一些测试文字！段落三，这仅仅是一些测试文字！

$('p').text('&amp;lt;b&amp;gt;无段落序号，这仅仅是一些替代文字！&amp;lt;/b&amp;gt;');

// 结果
&amp;lt;p&amp;gt;&amp;amp;lt;b&amp;amp;gt;无段落序号，这仅仅是一些替代文字！&amp;amp;lt;/b&amp;amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;amp;lt;b&amp;amp;gt;无段落序号，这仅仅是一些替代文字！&amp;amp;lt;/b&amp;amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;&amp;amp;lt;b&amp;amp;gt;无段落序号，这仅仅是一些替代文字！&amp;amp;lt;/b&amp;amp;gt;&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五复制元素&quot;&gt;五、复制元素&lt;/h2&gt;

&lt;p&gt;复制元素jQuery中只提供了一个方法&lt;code class=&quot;highlighter-rouge&quot;&gt;clone( [ boolean ] )&lt;/code&gt;方法，&lt;/p&gt;

&lt;p&gt;默认情况下，&lt;code class=&quot;highlighter-rouge&quot;&gt;.clone()&lt;/code&gt;方法不会复制匹配的元素或其后代元素中绑定的事件，不过，当为此函数传递一个true的boolean值时，就可以连同事件一起赋值，即&lt;code class=&quot;highlighter-rouge&quot;&gt;.clone( true )&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// html
&amp;lt;button id='btn1'&amp;gt;测试复制&amp;lt;/button&amp;gt;

// js
$('#btn1').click(function(){
	alert('测试复制事件！');
});

$('#btn1').clone(true).appendTo('body');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试结果是，点击复制的按钮也会弹出警示框显示&lt;code class=&quot;highlighter-rouge&quot;&gt;测试复制事件！&lt;/code&gt;，而没有设置参数的时候，点击复制后的按钮不会有任何相应。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[8] -- Event事件处理（2）</title>
   <link href="http://www.blogways.net/blog/2014/08/20/jQuery-source-analysis-event(2).html"/>
   <updated>2014-08-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/20/jQuery-source-analysis-event(2)</id>
   <content type="html">&lt;h2 id=&quot;二源码分析&quot;&gt;二、源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1源码结构&quot;&gt;1、源码结构&lt;/h3&gt;

&lt;p&gt;event的源码实现结构如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function returnTrue() {};

function returnFalse() {};

// 返回当前获得焦点的元素
function safeActiveElement() {};

jQuery.event = {

	global: {},
	
	// 绑定事件处理
	add: function( elem, types, handler, data, selector ) {},
	
	// 移除事件处理
	remove: function( elem, types, handler, selector, mappedTypes ) {},
	
	// 触发事件
	trigger: function( event, data, elem, onlyHandlers ) {},
	
	// 分派（执行）事件处理程序
	dispatch: function( event ) {},
	
	// 组装事件处理队列
	handlers: function( event, handlers ) {},
	
	// 封装jQuery.Event原始对象，修正event事件属性
	fix: function( event ) {},
	
	// 事件属性
	props: &quot;altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey &quot;
						+&quot;relatedTarget shiftKey target timeStamp view which&quot;.split(&quot; &quot;),
	
	fixHooks: {},
	
	keyHooks: {},
	
	mouseHooks: {},
	
	// 事件特例，如load、click、focus、blur、beforeunload等
	special: {},
	
	// 模拟事件触发
	simulate: function( type, elem, event, bubble ) {}
	
};

// jQuery事件对象，模拟实现部分W3C标准的DOM 3级别事件模型，统一了事件的属性
jQuery.Event = function( src, props ) {};

// jQuery事件对象原型
jQuery.Event.prototype = {
	// 是否已经阻止元素默认行为
	isDefaultPrevented: returnFalse,
	// 是否已经停止了事件传播
	isPropagationStopped: returnFalse,
	// 是否已经立即停止了事件传播
	isImmediatePropagationStopped: returnFalse,
	
	// 阻止元素的浏览器默认行为
	preventDefault: function() {},
	// 停止事件传播
	stopPropagation: function() {},
	// 立即停止事件传播
	stopImmediatePropagation: function() {}
};

// 如果不支持submit事件冒泡（IE），则submit事件委托
if ( !support.submitBubbles ) {};
// IE change事件委托，及checkbox/radio事件修正
if ( !support.changeBubbles ) {};
// 如果不支持focusin事件冒泡，则转为focus实现（focusin -&amp;gt; focus, focusout -&amp;gt; blur）
if ( !support.focusinBubbles ) {};

jQuery.fn.extend({
	// 完成一些参数调整，调用内部add方法完成事件绑定
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {},
	// 元素只能运行一次事件处理器函数
	one: function( types, selector, data, fn ) {},
	// 解除绑定：删除一个之前附加的事件句柄
	off: function( types, selector, fn ) {},
	// 执行事件处理函数和默认行为
	trigger: function( type, data ) {},
	
	// 执行事件处理函数，不执行默认行为，只触发匹配的第一个元素，不返回jQuery对象
	triggerHandler: function( type, data ) {}
});

jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
	&quot;change select submit keydown keypress keyup error contextmenu&quot;)
	.split(&quot; &quot;), function( i, name ) {

	// 处理事件绑定
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length &amp;gt; 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	// 便捷方法，在匹配的元素上绑定两个事件处理函数，
	// 鼠标移入时执行handlerIn，移出时执行handlerOut
	hover: function( fnOver, fnOut ) {},
	// 绑定
	bind: function( types, data, fn ) {},
	// 解绑定：删除一个之前附加的事件处理程序handler
	unbind: function( types, fn ) {},
	// 事件委托，调用on方法实现
	delegate: function( selector, types, data, fn ) {},
	// 删除事件委托，调用off实现
	undelegate: function( selector, types, fn ) {}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jQuery对事件的绑定和委托及接触是通过on和off方法来实现，而on和off方法则是通过调用jQuery.event的内部方法add来remove实现，而add和remove这是调用浏览器的原生事件addEventListener/removeEventListener或attachEvent/detachEvent来实现处理指定和删除事件处理程序，其实现的方向如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bind,delegate/unbind,undelegate -&amp;gt; on/off -&amp;gt; add/remove -&amp;gt; addEventListener,attachEvent/removeEventListener,detachEvent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一般情况下，jQuery中实现添加事件处理程序都是通过on或者事件特例（click，load，focus等）来实现的，相应的移除事件处理程序则是通过使用off方法来实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.bind( types,data, fn )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;.bind()&lt;/code&gt;方法用于直接附加一个事件处理程序到元素上。&lt;/p&gt;

&lt;p&gt;处理程序附加到jQuery对象中当前选中的元素，所以，在&lt;code class=&quot;highlighter-rouge&quot;&gt;.bind()&lt;/code&gt;绑定事件的时候，这些元素必须已经存在，很明显就是直接调用的,没利用委托机制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;.delegate( selector, types, data, fn )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;delegate事件委托其实质就是调用了on方法，将此方法的参数传递给on方法，让其代调用更具体的内部函数来实现事件委托，其源码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;delegate: function( selector, types, data, fn ) {
	return this.on( types, selector, data, fn );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由此可见，delegate就是调用了on方法，并将参数传递过去，自己本身并没有做任何的处理，因而可以变相的将dalegate视为on方法的别名。例如，将一个&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素的事件处理程序委托到祖先元素&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素上，html请参考上一篇开头的html文档&lt;a href=&quot;/blog/2014/08/19/jQuery-source-analysis-event(1).html&quot; title=&quot;jQuery源码解读[7] -- Event事件处理（1）&quot;&gt;Event事件处理（1）&lt;/a&gt;，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div').on('click', '.a', function(){
	alert('delegate by on()');
});

$('.div').delegate('.a', 'click', function(){
	alert('delegate by delegate()');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两种方法实现的功能都是一样的，将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素的click事件委托给&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素。&lt;/p&gt;

&lt;p&gt;任何时候只要有事件冒泡到&lt;code class=&quot;highlighter-rouge&quot;&gt;$('.div')&lt;/code&gt;上，它就查看该事件是否是click事件，以及该事件的目标元素是否与CCS选择器相匹配。如果两种检查的结果都为真的话，它就执行函数。&lt;/p&gt;

&lt;h3 id=&quot;2源码分析&quot;&gt;2、源码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;add( elem, types, handler, data, selector )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;elem：事件绑定的元素名称&lt;/p&gt;

&lt;p&gt;types：事件处理名称，如：click、bulr、mouseout等&lt;/p&gt;

&lt;p&gt;selector： 一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素&lt;/p&gt;

&lt;p&gt;data：当一个事件被触发时，要传递给事件处理函数的&lt;/p&gt;

&lt;p&gt;handler：事件被触发时，执行的函数&lt;/p&gt;

&lt;p&gt;其部分源码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add: function( elem, types, handler, data, selector ) {
	// ...
	
	// 尝试取出事件的namespace，如click.bbb.ccc中的bbb.ccc
    tmp = rtypenamespace.exec( types[t] ) || [];
    // 取出事件处理类型，如click
    type = origType = tmp[1];
    // 取出事件命名空间，如bbb.ccc，并根据&quot;.&quot;分隔成数组
    namespaces = ( tmp[2] || &quot;&quot; ).split( &quot;.&quot; ).sort();

    // 事件是否会改变当前状态，如果会则使用特殊事件
    special = jQuery.event.special[ type ] || {};

    // 根据是否已定义selector，决定使用哪个特殊事件api，如果没有非特殊事件，则用type
    type = ( selector ? special.delegateType : special.bindType ) || type;

    // 更具状态改变后的特殊事件
    special = jQuery.event.special[ type ] || {};

    // 组装用于特殊事件处理的对象
	handleObj = jQuery.extend({
			type: type,
			origType: origType,
			data: data,
			handler: handler,
			guid: handler.guid,
			selector: selector,
			needsContext: selector &amp;amp;&amp;amp; jQuery.expr.match.needsContext.test( selector ),
			namespace: namespaces.join(&quot;.&quot;)
		}, handleObjIn );
	
	// 第一次添加事件处理时，初始化事件处理函数队列
	if ( !(handlers = events[ type ]) ) {
		handlers = events[ type ] = [];
		handlers.delegateCount = 0;
		
		// 如果特殊事件处理程序函数返回false，使用addEventListener/attachEvent添加事件
		if ( !special.setup || special.setup.call( elem, data, namespaces, 
			eventHandle ) === false ) {
			// 为元素绑定全局事件处理函数
			if ( elem.addEventListener ) {
				elem.addEventListener( type, eventHandle, false );
			} else if ( elem.attachEvent ) {
				elem.attachEvent( &quot;on&quot; + type, eventHandle );
			}
		}
	}
	
	// 通过特殊事件add处理事件
    if ( special.add ) {
        // 添加事件
        special.add.call( elem, handleObj );
        // 设置处理函数的ID
        if ( !handleObj.handler.guid ) {
            handleObj.handler.guid = handler.guid;
        }
    }

    // 将事件处理函数推入处理列表
    if ( selector ) {
        handlers.splice( handlers.delegateCount++, 0, handleObj );
    } else {
        handlers.push( handleObj );
    }
		
	// ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从这里的源代码看，对于没有特殊事件特有监听方法和普通事件都用addEventListener来添加事件。而有特有监听方法的特殊事件，则调用相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;special.add.call&lt;/code&gt;来添加事件。总之而言，此方法是jQuery中为元素添加事件监听器的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;on( types, selector, data, fn, one )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;types：事件处理程序名称&lt;/p&gt;

&lt;p&gt;selector：一个选择器字符串，用于过滤出被选中的元素中能触发事件的后代元素&lt;/p&gt;

&lt;p&gt;data：当一个事件被触发时，要传递给事件处理函数的&lt;/p&gt;

&lt;p&gt;fn：事件触发时执行的程序&lt;/p&gt;

&lt;p&gt;one：近在内部使用，用于标识是否该事件只能被触发一次&lt;/p&gt;

&lt;p&gt;其源码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
	var type, origFn;

	// types可以是一个由types/handlers组成的map对象
	if ( typeof types === &quot;object&quot; ) {
		// 如果selector不是字符串
        // 则将传参由( types-Object, selector, data )变成( types-Object, data )
		if ( typeof selector !== &quot;string&quot; ) {
			data = data || selector;
			selector = undefined;
		}
		
		// 遍历所有types，递归调用将事件绑定到当前元素上
		for ( type in types ) {
			this.on( type, selector, data, types[ type ], one );
		}
		return this;
	}
	// 如果data为空，且fn为空
	if ( data == null &amp;amp;&amp;amp; fn == null ) {
		// 则传参由( types, selector )变成( types, fn )
		fn = selector;
		data = selector = undefined;

	// 否则如果只是fn为空
	} else if ( fn == null ) {
		// 且selector为字符串
		if ( typeof selector === &quot;string&quot; ) {

			// 则传参从( types, selector, data )变成( types, selector, fn )
			fn = data;
			data = undefined;
		} else {
			// 否则传参从( type, selector, data )变成( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	//如果fn为false则变成一个return false的函数
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		//如果fn现在还不存在，则直接return this
		return this;
	}

	if ( one === 1 ) {  // 如果one为1
		origFn = fn;  // 保存，并重定义fn
		fn = function( event ) {
			// 这个事件只触发一次，触发完成就用off取消掉
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};
		// 使用相同的ID，为了未来好删除事件
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	// 对所有用jQuery.event.add来添加事件
	return this.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面的代码可以看出，其实on()方法大部分的代码都是在模拟重载on()方法的重载，还有一小段代码提供了one()方法的实现，若为某个事件标识了one（即只会触发一次），那么在on()方法中就会备份别改写一个回调函数（事件触发时执行的函数），&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;origFn = fn;  // 保存，并重定义fn
fn = function( event ) {
	// 这个事件只触发一次，触发完成就用off取消掉
	jQuery().off( event );
	return origFn.apply( this, arguments );
};
// 使用相同的guid，为了未来好删除事件
fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过回调函数传递的事件对象参数，	使用off()方法将该触发事件取消绑定，达到不会在触发下一次，即仅触发了本次一次的目的，在改写的回调函数中，通过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;origFn.apply( this, arguments );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用未改写前的回调函数来实现触发后的事件处理，最后还讲副本及改写函数都设置一个统一的guid，以便未来好删除事件。&lt;/p&gt;

&lt;p&gt;而实际上on()方法最核心的代码其实就只有两行，就是最后两行代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;return this.each( function() {
	jQuery.event.add( this, types, fn, data, selector );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先此处的this是一个jQuery对象，引用的是希望被绑定事件的元素，就像&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div').on('click mouseleave', '.p', function(){....});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所示，当上面的代码运行到on()方法最后两行时，this指的就是&lt;code class=&quot;highlighter-rouge&quot;&gt;$('.div')&lt;/code&gt;所表示的jQuery对象。&lt;/p&gt;

&lt;p&gt;on()方法源码中，对当前jQuery对象调用each方法，调用&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.event&lt;/code&gt;的内部函数add()方法，为当前jQuery对象所包含的所有DOM元素添加事件。由此可以看出，这些源码中最最核心的还是add/remove方法，其它的各种样式的方法都在在这两个基础的方法上扩展实现的。&lt;/p&gt;

&lt;p&gt;相应的事件的触发，最核心的也是&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.event&lt;/code&gt;中的trigger()方法。&lt;/p&gt;

&lt;p&gt;从源码中可以看出，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;扩展到jQuery实例对象中的所有事件方法，都是通过直接调用on，off，trigger方法，间接调用add，remove，trigger，fix等一系列&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.event&lt;/code&gt;中的方法来实现实现的绑定、移除和触发的，当然前面也说过，最终将其添加到浏览器DOM上还是通过浏览器原生的addEventListener/attachEvent，removeEventListener/detachEvent来实现的。&lt;/p&gt;

&lt;p&gt;而jQuery中所做的就是在这些浏览器元素的添加事件监听方法的基础上，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.event&lt;/code&gt;对象，将原生的事件对象进行扩展与增强，然后实现功能更加强大的事件处理，最后将这些增强过后的事件处理接口（如：on, delegate, bind, off 等）扩展到jQuery实例对象中，暴露给用户使用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;简写绑定&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;前面说的都是一些标准的，通用的事件处理，下面我们来看一下一些简写的事件处理，就像如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div').click(function(){....});      or    $('.div').change(function(){....});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些方法不用通过on()方法，并为其传递事件处理类型名称，而是直接通过类型名称来创建事件处理，不需要在像下面这样创建事件处理，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div').on('change', function(){....});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相比之下，简写事件处理显得更加语意明确，书写简单，一看就能知道需要触发的条件是什么。其实现源代码如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.each( (&quot;blur focus focusin focusout load resize scroll unload click dblclick &quot; +
	&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; +
	&quot;change select submit keydown keypress keyup error contextmenu&quot;)
	.split(&quot; &quot;), function( i, name ) {

	// 处理事件绑定
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length &amp;gt; 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.split&lt;/code&gt;将所有的简写事件处理分为一个数组，然后使用&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.each&lt;/code&gt;遍历这些简写事件处理，通过&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.fn[ name ] = function( data, fn ) {
	return arguments.length &amp;gt; 0 ?
		this.on( name, null, data, fn ) :
		this.trigger( name );
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将其扩展到jQuery的实例对象当中去，万变不离其宗，虽然在创建事件处理的时候是通过这些简写事件名称来创建的，实际上这些事件的添加到元素、触发，还是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.event&lt;/code&gt;中基础的on()和trigger()方法来实现的。&lt;/p&gt;

&lt;h2 id=&quot;三示例&quot;&gt;三、示例&lt;/h2&gt;

&lt;p&gt;由于在前面一篇博文，介绍事件处理的一些概念的时候，已经应用了很多的示例，此处不在给出，如果需要查看，可以跳转！&lt;a href=&quot;/blog/2014/08/19/jQuery-source-analysis-event(1).html&quot; title=&quot;jQuery源码解读[7] -- Event事件处理（1）&quot;&gt;Event事件处理（1）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[7] -- Event事件处理（1）</title>
   <link href="http://www.blogways.net/blog/2014/08/19/jQuery-source-analysis-event(1).html"/>
   <updated>2014-08-19T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/19/jQuery-source-analysis-event(1)</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;h3 id=&quot;1事件传播&quot;&gt;1、事件传播&lt;/h3&gt;

&lt;p&gt;当页面上发生一个事件时，每个层次上的DOM元素都有机会处理借个时间，如一下html为例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class='div'&amp;gt;&amp;amp;lt;div&amp;amp;gt;
	&amp;lt;span class='span'&amp;gt;&amp;amp;lt;span&amp;amp;gt;
        	&amp;lt;a class='a'&amp;gt;&amp;amp;lt;a&amp;amp;gt;&amp;lt;/a&amp;gt;
    	&amp;lt;/span&amp;gt;
    	&amp;lt;p class='p'&amp;gt;&amp;amp;lt;p&amp;amp;gt;&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当使用图形表示上面的html，其结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/div.png&quot; alt=&quot;对应的html图形化结构图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从上面可以看出，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素位于&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;及更外层的元素内，那么在鼠标单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素所在的区域时，明显可以看出同时也单击了其所有的父辈元素，如span、div等。也就是说，在鼠标点击内部元素时，内部元素所有的直接父辈元素也应该能获得响应这次单击的机会。&lt;/p&gt;

&lt;p&gt;允许多个元素响应单击事件的策略叫做&lt;strong&gt;&lt;em&gt;事件捕获&lt;/em&gt;&lt;/strong&gt;，在事件捕获的工程中，最外层元素最先获得事件，然后向内将事件交给范围更小一级的可以捕获当前事件的元素，例如当点击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，其捕获过程如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;document -&amp;gt; 外层元素 -&amp;gt; div -&amp;gt; span -&amp;gt; a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里的外层元素就是div元素的所有直接父辈元素，值得注意的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;是所有DOM元素的父辈，即无论任何事件在捕获过程中，事件首先会交给&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，然后在向跟具体的触发事件元素传递。&lt;/p&gt;

&lt;p&gt;两外一种相反的策略叫做&lt;strong&gt;&lt;em&gt;事件冒泡&lt;/em&gt;&lt;/strong&gt;，即当事件发生时，会首先将事件传递给最具体的元素，此处为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素，然后在逐级向外传递事件，直到停止事件传播或传递到了&lt;code class=&quot;highlighter-rouge&quot;&gt;document&lt;/code&gt;，理出当点击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，其冒泡过程如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;a -&amp;gt; span -&amp;gt; div -&amp;gt; 外层元素 -&amp;gt; document
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于不同的浏览器采用的不同的事件策略，因此在DOM标准规定了同事使用两种策略：首先，事件从一般元素到具体元素逐层&lt;strong&gt;捕获&lt;/strong&gt;，然后，事件再通过&lt;strong&gt;冒泡&lt;/strong&gt;返回DOM树的顶层，事件处理程序可以注册到这个过程中的任何一个阶段，而jQuery中，如无特殊说明，默认将处理程序注册到&lt;strong&gt;冒泡&lt;/strong&gt;阶段。&lt;/p&gt;

&lt;p&gt;虽然默认是将处理程序注册到&lt;strong&gt;冒泡&lt;/strong&gt;阶段，但是事件冒泡可能会导致一些无法预料的问题，例如当我们为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素添加一个mouseout时间处理程序，当用户鼠标退出&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素时，会按照预期的一样触发事件处理程序，因为事件处理程序和触发事件元素都为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;所以不会有其他元素响应这个事件，但是当用户鼠标指针在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素内移动到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素外时，会触发一个mouseout事件，然后向外传递到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;时，会触发为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素指定的事件处理程序，这种结果显然不是所期望的。&lt;/p&gt;

&lt;h3 id=&quot;2事件对象&quot;&gt;2、事件对象&lt;/h3&gt;

&lt;p&gt;要解决前面所说的事件&lt;strong&gt;冒泡&lt;/strong&gt;所产生的问题，就需要说到事件对象了，事件对象是一种DOM结构，它会在元素获得处理事件的机会时传递给被调用的事件的处理程序，就拿前面的例子来说，当&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素触发mouseout事件并冒泡到&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素时，event对象对传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素上mouseout事件处理程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;event.target属性&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery中，扩展了事件对象中的event.target属性（保存着发生事件的目标元素），使其在所有的浏览器中都能够是用这个属性，通过event.target，可以确定DOM中首先接收到事件的元素（即实际被单击的元素），而在事件处理程序中的this指针，是对处理事件的DOM元素的引用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function(){
	$('.div').on( 'mouseout', function(event){
		if( event.target == this ){
			alert('mouseout div');
		}
	});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码就是利用了enevt事件对象，很好的解决了前面所说的mouseout事件在冒泡阶段会导致的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;event.stopPropagation()方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;同时事件对象还提供了一个.stopPropagation()方法，用于完全阻止事件冒泡，与target类似，这个方法也是DOM标准的基本方法，但是在IE8及更早版本中无法使用，而在jQuery中扩展了这个方法，可以放心的使用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function(){
	$('.div').click(function(){
   		alert('div click');
	});
	$('.span').click(function(){
    	alert('span click');
	});
	$('.a').click(function(event){
    	alert('a click');
   		event.stopPropagation();
	});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;同时添加单击事件分别显示消息，同时在&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素内调用&lt;code class=&quot;highlighter-rouge&quot;&gt;event.stopPropagation();&lt;/code&gt;，执行上面代码，当单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素时，会弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;span click&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;div click&lt;/code&gt;，但是在单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，只会弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;a click&lt;/code&gt;，由此可见stopPropagation方法成功阻止了事件的冒泡，事件处理程序只会被当前元素中执行，且事件不会继续冒泡，那么其它元素也就不会再触发此事件处理程序了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;event.preventDefault()方法&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多元素都会有默认的事件触发动作，例如：当点击一个&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;a&amp;gt;&lt;/code&gt;元素时，会默认跳转到指定了连接；当单击表单中的submit按钮，会默认提交当前表单。在实际操作中，我们可能会需要验证某些信息，而不希望这些元素执行默认操作，通常我们的做法是在JavaScript代码中&lt;code class=&quot;highlighter-rouge&quot;&gt;return false;&lt;/code&gt;，返回false这种做法实际上就是组合使用了.stopPropagation和.preventDefault()，阻止事件传播，阻止元素默认触发动作。&lt;/p&gt;

&lt;h3 id=&quot;3事件委托&quot;&gt;3、事件委托&lt;/h3&gt;

&lt;p&gt;事件冒泡虽然可能会导致一些问题，但是也为我们带来了很多的好处，而&lt;strong&gt;事件委托&lt;/strong&gt;就是利用冒泡策略来实现的，顾名思义，事件委托就是将事件处理程序委托给其它元素，让其代为处理某些元素的事件处理，当然此处的&lt;em&gt;其它元素&lt;/em&gt;是指其所有直接父辈元素。&lt;/p&gt;

&lt;p&gt;一种委托方式是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;event.target&lt;/code&gt;来判断是否触发特定元素的委托事件，例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function(){
	$('.div').click(function(event){
		if($(event.target).is('.p')){
			alert('delegate p to div')
		} else {
			alert('div click');
		}
	});
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上代码所示，鼠标点击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素会弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate p to div&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素的事件处理程序委托给了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，当用户单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，本身并无事件处理程序，因此向外冒泡，触发&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;的父元素&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素的事件处理程序，其中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;event.target&lt;/code&gt;判断目标元素是&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素，因而调用相应的事件处理，弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;dalegate p to div&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;首先要说明的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;event.target&lt;/code&gt;引用的是触发事件元素的html文档，而不是一个jQuery对象，可以在传递了事件对象的处理程序中通过如下代码显示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;console.log( event.target );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当单击了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素时，输出结果如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/eventtarget.png&quot; alt=&quot;span的event.target&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因而使用&lt;code class=&quot;highlighter-rouge&quot;&gt;$(html标签)&lt;/code&gt;创建一个对应html标签的jQuery对象，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;is()&lt;/code&gt;选中元素是否是希望的元素，如果是则执行委托事件处理，否则就执行其默认处理。&lt;/p&gt;

&lt;p&gt;而另一种事件委托方式，就是通过jQuery内置的事件委托，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.div').on( 'click mouseleave', '.p', function(event){
	if( event.type == 'click' ){
		alert('delegate p\'s click to div');
	} else if(event.type == 'mouseleave' ){
		alert('delegate p\'s mouseleave to div');
	}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码所示，将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素的click和mouseleave事件委托给了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素，当单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，会弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate p's click to div&lt;/code&gt;，相应的当鼠标离开&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素区域时，会弹出&lt;code class=&quot;highlighter-rouge&quot;&gt;delegate p's mouseleave to div&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;由上面可知，可以将某元素的事件处理程序委托给其所有直接父辈元素中的某一个元素，即冒泡阶段中，某元素之后的任何事件传递元素，而document作为所有页面元素的祖先元素，将事件委托给document很方便，但是也可能因为DOM嵌套层数太多，事件冒泡阶段的传递较多，导致事件处理效率不高，所以应该尽可能选择具体的委托元素，以减少不必要的开销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;早委托&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果我们需要在某个页面中，处理某个链接的单击事件，并阻止其默认事件（即，单击立即跳转到相应的链接），如果我们等到文档就绪之后在为其绑定单击事件，那么可能在绑定事件处理程序之前，该链接已经被点击，然后跳转到另一个页面了。把事件处理程序绑定到document上，不再等到加载完整的DOM结构之前就运行，即将事件委托作为一个IIFE放入&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;head&amp;gt;&lt;/code&gt;中，一旦加载玩绑定函数立即绑定，那么后面加载html内容时，单击触发的所有事件都会冒泡到document元素，执行相应的功能，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(function($){
	$(document).on( 'click mouseleave', '.a', function(event){
		alert('a click');
		event.preventDefault;
	});
})(jQuery);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;3自定义事件&quot;&gt;3、自定义事件&lt;/h3&gt;

&lt;p&gt;由浏览器的DOM实现自然触发的事件对任何WEB应用来说都是至关重要的，但是jQuery代码不没有局限于此，jQuery中支持对事件的自定义，即我们可以手动为DOM元素添加一些&lt;strong&gt;&lt;em&gt;自定义事件&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;由于是自定义事件，因而其触发必须是手动的方式来触发，其应用方式就像函数的定义与调用一样，自定义事件就像创建一个完成某项功能的的函数，在需要完成某个功能时，通过触发方式来触发自定义事件，就像调用函数一样，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function(){
	$(document).on( 'AlertHello', function(event){
		alert('Hello World!');
	} );
	
	$('.p').click(function(){
		$(this).trigger('AlertHello');
	});
}); 当点击`&amp;lt;p&amp;gt;`元素时，成功弹出`Hello World!`，当然也可以对自定义事件传递自定义参数，如：

$(document).on( 'AlertStr', function( event, str ){
	var s = str || &quot;Hello World!&quot;;
	alert(s);
}

$('.p').click(function(){
		$(this).trigger( 'AlertStr', 'jQuery');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而此时单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，如你所想的，弹出的是&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;4移除事件处理程序&quot;&gt;4、移除事件处理程序&lt;/h3&gt;

&lt;p&gt;有绑定事件处理程序，当然也有移除绑定，在jQuery中，移除事件处理程序通常是用.off()方法来实现，如移除&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素的单击事件，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.span').click(function(){
    	alert('span click');
});

$('.span').off('click');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素时，不会弹出任何警示框了，开始为其绑定了一个单击事件，然后移除了单击事件click的事件处理程序，之后单击都不会弹出提示。&lt;/p&gt;

&lt;p&gt;当然此处通过代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('.span').off('click');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是将&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素的所有单击事件都移除，言外一致就是只要是click事件的处理程序就被移除，不在响应click事件，而现实中我们通常只是希望移除某个或某些特定的事件，这就要用到事件处理的命名空间了。&lt;/p&gt;

&lt;p&gt;通过命名空间可以让.off()方法更具有针对性，避免移除仍需要的事件处理程序，而事件处理的命名空间，事件绑定事件处理程序的时候，附带传入的信息，用以表示一个或者一类的事件处理程序，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).ready(function(){
	$('.p').on( 'click.alerthello', function(){
		alert('Hello!');
	});
	$('.p').on( 'click.alerthello', function(){
		alert('Hello World!');
	});
	$('.p').on( 'click.alertjquery', function(){
		alert('Hello jQuery!');
	});
	
	$('.p').off('click.alerthello');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;单击&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素时，只弹出警示框显示&lt;code class=&quot;highlighter-rouge&quot;&gt;Hello jQuery!&lt;/code&gt;，而另外两个没有显示，说明成功移除了click单击事件中，&lt;code class=&quot;highlighter-rouge&quot;&gt;alerthello&lt;/code&gt;命名空间下所有的事件处理程序，而&lt;code class=&quot;highlighter-rouge&quot;&gt;alertjquery&lt;/code&gt;命名空间下的事件处理程序仍然保留。&lt;/p&gt;

&lt;h3 id=&quot;5dom2级及ie-事件处理程序&quot;&gt;5、DOM2级及IE 事件处理程序&lt;/h3&gt;

&lt;p&gt;DOM2级事件定义了两个方法，addEventListener()和removeEventListener()，用于处理指定和删除事件处理程序操作，这两个方法接收三个参数：事件处理程序名称、事件处理程序函数和一个布尔值（用于表示是否在捕获阶段调用事件处理程序，默认值为false，即在冒泡阶段调用事件处理程序）。&lt;/p&gt;

&lt;p&gt;IE中实现了与DOM中类似的两个方法：attachEvent()和detachEvent()，由于IE8及更早版本只支持冒泡阶段，因而这两个方法只接收两个参数：事件处理程序名称和事件处理程序函数。&lt;/p&gt;

&lt;p&gt;jQuery中的为DOM元素添加和删除事件处理程序中，最底层的操作也是通过这四个方法来实现的，实现了对IE及其它浏览器的事件处理程序的兼容。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;addEventListener( type, listener, capture )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;type 事件处理程序类型，即要监听的事件名称，例如click mouseout mouseleave等；&lt;/li&gt;
  &lt;li&gt;listener 事件处理程序的具体实现函数，当规定的事件发生时，执行该函数；&lt;/li&gt;
  &lt;li&gt;capture 如果为true，表示在事件捕获阶段调用事件处理程序。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;addEventListener()可能被调用多次，在同一个节点上为同一种类型的事件注册多个事件句柄。但要注意，DOM不能确定多个事件句柄被调用的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;removeEventListener( type, listener, capture )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;type 要删除事件处理程序的类型&lt;/li&gt;
  &lt;li&gt;listener 要删除的事件程序的函数&lt;/li&gt;
  &lt;li&gt;capture 如果要删除是捕获阶段的事件处理程序，则为true；如果要删除的是冒泡阶段的事件处理程序，则为false&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;attachEvent( type, listener )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;type 事件处理程序名称，带有一个“on”前缀，例如onclick onmouseout onmouseleave等；&lt;/li&gt;
  &lt;li&gt;listener 事件处理程序的具体实现函数，当规定的事件发生时，执行该函数；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法是一个特定与IE的事件注册方法。它和标准的addEventListener()方法（IE不支持它）具有相同的作用，只是两者传递的参数不同，而且IE中不支持&lt;strong&gt;&lt;em&gt;事件捕获&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;detachEvent( type, listener )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;type 要删除的事件监听器所针对的事件的类型，带有一个on前缀。&lt;/li&gt;
  &lt;li&gt;listener 要删除事件处理程序函数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个方法解除掉由attachEvent()方法所执行的事件句柄函数注册。它是removeEventListener()方法的特定与IE的替代。要为一个元素删除一个事件函数句柄，只需要使用你最初传递attachEvent()的相同参数来调用detachEvent()。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[6] -- Queue队列</title>
   <link href="http://www.blogways.net/blog/2014/08/15/jQuery-source-analysis-queue.html"/>
   <updated>2014-08-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/15/jQuery-source-analysis-queue</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;队列是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头.最先插入在元素将是最先被删除；反之最后插入的元素将最后被删除，因此队列又称为“&lt;strong&gt;&lt;em&gt;先进先出FIFO&lt;/em&gt;&lt;/strong&gt;”（First In First Out）的线性表。&lt;/p&gt;

&lt;p&gt;jQuery提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.queue/dequeue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.queue/dequeue&lt;/code&gt;，实现对队列的入队、出队操作,不同于队列定义的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.queue&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.queue&lt;/code&gt;不仅执行出队操作，返回队头元素，还会自动执行返回的队头元素。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;有一点要注意的是，在jQuery中，队列Queue只应用于动画模块！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;二源码分析&quot;&gt;二、源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1函数原型介绍&quot;&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;jQuery中，队列的实际实现方式很简单，代码量也不是很大，总共就70~80行代码左右，直接通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;分别将其实现扩展到jQuery的全局对象和实例对象中去，其函数原型，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery.extend扩展全局对象：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend({
	
	queue: function( elem, type, data ) {},
	
	dequeue: function( elem, type ) {},
	
	_queueHooks: function( elem, type ) {}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery.fn.extend扩展实例对象：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.fn.extend({

	queue: function( type, data ) {},
	
	dequeue: function( type ) {},
	
	clearQueue: function( type ) {},
	
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	// 当队列中指定类型的函数执行完毕后，（fx是默认的类型）
	// 返回一个解决延迟对象并完成回调函数后的promise对象，
	promise: function( type, obj ) {}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面的代码原型可以看出，全局对象对外提供了两个API：&lt;code class=&quot;highlighter-rouge&quot;&gt;queue/dequeue&lt;/code&gt;，这两个方法有两个作用，它们既是setter，又是getter，实例对象提供了四个API:&lt;code class=&quot;highlighter-rouge&quot;&gt;queue、dequeue、clearQueue、promise&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其中实例对象的方法都是在调用全局对象的queue/dequeue方法的基础上实现的。而&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;中扩展了promise方法，实现了对延迟对象的支持，通过在promise中创建一个Deferred实例，修改相应的方法并返回承诺（promise）。&lt;/p&gt;

&lt;h3 id=&quot;2jqueryqueuejquerydequeue-源码分析&quot;&gt;2、jQuery.queue、jQuery.dequeue 源码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;queue( elem, type, data )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其源码，如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;queue: function( elem, type, data ) {
	var queue;

	if ( elem ) { 	// elem必须存在，不然将没有含义
		// 改名，每个都要加上queue，用以标识不同的队列
		type = ( type || &quot;fx&quot; ) + &quot;queue&quot;;
		// 取出缓存数据，即缓存队列
		queue = jQuery._data( elem, type );

		// 如果data存在，才会进行后边转换数组、入队等操作，可以加速取出整个队列
		// 如果data不存在，直接跳到执行return queue || []，
		// 就相当于一个getter方法
		if ( data ) {
			// 如果队列不存在，或者队列存在且data是一个数组
			if ( !queue || jQuery.isArray(data) ) {
				// 通过创建新的数组来实现队列
				queue = jQuery._data( elem, type, jQuery.makeArray(data) );
			} else {
				// 如果队列存在，这直接将传递的数据加入队列
				// queue实际是一个数组
				queue.push( data );
			}
		}
		
		// 返回队列（即入队的同时，返回整个队列）
       	// 简洁实用的避免空引用的技巧
       	// 当queue存在时，直接返回queue，否则返回[]
		return queue || [];
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个参数elem是DOM元素，第二个参数type是字符串，第三个参数data可以是function或数组。前提提过它既是setter，有事getter，&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当传递三个参数的时候（ elem，type，data ），它就是一个setter，将传递过来的数据加到队列；&lt;/li&gt;
  &lt;li&gt;当传递两个参数的时候（ elem，type ），他就是一个getter，将type所指定的队列数据返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从中可以看出，队列Queue中的数据是通过缓存数据Cache来实现的，而在实现时，调用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery._data( elem, type, data )&lt;/code&gt;来创建缓存数据Cache，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery._data( elem, type )&lt;/code&gt;来返回/读取缓存的数据，当queue存在，直接调用&lt;code class=&quot;highlighter-rouge&quot;&gt;queue.push( data )&lt;/code&gt;将数据data加入队列。&lt;/p&gt;

&lt;p&gt;由&lt;code class=&quot;highlighter-rouge&quot;&gt;type ＝ ( type || &quot;fx&quot; ) + &quot;queue&quot;;&lt;/code&gt;可见，队列Queue在jQuery中是专职处理fx动画的。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;dequeue( elem, type )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;匹配的元素上执行队列中的下一个函数，其源码，如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 出队并执行
// 调用jQuery.queue取得整个队列，在调用shift取出第一个元素
dequeue: function( elem, type ) {
	type = type || &quot;fx&quot;;
	
	var queue = jQuery.queue( elem, type ), // 取得队列
		startLength = queue.length,
		fn = queue.shift(), 	// 取出队列中的第一个元素
		hooks = jQuery._queueHooks( elem, type ),
		next = function() {
			jQuery.dequeue( elem, type );
		};

	// 如果取出的fn是一个正在执行中标准动画fx，抛弃执行哨兵（inprogress），再取一个
	if ( fn === &quot;inprogress&quot; ) {
		fn = queue.shift();
		startLength--;
	}

	if ( fn ) {
		// 如果是标准动画，则在队列头部增加处理中标记属性，阻止fx自动处理
		if ( type === &quot;fx&quot; ) {
			// 在队列头部增加inprogress标记
			queue.unshift( &quot;inprogress&quot; );
		}

		// clear up the last queue stop function
		delete hooks.stop;
		// 执行取出的fn，并传入回调函数jQuery.dequeue
       	// 可以看到fn必须是函数，否则会出错
		fn.call( elem, next, hooks );
	}
	
	// 此时的队列成为空队列，实质是一个空数组，
	if ( !startLength &amp;amp;&amp;amp; hooks ) {
		// 调用队列里面的hooks（通过jQuery._removeData）
		// 删除type对应的空数组，完成队列数据的清理工作
		hooks.empty.fire();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;源码中先从缓存Cache中取出队列数据，再判断队列的长度，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;queue.shift();&lt;/code&gt;从队列中取出队头元素，然后做好一个预处理生成下一个的next，经判断修改最后调用相应的&lt;code class=&quot;highlighter-rouge&quot;&gt;.call()&lt;/code&gt;方法执行对头函数，在队列中所有Callbacks都执行完毕后，即&lt;code class=&quot;highlighter-rouge&quot;&gt;!startLength&lt;/code&gt;为真时，调用hooks完成清理工作中。&lt;/p&gt;

&lt;h2 id=&quot;三示例&quot;&gt;三、示例&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function fn1(){
	alert('test 1');
};
function fn2(){
	alert('test 2');
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;queue( elem, type, data )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// set
var vbody = $('body');

$.queue( vbody, 'test', fn1 );
$.queue( vbody, 'test', fn2 );

// get
var q = $.queue( vbody, 'test' );
console.log( q );  // 输出[function, function] 在Chrome的JavaScript控制台中显示，如下图所示：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/queue_get.png&quot; alt=&quot;Queue get&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面是将elem当作一个参数传递给queue，其实还可以不用这样写，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('body').queue( 'test', fn1 );
$('body').queue( 'test', fn2 );

$('body').queue( 'test' );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种写法跟是那个面显示设置elem，所实现的功能是完全一样的!&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;dequeue( elem, type)&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.dequeue( vbody, 'test' ); 	// test 1
$.dequeue( vbody, 'test' ); 	// test 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而在实际的应用当中，我们不可能为队列中每个元素进行手动的通过dequeue来调用，前面介绍dequeue的时候说过，&lt;strong&gt;做好一个预处理生成下一个的next&lt;/strong&gt;，next方法可以让队列中中断的地方连续起来执行，不需要在手动的去允许，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function fn3( next ){
	alert('test 3');
	next();
};

$.queue( vbody, 'test', fn3 );
$.queue( vbody, 'test', fn2 );

$.dequeue( vbody, 'test' ); 	// test 3  , test 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;像上面这样，只要在传入的函数的参数当中，增加一个next方法变量，然后在当前函数功能执行完成后，调用next方法，队列动画就会继续向后面进行，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var $div = $('div.testqueue');

$div.css({postition: 'relative'})
	.fadeTo('fast', 0.5)
	.fadeTo('slow', 1.0)
	.slideUp('slow')
	.queue(function(next){
		$div.css({background: '#f00'});
		next();
	})
	.slideDown('slow');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;像上面这样传递一个回调函数，&lt;code class=&quot;highlighter-rouge&quot;&gt;.queue()&lt;/code&gt;方法会把该函数添加到相应元素的效果队列当中，在这个回调函数当中，改变了相应元素的背景颜色，然后调用next继续执行下面的动画，将在队列中中断的地方连接起来，如果此处不调用next方法，这动画会在此处中断，有兴趣的话可以自己去尝试一下。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[5] -- Cache数据缓存</title>
   <link href="http://www.blogways.net/blog/2014/08/14/jQuery-source-analysis-cache.html"/>
   <updated>2014-08-14T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/14/jQuery-source-analysis-cache</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;Cache数据缓存系统现在广泛应用于DOM元素、动画、事件等方面，消除了将动画队列都存储到各DOM元素的自定义属性中所带来的隐患，另外如果给DOM元素添加过多的自定义的属性或数据可能会引起内存泄漏，其实质是使用了一种&lt;strong&gt;&lt;em&gt;低耦合的方式&lt;/em&gt;&lt;/strong&gt;将DOM和缓存数据联系起来。&lt;/p&gt;

&lt;p&gt;说到内存泄漏，相信大家都不会陌生，那么内存泄漏的定义是什么呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内存泄漏也称作“存储渗漏”，用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元，直到程序结束（其实说白了就是该内存空间使用完毕之后未回收）即所谓内存泄漏；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;内存泄漏形象的比喻是“操作系统可提供给所有进程的存储空间正在被某个进程榨干”，最终结果是程序运行时间越长，占用存储空间越来越多，最终用尽全部存储空间，整个系统崩溃。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;中，内存的分配和回收都是手动完成的，因而内存泄漏是经常发生的事情，而&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;使用的是一种称为&lt;strong&gt;&lt;em&gt;垃圾收集&lt;/em&gt;&lt;/strong&gt;的技术来管理分配给它的内存，当&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;代码生成一个需要使用新内存的项（如：创建一个对象或一个函数）时，系统就会为这个项留出一块内存空间。因为此对象或函数会被进行各种传递或引用，所以很多代码都会指向这块内存空间，&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;会跟踪这些对内存空间的引用，当某块内存空间没有再被任何其他代码引用时，这个对象占用的内存就会被释放。&lt;/p&gt;

&lt;p&gt;但是由于浏览器的差异，这些&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;的自动垃圾回收方法的实现并不一样，而且回收方法可能还存在着BUG，因而还是会导致内存泄露，&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;中会导致内存泄露的情况：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 循环引用
 2. `JavaScript`闭包
 3. DOM插入顺序
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;循环引用，两个或两个以上的对象或方法相互之间引用，形成一个&lt;strong&gt;&lt;em&gt;闭合环状引用&lt;/em&gt;&lt;/strong&gt;，则会导致内存泄露，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var A = document.getElementById('mImage'),
	 B = new Object();			or			A.relative = A;
 A.relative = B;
 B.relative = A;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二源码分析&quot;&gt;二、源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1函数原型介绍&quot;&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;首先，在&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;源码中，一条不变的实现方式就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;将Cache功能扩展给&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在扩展Cache功能的时候，其代码量并不多，实际的功能实现都是通过调用内部的私有函数来实现的，下面看下这些私有函数及扩展功能函数的函数原型：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 用来判断该元素是否能接受数据，返回true或false
jQuery.acceptData = function( elem ) {};

// 支持HTML5的data-属性
// 如果在指定元素elem没有找到key对应的数据data，就尝试读取HTML5的data属性
function dataAttr( elem, key, data ) {};

// 检测一个Cache对象是否为空
function isEmptyDataObject( obj ) {};

// jQuery内部实现Cache实际函数，存储缓存数据
function internalData( elem, name, data, pvt /* Internal Use Only */ ) {};
function internalRemoveData( elem, name, pvt ) {};   // 移除缓存数据

jQuery.extend({ 	// 扩展jQuery全局对象
	cache: {}, 	// 缓存对象，用于保存缓存数据

	// 如果你试图对下面的元素添加expando属性，
	// 它们会抛出不可捕捉的异常
	// 意思就是，以下元素没有Data：embed和applet，除了Flash之外的object
	noData: {
		&quot;applet &quot;: true,
		&quot;embed &quot;: true,
		&quot;object &quot;: &quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot;
	},
	
	// 用来判断HTMLElement或JS对象是否具有数据。返回true或false。
	// 即，如果调用了jQuery.data方法添加了属性，则返回true。
	hasData: function( elem ) {},

	// jQuery对外的缓存数据接口，用于存储数据
	data: function( elem, name, data ) {
		return internalData( elem, name, data );
	},
	// jQuery对外的缓存数据接口，用于删除数据
	removeData: function( elem, name ) {
		return internalRemoveData( elem, name );
	},

	// 私有函数，仅在内部使用
	_data: function( elem, name, data ) {
		return internalData( elem, name, data, true );
	},
	// 私有函数
	_removeData: function( elem, name ) {
		return internalRemoveData( elem, name, true );
	}
});

jQuery.fn.extend({ 	// 扩展jQuery实例对象
	// 在匹配的元素上存储任意数据，解决了循环引用和内存泄漏
	data: function( key, value ) {},
	
	// 在匹配的元素上移除给定key值的数据
	removeData: function( key ) {}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2internaldatainternalremovedata源码分析&quot;&gt;2、internalData、internalRemoveData源码分析&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$internalData( elem, name, data, pvt )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其源码，如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function internalData( elem, name, data, pvt /* Internal Use Only */ ) {
	if ( !jQuery.acceptData( elem ) ) {
		 // 是否可以附加数据，不可以则直接返回
		return;
	}

	var ret, thisCache,
		internalKey = jQuery.expando,

	// 必须区分处理DOM元素和JS对象，
	// IE6-7不能垃圾回收对象跨DOM对象和JS对象进行的引用属性
	isNode = elem.nodeType,

	// 如果是DOM元素，则使用全局的jQuery.Cache
    // 如果是JS对象，则直接附加到实例对象上
	cache = isNode ? jQuery.cache : elem,

	// Only defining an ID for JS objects if its cache already exists allows
	// the code to shortcut on the same path as a DOM node with no cache
	// 如果JS对象的cache已经存在，则需要为JS对象定义一个ID
    // 如果是DOM元素，则直接通过elem[ internalKey ]返回id，
    // 如果是JS对象，且JS对象的属性internalKey存在，返回internalKey 
	id = isNode ? elem[ internalKey ] : elem[ internalKey ] &amp;amp;&amp;amp; internalKey;

	// 尝试在一个没有任何数据的对象上获取数据时，避免做更多的不必要工作
	if ( (!id || !cache[id] || (!pvt &amp;amp;&amp;amp; !cache[id].data)) 
				&amp;amp;&amp;amp; data === undefined &amp;amp;&amp;amp; typeof name === &quot;string&quot; ) {
		return;
	}

	if ( !id ) {
		// 只有DOM节点需要一个唯一的ID，因为DOM元素的数据存储在全局的cache中
		if ( isNode ) {
			id = elem[ internalKey ] = deletedIds.pop() || jQuery.guid++;
		} else {
			id = internalKey;
		}
	}
	
	if ( !cache[ id ] ) {
		// 当对象使用JSON.stringify被序列化时，避免将jQuery元数据暴露在一个纯JS对象上
		cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };
	}

	// 可以为jQuery.data传递一个对象或函数作为参数，而不必须是key/value的方式
	// 将参数浅拷贝到存在的缓存数据中
	if ( typeof name === &quot;object&quot; || typeof name === &quot;function&quot; ) {
		if ( pvt ) {
			cache[ id ] = jQuery.extend( cache[ id ], name );
		} else {
			cache[ id ].data = jQuery.extend( cache[ id ].data, name );
		}
	}

	thisCache = cache[ id ];
	
	// jQuery内部数据存在一个独立的对象（thisCache[ internalKey ]）上，
	// 是为了避免内部数据和用户定义数据冲突
   	// 如果是私有数据
	if ( !pvt ) {
		if ( !thisCache.data ) {
			thisCache.data = {}; 	// 存放私有数据的对象不存在，则创建一个{}
		}

		thisCache = thisCache.data; 	// 使用私有数据对象替换thisCache
	}

	// 如果data不是undefined，表示传入了data参数，则存储data到name属性上
	if ( data !== undefined ) {
		thisCache[ jQuery.camelCase( name ) ] = data;
	}

	// 如果一个数据属性是被限定的，
	// 则检测转换为驼峰表示法和未转换的数据属性的name
	if ( typeof name === &quot;string&quot; ) {

		// 首先尝试找到as-is属性数据
		ret = thisCache[ name ];

		// 如果ret为null或者undefined，尝试没有或者违背定义属性数据
		if ( ret == null ) {

			// 尝试找到骆驼拼写法属性（因为有可能之前name被驼峰化了）
			ret = thisCache[ jQuery.camelCase( name ) ];
		}
	} else {
		ret = thisCache;
	}

	return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在源码中很多地方都出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;expando&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.expando&lt;/code&gt;，那到底它们是何方神圣？首先看一下&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.expando&lt;/code&gt;的源码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend({
	// 为了区别不同的jQuery实例存储的数据，使用前缀“jQuery”+jQuery版本号+随机数作为Key
	expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),
	
	// other code
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.expando&lt;/code&gt;实际上是一个字符串，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Math.random()&lt;/code&gt;生成，去掉了非数字字符，它作为HTMLElement或JavaScript对象的属性名，用以标识不同的HTML元素和JavaScript对象。&lt;/p&gt;

&lt;p&gt;前面提过，&lt;code class=&quot;highlighter-rouge&quot;&gt;internalData( elem, name, data, pvt )&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;中实际实现存储缓存数据的方法，每次调用（插入一个缓存数据）都会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.expando&lt;/code&gt;来生成一个key值，用以给插入的数据做一个标识，以便以后通过key值来访问，而在此方法中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;internalKey = jQuery.expando;&lt;/code&gt;，将key值保存在internalKey中用以内部使用。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;internalRemoveData( elem, name, pvt )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;其源代码，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function internalRemoveData( elem, name, pvt ) {
	var thisCache, i,
		isNode = elem.nodeType,
		cache = isNode ? jQuery.cache : elem,
		id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

	// 缓存数据中没有指定要删除的数据，直接return
	if ( !cache[ id ] ) {	return;	  }
		
	if ( name ) {
		// 取得实际要操作的缓存数据
		thisCache = pvt ? cache[ id ] : cache[ id ].data;
		if ( thisCache ) {

			// Support array or space separated string names for data keys
			// 支持数组或空格分割的字符串name作为数据的键值
			if ( !jQuery.isArray( name ) ) {
				// 在进行任何操作之前，尝试将整个字符串作为一个键值
				if ( name in thisCache ) {
					name = [ name ];
				} else {

					// split the camel cased version by spaces 
					// unless a key with the spaces exists
					// 将name转换为骆驼表示法
					name = jQuery.camelCase( name );
					// 判断尝试转换后的name是否在缓存数据中
					if ( name in thisCache ) {
						name = [ name ]; 	// 在，
					} else {
						name = name.split(&quot; &quot;);  // 不在，则将其用空格符分割
					}
				}
			} else {
				
				// 如果“name”是一个key值的数组，
				// 当数据最初被创建时，通过 (&quot;key&quot;, &quot;val&quot;) 签名，
				// key值将会通过jQuery.map()被转换为骆驼表示法。
				// 由于没办法 告知 key是如何被添加，原始的和骆驼表示法的key值将会被移除
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path. 
				name = name.concat( jQuery.map( name, jQuery.camelCase ) );
			}

			i = name.length;
			while ( i-- ) {
				delete thisCache[ name[i] ];
			}

			// 如果当前缓存中的数据被全部删除，				直接返回return
			if ( pvt ? !isEmptyDataObject(thisCache) 
								: !jQuery.isEmptyObject(thisCache) ) {
				return;
			}
		}
	}

	if ( !pvt ) {
		delete cache[ id ].data;

		// 不销毁父缓存，除非在缓存中之剩下内部数据对象
		if ( !isEmptyDataObject( cache[ id ] ) ) {
			return;
		}
	}

	// 销毁缓存
	if ( isNode ) {
		jQuery.cleanData( [ elem ], true );

	// Use delete when supported for expandos or `cache` is not a window per isWindow
	// 当支持suport.deleteExpando或cache不是。。。时，(反正就是支持用delete来删除缓存)
	// 使用delete销毁缓存
	} else if ( support.deleteExpando || cache != cache.window ) {
		delete cache[ id ];
	// 当所有条件都不满足时，直接置null
	} else {
		cache[ id ] = null;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;internalRemoveData&lt;/code&gt;方法中，大部分源码就是在通过判断，分析和处理找到需要删除数据的name，并没有太难理解的地方那个，此处不再详细讲解。&lt;/p&gt;

&lt;h2 id=&quot;三示例&quot;&gt;三、示例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;jQuery.data( elem, name, data )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;jQuery.data 这是提供给客户端程序员使用的方法，它同时是setter/getter。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;传一个参数，返回附加在指定元素的所有数据，即&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  thisCachejQuery.data(elem); // thisCache
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传二个参数，返回指定的属性值&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jQuery.data(elem, 'name');  或  $.data(elem, 'name');
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传三个参数，设置属性及属性值&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  jQuery.data(elem, 'name', 'Jack');		或    $.data(elem, 'name', 'Jack');
  jQuery.data(elem, 'oName', {});			或    $.data(elem, 'oName', {});
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;传四个参数，第四个参数pvt仅提供给jQuery库自身使用，即&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery._data&lt;/code&gt;方法中传&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，因为jQuery的事件模块严重依赖于jQuery.data，为避免人为的不小心重写，所以在这个版本中加入的。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为JavaScript对象提供缓存，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var oMyJs = {};
$.data(oMyJs, 'info', 'Hello World');
$.data(oMyJs, 'info'); // Hello World
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;为HTMLElement提供缓存，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// html
&amp;lt;div id=&quot;mdiv&quot;&amp;gt;&amp;lt;/div&amp;gt;

// js
var elem = $('mdiv');
$.data(elem, 'info', 'Hello World');
$.data(elem, 'info');     // Hello World
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你使用的时Chrome，你可以打开JavaScript控制台，并添上&lt;code class=&quot;highlighter-rouge&quot;&gt;console.log(oMyJs/elem);&lt;/code&gt;，运行你就能看到元素上附加的数据了，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/oMyJs.png&quot; alt=&quot;$.data( oMyJs )&quot; /&gt;
&lt;img src=&quot;/images/elem.png&quot; alt=&quot;$.data( elem )&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[4] -- Callbacks和Deferred介绍</title>
   <link href="http://www.blogways.net/blog/2014/08/13/jQuery-source-analysis-callback-deferred.html"/>
   <updated>2014-08-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/13/jQuery-source-analysis-callback-deferred</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;h3 id=&quot;1jquerycallbacks&quot;&gt;1、jQuery.Callbacks&lt;/h3&gt;

&lt;p&gt;首先，来考虑一个问题，我们想让某些函数按照先后顺序执行，你最先想到的是什么？队列？那让我们来看一下用队列函数来实现，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function fnLikeQueue( fnList, callback){
    var fnTask;
    while(fnList.length &amp;gt; 0){
        fnTask = fnList.shift();
        fnTask(); 	// 执行函数
    }
    callback();
};
fnLikeQueue( [function(){
        alert('one');
    }, function(){
        alert('two');
    }, function(){
        alert('three');
    }], function(){
        alert('I\'m a callback');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行上面代码将会顺序弹出警示框，显示，&lt;/p&gt;

 	one,two,three,i’m a callback

&lt;p&gt;这种方法要判断函数序列的长度，每次运行还要取出一个函数在执行，而且向函数序列中添加新的函数也不是很方便，直观感觉不是很Fashion，现在来试试&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.Callbacks&lt;/code&gt;，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var callbacks = $.Callbacks();
callbacks.add(function() {
	alert('one');
});
callbacks.add(function() {
	alert('two');
});
callbacks.fire(); 	// 显示 'one', 'two'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用起来要便捷很多，代码又很清晰，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.Callbacks&lt;/code&gt;是一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。&lt;/p&gt;

&lt;h3 id=&quot;2deferred&quot;&gt;2、Deferred&lt;/h3&gt;

&lt;p&gt;实际开发过程中，我们经常遇到某些耗时很长的JavaScript操作，其中既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），我们不可能等待这些操作完成，然后再继续后面的操作。&lt;/p&gt;

&lt;p&gt;通常的做法是，为它们指定回调函数（Callback），即规定当操作执行完毕后，应该执行的某些动作。&lt;/p&gt;

&lt;p&gt;但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了Deferred对象，简单说，Deferred对象就是jQuery的&lt;strong&gt;回调函数解决方案&lt;/strong&gt;，其含义是”延迟”到未来某个点再执行。&lt;/p&gt;

&lt;p&gt;通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;$.Deferred()&lt;/code&gt;构造函数可以创建一个新的延迟对象，每个延迟对象都会向其它代码&lt;strong&gt;承诺&lt;/strong&gt;（promise）提供数据，对于任何延迟对象，调用它的&lt;code class=&quot;highlighter-rouge&quot;&gt;.promise()&lt;/code&gt;方法可以取得其承诺对象，通过调用其承诺对象的相应方法，可以添加承诺兑现时调用的处理程序：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.done()&lt;/code&gt;方法添加的处理程序会在延迟对象被 &lt;strong&gt;成功解决&lt;/strong&gt; 之后调用；&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.fail()&lt;/code&gt;方法添加的处理程序会在延迟对象被 &lt;strong&gt;拒绝&lt;/strong&gt; 之后调用；&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.always()&lt;/code&gt;方法添加的处理程序会在延迟对象完成其任务（&lt;strong&gt;无论解决还是拒绝&lt;/strong&gt;）时调用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;首先，看下jQuery中Ajax的传统写法，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.ajax({
	url: 'index.html',
	success: function(){
		alert('Done!');
	},
	error:function(){
		alert('Fail!');
	}
}); 其中success为请求成功后调用的操作，而error是请求失败后执行的操作，而在有了Deferred对象之后，就不需要像上面一样，再在ajax的请求选项中编写很多很长的操作，如：

$.ajax('index.html')
 .done(function(){  alert('Done!');  })
 .fail(function(){  alert('Fail!');  });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，done()相当于success方法，fail()相当于error方法。采用连缀写法以后，大大提高了代码的可读性。&lt;/p&gt;

&lt;h2 id=&quot;二jquerycallbacks源码分析&quot;&gt;二、jQuery.Callbacks源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1函数原型介绍&quot;&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;在下面的代码中，可以看懂Callbacks的原型中需要传递一个参数options，一个由空格分开选项的可选项列表，常用的参数：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;once&lt;/strong&gt;:   确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;memory&lt;/strong&gt;: 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;unique&lt;/strong&gt;: 确保一次只能添加一个回调(所以在列表中没有重复的回调).&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;stopOnFalse&lt;/strong&gt;: 当一个回调函数返回false 时中断调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.Callbacks&lt;/code&gt;是在jQuery内部使用，如为&lt;code class=&quot;highlighter-rouge&quot;&gt;.ajax&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;$.Deferred&lt;/code&gt;等组件提供&lt;strong&gt;基础功能&lt;/strong&gt;的函数，在jQuery引入了Deferred对象（异步列队）之后，jQuery内部基本所有有异步的代码都被promise所转化成同步代码执行。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.Callbacks&lt;/code&gt;的函数原型，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.Callbacks = function( options ) {

	// 在需要的情况下，将字符串格式选项转换成对象格式，
	// 在转换时会优先检测缓存
	options = typeof options === &quot;string&quot; ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var 
		firing, 	// 标记当前Callbacks列表是否正在运行
		// Last fire value (for non-forgettable lists)
		// 
		memory,
		fired,  // 标记是否Callbacks列表是否已经执行
		firingLength,  // Callbacks运行时，循环结束位置
		firingIndex,  // 当前正在运行的Callbacks的索引（下标）
		
		// Callbacks列表运行时，开始循环的第一个回调函数
		// 供add和fireWith方法使用
   		firingStart,        		       		
		list = [],  // 实际的回调函数列表
		
		// 只有在选项没有设置为once时，stack才存在 
		// stack用来存储参数信息（此时函数列表已经处于firing状态，
		// 必须将其他地方调用fire时的参数存储，之后再至此执行fire
		stack = !options.once &amp;amp;&amp;amp; [],
		
		// 用给定的参数调用所有的回调函数
		fire = function( data ) {},
		// 实际的 Callbacks 对象
		self = {
			// 回调列表中添加一个回调函数或回调函数的集合
			add: function() {},

			// 从回调列表中的删除一个回调函数或回调函数集合
			remove: function() {},
			
			// 返回是否列表中已经拥有一个相同的回调函数
			has: function( fn ) {},
			
			// 从列表中删除所有的回调函数
			empty: function() {},
			
			// 禁用列表中的回调函数
			disable: function() {},
			
			// 确定列表是否已被禁用
			disabled: function() {},
			
			// 锁定当前状态的回调函数列表
			lock: function() {},
			
			// 确定回调函数列表是否已被锁定
			locked: function() {},
			
			// 访问给定的上下文和参数列表中的所有回调函数
			fireWith: function( context, args ) {},
			
			// 用给定的参数调用所有的回调函数
			fire: function() {},    			
			// 判断回调函数是否被已经被调用了至少一次
			fired: function() {}
		};
	return self;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2addfire源码分析&quot;&gt;2、add、fire源码分析&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$.Callbacks().add( callbacks )&lt;/code&gt;的源码如下所示，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;add: function() {
	if ( list ) {
		var start = list.length;	// 保存当前list长度
		(function add( args ) {
			jQuery.each( args, function( _, arg ) {
				var type = jQuery.type( arg );
				// 如果传递过来的参数是函数，
				// 没有设置‘unique’，则将传递过来的回调函数直接push到列表中
				// 如果设置了‘unique’，则判断现在列表中是否已存在，
				// 若不存在，则直接push到Callbacks列表
				if ( type === &quot;function&quot; ) {
					if ( !options.unique || !self.has( arg ) ) {
						list.push( arg );
					}
				} else if ( arg &amp;amp;&amp;amp; arg.length &amp;amp;&amp;amp; type !== &quot;string&quot; ) {
					// 如果传递过来的时一个数组，则递归调用add实现回调函数的添加
					add( arg );
				}
			});
		})( arguments );
		    		
		// 当回调函数正在执行时，则修改firingLength，确保当前添加的回调函数能够被执行
		if ( firing ) {
			firingLength = list.length;

		// 如果不是firing状态，并且设置了memory
		//（肯定是在fired状态时才会执行这一步，因为memory是在fire一次后才会被赋值） 
		// 此时memory已经是上次fire是传递的参数，
		// 那么将会直接执行刚添加的函数集，而无需fire 
		} else if ( memory ) {
			firingStart = start;
			fire( memory );
		}
	}
	return this;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当开发人员通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.add( callbacks )&lt;/code&gt;向回调函数列表添加回调函数时，在函数内直接将参数传递给一个&lt;code class=&quot;highlighter-rouge&quot;&gt;立即调用函数表达式(IIFE)&lt;/code&gt;，根据传递参数的类型，采取不同的方式将其添加到回调列表中去。&lt;/p&gt;

&lt;p&gt;这里需要注意的一处是，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ( !options.unique || !self.has( arg ) ) {
	list.push( arg );
} 它隐含的表达了两个判断，
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;是否设置了“unique”；&lt;/li&gt;
  &lt;li&gt;在设置了“unique”的前提下，判断是否在回调列表中存在，&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用一般的函数语句，通常是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if( !options.unique ){
	// push
}else if(!self.has( arg )){
	push
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面也有提到，像源码中的这种书写方式，看起来非常的简洁，唯一的不好就是阅读起来不是很方便。
&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fire&lt;/code&gt;&lt;/strong&gt;方法，外部调用此方法是，jQuery内部的调用方向为，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;self.fire --&amp;gt; self.fireWith --&amp;gt; file
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在前面的Callbacks函数原型中介绍过，self是真正的Callbacks对象，也就是我们使用是调用的Callbacks对象就是self，那么这里的self.fire和self.fireWith只是Callbacks对外提供的方法，而实际上实现fire功能的是Callbacks内部私有的&lt;code class=&quot;highlighter-rouge&quot;&gt;fire&lt;/code&gt;方法，也就是此处要讲的源码，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 运行回调函数列表
fire = function( data ) {
	// 如果参数memory为true，则记录data
	memory = options.memory &amp;amp;&amp;amp; data;
	fired = true; 	// 标记运行回调函数
	firingIndex = firingStart || 0;
	firingStart = 0;
	firingLength = list.length;
	firing = true; 	// 标记正在运行回调函数
	
	for ( ; list &amp;amp;&amp;amp; firingIndex &amp;lt; firingLength; firingIndex++ ) {
		if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false 
						&amp;amp;&amp;amp; options.stopOnFalse ) {
			memory = false; 	// 阻止未来可能由于add所产生的回调
			break; 	// 由于参数options设置了stopOnFalse，
			// 所有当有回调函数运行结果为false时，退出循环
		}
	}
	// 标记结束运行回调
	firing = false;
	if ( list ) { 	// 如果Callbacks列表存在
		if ( stack ) { 	// stack存在
			
			// stack不为空，即stack中存有参数信息，
			// 当firing在运行时，通过add添加的Callbacks都将保存到stack中
			if ( stack.length ) {
				//从stack中取出，递归fire执行stack中的Callbacks
				fire( stack.shift() );
			}
		} else if ( memory ) {
			list = [];
		} else {
			// 阻止回调列表中的回调
			self.disable();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中需要注意的是，在未参数memory赋值时，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;memory = options.memory &amp;amp;&amp;amp; data;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行此语句后，当&lt;code class=&quot;highlighter-rouge&quot;&gt;options.memory&lt;/code&gt;的值为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;时，memory的值是data中的值，这跟&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JAVA
&lt;/code&gt;等语言不同，在&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JAVA&lt;/code&gt;中，执行上面语句过后的值是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;类型的值（true 或 false）。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;中，它能完成非常‘完美’的功能，&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当options.memory存在时，该语句就相当于一条赋值语句&lt;code class=&quot;highlighter-rouge&quot;&gt;memory = data;&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;当options.memory不存在时，memory值为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;像这样写之后，就再也不用为写一些复杂的判断语句了，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if( options.memory ){
	memory = data;
} else {					或者  memory = options.memory ? data : false;
	memory = false;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而且看上去非常的“&lt;strong&gt;优雅&lt;/strong&gt;”不是么？ 当然还有&lt;code class=&quot;highlighter-rouge&quot;&gt;||&lt;/code&gt;操作也一样，以前我们这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if( options.memory ){
	memory = true;
} else {					或者 memory = options.memory ? true : data;
	memory = data;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在我们可以这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;memory = options.memory || data;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以复制下面代码到&lt;a href=&quot;&amp;quot;http://jsfiddle.net/&amp;quot;&quot; title=&quot;http://jsfiddle.net/&quot;&gt;JSFiddle.net&lt;/a&gt;去测试一下！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var options = true,
data = 'I\'m a String',
ret;
ret = options &amp;amp;&amp;amp; data; //!options &amp;amp;&amp;amp; data;  //options || data; //!options || data;
alert(ret);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，这都只能在&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;中这么写，你要是在&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JAVA&lt;/code&gt;中也这么写，&lt;strong&gt;恭喜你，慢慢调BUG吧~~&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;fire&lt;/code&gt;源码中，真正最终执行回调函数的代码是，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;list[ firingIndex ].apply( data[ 0 ], data[ 1 ] )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;的使用，可以参考&lt;a href=&quot;&amp;quot;/blog/2014/07/22/somethings-of-array-and-function.html&amp;quot;&quot; title=&quot;http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function.html&quot;&gt;JavaScript中，Array和Function的那些事儿&lt;/a&gt;！&lt;/p&gt;

&lt;h3 id=&quot;3示例&quot;&gt;3、示例&lt;/h3&gt;

&lt;p&gt;下面是两个函数fn1和fn2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function fn1( value ) {
	alert( value );
}
 
function fn2( value ) {
	fn1(&quot;fn2 says: &quot; + value);
	return false;
} ***$.Callbacks( 'once' )***
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;确保这个回调列表只执行（ .fire() ）一次。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var callbacks = $.Callbacks('once');
callbacks.add( fn1 );
callbacks.fire( 'hello' );

callbacks.add( fn2 );
callbacks.fire( 'world' );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只会显示“hello”，而不会显示“world”，因为在创建Callbacks实例对象的时候，传递了参数“once”，仅运行一次，因而后面的&lt;code class=&quot;highlighter-rouge&quot;&gt;callbacks.fire( 'world' );&lt;/code&gt;是不会执行的。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( ‘memory’ )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var callbacks = $.Callbacks('memory');
callbacks.add(function() {
	alert('f1');
});

callbacks.fire(); //输出 'f1',这时函数列表已经执行完毕!

callbacks.add(function() {
	alert('f2');
}); //memory作用在这里，没有fire，一样有结果: f2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( ‘unique’ )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;确保一次只能添加一个回调函数(所以在列表中没有重复的回调函数)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var callbacks = $.Callbacks('unique');
callbacks.add( fn1 ); 	// 添加成功
callbacks.add( fn1 ); 	// 添加失败
// 显示结果hello world
callbacks.fire( 'hello world' );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;$.Callbacks( ‘stopOnFlase’ )&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当一个回调函数返回false 时，中断调用&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var callbacks = $.Callbacks('stopOnFalse');
callbacks.add(f1);
callbacks.add(function(){
	return false;
});
callbacks.add(f2);
// 只显示 hello world!
callbacks.fire( 'hello world!' );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h2 id=&quot;三deferred源码分析&quot;&gt;三、Deferred源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1函数原型介绍-1&quot;&gt;1、函数原型介绍&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;通过jQuery.extend&lt;/code&gt;将Deferred扩展到jQuery&lt;strong&gt;全局对象&lt;/strong&gt;中去，扩展原理前面已经讲过，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend({
	Deferred: function( fnc ){},
	// Deferred 帮助
	when: function( subordinate /* , ..., subordinateN */ ) {}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;首先来看下Deferred的代码结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Deferred: function( func ) {
	var tuples = [
		// 动作，添加监听器，处理程序列表（回调函数列表），最终状态
		// 创建了三个$.Callbacks对象，分别表示成功、失败、处理中三种状态
		[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],
		[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],
		[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]
	],
	state = &quot;pending&quot;,
	promise = {
		state: function() {},
		always: function() {},
		then: function( /* fnDone, fnFail, fnProgress */ ) {},
		
		// 为当前deferred，返回一个promise对象
		// 如果传递参数obj对象给此方法，则promise将被扩展到此obj对象
		promise: function( obj ) {}
	},
	deferred = {};
	
	// 增加一组特定的方法
	jQuery.each( tuples, function( i, tuple ) {
		deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
	}

	return deferred;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Deferred实例的创建，跟Callbacks的雷士，调用一个函数，然后返回的是内部构建的Deferred对象，创建了一个promise对象，具有state、always、then、primise方法，扩展primise对象生成最终的Deferred对象，返回该对象。&lt;/p&gt;

&lt;h3 id=&quot;2源码分析&quot;&gt;2、源码分析&lt;/h3&gt;

&lt;p&gt;Deferred部分源码，如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.each( tuples, function( i, tuple ) {
	var list = tuple[ 2 ],
		stateString = tuple[ 3 ];

	// 通过下面的语句，实现对应的将$.Callbacks实例对象，
	// 绑定到promise对象上
	promise[ tuple[1] ] = list.add;

	// 处理状态
	if ( stateString ) {
		list.add(function() {
			// state = [ resolved | rejected ]
			state = stateString;

		// 默认会预先向doneList,failList中的list添加三个回调函数
		}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
	}

	// deferred[ resolve | reject | notify ]
	deferred[ tuple[0] ] = function() {
		deferred[ tuple[0] + &quot;With&quot; ]( this === deferred ? promise : this, arguments );
		return this;
	};
	deferred[ tuple[0] + &quot;With&quot; ] = list.fireWith;
});

// 将promise对象合并到deferred对象中
// 使用的是promise.promise( obj )，通过调用jQuery.extend扩展
// promise( obj ){
//     return obj != null ? jQuery.extend( obj, promise ) : promise;
// }
promise.promise( deferred );

return deferred;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;源码中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;promise[ tuple[1] ] = list.add;&lt;/code&gt;将回调函数绑定到相应的promise对象上，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;promise.done = $.Callbacks(&quot;once memory&quot;).add
promise.fail = $.Callbacks(&quot;once memory&quot;).add
promise.progress = $.Callbacks(&quot;memory&quot;).add
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;i ^ 1&lt;/code&gt;按位异或运算，实际上第二个传参数是1、0索引对调了，所以取值是&lt;code class=&quot;highlighter-rouge&quot;&gt;failList.disable&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;doneList.disable&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;3示例-1&quot;&gt;3、示例&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var d = $.Deferred();

setTimeout(function(){
	    d.resolve( 'hello world' );
},0);

d.then( function( value ){
  console.log( value );
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当延迟对象被 resolved 时，任何通过&lt;code class=&quot;highlighter-rouge&quot;&gt;deferred.then&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;deferred.done&lt;/code&gt;添加的处理函数，都会被调用。回调函数的执行顺序和它们被添加的顺序是一样的。传递给&lt;code class=&quot;highlighter-rouge&quot;&gt;deferred.resolve()&lt;/code&gt;的args参数，会传给每个回调函数。当延迟对象进入&lt;code class=&quot;highlighter-rouge&quot;&gt;resolved&lt;/code&gt;状态后，再添加的任何处理函数，当它们被添加时，就会被立刻执行，并带上传入给&lt;code class=&quot;highlighter-rouge&quot;&gt;.resolve()&lt;/code&gt;的参数。&lt;/p&gt;

&lt;p&gt;调用d.resolve(22) 就等于是调用，匿名函数并传入参数值”hello world”：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function(val){
	console.log(val); 	// 显示hello world
} 更多关于Deferred对象的例子及讲解，请参考[jQuery的deferred对象详解][]!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[3] -- 简单DOM遍历方法</title>
   <link href="http://www.blogways.net/blog/2014/08/12/jQuery-source-analysis-dom-traversal.html"/>
   <updated>2014-08-12T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/12/jQuery-source-analysis-dom-traversal</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;DOM遍历有两个核心的函数，其它的遍历方法都通过调用这两个方法来间接实现相应的功能，这两个核心函数的函数原型，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dir: function( elem, dir, until ) {},
sibling: function( n, elem ) {} `dir( elem, dir, until )`，从一个元素出发，迭代检索某个方向上的所有元素并记录，直到与遇到 document 对象或遇到 until 匹配的元素；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sibling( n, elem )&lt;/code&gt;，返回 n 元素的所有后续兄弟元素，包含 n，不包含 elem, 返回 n 的兄弟节点(把 n, elem 设为相同元素时，则不返回本身).&lt;/p&gt;

&lt;p&gt;然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend()&lt;/code&gt;方法将两个核心函数扩展到&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;全局对象中去，以便后面需要的时候直接通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.dir/sibling&lt;/code&gt;调用。&lt;/p&gt;

&lt;h3 id=&quot;1dir-elem-dir-until-和sibling-n-elem-的实现&quot;&gt;1、dir( elem, dir, until )和sibling( n, elem )的实现&lt;/h3&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;jquery-1.11.1.js&lt;/code&gt;中，其源码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend({
 	// elem		起始元素
 	// dir		迭代方向，可选值：parentNode nextSibling previousSibling
 	// until	选择器表达式，如果遇到until匹配的元素，迭代终止
	dir: function( elem, dir, until ) {
		var matched = [],	// 保存匹配元素
			// 根据dir从elem取出一个元素作为匹配的开始节点，
			// cur表示匹配开始节点，为当前节点在dir迭代方向的下一个节点，
			// 因此匹配结果不包含本节点
			cur = elem[ dir ];

		// 通过while循环 、 cur = cur[dir]（根据迭代方向，向后移动一个节点），
		// 实现向迭代方向的遍历，
		// 当遍历完，或遇到document（cur.nodeType === 9），
		// until匹配的元素（ jQuery( cur ).is( until ) ）时，结束遍历，返回结果
		while ( cur &amp;amp;&amp;amp; cur.nodeType !== 9 &amp;amp;&amp;amp; (until === undefined 
						|| cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				// 将匹配的Element元素压入matched结果集中
				matched.push( cur );
			}
			cur = cur[dir]; 	// 像dir方向，往后一个节点
		}
		return matched;
	},
	
	// n	  起始元素（包含在返回结果中）
	// elem	  剔除元素（不包含在结果集中）
	sibling: function( n, elem ) {
		var r = [];
		
		// 将 n 是否存在作为判断循环是否继续的依据，
		// 先判断 n 的存在与否，再移动当前节点，
		// 因此结果集中包含 n 
		for ( ; n; n = n.nextSibling ) {
			// 当元素类型为Element 且 节点不为 elem 时，
			// 将当前元素压入结果集，
			if ( n.nodeType === 1 &amp;amp;&amp;amp; n !== elem ) {
				r.push( n );
			}
		}
		return r;
	}
}); 从上面的代码可以发现，虽然两个核心函数的代码量很少，但是实际上用它们能实现的功能是非常强大的。就拿`dir`函数来说，它支持3个迭代方向，这意味着它能实现至少3个函数的功能，再加上`until`是选择器表达式，所有它能遍历筛选的元素是非常多的。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dir( elem, dir, until )&lt;/code&gt;函数中判断遇到&lt;code class=&quot;highlighter-rouge&quot;&gt;until&lt;/code&gt;匹配元素结束迭代的判断语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )  其隐含的表达出了执行最后一个判断语句（即遇到`until`匹配元素结束迭代）的执行条件是：

until !== undefined &amp;amp;&amp;amp; cur.nodeType === 1 即`until`必须存在，`cur`节点必须是`Element`元素，这种写法虽然阅读和维护都不是很方便，但是看上去比较简洁，同时节约了很多的代码，在`jQuery`中很多地方都使用了这种写法，有兴趣可以自己去看看。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;2hasclosestindexaddaddback扩展&quot;&gt;2、has、closest、index、add、addBack扩展&lt;/h3&gt;

&lt;p&gt;在向&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;扩展两个核心函数的同时，也通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;向&lt;strong&gt;实例对象&lt;/strong&gt;扩展了遍历方法，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.fn.extend({
	// 判断当前元素集合中，是否包含target选择符指定的元素
	// 当前元素集合指调用has的实例对象当中的元素
	has: function( target ) {},
	
	// 与选择符selectors匹配的第一个元素，遍历路径从选中元素开始，
	// 沿DOM树向上在其中祖先节点中查找
	closest: function( selectors, context ) {},

	// 在当前元素集合中，返回给定elem元素所在的索引位置
	index: function( elem ) {},

	// 为选中的元素（当前匹配元素集合），加上与给定选择符selector匹配的元素
	add: function( selector, context ) {},

	// 为选中的元素，加上内部jQuery栈中与给定选择符selector匹配的元素
	addBack: function( selector ) {}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二遍历方法&quot;&gt;二、遍历方法&lt;/h2&gt;

&lt;h3 id=&quot;1遍历方法的函数原型&quot;&gt;1、遍历方法的函数原型&lt;/h3&gt;

&lt;p&gt;首先调用两个核心函数，实现相应的遍历方法，然后将这些方法一起包装到一个对象&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;&lt;/code&gt;当中，最后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.each&lt;/code&gt;遍历这个方法对象，并在其回调函数中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn[ name ] = function9){}&lt;/code&gt;添加到&lt;strong&gt;实例对象&lt;/strong&gt;中，其函数原型如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.each({
	parent: function( elem ) { 	// 父元素
		var parent = elem.parentNode;
		
		// 有父元素，且父元素不为DocumentFragment时，返回父元素
		// 否则返回null
		return parent &amp;amp;&amp;amp; parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) { 	// 祖先元素
		// 检索所有祖先元素，直到document
		return jQuery.dir( elem, &quot;parentNode&quot; );
	},
	
	// 每个选中元素的所有祖先元素，直到但不包含util的祖先元素，
	parentsUntil: function( elem, i, until ) {  
		// 检索所有祖先元素，直到遇到与until匹配的元素
		return jQuery.dir( elem, &quot;parentNode&quot;, until );
	},
	next: function( elem ) { 	// 每个选中元素紧邻的下一个同辈元素
		return sibling( elem, &quot;nextSibling&quot; );
	},
	prev: function( elem ) { 	// 每个选中元素紧邻的上一个同辈元素
		return sibling( elem, &quot;previousSibling&quot; );
	},
	nextAll: function( elem ) { 	// 每个选中元素之后的所有同辈元素
		return jQuery.dir( elem, &quot;nextSibling&quot; );
	},
	prevAll: function( elem ) { 	// 每个选中元素之前的所有同辈元素
		return jQuery.dir( elem, &quot;previousSibling&quot; );
	},
	
	// 匹配每个选中元素之后的所有同辈元素，
	// 直到遇到与until匹配的元素，不包含until
	nextUntil: function( elem, i, until ) {  
		return jQuery.dir( elem, &quot;nextSibling&quot;, until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, &quot;previousSibling&quot;, until );
	},
	
	// 给定节点的所有同辈元素
	siblings: function( elem ) {
		// elem父元素的第一个子节点的所有兄弟元素，排除当前节点
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	// 子节点
	children: function( elem ) {
		// elem的第一个子节点的所有兄弟元素，即为elem的所有子节点
		return jQuery.sibling( elem.firstChild );
	},
	// 所有的子节点，包含Element、Text、Comment
	contents: function( elem ) {
		return jQuery.nodeName( elem, &quot;iframe&quot; ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	// 将遍历对象中的方法扩展到jQuery实例对象中去
	jQuery.fn[ name ] = function( until, selector ) {

		// 将当前匹配集合中的元素，用fn处理，
		// 然后用until过滤处理结果，最后返回匹配结果
		var ret = jQuery.map( this, fn, until );

		// 不过函数名不以Until结尾
		if ( name.slice( -5 ) !== &quot;Until&quot; ) {
			// 不需要参数until，只有一个参数selector，util只到这里为止
			selector = until;
		}
		if ( selector &amp;amp;&amp;amp; typeof selector === &quot;string&quot; ) {
			// 对ret数组用selector进行过滤，只留下匹配的元素
			// jQuery.filter会调用jQuery.find.matches &amp;gt; Sizzle.matches 
			// &amp;gt; Sizzle，Sizzle查找、过滤的结果已经经过排序、去重
			ret = jQuery.filter( selector, ret );
		}

		if ( this.length &amp;gt; 1 ) {
			// 去除重复
			if ( !guaranteedUnique[ name ] ) {
				ret = jQuery.unique( ret );
			}

			// parent或prev的遍历matched应该反转，使matched顺序更符合逻辑
			if ( rparentsprev.test( name ) ) {
				// 倒序
				ret = ret.reverse();
			}
		}
		// 根据操作结果，构造新的jQuery对象并返回用以后续操作
		return this.pushStack( ret );
	};
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用：&lt;/h3&gt;

&lt;p&gt;HTML：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// html
&amp;lt;h2&amp;gt;Shakespeare's Plays&amp;lt;/h2&amp;gt;
&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;As You Like It&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;Comedy&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;All's Well that Ends Well&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;Comedy&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;1601&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;Hamlet&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;1604&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;Macbeth&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;1606&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;Romeo and Juliet&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;1595&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;Henry IV, Part I&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;1596&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
	        &amp;lt;td&amp;gt;Henry V&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt;
	        &amp;lt;td&amp;gt;1599&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CSS：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.highlight {
	font-size: large;
    font-family: monospace;
    font-weight: bold;
	font-style: italic;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1next&quot;&gt;1、next()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;，每个选中元素紧邻的下一个同辈元素，给表格中包含Henry的邻近单元格加一个高亮，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').next().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;td:contains(Henry)&lt;/code&gt;筛选出包含Henry内容的单元格（两处），则此时的选中元素是&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;td&amp;gt;Henry IV, Part I&amp;lt;/td&amp;gt; 和 &amp;lt;td&amp;gt;Henry V&amp;lt;/td&amp;gt;，
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;为选中元素的下一个同辈元素，所以在&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;过后的选中元素是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt; 和 &amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将代码复制到&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle&lt;/a&gt;测试显示结果，表格里面的两个History显示为hightlight类的样式了。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;2nextall&quot;&gt;2、nextAll()&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;nextALl()&lt;/code&gt;，选中元素之后的所有同辈元素，给表格包含Henry的之后所有单元格加高亮，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').nextAll().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其它与前面是一样的，不一样的时，在执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;nextAll()&lt;/code&gt;之后，选中的元素是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;td&amp;gt;Tragedy&amp;lt;/td&amp;gt;、&amp;lt;td&amp;gt;1595&amp;lt;/td&amp;gt;、&amp;lt;td&amp;gt;History&amp;lt;/td&amp;gt; 和 &amp;lt;td&amp;gt;1599&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试运行过后，可以看到两个包含Henry行的当前但与昂之后的所有单元格均显示为hightlight类的样式了。&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;3addbackparentchildren&quot;&gt;3、addBack()、parent()、children()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;addBack()&lt;/code&gt;，选中的元素，加上内部&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;栈中之前选中的那一组元素，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').nextAll().addBack().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;addBack()&lt;/code&gt;之后，相应行中所有单元格都显示为hightlight类的样式了。事实上，要选择同一组元素，可以采用的方法很多，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('td:contains(&quot;Henry&quot;)').parent().children().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;h3 id=&quot;4siblings&quot;&gt;4、siblings()&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;siblings()&lt;/code&gt;，当前选中节点的所有同辈元素，剔除当前选中元素，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$('td:contains(&quot;Tragedy&quot;)').siblings().addClass('highlight');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;siblings()&lt;/code&gt;之前的选中元素为表格中包含“Tragedy”的三个单元格&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;td&amp;gt;&amp;lt;/td&amp;gt;&lt;/code&gt;元素，而执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;siblings()&lt;/code&gt;之后，选中的元素为前面选中元素的所有同辈元素，即：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;td&amp;gt;Hamlet&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1604&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Macbeth&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1606&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;Romeo and Juliet&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;1595&amp;lt;/td&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行测试过后，这几项就会显示为highlight类的样式了。&lt;/p&gt;

&lt;p&gt;测试网站推荐&lt;a href=&quot;http://jsfiddle.net&quot;&gt;JSFiddle&lt;/a&gt;!!&lt;/p&gt;

&lt;p&gt;&amp;lt;/br&amp;gt;&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[2] -- 基础工具函数</title>
   <link href="http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-two.html"/>
   <updated>2014-08-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-two</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;前面一次讲了在&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;源码中，是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;将后续的大部分功能进行扩展的。&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;扩展&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的&lt;strong&gt;全局对象&lt;/strong&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;扩展&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的&lt;strong&gt;实例对象&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;要了解&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;工具函数的扩展，首先要了解&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;的实现，便于了解其工作原理，这样在后面的学习中才不会有疑惑的地方。&lt;/p&gt;

&lt;h3 id=&quot;1jqueryextend和jqueryfnextend的实现&quot;&gt;1、jQuery.extend和jQuery.fn.extend的实现&lt;/h3&gt;
&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;jquery-1.11.1.js&lt;/code&gt;中，其源码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// .extend( [ boolean, ] target, src1, src2, ... )
// .fn.extend( target)
// 上面为两个函数的原型，其中extend包含一个可选的boolean型参数，其含义为是否进行深度扩展
// 此处的target为 接受扩展 的对象
jQuery.extend = jQuery.fn.extend = function() {
	var src, copyIsArray, copy, name, options, clone,
	
	// 若无特殊情况，参数中的第一个为target，若没有传递参数，默认为{}
	target = arguments[0] || {}, 			i = 1,
	length = arguments.length,

	// 是否进行深度复制的flag，即为参数中[ boolean ]所传递过来的值，默认为false
	deep = false; 	

	// 处理深度复制的情况，若设置了[ boolean ]，则其位置必为arguments中第一个(arguments[0])
	if ( typeof target === &quot;boolean&quot; ) {
		deep = target;

		// 跳过 [ boolean ] 参数，取得target扩展对象
		target = arguments[ i ] || {};
		i++;
	}

	// 处理target是一个string或其他什么（可能发生在深度复制中）
	if ( typeof target !== &quot;object&quot; &amp;amp;&amp;amp; !jQuery.isFunction(target) ) {
		target = {};
	}

	// 如果只有一个参数被传递过来，则扩展jQuery自己，即将target值设为this
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i &amp;lt; length; i++ ) {
		// 只处理不为空或undefined值
		if ( (options = arguments[ i ]) != null ) {
			// 扩展基础对象
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// 防止死循环
				if ( target === copy ) {
					continue;	// 当传递过来的参数中的所有属性及方法，
				}

				// 如果进行深度扩展，且我们正在合并的是一个纯对象或者数组，就递归调用
				if ( deep &amp;amp;&amp;amp; copy &amp;amp;&amp;amp; ( jQuery.isPlainObject(copy) 
						|| (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src &amp;amp;&amp;amp; jQuery.isArray(src) ? src : [];
					} else {
						clone = src &amp;amp;&amp;amp; jQuery.isPlainObject(src) ? src : {};
					}
					// 别直接修改原始对象，而是使用他们的一个副本
					target[ name ] = jQuery.extend( deep, clone, copy );
				// 排除参数中的undefined值
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}
	// 返回修改过后的对象
	return target;
}; 源码中通过`target[ name ] = jQuery.extend( deep, clone, copy );`和`target[ name ] = copy;`来具体实现目标对象的扩展，前者在选择了深度扩展且扩展对象为数组或纯对象时，通过递归调用`jQuery.extend`实现，后者是直接赋值。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两者相同一点就是同名属性或方法的直接赋值，这就使得后面的属性或方法会&lt;strong&gt;覆盖&lt;/strong&gt;前面或者&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;中的同名属性或方法。而当&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;只有一个参数的时候，会将其扩展到&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的&lt;strong&gt;全局对象&lt;/strong&gt;或&lt;strong&gt;实例对象&lt;/strong&gt;当中去，我们可以利用这一特性，扩展&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的功能，而实际上我们也是这么做的，这个会在后面谈到，此处不再详细说明。&lt;/p&gt;

&lt;h2 id=&quot;二工具函数&quot;&gt;二、工具函数&lt;/h2&gt;
&lt;h3 id=&quot;1工具函数的函数原型&quot;&gt;1、工具函数的函数原型&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;中扩展的&lt;strong&gt;全局对象&lt;/strong&gt;工具函数，其函数原型如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.extend({
	// 在页面中生成一个唯一标识每一个副本jQuery
	expando: &quot;jQuery&quot; + ( version + Math.random() ).replace( /\D/g, &quot;&quot; ),

	// 在没有ready模块时，假定jQuery准备完成
	isReady: true,
	// 抛出指定的错误信息
	error: function( msg ) {	throw new Error( msg );    },
	// 空操作
	noop: function() {},
	isFunction: function( obj ) {}, 	// 判断参数是否为一个函数
	
	// 当Array存在判断函数时，只做一个简单的赋值引用，若无则手动创建一个
	isArray: Array.isArray || function( obj ) {},   
	
	isWindow: function( obj ) {}, 	// 判断参数是否为浏览器窗口对象window

	isNumeric: function( obj ) {}, 	// 判断参数是不是数值

	isEmptyObject: function( obj ) {},  // 判断参数是否是一个空对象

	// 判断参数obj是不是通过对象字面量或new Object创建的
	isPlainObject: function( obj ) {},  

	type: function( obj ) {},  // 返回obj类型

	globalEval: function( data ) {},   // 在全局上下文中，求给定的JavaScript字符串数据的值

	// 将参数字符串转换为骆驼表示法，如camelCase,nodeName等，
	// 基本上jQuery中所有的方法都是用的骆驼表示法
	camelCase: function( string ) {},	

	nodeName: function( elem, name ) {},	// 返回指定元素的节点名称与给定的名字是否一样

	// args 仅在each内部使用，对obj执行规定运行的函数callback
	each: function( obj, callback, args ) {},

	trim: function( text ) {},  // 去除参数text末尾中的空白符，包括回车、空格、制表符、换行符

	// results 仅在内部使用，转换一个类似数组的对象成为真正的JavaScript数组
	makeArray: function( arr, results ) {	}, 

	// 确定第一个参数在数组中的位置(如果没有找到则返回 -1 )
	inArray: function( elem, arr, i ) {},  

	merge: function( first, second ) {},  // 将两个参数合并，并返回合并后的值

	grep: function( elems, callback, invert ) {},  // 数组元素过滤筛选

	// arg 仅在内部使用，对当前集合elems中的每个元素调用callback，
	// 将返回结果作为一个新的jQuery对象
	map: function( elems, callback, arg ) {},

	// 一个对象的全局的GUID计数器
	guid: 1,

	// optionally partially applying any arguments
	// 创建一个新的，在指定上下文中执行的函数
	proxy: function( fn, context ) {},

	now: function() { return +( new Date() ); },  // 返回当前时间

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;中扩展的&lt;strong&gt;实例对象&lt;/strong&gt;工具函数，其函数原型如下代码所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.fn.extend({
	// 返回与给定selector选择符匹配的后代元素
	find: function( selector ) {},
	// 与给定的选择符selector匹配的选中元素
	filter: function( selector ) {},
	
	not: function( selector ) {}, 	// 选中给定元素集中与给定选择符不匹配的元素

	// 根据选择符来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true
	is: function( selector ) {} 	
}); ## 三、源码分析 ## ### 1、each（ obj, callback ）遍历 ### `jQuery`中，`each`的源码中关键代码如下所示：

var value,
	i = 0,
	length = obj.length,
	isArray = isArraylike( obj );

	if ( isArray ) {
		for ( ; i &amp;lt; length; i++ ) {
			value = callback.call( obj[ i ], i, obj[ i ] );
			if ( value === false ) {
				break;
			}
		}
	} else {
		for ( i in obj ) {
			value = callback.call( obj[ i ], i, obj[ i ] );

			if ( value === false ) {
				break;
			}
		}
	}
return obj; 首先通过**数组**和**对象**两种方式来遍历参数`obj`，对`obj`中的每个元素调用`callback.call`将每个元素绑定到回调函数上执行，并返回执行结果。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当回调函数返回&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;，则停止循环。在其源码中还涉及到&lt;code class=&quot;highlighter-rouge&quot;&gt;callback.apply&lt;/code&gt;的方式来调用回调函数，其作用于&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;一样，都是将函数绑定到另外一个对象上去运行。关于&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;的详细说明，可以跳转到[JavaScript中，Array和Function的那些事儿][]查看详细信息！
[JavaScript中，Array和Function的那些事儿]: http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function.html “JavaScript中，Array和Function的那些事儿”&lt;/p&gt;

&lt;h3 id=&quot;示例&quot;&gt;示例：&lt;/h3&gt;
&lt;p&gt;测试代码如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/jquery/jquery.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/javascript&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
				&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;button&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;click&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    				&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;li&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
    	  				&lt;span class=&quot;nx&quot;&gt;alert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    				&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  				&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
			&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;button&amp;gt;&lt;/span&gt;输出每个列表项的值&lt;span class=&quot;nt&quot;&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Coffee&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Milk&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
			&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Soda&lt;span class=&quot;nt&quot;&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
		&lt;span class=&quot;nt&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;
	&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt; 运行上面代码，会依次弹出三个警示框，分别显示`&lt;span class=&quot;nt&quot;&gt;&amp;lt;li&amp;gt;&amp;lt;/li&amp;gt;&lt;/span&gt;`中的值。你可以到[$.each()遍历][]运行测试样例！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;function(){}&lt;/code&gt;就是&lt;code class=&quot;highlighter-rouge&quot;&gt;each( obj, callback )&lt;/code&gt;中的回调函数&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;，此处只是显示列表项的值，不需要指定特定的&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;element&lt;/code&gt;，在某些情况下需要用之来辨别当前所遍历的元素，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var info = [ 
		{ &quot;name&quot;:&quot;aaa&quot;, &quot;age&quot;:22, &quot;hobby&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;] },
		{ &quot;name&quot;:&quot;bbb&quot;, &quot;age&quot;:23, &quot;hobby&quot;:[&quot;a&quot;,&quot;b&quot;,&quot;d&quot;] },
		{ &quot;name&quot;:&quot;ccc&quot;, &quot;age&quot;:22, &quot;hobby&quot;:[&quot;a&quot;,&quot;c&quot;,&quot;d&quot;] } 
	];
$.each( info, function( index, item ){
	var name = item.name,
		age = item.age,
		hobby = item.hobby;
	alert(&quot;My name is &quot; + name + &quot;,I am &quot; + age + 
					&quot; years old,my hobbies are &quot; + hobby);
}); 上面的代码会逐条输出`info`中的信息，你可以将上面代码复制到[JSFiddle][]运行测试！
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;为当前元素在&lt;code class=&quot;highlighter-rouge&quot;&gt;info&lt;/code&gt;中的索引，&lt;code class=&quot;highlighter-rouge&quot;&gt;item&lt;/code&gt;是对当前遍历元素的引用，因此在函数体内使用&lt;code class=&quot;highlighter-rouge&quot;&gt;item.name/age/hobby&lt;/code&gt;即可得到当前遍历元素的值，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;alert()&lt;/code&gt;显示到界面。&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jQuery源码解读[1] -- 总体结构及构造函数</title>
   <link href="http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-one.html"/>
   <updated>2014-08-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/08/10/jQuery-source-analysis-one</id>
   <content type="html">&lt;h2 id=&quot;一前言&quot;&gt;一、前言&lt;/h2&gt;

&lt;p&gt;首先了解一下&lt;strong&gt;块级作用域&lt;/strong&gt;与&lt;strong&gt;函数作用域&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;块级作用域&lt;/strong&gt;：任何一对花括号{}中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;函数作用域&lt;/strong&gt;：定义在函数中的参数和变量在函数外部是不可见的。&lt;/p&gt;

&lt;p&gt;大家都知道&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;中是没有块级作用域的，那么作为&lt;code class=&quot;highlighter-rouge&quot;&gt;Javascript&lt;/code&gt;的一个框架，&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;要应用到各种环境中，要怎么解决命名空间冲突的问题是一个关键。&lt;/p&gt;

&lt;h3 id=&quot;1立即调用函数表达式iife&quot;&gt;1、立即调用函数表达式（IIFE）&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;源码中，你会看到如下的代码结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(function( global, factory){
	//code
}(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal){
	//code
	
	if ( typeof noGlobal === strundefined ) {
		window.jQuery = window.$ = jQuery;
	}
	return jQuery;
})); 1. 这是一个`立即调用函数表达式(IIFE)`，创建一个匿名函数`function( global, factory){}`，创建完成后立即传递参数并运行。 2. 在函数名后面直接加一对`()`表示调用该函数,

	function fn( a, b ){};
	fn();	//调用函数
而IIFE只是将分开的两步作为一步来书写，

	( function( a, b ){
		//code
	}( x, y ) );
这就叫做`立即调用函数表达式(IIFE)`。此外，还有另一种书写方式：

	(functioin( a, b ){
		//code
	})( x, y ); 3. 通过定义一个`IIFE`，相当于创建了一个“私有”的命名空间，该命名空间中的**所有变量和方法**只为自己所有，如不进行特殊处理，函数外无法访问这些变量及方法，不会破坏全局的命名空间，达到了与`块级作用域`一样的效果。 4. 提及`立即调用函数表达式()IIFE)`，你会发现一个非常有趣的事实，测试代码如下：

	$(document).ready(function(){
		(function(){
			undefined = &quot;now it's defined&quot;;
			alert(undefined);
			alert(typeof undefined);
		})();
		//会弹出警示框，now it's defined   ;   string
	});
感兴趣的话可以将代码代码复制到**[JSFiddle.net][]**自己测试一下。结果是只有firefox的测试结果为`undefined`，其他主流浏览器都显示为`now it's defined`。

鉴于上面出现的问题，所以在`jQuery`源码中用了`strundefined = typeof undefined;`在未来得及更改`undefined`之前为其创建一个不可变的常数副本。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;window.jQuery = window.$ = jQuery;&lt;/code&gt;通过此代码，将&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;$&lt;/code&gt;标示符暴露给&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;，最后&lt;code class=&quot;highlighter-rouge&quot;&gt;return jQuery;&lt;/code&gt;返回jQuery实例供外部使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;二代码结构&quot;&gt;二、代码结构&lt;/h2&gt;
&lt;h3 id=&quot;1jquery源码结构&quot;&gt;1、jQuery源码结构&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;源码中，从前到后代码实现的功能如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(function( global, factory){
	//code
}(typeof window !== &quot;undefined&quot; ? window : this, function( window, noGlobal){
	
	jQuery = function( selector, context ) {
		return new jQuery.fn.init( selector, context );
	};
	
	jQuery.fn = jQuery.prototype = {
		// Code
	};
	
	jQuery.extend = jQuery.fn.extend = function() {
		// Code
	};
	
	jQuery.extend({
		//Code
	});
	// jQuery选择器引擎
	var Sizzle = (function( window ){
		// Code
		// 使用立即调用函数表达式(IIFE)，生成Sizzle
	})( window );
	
	init = jQuery.fn.init = function( selector, context ) {
		// Code
	}
	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery.fn;
	
	// DOM遍历方法
	
	// Callback及Deferred，回调函数及延迟方法
	
	// Support 浏览器测试
	
	// Data 数据缓存；
	
	// Queue 队列操作；
	
	// Event 事件处理；浏览器兼容处理
	
	// DOM 操作方法；DOM节点插入方法；
	
	// CSS
	
	// FX 动画
	
	// Attr 特性与属性（attr、prop、class）
	
	// 异步请求 AJAX
	
	// 位置坐标、窗口视口大小
	
	
	return jQuery;
}));	 以上为`jQuery`源码的大致的代码结构，从中可以看出代码结构非常清晰、条理明确，以上为`jquery-1.11.1.js`版本当中的代码结构。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三源码分析&quot;&gt;三、源码分析&lt;/h2&gt;
&lt;h3 id=&quot;1构造jquery对象&quot;&gt;1、构造jQuery对象&lt;/h3&gt;
&lt;p&gt;在我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的时候，并没有像&lt;code class=&quot;highlighter-rouge&quot;&gt;javascript&lt;/code&gt;一样，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// js									// jquery
var jq = function(){					$(document).ready(...);
	// constructor 构造器				$.getJSON(...);
};										$.ajax(...);

jq.prototype = {
	// prototype 原型
	find: function(){},
	show: function(){}
};

var jq1 = new jq();
jq1.find(); `jQuery`没有通过`new`来创建实例，按照我们的书写方式，那么`$()`应该返回的是一个`jQuery`的实例对象，源码中的实现方式如下：

jQuery = function( selector, context ) {
	return new jQuery.fn.init( selector, context );
};
	（）
jQuery.fn = jQuery.prototype = {
	// Code
}; 通过将`jQuery`类当作一个工厂方法来创建实例，将该创建方法放到`prototype`原型当中，那么在我们调用的时候就不必通过`new`关键字来创建了，直接调用`jQuery( selector, context )`。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果直接将创建方法&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;放到&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype&lt;/code&gt;当中:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery = function( selector, context ) {
	return new jQuery.prototype.init( selector, context );
};
	
jQuery.fn = jQuery.prototype = {
	init: function(){
		this.age = 23;
		return this;	// 返回jQuery实例对象
	},
	age: 18
	// code
};
jQuery().age	// 23 如上所示，因为使用的时工厂模式来创建并返回一个`jQuery`的实例，那么`init`中`return this;`的`this`就表示当前实例（`jQuery`对象的实例），这久导致了一个严重的问题，`init`方法当中指像直接的`this`没有了。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实际的情况是，内部的&lt;code class=&quot;highlighter-rouge&quot;&gt;this&lt;/code&gt;会覆盖上传的，因此返回的对象不是一个代表&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的实例，而是一个&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;的实例，所以&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.age&lt;/code&gt;的值不是18，而是23.&lt;/p&gt;

&lt;p&gt;因为&lt;code class=&quot;highlighter-rouge&quot;&gt;init&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的&lt;strong&gt;作用域相同&lt;/strong&gt;（都为&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.prototype.init&lt;/code&gt;）才会导致上面情况的发生，在源码中的解决方式是将&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的作用域挂载到&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.init&lt;/code&gt;当中，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jQuery.fn = jQuery.prototype = {
	// code
};
init = jQuery.fn.init = function( selector, context ) {
	// Code
}
init.prototype = jQuery.fn; 首先执行`jQuery.fn = jQuery.prototype`，再执行`(jQuery.fn.)init.prototype = jQuery.fn;`，在执行那个这些语句后，挂载到`jQuery.fn.init`上就相当于挂载到了`jQuery.prototype.init`，即挂载到了`jQuery`函数上。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后的结果是挂载到了我们最终使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;对象实例上，&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.init&lt;/code&gt;是实际上创建&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;实例对象的地方。&lt;/p&gt;

&lt;h3 id=&quot;2jqueryextend和jqueryfnextend&quot;&gt;2、jQuery.extend和jQuery.fn.extend&lt;/h3&gt;
&lt;p&gt;合并两个或更多对象的属性到第一个对象中，&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;中后续的&lt;strong&gt;大部分功能&lt;/strong&gt;都时通过该函数进行扩展，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.fn.extend&lt;/code&gt;扩展的函数，大部分都会调用通过&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery.extend&lt;/code&gt;扩展的同名函数。函数原型如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.extend( target, object1, object2, ... )
.fn.extend( target, object1, object2, ... )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;如果传入两个或多个对象，所有对象的属性会被添加到第一个对象&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;中，&lt;/li&gt;
  &lt;li&gt;如果只传入一个对象，则将对象的属性添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;对象中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;用这种方式，我们可以为&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;命名空间增加新的方法。可以用于编写&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;插件，如果不想改变传入的对象，可以传入一个空对象：&lt;code class=&quot;highlighter-rouge&quot;&gt;$.extend({}, object1, object2, ... );&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;默认合并操作是不迭代的，即便&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;的某个属性是对象或属性，也会被完全覆盖而不是合并&lt;/li&gt;
  &lt;li&gt;第一个参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，则会迭代合并&lt;/li&gt;
  &lt;li&gt;从&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;原型继承的属性会被拷贝&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;值不会被拷贝&lt;/li&gt;
  &lt;li&gt;因为性能原因，&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;自带类型的属性不会合并&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;更详细讲解请参考[jQuery.extend 函数详解][] ！
[jQuery.extend 函数详解]: http://www.cnblogs.com/RascallySnake/archive/2010/05/07/1729563.html&lt;/p&gt;

&lt;h3 id=&quot;3jqueryextend-示例&quot;&gt;3、jQuery.extend 示例&lt;/h3&gt;
&lt;h4 id=&quot;1extendobject--extend-target-obj1-obj2--&quot;&gt;1）$.extend(object) / $.extend( target, obj1, obj2, … )&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$.extend( object )&lt;/code&gt;方法就是将&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;合并到&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的&lt;strong&gt;全局对象&lt;/strong&gt;中去，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.extend({
  		sum: function( a, b ){ 
  			return a + b;
  		}
  	}); 将`sum`方法扩展到`jQuery`的全局方法中去，类似于`C/C++`、`JAVA`当中的静态方法。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$.extend( target, obj1, obj2, ... )&lt;/code&gt;方法将&lt;code class=&quot;highlighter-rouge&quot;&gt;obj1, obj2, ...&lt;/code&gt;合并到&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;当中，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var result = $.extend( {}, { name: 'A', age: 20}, {name: 'B', gender: 'female'} );
// result = { name: 'B', age: 20, gender: 'female'};
// 此处target为 {} ,将obj1，obj2合并到一个新的对象中
// 在不希望改变target的情况下使用
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2-fnextendobj&quot;&gt;2) $.fn.extend(obj)&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$.fn.extend( object )&lt;/code&gt;方法是讲&lt;code class=&quot;highlighter-rouge&quot;&gt;object&lt;/code&gt;合并到&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的&lt;strong&gt;实例对象&lt;/strong&gt;中去。&lt;/p&gt;

&lt;p&gt;类似&lt;code class=&quot;highlighter-rouge&quot;&gt;C/C++&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;JAVA&lt;/code&gt;中&lt;strong&gt;类的方法&lt;/strong&gt;，只有&lt;code class=&quot;highlighter-rouge&quot;&gt;jQuery&lt;/code&gt;的实例可以调用！&lt;/p&gt;

&lt;p&gt;===&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;未完待续。。。&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JavaScript中，Array和Function的那些事儿</title>
   <link href="http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function.html"/>
   <updated>2014-07-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/07/22/somethings-of-array-and-function</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol type=&quot;I&quot;&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;概述&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;
            &lt;a href=&quot;#2&quot;&gt;Function的那些事儿&lt;/a&gt;
            &lt;ol type=&quot;1&quot;&gt;
                &lt;li&gt;arguments不是Array，但可以构造出一个Array对象来！&lt;/li&gt;
                &lt;li&gt;相同功能，不同调用形式的两方法——apply和call&lt;/li&gt;
                &lt;li&gt;去优雅地使用apply和call吧！&lt;/li&gt;
                &lt;li&gt;使用bind方法，再造函数！&lt;/li&gt;
                &lt;li&gt;uncurryThis，你知道吗？&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/li&gt;
        &lt;li&gt;
            &lt;a href=&quot;#3&quot;&gt;Array的那些事儿&lt;/a&gt;
            &lt;ol type=&quot;1&quot;&gt;
                &lt;li&gt;可以浅度复制数组的slice方法&lt;/li&gt;
                &lt;li&gt;不仅仅作用于数组的堆栈操作，四方法：push/pop/shift/unshift&lt;/li&gt;
                &lt;li&gt;可删可插入的splice方法&lt;/li&gt;
                &lt;li&gt;forEach/map/reduce的实现与效率！&lt;/li&gt;
                &lt;li&gt;其他：join/concat/sort/reverse/...&lt;/li&gt;
            &lt;/ol&gt;
        &lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;结束&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;

&lt;p&gt;在JavaScript中，内置对象Array和Function本身提供了不少方法，有些方法为人所熟知，有些方法则不被注意。而有些方法虽然被人所熟悉，却又有不被重视的使用场景，去实现一些妙用。&lt;/p&gt;

&lt;p&gt;本文结合当下自己的使用心得，一方面做个分享，一方面也是个备忘，哈哈！&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;二function的那些事儿&quot;&gt;二、Function的那些事儿&lt;/h3&gt;

&lt;h4 id=&quot;21-arguments不是array&quot;&gt;2.1 arguments不是Array！&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt;是函数被执行时，传入的实参集合。他直接在函数里面被类似于一个数组进行访问。&lt;/p&gt;

&lt;p&gt;在Chrome浏览器的控制台执行下面代码（&lt;em&gt;本文代码都可以在Chrome浏览器的控制台中运行&lt;/em&gt;）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function testFunc() { 
    console.log(arguments);
    
    for(var i=0; i&amp;lt;arguments.length; ++i) {
        console.log(arguments[i]);
    }
        
    for(var idx in arguments) {
        console.log(arguments[idx]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;传入参数运行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testFunc(1,2,3,4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[1, 2, 3, 4]
1
2
3
4
1
2
3
4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面例子中，我们可以访问&lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;属性，来确定实参的个数，以及通过下标对&lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt;进行访问，获取我们需要的某个参数。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;：arguments不是一个Array！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var testFunc = function() { 
    console.log(&quot;[] 是一个 Array？&quot;+Array.isArray([]));
    console.log(&quot;arguments 是一个Array？&quot;+Array.isArray(arguments));
    console.log(&quot;arguments toString:&quot; + arguments.toString());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;传入参数运行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testFunc(1,2,3,4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;执行结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[] 是一个 Array？true
arguments 是一个Array？false
arguments toString:[object Arguments] 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;提示&lt;/span&gt;：我们可以基于arguments构造一个数组对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;示例代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var testFunc = function() { 
    var args = Array.prototype.slice.apply(arguments);
    console.log(&quot;args 是一个 Array?&quot;+Array.isArray(args));
    console.log(args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;testFunc(1,2,3,4)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;args 是一个 Array?true
[1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，你也可以在构造的同时，对实参进行裁剪。参考代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var testFunc = function() { 
    var args = Array.prototype.slice.call(arguments, 1);
    console.log(args);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;22-相同功能不同参数形式的两方法apply和call&quot;&gt;2.2 相同功能，不同参数形式的两方法——apply和call&lt;/h4&gt;

&lt;p&gt;这两个方法的功能相同，只是定义参数方式不同：
它们的作用都是将函数绑定到另外一个对象上去运行，两者仅在定义参数方式有所区别：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Function.apply(thisArg,argArray);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Function.call(thisArg[,arg1,arg2…]);&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;他们的功能，都是将函数绑定到一个指定的对象上去运行，即所有函数内部的this指针都会被赋值为thisArg。&lt;/p&gt;

&lt;p&gt;这种功能，可以实现将函数作为特定对象的方法，进行执行的目的。&lt;/p&gt;

&lt;p&gt;为什么会有这两种不同的形式呢？是为满足需求，而决定的！&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.call&lt;/code&gt;的形式很自然，调用起来很方便，就像&lt;code class=&quot;highlighter-rouge&quot;&gt;2.1&lt;/code&gt;小节最后那个例子那样。在这个例子中，你肯定不愿意使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.apply&lt;/code&gt;，是不是？&lt;/p&gt;

&lt;p&gt;但是，它存在一个缺点：当函数的参数个数是动态的，只能在运行过程中才能确定下来，那么使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.call&lt;/code&gt;就不合适了，就只能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.apply&lt;/code&gt;了。在运行过程中，将动态的参数都放到数组中去，然后把数组作为一个参数，传给&lt;code class=&quot;highlighter-rouge&quot;&gt;Function.apply&lt;/code&gt;。这样就完美的解决问题了！&lt;/p&gt;

&lt;h4 id=&quot;23-去优雅地使用apply和call吧&quot;&gt;2.3 去优雅地使用apply和call吧&lt;/h4&gt;

&lt;p&gt;有一个动态数组:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numbers=[]
for(var i=0; i&amp;lt;100; ++i) {
    numbers[i] = Math.floor(Math.random()*10000);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要求：从中找到最大数和最小数。&lt;/p&gt;

&lt;p&gt;先看看常规的方法吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;max = -Infinity, min = +Infinity;

numbers.forEach(function(item) {
  if (item &amp;gt; max) max = item;
  if (item &amp;lt; min) min = item;
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，如何优雅地使用&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;去编码呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var max = Math.max.apply(null, numbers);
var min = Math.min.apply(null, numbers);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就执行效率而言，后者也比前者快！&lt;/p&gt;

&lt;p&gt;当然，就解决这个题目而言，还有更快的方案，有兴趣地话，可以看看笔者的测试：&lt;a href=&quot;http://jsperf.com/apply-vs-loop-for-max/2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://jsperf.com/apply-vs-loop-for-max/2&lt;/code&gt;&lt;/a&gt;。这个测试的结果，可能会颠覆你的认知，让你惊讶的。^_^&lt;/p&gt;

&lt;h4 id=&quot;24-使用bind方法定制函数&quot;&gt;2.4 使用bind方法，定制函数！&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;fun.bind(thisArg[, arg1[, arg2[, …]]])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果说，前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;call&lt;/code&gt;方法是将函数绑定到特定的对象上去执行。那么，&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;方法，就是只绑定，不执行。&lt;/p&gt;

&lt;p&gt;它生成一个新的方法，它可以给已知的函数&lt;code class=&quot;highlighter-rouge&quot;&gt;fun&lt;/code&gt;绑定执行的对象&lt;code class=&quot;highlighter-rouge&quot;&gt;thisArg&lt;/code&gt;，还可以绑定执行的参数&lt;code class=&quot;highlighter-rouge&quot;&gt;[, arg1[, arg2[, ...]]]&lt;/code&gt;，绑定的参数可以是部分，也可以是全部。&lt;/p&gt;

&lt;p&gt;所以，就实现的功能而言，&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;方法也可以借助&lt;code class=&quot;highlighter-rouge&quot;&gt;apply&lt;/code&gt;方法，用下面代码模拟：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Function.prototype.bind = function(ctx) {
    var fn = this;
    var args = Array.prototype.slice.call(arguments, 1);
    return function() {
        fn.apply(ctx, args.concat(Array.prototype.slice.call(arguments)));
    };
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么，&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;有哪些作用，适合用在哪些场合呢？&lt;/p&gt;

&lt;p&gt;看下面这段代码：&lt;/p&gt;

&lt;p&gt;背景设定：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.x = 9; 
var module = {
  x: 81,
  getX: function() { return this.x; }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module.getX(); // 81
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如你所愿，执行结果是 &lt;code class=&quot;highlighter-rouge&quot;&gt;81&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;有时，你可能不经意间，进行赋值：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var getX = module.getX;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再运行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;getX(); // 9, because in this case, &quot;this&quot; refers to the global object
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;可能，你希望结果是 &lt;code class=&quot;highlighter-rouge&quot;&gt;81&lt;/code&gt;，但却是&lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;怎么才能让结果仍然是 &lt;code class=&quot;highlighter-rouge&quot;&gt;81&lt;/code&gt;呢？&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// create a new function with 'this' bound to module
var boundGetX = getX.bind(module);
boundGetX(); // 81
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;是的，如上使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bind&lt;/code&gt;就可以了！&lt;/p&gt;

&lt;h4 id=&quot;25-uncurrythis你知道吗&quot;&gt;2.5 uncurryThis，你知道吗？&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uncurryThis&lt;/code&gt;话题，来自于&lt;code class=&quot;highlighter-rouge&quot;&gt;Brendan Eich&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;JavaScript&lt;/code&gt;之父)的一个&lt;a href=&quot;http://twitter.com/BrendanEich/status/128975787448741891&quot;&gt;tweet&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;uncurryThis&lt;/code&gt;的最重要的用途，就是&lt;strong&gt;将对象的方法变为函数去使用&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;特殊一点，可以将A对象的方法a使用到B对象上去。在前面&lt;code class=&quot;highlighter-rouge&quot;&gt;2.1&lt;/code&gt;小节中，我们就用到了这个技巧，在&lt;code class=&quot;highlighter-rouge&quot;&gt;Arguments&lt;/code&gt;对象上使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;对象的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;slice&lt;/code&gt;。很有用，不是吗？&lt;/p&gt;

&lt;p&gt;那么怎么实现&lt;code class=&quot;highlighter-rouge&quot;&gt;uncurryThis&lt;/code&gt;呢？&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;扩展Function原型去实现（Brendan Eich写的实现代码）:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Function.prototype.uncurryThis = function () {
      var f = this;
      return function () {
          var a = arguments;
          return f.apply(a[0], [].slice.call(a, 1));
      };
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;使用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var toUpperCase = String.prototype.toUpperCase.uncurryThis();
[ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ].map(toUpperCase)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;运行结果：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ 'FOO', 'BAR', 'BAZ' ]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;独立的函数实现：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var uncurryThis = function(f) {
      var call = Function.call;
      return function() {
          return call.apply(f, arguments);
      };
};
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;使用：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var toUpperCase = uncurryThis(String.prototype.toUpperCase);
[ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot; ].map(toUpperCase)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;运行结果：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[ 'FOO', 'BAR', 'BAZ' ]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;h3 id=&quot;三array的那些事儿&quot;&gt;三、Array的那些事儿&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Array是个很常用的内置对象，在Javascript规范的逐步完善中，其内置方法在不知不觉中已经提供了很多了。本文仅介绍一些常用的方法。&lt;/p&gt;

&lt;h4 id=&quot;31-可以浅度复制数组的slice方法&quot;&gt;3.1 可以浅度复制数组的slice方法&lt;/h4&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.slice(begin[, end])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说明：返回一个新的浅度复制数组，包含从 &lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt; （不包括该元素）的 &lt;code class=&quot;highlighter-rouge&quot;&gt;arr&lt;/code&gt; 中的元素。(&lt;em&gt;原数组内容不发生变化&lt;/em&gt;)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;表示在原数组上，选取的范围。如果&lt;code class=&quot;highlighter-rouge&quot;&gt;end&lt;/code&gt;省略，表示原数组的结尾。 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;begin&lt;/code&gt;省略，表示从0位开始。也可以是负数，表示从原数组的尾部开始计算位置。&lt;/p&gt;

&lt;p&gt;举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1,2,3,4,5,6,7,8];
arr.slice(2,4);      // [3, 4]
arr.slice(4);        // [5, 6, 7, 8]
arr.slice(-3);       // [6, 7, 8]
arr.slice(3, -2);    // [4, 5, 6]
arr.slice(-3, -1);   // [6, 7]
arr.slice();         // [1,2,3,4,5,6,7,8]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;提示&lt;/span&gt;：利用&lt;code class=&quot;highlighter-rouge&quot;&gt;Array.prototype.slice&lt;/code&gt;,我们可以将一个类似array对象，转换为array对象&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;arguments&lt;/code&gt;不是数组，但可以转换为数组。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var args = Array.prototype.slice.call(arguments);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们还可以看一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function a() { return {length:2, 0:&quot;hello&quot;, 1:&quot;world&quot;}}

var t = a();

var z = Array.prototype.slice.call(t);

t instanceof Array;      // false
z instanceof Array       // true
console.log(z);          // [&quot;hello&quot;, &quot;world&quot;] 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;32-不仅仅作用于数组的堆栈操作四方法pushpopshiftunshift&quot;&gt;3.2 不仅仅作用于数组的堆栈操作，四方法：push/pop/shift/unshift&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.push(element1, …, elementN)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.pop()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.shift()&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.unshift(element1, …, elementN)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;将n个元素&lt;code class=&quot;highlighter-rouge&quot;&gt;element1, ..., elementN&lt;/code&gt;追加到数组的尾部，其返回值为调用后数组的长度；&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var sports = [&quot;soccer&quot;, &quot;baseball&quot;];
var total = sports.push(&quot;football&quot;, &quot;swimming&quot;);
console.log(sports); // [&quot;soccer&quot;, &quot;baseball&quot;, &quot;football&quot;, &quot;swimming&quot;]
console.log(total);  // 4
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pop&lt;/code&gt;将数组的最后一个对象删除，其返还值就是这个删除的元素。如果是个空数组，则返回值为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];
var popped = myFish.pop();
console.log(myFish);  // [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;] 
console.log(popped);  // &quot;surgeon&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;shift&lt;/code&gt; 删除数组的第一个数，并且数组内剩余的值，坐标依次前移。返回值为删掉的元素。如果是个空数组，那么返回值为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];
var shifted = myFish.shift();
console.log(myFish);   // [&quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]
console.log(shifted);  // &quot;angel&quot;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unshift&lt;/code&gt;将n个元素&lt;code class=&quot;highlighter-rouge&quot;&gt;element1, ..., elementN&lt;/code&gt;插入道数组的头部。其返回值为调用后数组的长度。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var arr = [1, 2];
arr.unshift(0); // result of call is 3, the new array length
// arr is [0, 1, 2]
arr.unshift(-2, -1); // = 5
// arr is [-2, -1, 0, 1, 2]
arr.unshift( [-3] );
// arr is [[-3], -2, -1, 0, 1, 2]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通过上面这四个方法，可以对数组进行堆栈操作了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;：这四个用作堆栈操作的方法，其实还支持非数组对象。不过，支持的对象需要类似数组。从某种角度而言，这也是支持你实现自定义的具有堆栈功能的对象。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;所谓的类似数组，就是有&lt;code class=&quot;highlighter-rouge&quot;&gt;length&lt;/code&gt;属性，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;0...n&lt;/code&gt;下标去访问元素。仅此，即可！&lt;/p&gt;

&lt;p&gt;看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myQueue = function() {return {length:0}};

var tz = new myQueue();

Array.prototype.push.call(tz, &quot;hello&quot;, &quot;world&quot;);  // 2

console.log(Array.prototype.slice.call(tz));  //[&quot;hello&quot;, &quot;world&quot;] 

Array.prototype.shift.call(tz);     // &quot;hello&quot;

console.log(Array.prototype.slice.call(tz));  //[&quot;world&quot;] 

Array.prototype.unshift.call(tz, &quot;hello&quot;);    // 2

console.log(Array.prototype.slice.call(tz));  //[&quot;hello&quot;, &quot;world&quot;] 

Array.prototype.pop.call(tz);     // &quot;world&quot;

console.log(Array.prototype.slice.call(tz));  //[&quot;hello&quot;] 

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;神奇吧！&lt;/p&gt;

&lt;h4 id=&quot;33-可删可插入的splice方法&quot;&gt;3.3 可删可插入的splice方法&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;array.splice(index , howMany[, element1[, …[, elementN]]])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;array.splice(index)   // SpiderMonkey/Firefox/Chrome extension&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其中， &lt;code class=&quot;highlighter-rouge&quot;&gt;index&lt;/code&gt;表示数组中操作所开始的位置。如果大于数组的长度，那就重定位为数组的尾端。如果是负数，那就从数组的尾端向前移。&lt;code class=&quot;highlighter-rouge&quot;&gt;howMany&lt;/code&gt;，表示要删除的个数，如果是0，则表示不删除。&lt;code class=&quot;highlighter-rouge&quot;&gt;[, element1[, ...[, elementN]]]&lt;/code&gt;，表示要插入的个数。 该方法的返回值为：删除的元素数组。&lt;/p&gt;

&lt;p&gt;看实例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var myFish = [&quot;angel&quot;, &quot;clown&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;];

//removes 0 elements from index 2, and inserts &quot;drum&quot;
var removed = myFish.splice(2, 0, &quot;drum&quot;);
//myFish is [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;mandarin&quot;, &quot;surgeon&quot;]
//removed is [], no elements removed

//removes 1 element from index 3
removed = myFish.splice(3, 1);
//myFish is [&quot;angel&quot;, &quot;clown&quot;, &quot;drum&quot;, &quot;surgeon&quot;]
//removed is [&quot;mandarin&quot;]

//removes 1 element from index 2, and inserts &quot;trumpet&quot;
removed = myFish.splice(2, 1, &quot;trumpet&quot;);
//myFish is [&quot;angel&quot;, &quot;clown&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]
//removed is [&quot;drum&quot;]

//removes 2 elements from index 0, and inserts &quot;parrot&quot;, &quot;anemone&quot; and &quot;blue&quot;
removed = myFish.splice(0, 2, &quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;);
//myFish is [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;, &quot;trumpet&quot;, &quot;surgeon&quot;]
//removed is [&quot;angel&quot;, &quot;clown&quot;]

//removes 2 elements from index 3
removed = myFish.splice(3, Number.MAX_VALUE);
//myFish is [&quot;parrot&quot;, &quot;anemone&quot;, &quot;blue&quot;]
//removed is [&quot;trumpet&quot;, &quot;surgeon&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;提示&lt;/span&gt;：我们可以用splice方法来实现数组的堆栈操作：push/pop/shift/unshift方法&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;函数方式实现：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var push = function(arr) {
    var args = Array.prototype.slice.call(arguments,1);
    args = [arr.length, 0].concat(args);
    Array.prototype.splice.apply(arr, args);
    return arr.length;
}

var pop = function(arr) {
    if (arr.length==0) return undefined;
    var el = Array.prototype.splice.call(arr, arr.length-1);
    return el[0];
}

var shift = function(arr) {
    if (arr.length==0) return undefined;
    var el = Array.prototype.splice.call(arr, 0, 1);
    return el[0];
}


var unshift = function(arr) {
    var args = Array.prototype.slice.call(arguments,1);
    args = [0, 0].concat(args);
    Array.prototype.splice.apply(arr, args);
    return arr.length;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;原型方式实现：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Array.prototype.push = function() {
    var self = this;
    var args = Array.prototype.slice.call(arguments);
    args = [self.length, 0].concat(args);
    Array.prototype.splice.apply(self, args);
    return self.length;
}

Array.prototype.pop = function() {
    var self = this;
    if (self.length==0) return undefined;
    var el = Array.prototype.splice.call(self, self.length-1);
    return el[0];
}

Array.prototype.shift = function() {
    var self = this;
    if (self.length==0) return undefined;
    var el = Array.prototype.splice.call(self, 0, 1);
    return el[0];
}


Array.prototype.unshift = function() {
    var self = this;
    var args = Array.prototype.slice.call(arguments);
    args = [0, 0].concat(args);
    Array.prototype.splice.apply(self, args);
    return self.length;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;splice&lt;/code&gt;方法来替代实现的，所以，这些方法不能用于类似数组对象。&lt;/p&gt;

&lt;p&gt;笔者做了下性能对比测试：原生的最快，原型形式模拟的次之，函数形式模拟的最慢。性能测试见：&lt;a href=&quot;http://jsperf.com/splice-vs-push-pop-shift-unshift&quot;&gt;http://jsperf.com/splice-vs-push-pop-shift-unshift&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;34-foreachmapreduce的实现与效率&quot;&gt;3.4 forEach/map/reduce的实现与效率！&lt;/h4&gt;

&lt;p&gt;先看定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.forEach(callback[, thisArg])&lt;/p&gt;

  &lt;p&gt;arr.reduce(callback,[initialValue])&lt;/p&gt;

  &lt;p&gt;arr.map(callback[, thisArg])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;给使用示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numbers=[]
for(var i=0; i&amp;lt;100; ++i) {
    numbers[i] = i;
}

var sum = 0;
numbers.forEach(function(item) {
  sum += item;
})

console.log(sum);   //4950

var sum = numbers.reduce(function(sum, item){
    return sum+item;
}, 0);

console.log(sum);  //4950

numbers.slice(1,4).map(function(item){return Math.pow(item,2)});  //[1, 4, 9]

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不太想写新手入门教程。写到这里，想说的是&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;下面几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;可以替代&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;的实现，并且效率略高一点点。实现和测试可见：&lt;a href=&quot;http://jsperf.com/apply-vs-loop-for-max/2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://jsperf.com/apply-vs-loop-for-max/2&lt;/code&gt;&lt;/a&gt;；&lt;/li&gt;
  &lt;li&gt;无论&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;，都没有手写的&lt;code class=&quot;highlighter-rouge&quot;&gt;loop&lt;/code&gt;循环效率高。具体测试可见&lt;a href=&quot;http://jsperf.com/apply-vs-loop-for-max/2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://jsperf.com/apply-vs-loop-for-max/2&lt;/code&gt;&lt;/a&gt;；&lt;/li&gt;
  &lt;li&gt;无论&lt;code class=&quot;highlighter-rouge&quot;&gt;forEach&lt;/code&gt;还是&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;，其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;callback&lt;/code&gt;都是同步执行的，&lt;code class=&quot;highlighter-rouge&quot;&gt;async.js&lt;/code&gt;框架中提供了对应的异步实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;35-其他joinconcatsortreverseeverysome&quot;&gt;3.5 其他：join/concat/sort/reverse/every/some…&lt;/h4&gt;

&lt;p&gt;Array内置了很多方法，下面在给出几个使用较多的方法的定义及使用示例。&lt;/p&gt;

&lt;p&gt;定义：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;str = arr.join(separator)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;arr.concat(value1, value2, …, valueN)&lt;/p&gt;

  &lt;p&gt;arr.sort([compareFunction])&lt;/p&gt;

  &lt;p&gt;arr.reverse()&lt;/p&gt;

  &lt;p&gt;arr.every(callback[, thisArg])&lt;/p&gt;

  &lt;p&gt;arr.some(callback[, thisArg])&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = new Array(&quot;Wind&quot;,&quot;Rain&quot;,&quot;Fire&quot;);
var myVar1 = a.join();      // assigns &quot;Wind,Rain,Fire&quot; to myVar1
var myVar2 = a.join(&quot;, &quot;);  // assigns &quot;Wind, Rain, Fire&quot; to myVar2
var myVar3 = a.join(&quot; + &quot;); // assigns &quot;Wind + Rain + Fire&quot; to myVar3


var alpha = ['a', 'b', 'c'];
var alphaNumeric = alpha.concat(1, [2, 3]);   //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3] 
alphaNumeric = alpha.concat(1,[2,3],[[4]]);   //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, 1, 2, 3, [4]]
 

var scores = [1, 2, 10, 21]; 
scores.sort(); // [1, 10, 2, 21]
scores.sort(function(a,b){return a-b}); //[1, 2, 10, 21]


var myArray = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;];
myArray.reverse();    // [&quot;three&quot;, &quot;two&quot;, &quot;one&quot;]



function isBigEnough(element, index, array) {
  return (element &amp;gt;= 10);
}
var passed = [12, 5, 8, 130, 44].every(isBigEnough);   //false
passed = [12, 54, 18, 130, 44].every(isBigEnough);     //true


passed = [2, 5, 8, 1, 4].some(isBigEnough);  //false
passed = [12, 5, 8, 1, 4].some(isBigEnough);  //true

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;：&lt;code class=&quot;highlighter-rouge&quot;&gt;concat&lt;/code&gt;是浅层复制，从上面例子中也可以看出来。&lt;/strong&gt;，如果想实现深层复制，可以参考&lt;code class=&quot;highlighter-rouge&quot;&gt;underscore.js&lt;/code&gt;框架中的&lt;code class=&quot;highlighter-rouge&quot;&gt;_.flatten&lt;/code&gt;,或者参考&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype.js&lt;/code&gt;框架中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Array#flatten()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;四结束&quot;&gt;四、结束&lt;/h3&gt;

&lt;p&gt;非常高兴，你能耐心看完这篇文章，希望能给你带来帮助！欢迎讨论！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[4] -- Router</title>
   <link href="http://www.blogways.net/blog/2014/06/16/node-express4.x-api-4.html"/>
   <updated>2014-06-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/16/node-express4.x-api-4</id>
   <content type="html">&lt;h2 id=&quot;express4x-api-翻译4--router&quot;&gt;Express4.x API 翻译[4] – Router&lt;/h2&gt;

&lt;h3 id=&quot;router&quot;&gt;Router()&lt;/h3&gt;

&lt;p&gt;路由器是一个孤立的中间件和路由实例。路由器被看作是唯一能胜任中间件和路由的迷你应用。每个express应用都包含一个内置的路由器。&lt;/p&gt;

&lt;p&gt;路由器行为像中间件本身，可以在应用或者其他路由里使用。&lt;/p&gt;

&lt;p&gt;使用”express.Router()”创建一个新的路由器。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var router = express.Router([options]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;改变路由行为的可选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;caseSensitive 开启大小写敏感，默认不开启，”/Foo”和”/foo”同样处理。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Strict 开启严格路由，默认”/foo”和”/foo/”指向同一个路由。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // invoked for any requests passed to this router
  router.use(function(req, res, next) {
    // .. some logic here .. like any other middleware
    next();
  });
	
  // will handle any request that ends in /events
  // depends on where the router is &quot;use()'d&quot;
  router.get('/events', function(req, res, next) {
    // ..
  });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然后你可以使用一个特定的根url路由器，像这样分离路由到多个文件或者迷你应用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// only requests to /calendar/* will be sent to our &quot;router&quot;
app.use('/calendar', router); ### router.use([path], function)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用中间件功能，可配置挂载路径，默认挂到”/”根路径。&lt;/p&gt;

&lt;p&gt;中间件像一个管道，请求从第一个你定义的中间件开始，然后沿着这个线路一直向下，匹配每一个中间件堆栈中符合的路由。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var app = express();
var router = express.Router();

// simple logger for this router's requests
// all requests to this router will first hit this middleware
router.use(function(req, res, next) {
  console.log('%s %s %s', req.method, req.url, req.path);
  next();
});

// this will only be invoked if the path ends in /bar
router.use('/bar', function(req, res, next) {
  // ... maybe some additional /bar logging ...
  next();
});

// always invoked
router.use(function(req, res, next) {
  res.send('Hello World');
});

app.use('/foo', router);

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;挂载路径被剥离，是不可见的中间件功能。此功能的主要用途是挂载中间件的操作不需要根据它的前缀路径来修改代码。&lt;/p&gt;

&lt;p&gt;使用router.user()定义中间件的顺序非常重要，他们依次被调用，因此这个决定中间件的优先级。例如通常logger是第一个需要用到的中间件，用来记录每个请求：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var logger = require('morgan');

router.use(logger());
router.use(express.static(__dirname + '/public'));
router.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在假设你想忽略静态文件请求的日志，但在logger()之间继续记录路径跟中间件日志，你只需要将static()移到前面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.use(express.static(__dirname + '/public'));
router.use(logger());
router.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个具体的例子是来自多个文件目录的文件服务，优先从”./public”中查找：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads')); ### router.param([name], callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;路由参数映射逻辑。例如当一个路由中包含:user，加载逻辑会自动提供req.user给路由，或者执行参数输入验证。&lt;/p&gt;

&lt;p&gt;下面的代码说明了如果回调，很像中间件，从而支持异步操作，但多了一个id参数。当执行加载用户时，验证req.user，不成功抛出一个错误到next(err)。&lt;/p&gt;

&lt;p&gt;要注意，触发一个命名参数函数来运行路由，仅仅在next在没有被参数处理错误调用的情况下执行。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      return next(err);
    }
    else if (!user) {
      return next(new Error('failed to load user'));
    }
    
    req.user = user;
    next();
  });
});

// this route uses the &quot;:user&quot; named parameter
// which will cause the 'user' param callback to be triggered
router.get('/users/:user', function(req, res, next) {
  // req.user WILL be defined here
  // if there was an error, normal error handling will be triggered
  // and this function will NOT execute
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外你可能只传递一个回调函数，在这种情况下你有机会修改router.param()API。例如express_params定义的回调函数允许你限制参数为给定的正则表达式。&lt;/p&gt;

&lt;p&gt;这个例子有点超前，检查当第二个参数为正则表达式时，返回类似”user”参数示例的回调函数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该方法现在被用来有效的验证参数，或者解析他们提供分组：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.param('id', /^\d+$/);

router.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

router.param('range', /^(\w+)\.\.(\w+)?$/);

router.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;router.user()方法也支持命名参数，使其他路由提供的挂载点能使用命名参数预加载。&lt;/p&gt;

&lt;h3 id=&quot;routerroutepathxl&quot;&gt;router.route(path)xl&lt;/h3&gt;

&lt;p&gt;返回一个可以用来处理HTTP请求带有可选中间件的中间件路由。推荐使用router.route()避免重复路由定义和拼写错误。&lt;/p&gt;

&lt;p&gt;根据前面所学建立route.param()示例，我们看到router.route()可以让我们轻松的应对各种HTTP请求处理。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var router = express.Router();

router.param('user_id', function(req, res, next, id) {
  // sample user, would actually fetch from DB, etc...
  req.user = {
    id: id,
    name: 'TJ'
  };
  next();
});

router.route('/users/:user_id')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(req.user);
})
.put(function(req, res, next) {
  // just an example of maybe updating the user
  req.user.name = req.params.name;
  // save user ... etc
  res.json(req.user);
})
.post(function(req, res, next) {
  next(new Error('not implemented'));
})
.delete(function(req, res, next) {
  next(new Error('not implemented'));
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个方法重新使用单’/users/:user_id’路径，添加对各种HTTP请求的处理。&lt;/p&gt;

&lt;h3 id=&quot;routerverbpath-callback-callback&quot;&gt;router.VERB(path, [callback…], callback)&lt;/h3&gt;

&lt;p&gt;Express中router.VERB()方法提供路由功能，其中WERB属于HTTP请求，例如router.post()。可以有多个回调，所有回调同等对待，行为很像中间件，遇到异常时这些回调会调用next(‘route’)不再执行剩余的回调。这种机制可以用来执行有先决条件的路由，然后将控制权移交到其他没有限制的路由。&lt;/p&gt;

&lt;p&gt;下面的代码演示了最简单路由定义。Express将这些路径转换成正则表达式，内部用来匹配即将到来的请求。在执行路由匹配时查询字符串不用考虑，例如”GET /”匹配的路由与”GET /?name=tobi”是一致的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.get('/', function(req, res){
  res.send('hello world');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;正则表达式也可以使用，当你有非常特殊的限制的时候是很有用的，例如”GET /commits/71dbb9c”能很好的匹配路由”GET /commits/71dbb9c..4c084f9”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;router.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[3] -- Response</title>
   <link href="http://www.blogways.net/blog/2014/06/13/node-express4.x-api-3.html"/>
   <updated>2014-06-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/13/node-express4.x-api-3</id>
   <content type="html">&lt;h2 id=&quot;express4x-api-翻译3--response&quot;&gt;Express4.x API 翻译[3] – Response&lt;/h2&gt;

&lt;h3 id=&quot;resstatuscode&quot;&gt;res.status(code)&lt;/h3&gt;
&lt;p&gt;node &lt;code class=&quot;highlighter-rouge&quot;&gt;res.statusCode=&lt;/code&gt;可链接的别名&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.status(404).sendfile('path/to/404.png'); ### res.set(field, [value]) 设置响应头内字段值，或者通过一个对象一次设置多个字段。

res.set('Content-Type', 'text/plain');

res.set({
  'Content-Type': 'text/plain',
  'Content-Length': '123',
  'ETag': '12345'
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;res.header(field, [value])别名。&lt;/p&gt;

&lt;h3 id=&quot;resgetfield&quot;&gt;res.get(field)&lt;/h3&gt;
&lt;p&gt;获取响应头内字段值，不区分大小写。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.get('Content-Type');
// =&amp;gt; &quot;text/plain&quot; ### res.cookie(name, value, [options]) 设置cookie名称和值，可以是字符串或者对象转换成的JSON。路径选项默认为&quot;/&quot;。

res.cookie('name', 'tobi', { domain: '.example.com', path: '/admin', secure: true });
res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;maxAge选项可以很方便的设置从当前时间开始以毫秒为单位的过期时间。下面的写法等同于上一个例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个对象可以通过序列化成JSON传递，它由bodyParser()中间件自动解析。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('cart', { items: [1,2,3] });
res.cookie('cart', { items: [1,2,3] }, { maxAge: 900000 });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方法也支持签名cookie。添加一个简单的signed选项。res.cookie()将隐藏传递给cookieParser(secret)对值签名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('name', 'tobi', { signed: true });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后你可以使用req.signedCookie来访问这个值。&lt;/p&gt;

&lt;h3 id=&quot;resclearcookiename-options&quot;&gt;res.clearCookie(name, [options])&lt;/h3&gt;
&lt;p&gt;删除cookie里面值。默认路径为”/”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.cookie('name', 'tobi', { path: '/admin' });
res.clearCookie('name', { path: '/admin' }); ### res.redirect([status], url)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;重定向到给定的url，可选状态编码默认为302”Found”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('/foo/bar');
res.redirect('http://example.com');
res.redirect(301, 'http://example.com');
res.redirect('../login');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Express支持几种形式的重定向，首先一个完整合格的URI重定向到不同的域名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('http://google.com');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第二种形式是相对路径的重定向，例如你正在http://example.com/admin/post/new，接着重定向到/admin，你将会登录http://example.com/admin：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('/admin');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其次相对于应用程序挂载点的相对重定向。例如你有一个博客应用程序挂载在/blog下，理论上来说并不知道它挂载在哪边，因此重定向到/admin/post/new将会跳转到http://example.com/admin/post/new，相对挂载点的重定向将会跳转到http://example.com/blog/admin/post/new：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('admin/post/new');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然相对路径的重定向也是支持的。如果你在http://example.com/admin/post/new，下面的重定向转跳转到http://example.com/admin/post：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('..');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后一个特殊情况是back重定向，重定向到Referer(或Refererer)，找不到默认为/。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.redirect('back');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reslocation&quot;&gt;res.location&lt;/h3&gt;
&lt;p&gt;设置location头。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.location('/foo/bar');
res.location('foo/bar');
res.location('http://example.com');
res.location('../login');
res.location('back');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可以使用res.redirect()相同的urls。&lt;/p&gt;

&lt;p&gt;例如你的应用挂载在/blog下，使用下面的代码设置location头为/blog/admin：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.location('admin') ### res.send([body|status], [body]) 发送一个响应。

res.send(new Buffer('whoop'));
res.send({ some: 'json' });
res.send('
some html

');
res.send(404, 'Sorry, we cannot find that!');
res.send(500, { error: 'something blew up' });
res.send(200);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此方法适用于执行大量的简单非流式的响应任务，例如在未提前定义和提供自动HEAD和HTTP缓存刷新支持的情况下自动设定Content-Length。
当传入的内容为Buffer，那么Content-Type会被设置为”application/octet-stream”，除非预先定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.set('Content-Type', 'text/html');
res.send(new Buffer('
some html

'));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当发送字符串时Content-Type设置默认为”text/html”：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.send('
some html

');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当发送数组或者对象时Express将会转换成JSON格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.send({ user: 'tobi' })
res.send([1,2,3])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后如果返回的是一个数字，没有前面提到的任何一个响应体，Express会为你设置一个响应字符串。例如200将会响应文本”OK”，400响应”Not Found”等等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.send(200)
res.send(404)
res.send(500) ### res.json([status|body], [body])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;发送一个JSON返回。当返回对象或者数组时该方法与res.send()相同，然而它可以用来将非对象(null, undefined, 等等)转换成精准的JSON，尽管严格来说这些并不是有效的JSON。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.json(null)
res.json({ user: 'tobi' })
res.json(500, { error: 'message' }) ### res.jsonp([status|body], [body])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用JSONP发送JSON响应。该方法与res.json()相同，但多了对JSONP回调的支持。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.jsonp(null)
// =&amp;gt; null

res.jsonp({ user: 'tobi' })
// =&amp;gt; { &quot;user&quot;: &quot;tobi&quot; }

res.jsonp(500, { error: 'message' })
// =&amp;gt; { &quot;error&quot;: &quot;message&quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认JSONP回调函数名是callback，但你可以通过修改jsonp callback name参数重新定义。以下是JSONP响应的一些例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ?callback=foo
res.jsonp({ user: 'tobi' })
// =&amp;gt; foo({ &quot;user&quot;: &quot;tobi&quot; })

app.set('jsonp callback name', 'cb');

// ?cb=foo
res.jsonp(500, { error: 'message' })
// =&amp;gt; foo({ &quot;error&quot;: &quot;message&quot; }) ### res.type(type)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置Content-Type类型为mime的类型，或者当”/”存在时Content-Type被简单的设置成该类型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.type('.html');
res.type('html');
res.type('json');
res.type('application/json');
res.type('png'); ### res.format(object)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行请求时存在请求Accept头上下文转换。该方法使用req.accepted，这是一个按可接受类型重要性排序的数组，否则第一个回调函数被调用。当没有匹配的回调函数执行时服务器返回406 “Not Acceptable”，或者调用默认的回调函数。&lt;/p&gt;

&lt;p&gt;设置Content-Type为你选择一个回调函数，但你可以在回调函数中使用res.set()或者res.type()等修改。&lt;/p&gt;

&lt;p&gt;下例当Accept头字段设置成”application/json”或”&lt;em&gt;/json”时响应{ “message”: “hey” }，但如果设置成”&lt;/em&gt;/*“时将会响应”hey”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.format({
  'text/plain': function(){
    res.send('hey');
  },
  
  'text/html': function(){
    res.send('
hey

');
  },
  
  'application/json': function(){
    res.send({ message: 'hey' });
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了规范化的MIME类型你还可以使用扩展名映射这些类型，提供一个稍微不那么详细的实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.format({
  text: function(){
    res.send('hey');
  },
  
  html: function(){
    res.send('
hey

');
  },
  
  json: function(){
    res.send({ message: 'hey' });
  }
}); ### res.attachment([filename])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置Content-Disposition头字段为”attachment”。如果给定一个文件名，那么Content-Type将会通过res.type()自动设置成基于扩展名的类型，Content-Disposition的”filename=”参数同时也被设置。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.attachment();
// Content-Disposition: attachment

res.attachment('path/to/logo.png');
// Content-Disposition: attachment; filename=&quot;logo.png&quot;
// Content-Type: image/png ### res.sendfile(path, [options], [fn]])
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;传输文件到给定的路径。&lt;/p&gt;

&lt;p&gt;自动设置默认基于文件扩展名的Content-Type响应头。当传输发生错误时fn(err)回调函数被调用。&lt;/p&gt;

&lt;p&gt;选项：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;maxAge 以毫秒为单位默认为0&lt;/li&gt;
  &lt;li&gt;root 相对文件名根目录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在下例中该方法为文件服务提供细粒度支持：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/user/:uid/photos/:file', function(req, res){
  var uid = req.params.uid
    , file = req.params.file;
    
  req.user.mayViewFilesFrom(uid, function(yes){
    if (yes) {
      res.sendfile('/uploads/' + uid + '/' + file);
    } else {
      res.send(403, 'Sorry! you cant see that.');
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如有任何问题或者疑问请参阅send附加文档。&lt;/p&gt;

&lt;h3 id=&quot;resdownloadpath-filename-fn&quot;&gt;res.download(path, [filename], [fn])&lt;/h3&gt;

&lt;p&gt;传输路径中的文件作为附件，通常浏览器会提醒用户下载。Content-Disposition “filename=”参数，也就是显示在浏览器对话框的默认文件名，你也可以提供一个自定义文件名。&lt;/p&gt;

&lt;p&gt;当传输完成或者中途发生错误时将会调用fn回调函数，该方法使用res.sendfile()来传输文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.download('/report-12345.pdf');

res.download('/report-12345.pdf', 'report.pdf');

res.download('/report-12345.pdf', 'report.pdf', function(err){
  if (err) {
    // handle error, keep in mind the response may be partially-sent
    // so check res.headersSent
  } else {
    // decrement a download credit etc
  }
}); ### res.links(links) 加入给定的链接来填充&quot;Link&quot;响应头字段。

res.links({
  next: 'http://api.example.com/users?page=2',
  last: 'http://api.example.com/users?page=5'
}); 处理后：

Link: &amp;lt;http://api.example.com/users?page=2&amp;gt;; rel=&quot;next&quot;, 
      &amp;lt;http://api.example.com/users?page=5&amp;gt;; rel=&quot;last&quot; ### res.locals
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;响应本地化变量作用域为request，因此只适用于在该request/response周期内呈现的视图，如果有的话。其实该API跟app.locals是等同的。&lt;/p&gt;

&lt;p&gt;这个对象适用于的request级别的信息，例如request路径，用户认证，用户设置等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(function(req, res, next){
  res.locals.user = req.user;
  res.locals.authenticated = ! req.user.anonymous;
  next();
}); ### res.render(view, [locals], callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;渲染一个视图，同时向回调函数传递渲染后的字符串。发生错误时内部调用next(err)。回调函数传入可能发生的错误以及渲染后的页面，这样就不会自动执行响应了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;res.render('index', function(err, html){
  // ...
});

res.render('user', { name: 'Tobi' }, function(err, html){
  // ...
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[2] -- Request</title>
   <link href="http://www.blogways.net/blog/2014/06/11/node-express4.x-api-2.html"/>
   <updated>2014-06-11T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/11/node-express4.x-api-2</id>
   <content type="html">&lt;h2 id=&quot;express4x-api-翻译2--request&quot;&gt;Express4.x API 翻译[2] – Request&lt;/h2&gt;

&lt;h3 id=&quot;reqparams&quot;&gt;req.params&lt;/h3&gt;

&lt;p&gt;此属性是一个包含映射路由”parameters”的对象。例如你使用/user/:name路由，那么”name”属性对你来说就是一个req.params.name变量。该对象默认为{}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /user/tj
req.params.name
// =&amp;gt; &quot;tj&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当在定义路由规则时使用了正则表达式，使用req.params[N]获取所有参数匹配数组，其中N表示数组的第几个。此规则适用于包含未定义的通配符的路由字符串，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;/file/*&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /file/javascripts/jquery.js
req.params[0]
// =&amp;gt; &quot;javascripts/jquery.js&quot; ### req.query
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此属性是一个包含解析查询字符串的对象，默认为{}。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /search?q=tobi+ferret
req.query.q
// =&amp;gt; &quot;tobi ferret&quot;

// GET /shoes?order=desc&amp;amp;shoe[color]=blue&amp;amp;shoe[type]=converse
req.query.order
// =&amp;gt; &quot;desc&quot;

req.query.shoe.color
// =&amp;gt; &quot;blue&quot;

req.query.shoe.type
// =&amp;gt; &quot;converse&quot; ### req.param(name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回当前name参数的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ?name=tobi
req.param('name')
// =&amp;gt; &quot;tobi&quot;

// POST name=tobi
req.param('name')
// =&amp;gt; &quot;tobi&quot;

// /user/tobi for /user/:name 
req.param('name')
// =&amp;gt; &quot;tobi&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查找优先级如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;req.params&lt;/li&gt;
  &lt;li&gt;req.body&lt;/li&gt;
  &lt;li&gt;req.query&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;直接使用req.body，req.params，和req.query应该更新清晰，除非你确实需要接收每个对象的输入。&lt;/p&gt;

&lt;h3 id=&quot;reqroute&quot;&gt;req.route&lt;/h3&gt;

&lt;p&gt;当前匹配的路由包含多个属性，如路由的原始路径字符串以及转换后的正则表达式等。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/user/:id?', function(req, res){
  console.log(req.route);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;path:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'/user/:id?',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;keys:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;name:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'id',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;optional:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;regexp:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/^\/user(?:\/(&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;^\/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;+?))?\/?$/i,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;params:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;id:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;###&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;req.cookies&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当cookieParser()中间件使用时该对象默认为{}，除此之外还包含由用户代理发送的cookies。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Cookie: name=tj
req.cookies.name
// =&amp;gt; &quot;tj&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如有任何问题或者疑问请参阅cookie-parser附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqsignedcookies&quot;&gt;req.signedCookies&lt;/h3&gt;

&lt;p&gt;当cookieParser(secret)中间件使用该对象默认为{}，还包括用户代理发送的签名cookies，未签名以及准备使用的。签名cookies存放于一个单独的对象，以显示开发者的意图，否则可以通过在req.cookie设置值发起恶意攻击，从而很轻易的欺骗。需要注意的是签名的cookie并不意味着它是隐藏的或者是加密的，这个防止篡改的秘密只是简单的将签名私有化。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Cookie: user=tobi.CP7AWaXDfAKIRfH49dQzKJx7sKzzSoPq7/AcBBRVwlI3
req.signedCookies.user
// =&amp;gt; &quot;tobi&quot; 如有任何问题或者疑问请参阅cookie-parser附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqgetfield&quot;&gt;req.get(field)&lt;/h3&gt;

&lt;p&gt;获取请求头内的field字段，不区分大小写。Referrer和Referer字段可以互换。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.get('Content-Type');
// =&amp;gt; &quot;text/plain&quot;

req.get('content-type');
// =&amp;gt; &quot;text/plain&quot;

req.get('Something');
// =&amp;gt; undefined 别名为req.header(field)。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqacceptstypes&quot;&gt;req.accepts(types)&lt;/h3&gt;

&lt;p&gt;检查给定的types是不是可以接受的，当结果为true时返回最佳匹配，否则返回undefined，在这种情况下你应该返回406”Not Acceptable”。&lt;/p&gt;

&lt;p&gt;type可以是单一的mine类型的字符串，比如”application/json”，扩展名如”json”，也可以是以逗号分隔的列表或者数组。当为列表或数组时将返回最佳匹配。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Accept: text/html
req.accepts('html');
// =&amp;gt; &quot;html&quot;

// Accept: text/*, application/json
req.accepts('html');
// =&amp;gt; &quot;html&quot;
req.accepts('text/html');
// =&amp;gt; &quot;text/html&quot;
req.accepts('json, text');
// =&amp;gt; &quot;json&quot;
req.accepts('application/json');
// =&amp;gt; &quot;application/json&quot;

// Accept: text/*, application/json
req.accepts('image/png');
req.accepts('png');
// =&amp;gt; undefined

// Accept: text/*;q=.5, application/json
req.accepts(['html', 'json']);
req.accepts('html, json');
// =&amp;gt; &quot;json&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqacceptscharsetcharset&quot;&gt;req.acceptsCharset(charset)&lt;/h3&gt;
&lt;p&gt;检查给定的字符集是否可以支持。&lt;/p&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqacceptslanguagelang&quot;&gt;req.acceptsLanguage(lang)&lt;/h3&gt;
&lt;p&gt;检查给定的lang是否支持。&lt;/p&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅accepts附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqistype&quot;&gt;req.is(type)&lt;/h3&gt;

&lt;p&gt;检查传入请求字符串是否包含了”Content-Type”头字段，并且给出匹配的mine类型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// With Content-Type: text/html; charset=utf-8
req.is('html');
req.is('text/html');
req.is('text/*');
// =&amp;gt; true

// When Content-Type is application/json
req.is('json');
req.is('application/json');
req.is('application/*');
// =&amp;gt; true

req.is('html');
// =&amp;gt; false
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如有任何问题或者疑问，请参阅type-is附加文档。&lt;/p&gt;

&lt;h3 id=&quot;reqip&quot;&gt;req.ip&lt;/h3&gt;

&lt;p&gt;返回远程地址，或者当信任代理已启用时返回代理地址。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.ip
// =&amp;gt; &quot;127.0.0.1&quot; ### req.ips
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当信任代理为true时，解析”X-Forwarded-For”ip地址列表返回一个数组，否则返回一个空数组。例如当值为”client, proxy1, proxy2”时你会获得[“client”, “proxy1”, “proxy2”]数组，其中”proxy2”是最远的下游地址。&lt;/p&gt;

&lt;h3 id=&quot;reqpath&quot;&gt;req.path&lt;/h3&gt;
&lt;p&gt;返回请求的URL路径名。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// example.com/users?sort=desc
req.path
// =&amp;gt; &quot;/users&quot; ### req.host Returns the hostname from the &quot;Host&quot; header field (void of portno).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回从”Host”头字段内取出的主机名(不包含端口)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Host: &quot;example.com:3000&quot;
req.host
// =&amp;gt; &quot;example.com&quot; ### req.fresh
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查请求是否刷新，通过对Last-Modified和/或ETag进行匹配，表明资源是不是最新的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.fresh
// =&amp;gt; true 如有任何问题或者疑问，请参阅fresh附加文档。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;reqstale&quot;&gt;req.stale&lt;/h3&gt;

&lt;p&gt;检查请求是否过期，如果Last-Modified和/或ETag不匹配，表有资源是过期的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.stale
// =&amp;gt; true ### req.xhr
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查请求头里是否包含”X-Requested-With”字段并且值为”XMLHttpRequest”(jQuery等)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;req.xhr
// =&amp;gt; true ### req.protocol 当使用TLS请求时返回&quot;http&quot;或&quot;https&quot;协议字符串。当信任路由设置为开启时&quot;X-Forwarded-Proto&quot;头字段将被信任。如果你正在运行一个支持https协议的反向代理，那么这个是支持的。


req.protocol
// =&amp;gt; &quot;http&quot; ### req.secure
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;检查TLS连接是否建立。这是一个简写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;'https' == req.protocol; ### req.subdomains Return subdomains as an array. 返回子域数组。

// Host: &quot;tobi.ferrets.example.com&quot;
req.subdomains
// =&amp;gt; [&quot;ferrets&quot;, &quot;tobi&quot;] ### req.originalUrl
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此属性很像req.url，但它保留了原始请求的url，允许你在做内部路由时自由重写req.url。例如app.use()中间件将重写req.url重新定义挂载点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /search?q=something
req.originalUrl
// =&amp;gt; &quot;/search?q=something&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>node 插件化开发</title>
   <link href="http://www.blogways.net/blog/2014/06/10/node-plugin.html"/>
   <updated>2014-06-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/10/node-plugin</id>
   <content type="html">&lt;h2 id=&quot;一非插件化开发在node-express下的实现&quot;&gt;一、非插件化开发在node-express下的实现&lt;/h2&gt;
&lt;p&gt;以下为我们日志分析系统中添加一个查询明细页面要添加的代码：&lt;/p&gt;

&lt;p&gt;1、建立明细页面调转逻辑控制文件detail.js，添加代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.qrydetail = function(req, res) {
	res.render('query/detail',{
	    layout: false,
		errors: req.flash('error') 
	})
} 2、建立登录页面detail.html；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、在路由控制文件routes.js引入detail.js：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var detailModule = require('../app/controllers/detail')
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、在路由控制文件routes.js中添加路由：app.get(‘/detail.html’,       detailModule.qrydetail)；&lt;/p&gt;

&lt;p&gt;访问：http://localhost:3000/detail.html&lt;/p&gt;

&lt;p&gt;缺点：&lt;/p&gt;

&lt;p&gt;1) 每次添加链接都需要修改routes.js，时间久了文件很大不便于维护；&lt;/p&gt;

&lt;p&gt;2) 多人协作routes.js会同时被多人修改；&lt;/p&gt;

&lt;p&gt;3) 无法支持不改动代码多模块的安装卸载&lt;/p&gt;

&lt;h2 id=&quot;二插件化模块添加&quot;&gt;二、插件化模块添加&lt;/h2&gt;

&lt;p&gt;1、plugin安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ npm install plugin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、与express集成&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var plugin = require('plugin')；
//Plug-in technology    
plugin(app).require(config.root+'/app/controllers/plugin').load();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上代码含义为：node服务启动时会加载’/app/controllers/plugin’目录下所有js文件作为项目插件（当然文件内容有一定格式）&lt;/p&gt;

&lt;p&gt;3、添加一个查询明细页面&lt;/p&gt;

&lt;p&gt;1) 建立明细查询模块页面detail.js，代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.plugin = function(server) {

   server.get('/detail.html', function(req, res) { 
        res.render('query/detail',{
		    layout: false,
			errors: req.flash('error') 
		})   	              
   });
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2) 建立登录页面detail.html；&lt;/p&gt;

&lt;p&gt;访问：http://localhost:3000/detail.html&lt;/p&gt;

&lt;p&gt;优点：&lt;/p&gt;

&lt;p&gt;a) 无需修改routes.js；&lt;/p&gt;

&lt;p&gt;b) 支持不改动代码多模块的安装卸载(卸载将’/app/controllers/plugin’目录下detail.js文件删除即可)&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>node 日志管理log4js</title>
   <link href="http://www.blogways.net/blog/2014/06/09/node-log4js.html"/>
   <updated>2014-06-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/09/node-log4js</id>
   <content type="html">&lt;h2 id=&quot;一默认的控制台输出&quot;&gt;一、默认的控制台输出&lt;/h2&gt;
&lt;p&gt;我们使用express框架时，开发模式用node或者supervisor启动nodejs应用时，控制台都是显示如下的日志。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /css/bootstrap.min.css 304 1ms
GET /css/my.css 304 0ms
GET /js/bootstrap.min.js 304 4ms
GET /js/jquery-1.9.1.min.js 304 6ms
GET /js/holder.js 304 3ms
GET /cat/json/latest 200 6ms
GET /cat/json/master 200 4ms
GET /cat/json/classic 200 2ms
GET /about 200 6ms
GET /css/bootstrap.min.css 304 2ms
GET /css/my.css 304 2ms
GET /js/bootstrap.min.js 304 2ms
GET /js/jquery-1.9.1.min.js 304 1ms
GET /js/holder.js 304 1ms
GET /js/bootstrap.min.js 304 1ms
GET / 304 6ms
GET /js/jquery-1.9.1.min.js 304 2ms
GET /css/my.css 304 1ms
GET /css/bootstrap.min.css 304 1ms
GET /js/bootstrap.min.js 304 2ms
GET /js/holder.js 304 2ms
GET /cat/json/latest 200 3ms
GET /cat/json/master 200 2ms
GET /cat/json/classic 200 2ms
GET /admin/ 304 13ms
GET /css/bootstrap.min.css 304 3ms
GET /js/jquery-1.9.1.min.js 304 2ms
GET /css/my.css 304 2ms
GET /js/bootstrap.min.js 304 1ms
GET /js/holder.js 304 2ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以在代码中，用console.log()打印一些控制台日志。&lt;/p&gt;

&lt;p&gt;修改routes/index.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exports.index = function(req, res){
console.log(&quot;This is an index page!&quot;);
res.render('index', {
  		title:'首页|moive.me',
  		page:'index'
  		});
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;访问页面，结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;This is an index page!
GET / 304 19ms
GET /css/bootstrap.min.css 304 4ms
GET /css/my.css 304 2ms
GET /js/jquery-1.9.1.min.js 304 38ms
GET /js/holder.js 304 29ms
GET /js/bootstrap.min.js 304 28ms
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样的输出的结果，都是在控制台显示，一旦server重启日志就丢失了。对于程序开发来说，这样的输出已经够用了。但是在生产环境上，我们希望能把控制台的输出，保存到文件中，而且需要更多的信息，不仅仅是默认的简化的日志信息。&lt;/p&gt;

&lt;p&gt;由于express框架没有日志功能，我们需要引入log4js包来完成这个功能。&lt;/p&gt;

&lt;h2 id=&quot;二配置log4js与express框架集成&quot;&gt;二、配置log4js与express框架集成&lt;/h2&gt;

&lt;p&gt;1、安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install log4js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、修改项目入口配置文件，如日志分析项目express.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var log4js = require('log4js');
log4js.configure({
  appenders: [
    { type: 'console' }, //控制台输出
    {
      type: 'file', //文件输出
      filename: 'logs/log.log', 
      maxLogSize: 1024,
      backups:3,
      category: 'normal' 
    }
  ]
});
var logger = log4js.getLogger('normal');
logger.setLevel('INFO');
...

app.use(log4js.connectLogger(logger, {level:log4js.levels.INFO}));
app.use(app.router);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要在express.js中进行log4js的配置。
appenders中配置了两个输出，一个是控制台输出，一个是文件输出。&lt;/p&gt;

&lt;p&gt;appenders.type=file的对象,指定文件输出位置及文件大小，当超过maxLogSize大小时，会自动生成一个新文件。logs的文件目录要动手创建。
level:log4js.levels.INFO, 设置默认日志输出级别是INFO。&lt;/p&gt;

&lt;p&gt;log4js的输出级别6个: trace, debug, info, warn, error, fatal
logger.trace(‘Entering cheese testing’);
logger.debug(‘Got cheese.’);
logger.info(‘Cheese is Gouda.’);
logger.warn(‘Cheese is quite smelly.’);
logger.error(‘Cheese is too ripe!’);
logger.fatal(‘Cheese was breeding ground for listeria.’);&lt;/p&gt;

&lt;p&gt;如果输出级别是INFO，则不会打印出低于info级别的日志trace,debug，只打印info,warn,error,fatal。这样做的好处在于，在生产环境中我们可能只关心异常和错误，并不关心调试信息。从而大大减少日志的输出，能减少磁盘写入。而在开发环境中，我们可以需要打印非常多的信息，帮助开发人员定位错误，调试代码。&lt;/p&gt;

&lt;p&gt;还有一个好处就是，代码中可以混有各种的日志打印代码。我们只要在一个配置文件中，修改输出级别，日志输出就会发生变化，不用修改所有的代码。如果所有地方都是console.log()，那么上线的时候，改动这个东西就要花很多时间。&lt;/p&gt;

&lt;h2 id=&quot;三根据项目配置log4js&quot;&gt;三、根据项目配置log4js&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;增加replaceConsole代替console.log()&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var log4js = require('log4js');
 log4js.configure({
   appenders: [
     { type: 'console' },{
       type: 'file', 
       filename: 'logs/log.log', 
       maxLogSize: 1024,
       backups:4,
       category: 'normal' 
     }
   ],
   replaceConsole: true
 });
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;调整日志输出的格式&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; app.use(log4js.connectLogger(logger, {level: 
 level:log4js.levels.INFO, format:':method :url'}));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;自动调整日志输出级别&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 日志级别对应规则：
 http responses 3xx, level = WARN
 http responses 4xx &amp;amp; 5xx, level = ERROR
 else, level = INFO	 设置level为auto:

 app.use(log4js.connectLogger(logger, {level: 'auto', format:':method :url'}));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;四调整log4js结构&quot;&gt;四、调整log4js结构&lt;/h2&gt;

&lt;p&gt;我们在配置log4js时会有一个问题。就是以上所有配置信息都是在express.js中做的，logger也是在这里直接定义的。如果在控制器(routes)想用log4js进行输出，我们现在拿不到logger的句柄。&lt;/p&gt;

&lt;p&gt;新建立log.js&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var log4js = require('log4js');

log4js.configure({

    appenders: [
        {
            type: 'console',
            category: &quot;console&quot;

        }, //控制台输出
        {
            type: &quot;file&quot;,
            filename: 'logs/log.log',
            pattern: &quot;_yyyy-MM-dd&quot;,
            maxLogSize: 20480,
            backups: 3,
            category: 'dateFileLog'

        }//日期文件格式
    ],
    replaceConsole: true,   //替换console.log
    levels:{
        dateFileLog: 'debug',
        console: 'debug'
    }
});


var dateFileLog = log4js.getLogger('dateFileLog');
var consoleLog = log4js.getLogger('console');
exports.logger = consoleLog;


exports.use = function(app) {
    app.use(log4js.connectLogger(consoleLog, {level:'INFO', format:':method :url'}));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们把logger单独定义出来，并且做为API暴露出来，此处是开发调试，没有使用文件输出。
这样在其他模块中使用logger输出日志只需如下操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var logger = require('../../log').logger;
logger.debug(&quot;collectTime=%s&quot;,collectTime);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就已经玩转log4js了，如果部署生产需要文件输出只要修改log.js中dateFileLog级别，然后设置exports.logger=dateFileLog即可。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Express4.x API 翻译[1] -- Application</title>
   <link href="http://www.blogways.net/blog/2014/06/09/node-express4.x-api-1.html"/>
   <updated>2014-06-09T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/09/node-express4.x-api-1</id>
   <content type="html">&lt;h2 id=&quot;express4x-api-翻译1--application&quot;&gt;Express4.x API 翻译[1] – Application&lt;/h2&gt;

&lt;p&gt;之前参与过一个node的项目，使用express框架，感觉这种异步IO以及事件驱动的架构设计用在一些高并发的场景还是大有可为的，决定深入学习一下。刚开始写几个例子就发现问题了，以前用的是3.5的版本，可以很好的集成在webstorm工具里面使用，到4.x版本的时候就一堆问题，工具已经无法创建新的项目，单独用命令生成，发现启动方法也跟以前不一样，4.x是用npm去启动bin下面的www文件，一些以前的写法现在也用不了，本想回到之前的版本，但看4.x的版本更新很快，应该也是以后的趋势，而且专注高性能，有必要直接学习之。从哪下手比较好呢，网上4.x的例子跟文档都很少，索性还是从API看起吧，刚好英文比较差，算是一起学了。&lt;/p&gt;

&lt;h3 id=&quot;express&quot;&gt;express()&lt;/h3&gt;
&lt;p&gt;创建一个 express 应用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var app = express();

app.get('/', function(req, res){
  res.send('hello world');
});

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;application&quot;&gt;Application&lt;/h2&gt;
&lt;h3 id=&quot;settings&quot;&gt;settings&lt;/h3&gt;

&lt;p&gt;提供以下设置用来改变Express行为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;env&lt;/code&gt; 环境模式，默认为process.env.NODE_ENV (NODE_ENV 环境变量) 或者 “development”&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trust proxy&lt;/code&gt; 启用反向代理，默认disabled&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;jsonp callback name&lt;/code&gt; 通过 ?callback= 更新默认回调函数的名称&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;json replacer&lt;/code&gt; JSON replacer callback，默认为null&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;case sensitive routing&lt;/code&gt; 路由启用区分大小写，默认为disabled，”/Foo”和”/foo”默认是同一个地址&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;strict routing&lt;/code&gt; 启用严谨路由，默认情况下”/foo”和”/foo/”被解析成同一个路由&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;view cache&lt;/code&gt; 启用视图模板编译缓存，产品模式下默认enabled&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;view engine&lt;/code&gt; 缺省状态下默认模板引擎&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;views&lt;/code&gt; 视图目录路径，默认”process.cwd()+’/views’”&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x-powered-by&lt;/code&gt; 启用X-Powered-By: Express HTTP header，默认enabled&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;appsetname-value&quot;&gt;app.set(name, value)&lt;/h3&gt;
&lt;p&gt;设置指定name的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('title', 'My Site');
app.get('title');
// =&amp;gt; &quot;My Site&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appgetname&quot;&gt;app.get(name)&lt;/h3&gt;
&lt;p&gt;获取对应name的值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('title');
// =&amp;gt; undefined

app.set('title', 'My Site');
app.get('title');
// =&amp;gt; &quot;My Site&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;appenablename&quot;&gt;app.enable(name)&lt;/h3&gt;
&lt;p&gt;设置name值为true&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.enable('trust proxy');
app.get('trust proxy');
// =&amp;gt; true ### app.disable(name) 设置name值为false

app.disable('trust proxy');
app.get('trust proxy');
// =&amp;gt; false ### app.enabled(name) 检查name对应的值是否为true

app.enabled('trust proxy');
// =&amp;gt; false

app.enable('trust proxy');
app.enabled('trust proxy');
// =&amp;gt; true ### app.disabled(name) 检查name对应的值是否为false

app.disabled('trust proxy');
// =&amp;gt; true

app.enable('trust proxy');
app.disabled('trust proxy');
// =&amp;gt; false ### app.use([path], function) 使用给定的中间件function，可选择挂载path，默认&quot;/&quot;

var express = require('express');
var app = express();

// simple logger
app.use(function(req, res, next){
  console.log('%s %s', req.method, req.url);
  next();
});

// respond
app.use(function(req, res, next){
  res.send('Hello World');
});

app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;挂载路径被剥离出来，对于中间件函数来说是不可见的。这么设计是为了让中间件在不用修改任何代码的情况下就可以在任意前缀的路径下执行。&lt;/p&gt;

&lt;p&gt;这里有一个具体的例子，通过express.static()方法使用./public来管理文件服务用例的中间件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /javascripts/jquery.js
// GET /style.css
// GET /favicon.ico
app.use(express.static(__dirname + '/public'));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如你想为自有的静态文件增加前缀’/static’，你可以使用’mounting’功能。挂载的中间件函数不会被调用，除非req.url包含这个前缀，当函数被调用时，前缀是被剥离出去的。当然这只会影响到这个函数，挂载好后随后的中间件还是会通过包含&lt;code class=&quot;highlighter-rouge&quot;&gt;/static&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;req.url&lt;/code&gt;查看到。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// GET /static/javascripts/jquery.js
// GET /static/style.css
// GET /static/favicon.ico
app.use('/static', express.static(__dirname + '/public'));
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;中间件使用app.use()定义的顺序是非常重要的，它们依次被调用，因此这个决定了中间件的优先级。例如，一般来说日志中间件是你要用到的第一个中间件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var logger = require('morgan');

app.use(logger());
app.use(express.static(__dirname + '/public'));
app.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在假设你想忽略静态文件的请求日志，但又想在logger()定义之后继续使用日志路由，你只需要将static()移动前面就可以了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));
app.use(logger());
app.use(function(req, res){
  res.send('Hello');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个具体的例子是从众多的目录文件服务中，给予”./public”最高的优先级：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use(express.static(__dirname + '/public'));
app.use(express.static(__dirname + '/files'));
app.use(express.static(__dirname + '/uploads')); ### app.engine(ext, callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注册给定的模板引擎的callback默认用来处理扩展名为ext的文件。例如，如果你试图渲染一个”foo.jade”文件，Express将在内部调用以下代码，并缓存require()给后续调用以提高性能。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.engine('jade', require('jade').__express);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;引擎没有提供._express渲染方法，或者你想映射一个不一样的扩展名在模板引擎上，你可以用这个方法。例如映射EJS模板引擎来渲染”.html”文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.engine('html', require('ejs').renderFile);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这种情况下，EJS提供.renderFile()方法使用Express定义的参数：(path, options, callback)，但要注意这个方法是在内部给ejs._express取一个别名，如果你使用”.ejs”可以什么都不要做。&lt;/p&gt;

&lt;p&gt;有些模板引擎并不遵循这一规则，consolidate.js库的建立是为了映射所有的node流行模板引擎遵循这一规则，从而使得他们在Express内无缝工作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var engines = require('consolidate');
app.engine('haml', engines.haml);
app.engine('html', engines.hogan); ### app.param([name], callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;映射路由参数规则。例如当:user存在于一个路由路径中，你需要自动提供req.user给路由映射启动逻辑，或者执行输入参数验证。&lt;/p&gt;

&lt;p&gt;下面的代码说明了如果callback很像中间件，从而支持异常操作，但却增加了一个参数，这里命名为id。然后尝试执行加载用户信息，赋值给req.user，否则传递一个错误到next(err)。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.param('user', function(req, res, next, id){
  User.find(id, function(err, user){
    if (err) {
      next(err);
    } else if (user) {
      req.user = user;
      next();
    } else {
      next(new Error('failed to load user'));
    }
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，你可能只传递一个回调函数，在这种情况下你有机会改变app.param()API。例如express-params定义了下面的回调函数，它允许你使用给定的正则表达式限制参数。&lt;/p&gt;

&lt;p&gt;这个例子有点更先进，检查当第二个参数是正则表达式，返回回调函数很像”user”参数例子。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.param(function(name, fn){
  if (fn instanceof RegExp) {
    return function(req, res, next, val){
      var captures;
      if (captures = fn.exec(String(val))) {
        req.params[name] = captures;
        next();
      } else {
        next('route');
      }
    }
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该方法可以被用来有效的验证参数，或者解析提供匹配分组：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.param('id', /^\d+$/);

app.get('/user/:id', function(req, res){
  res.send('user ' + req.params.id);
});

app.param('range', /^(\w+)\.\.(\w+)?$/);

app.get('/range/:range', function(req, res){
  var range = req.params.range;
  res.send('from ' + range[1] + ' to ' + range[2]);
}); ### app.VERB(path, [callback...], callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Express中App.WEB()方法提供了路由功能，其中VERB是一个HTTP动作，跟app.post()类似。可提供多个回调函数，都是一视同仁，表现跟中间件一样，唯一不一样的是通过调用next(‘route’)来继续其余的路由回调。这个机制可以用来执行路由的前提条件，然后将控制权传递给随后的路由，没有理由进行路由的匹配。&lt;/p&gt;

&lt;p&gt;下面的代码说明了多个简单路由定义的可行性。Express将路径字符串转换成正由表达式，用来在内部匹配到来的请求。在执行这些匹配时查询字符串不考虑，例如”GET /”将匹配以下的路由，如”GET /?name=tobi”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/', function(req, res){
  res.send('hello world');
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;正由表达式也可以使用，如果你有非常特殊的限制可能是有用的，例如下面的”GET /commits/71dbb9c”表达式将很好的匹配”GET /commits/71dbb9c..4c084f9”。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res){
  var from = req.params[0];
  var to = req.params[1] || 'HEAD';
  res.send('commit range ' + from + '..' + to);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以传递一些回调函数，对于利用中间件加载资源、执行验证等很有用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/user/:id', user.load, function(){
  // ... 
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你有多个共同的中间件路由，可以使用路由api的all。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var middleware = [loadForum, loadThread];

app.route('/forum/:fid/thread/:tid')
.all(loadForum)
.all(loadThread)
.get(function() { //... });
.post(function() { //... });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两个中间件将用来处理GET和POST请求。&lt;/p&gt;

&lt;h3 id=&quot;appallpath-callback-callback&quot;&gt;app.all(path, [callback…], callback)&lt;/h3&gt;

&lt;p&gt;此方法功能就像app.VERB()方法，但它匹配所有HTTP的动作。
该方法用于映射具体的路径前缀的”global”逻辑或者任意匹配非常有用。例如如果你将下面的路由放在其他路由前面定义，这将导致从这个规则起所有的请求都需要身份验证，并自动加载一个用户。请记住这些回调函数不应该被当作终点，loadUser可以当作一个任务，然后调用next()继续匹配随后的路由。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all('*', requireAuthentication, loadUser); 等价于：

app.all('*', requireAuthentication)
app.all('*', loadUser);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一个很好的例子是白名单”global”功能。下面的例子跟之前很像，但只限制”/api”为前缀的路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.all('/api/*', requireAuthentication); ### app.route(path)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回一个路由的实例用来处理可选的中间件HTTP动作。推荐使用app.route()方法用来避免路由重复命名以及由此导致的错误。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var app = express();

app.route('/events')
.all(function(req, res, next) {
  // runs for all HTTP verbs first
  // think of it as route specific middleware!
})
.get(function(req, res, next) {
  res.json(...);
})
.post(function(req, res, next) {
  // maybe add a new event...
}) ### app.locals
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;应用本地变量提供给所有在这个应用程序内渲染的模板。这是一个非常有用的模板函数，就像应用程序级别数据一样。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.locals.title = 'My App';
app.locals.strftime = require('strftime');
app.locals.email = 'me@myapp.com';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该app.locals对象是JavaScript对象。添加在它上面的属性被当成应用程序内部的本地变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.locals.title
// =&amp;gt; 'My App'

app.locals.email
// =&amp;gt; 'me@myapp.com'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下Express只有一个应用程序级别的局部变量，那就是settings。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set('title', 'My App');
// use settings.title in a view ### app.render(view, [options], callback)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用回调函数返回的渲染字符串渲染视图。这是res.render()的应用程序级别的版本，它们的行为是一样的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.render('email', function(err, html){
  // ...
});

app.render('email', { name: 'Tobi' }, function(err, html){
  // ...
}); ### app.listen()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;绑定并监听给定主机和端口的连接，该方法和node的http.Server#listener()方法是一致的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var app = express();
app.listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;express()返回的app实际上是一个JavaScript函数，目的是传递给node的http服务器作为回调处理请求。这使得你可以轻松的为你的应用程序提供HTTP和HTTPS版本相同的代码库，app并不从HTTP或者HTTPS继承，就是一个简单的回调函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require('express');
var https = require('https');
var http = require('http');
var app = express();

http.createServer(app).listen(80);
https.createServer(options, app).listen(443);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该app.listen()方法定义成一个简单方便的方法，如果你想使用HTTPS或者同时使用，使用上面的方法。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.listen = function(){
  var server = http.createServer(this);
  return server.listen.apply(server, arguments);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>node Express 框架搭建</title>
   <link href="http://www.blogways.net/blog/2014/06/06/node-express.html"/>
   <updated>2014-06-06T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/06/node-express</id>
   <content type="html">&lt;h2 id=&quot;一express安装&quot;&gt;一、Express安装&lt;/h2&gt;
&lt;p&gt;Express是一个node.js模块，采用npm全局模块。&lt;/p&gt;

&lt;p&gt;npm install -g express&lt;/p&gt;

&lt;h3 id=&quot;二新建项目&quot;&gt;二、新建项目&lt;/h3&gt;

&lt;p&gt;创建一个项目express testExpress,会自动生成目录。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   create : testExpress
   create : testExpress/package.json
   create : testExpress/app.js
   create : testExpress/public
   create : testExpress/public/images
   create : testExpress/views
   create : testExpress/views/layout.jade
   create : testExpress/views/index.jade
   create : testExpress/routes
   create : testExpress/routes/index.js
   create : testExpress/routes/user.js
   create : testExpress/public/stylesheets
   create : testExpress/public/stylesheets/style.css
   create : testExpress/public/javascripts
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行node app.js （运行程序，默认地址是http://localhost:3000）
如果打开页面出错，可能你没有安装jade模块，那就输入npm install jade进行安装，在我们
日志分析系统中没有用jade模板，用的ejs模板。&lt;/p&gt;

&lt;h3 id=&quot;三express项目目录文件介绍&quot;&gt;三、express项目目录文件介绍&lt;/h3&gt;

&lt;p&gt;Express目录介绍：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;目录/文件	                                  说明

package.json	 						npm依赖配置文件， java Maven中的pom.xml文件
app.js                                  项目的入口文件
routes/                                 用于存放路由文件
public/                                 静态文件
javascript/                             js
stylesheets/                            css
images/                                 图片
views/                                  模板文件, express默认采用jade
node_modules/                           存放npm安装到本地依赖包，依赖包在package.json文件
										中声明，使用npm install指令安装
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;申明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;以上目录文件介绍仅对于express框架自动生成目录，框架没有除了package.json文件和 node_modules目录，
没有限定其他文件名称和目录结构，大家在实际开发中可以根据项目需要重新定义目录结构。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四运行原理&quot;&gt;四、运行原理&lt;/h3&gt;

&lt;p&gt;4.1　底层：http模块&lt;/p&gt;

&lt;p&gt;Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var http = require(&quot;http&quot;);

var app = http.createServer(function(request, response) {
  response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
  response.end(&quot;Hello world!\n&quot;);
});

app.listen(3000, &quot;localhost&quot;);
console.log(&quot;Server running at http://localhost:3000/&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。&lt;/p&gt;

&lt;p&gt;4.2　对http模块的再包装&lt;/p&gt;

&lt;p&gt;Express框架的核心是对http模块的再包装。上面的代码用Express改写如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);

var app = express();

app.use(function(request, response) {
  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  response.end(&quot;Hello world!\n&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比较两段代码，可以看到它们非常接近，唯一的差别是createServer方法的参数，从一个回调函数变成了一个Epress对象的实例。而这个实例使用了use方法，加载了与上一段代码相同的回调函数。&lt;/p&gt;

&lt;p&gt;Express框架等于在http模块之上，加了一个中间层，而use方法则相当于调用中间件。&lt;/p&gt;

&lt;p&gt;4.3　中间件&lt;/p&gt;

&lt;p&gt;简单说，中间件（middleware）就是处理HTTP请求的函数，用来完成各种特定的任务，比如检查用户是否登录、分析数据、以及其他在需要最终将数据发送给用户之前完成的任务。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。&lt;/p&gt;

&lt;p&gt;node.js的内置模块http的createServer方法，可以生成一个服务器实例，该实例允许在运行过程中，调用一系列函数（也就是中间件）。当一个HTTP请求进入服务器，服务器实例会调用第一个中间件，完成后根据设置，决定是否再调用下一个中间件。中间件内部可以使用服务器实例的response对象（ServerResponse，即回调函数的第二个参数），以及一个next回调函数（即第三个参数）。每个中间件都可以对HTTP请求（request对象）做出回应，并且决定是否调用next方法，将request对象再传给下一个中间件。&lt;/p&gt;

&lt;p&gt;一个不进行任何操作、只传递request对象的中间件，大概是下面这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function uselessMiddleware(req, res, next) { 
	next();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码的next为中间件的回调函数。如果它带有参数，则代表抛出一个错误，参数为错误文本。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function uselessMiddleware(req, res, next) { 
	next('出错了！');
} 抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4.4　use方法&lt;/p&gt;

&lt;p&gt;use是express调用中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);

var app = express();

app.use(function(request, response, next) {
  console.log(&quot;In comes a &quot; + request.method + &quot; to &quot; + request.url);
  next();
});

app.use(function(request, response) {
  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  response.end(&quot;Hello world!\n&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码先调用第一个中间件，在控制台输出一行信息，然后通过next方法，调用第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以不再request对象就不再向后传递了。&lt;/p&gt;

&lt;p&gt;使用use方法，可以根据请求的网址，返回不同的网页内容。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);

var app = express();

app.use(function(request, response, next) {
  if (request.url == &quot;/&quot;) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
    response.end(&quot;Welcome to the homepage!\n&quot;);
  } else {
    next();
  }
});

app.use(function(request, response, next) {
  if (request.url == &quot;/about&quot;) {
    response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  } else {
    next();
  }
});

app.use(function(request, response) {
  response.writeHead(404, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  response.end(&quot;404 error!\n&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。&lt;/p&gt;

&lt;p&gt;除了在回调函数内部，判断请求的网址，Express也允许将请求的网址写在use方法的第一个参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.use('/', someMiddleware);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码表示，只对根目录的请求，调用某个中间件。&lt;/p&gt;

&lt;h3 id=&quot;五express的方法&quot;&gt;五、Express的方法&lt;/h3&gt;

&lt;p&gt;5.1　all方法和HTTP动词方法&lt;/p&gt;

&lt;p&gt;针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var express = require(&quot;express&quot;);
var http = require(&quot;http&quot;);
var app = express();

app.all(&quot;*&quot;, function(request, response, next) {
  response.writeHead(200, { &quot;Content-Type&quot;: &quot;text/plain&quot; });
  next();
});

app.get(&quot;/&quot;, function(request, response) {
  response.end(&quot;Welcome to the homepage!&quot;);
});

app.get(&quot;/about&quot;, function(request, response) {
  response.end(&quot;Welcome to the about page!&quot;);
});

app.get(&quot;*&quot;, function(request, response) {
  response.end(&quot;404!&quot;);
});

http.createServer(app).listen(3000);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。&lt;/p&gt;

&lt;p&gt;除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。&lt;/p&gt;

&lt;p&gt;这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(&quot;/hello/:who&quot;, function(req, res) {
  res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码将匹配“/hello/alice”网址，网址中的alice将被捕获，作为req.params.who属性的值。需要注意的是，捕获后需要对网址进行检查，过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值。&lt;/p&gt;

&lt;p&gt;如果在模式参数后面加上问号，表示该参数可选：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get('/hello/:who?',function(req,res) {
if(req.params.id) {
    res.end(&quot;Hello, &quot; + req.params.who + &quot;.&quot;);
}
else {
    res.send(&quot;Hello, Guest.&quot;);
}
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.2　set方法&lt;/p&gt;

&lt;p&gt;set方法用于指定变量的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.set(&quot;views&quot;, __dirname + &quot;/views&quot;);
app.set(&quot;view engine&quot;, &quot;jade&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码使用set方法，为系统变量“views”和“view engine”指定值。&lt;/p&gt;

&lt;p&gt;5.3　response对象&lt;/p&gt;

&lt;p&gt;（1）response.redirect方法&lt;/p&gt;

&lt;p&gt;response.redirect方法允许网址的重定向。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;response.redirect(&quot;/hello/anime&quot;);
response.redirect(&quot;http://www.example.com&quot;);
response.redirect(301, &quot;http://www.example.com&quot;); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（2）response.sendFile方法&lt;/p&gt;

&lt;p&gt;response.sendFile方法用于发送文件。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;response.sendFile(&quot;/path/to/anime.mp4&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;（3）response.render方法&lt;/p&gt;

&lt;p&gt;response.render方法用于渲染网页模板。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app.get(&quot;/&quot;, function(request, response) {
  response.render(&quot;index&quot;, { message: &quot;Hello World&quot; });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。&lt;/p&gt;

&lt;p&gt;5.4　requst对象&lt;/p&gt;

&lt;p&gt;（1）request.ip&lt;/p&gt;

&lt;p&gt;request.ip属性用于获得HTTP请求的IP地址。&lt;/p&gt;

&lt;p&gt;（2）request.files&lt;/p&gt;

&lt;p&gt;request.files用于获取上传的文件。&lt;/p&gt;

&lt;h3 id=&quot;六日志系统部分配置&quot;&gt;六、日志系统部分配置&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// should be placed before express.static
app.use(express.compress({
  filter: function (req, res) {
    return /json|text|javascript|css/.test(res.getHeader('Content-Type'))
  },
  level: 9
}))

app.use(express.favicon('public/favicon.ico'))
app.use(express.static(config.root + '/public'))

// don't use logger for test env
if (process.env.NODE_ENV !== 'test') {
  app.use(express.logger('dev'))
}

// set views path, template engine and default layout
  app.engine('html', require('ejs').__express)
app.set('views', config.root + '/app/views')
app.set('view engine', 'html')

app.use(partials());
app.use(pjax());


// cookieParser should be above session
app.use(express.cookieParser())


// bodyParser should be above methodOverride
app.use(express.bodyParser())
app.use(express.methodOverride())

//log4js
log.use(app);

 app.use(function(req, res, next){
	res.on('header', function() {
		if (!req.session) return;
		if (req.session.cookie.expires==null) return;
		req.session.cookie.expires = new Date(Date.now() + 1000*60*60*24*14)
	})
	next()
});

// express/mongo session storage
app.use(express.session({
  secret: 'logAnalyse-pangu',
  cookie: { maxAge: 900000 },  //15 minute
  store: new mongoStore({
    url: config.db,
    collection : 'sessions'
  })
}))



// connect flash for flash messages - should be declared after sessions
app.use(flash())

// adds CSRF support
if (process.env.NODE_ENV !== 'test') {
    app.use(express.csrf())
}

app.use(function(req, res, next){
  //if(req.url != &quot;/faye&quot;)
      res.locals.csrf_token = req.csrfToken();
  next()
})


//menu Plug-in technology    
var menus = [];
require('../app/controllers/menu').loadMenu(config.root+'/app/controllers/menu',
function(m){menus = m;});

  
//Public Response Information 
app.use(function(req, res, next){         
    if (req.session.user){ 
        res.locals.menus = menus;
        res.locals.current_user = req.session.user;
    }else{ 
                 
       if(req.url != &quot;/login.html&quot; &amp;amp;&amp;amp; req.url != &quot;/auth.html&quot; &amp;amp;&amp;amp; req.url != &quot;/logout&quot; 
       &amp;amp;&amp;amp; req.url != &quot;/register&quot; &amp;amp;&amp;amp; req.url != &quot;/registerAction&quot;){
            if (req.url == &quot;/getInbox.html&quot;){
               ContentType = &quot;text/plain&quot;;
               res.StatusCode =500;
               res.write(&quot;会话超时，请重新登录！&quot;);
               res.end();
               return;
            }
            return res.redirect('/login.html')
       }
    }
    return next();   
});

            
//Plug-in technology    
plugin(app).require(config.root+'/app/controllers/plugin').load();

// routes should be at the last
app.use(app.router)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>EventProxy在node的应用</title>
   <link href="http://www.blogways.net/blog/2014/06/05/node-eventproxy.html"/>
   <updated>2014-06-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/06/05/node-eventproxy</id>
   <content type="html">&lt;h2 id=&quot;一eventproxy简介&quot;&gt;一、EventProxy简介&lt;/h2&gt;
&lt;p&gt;EventProxy作者 田永强，新浪微博@朴灵，前端工程师，曾就职于SAP，现就职于淘宝，花名朴灵，致力于NodeJS和Mobile Web App方面的研发工作。EventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有以下几个特点：&lt;/p&gt;

&lt;p&gt;1.利用事件机制解耦复杂业务逻辑；&lt;/p&gt;

&lt;p&gt;2.移除被广为诟病的深度callback嵌套问题；&lt;/p&gt;

&lt;p&gt;3.将串行等待变成并行等待，提升多异步协作场景下的执行效率；&lt;/p&gt;

&lt;p&gt;4.友好的Error handling；&lt;/p&gt;

&lt;p&gt;5.无平台依赖，适合前后端，能用于浏览器和Node.js；&lt;/p&gt;

&lt;p&gt;6.兼容CMD，AMD以及CommonJS模块环境。&lt;/p&gt;

&lt;h3 id=&quot;二安装&quot;&gt;二、安装&lt;/h3&gt;

&lt;p&gt;通过NPM安装即可使用：$ npm install eventproxy&lt;/p&gt;

&lt;p&gt;调用:var EventProxy = require(‘eventproxy’);&lt;/p&gt;

&lt;h3 id=&quot;三使用&quot;&gt;三、使用&lt;/h3&gt;

&lt;p&gt;这里只简单介绍EventProxy在node环境中的应用，至于前端及其他环境使用见：https://github.com/JacksonTian/eventproxy。&lt;/p&gt;

&lt;p&gt;1.过去异步的I/O操作时，很容易会写成回调函数深度嵌套，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var add= function (v1, v2, v3){
   console.log(v1+v2+v3+'');
};

var value1,value2,value3

clinet.get(&quot;key1&quot;, function (err, data) {
    // do something
     value1 = data

    clinet.get(&quot;key2&quot;, function (err, data) {
        // do something
        value2=data
        clinet.get(&quot;key3&quot;, function (err, data) {
            //do something
             value3 = data
            add(value1, value2, value3);
        });

    });

});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.使用EventProxy后可以更多关心业务，去掉深度嵌套，并且在一些情况下显著提高效率&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var EventProxy = require('./eventproxy');
 	 var proxy = new EventProxy();
 var add= function (v1, v2, v3){
   console.log(v1+v2+v3+'');
 };

 proxy.assign(&quot;v1&quot;, &quot;v2&quot;, &quot;v3&quot;, add);
 clinet1.get(&quot;key1&quot;, function (err, data) {
    //do something
    proxy.trigger(&quot;v1&quot;, data);

 });

 clinet2.get(&quot;data&quot;, function (err, data) {
    //do something
    proxy.trigger(&quot;v2&quot;, data);

 });

 clinet3.get(&quot;l10n&quot;, function (err, data) {
    //do something
    proxy.trigger(&quot;v3&quot;, data);

 });
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.EventProxy在日志分析系统中的应用&lt;/p&gt;

&lt;p&gt;以下为日志系统中服务启动加载菜单的程序：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var fs = require('fs')，
EventProxy = require('eventproxy').EventProxy;


exports.loadMenu = function(dir,cb){
   	
var proxy = new EventProxy();
  proxy.assign('menus', cb);
fs.readdir(dir, function(err, files) {

    var menusTemp = [];
    if(err) {
        throw new Error(err);
    }

    files.forEach(function(filename) {
        if(filename.substring(filename.length-3) == '.js'){
            var filepath = [ dir, filename ].join('/');
            var tmp = require(filepath);
            for (m in tmp){
                menusTemp.push(tmp[m]);
            }
        }
    });  
         
    proxy.trigger('menus', menusTemp);
 }); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中loadMenu是在服务启动是被调用，传入的参数为菜单文件路径、回调函数，程序首先通过
proxy.assign(‘menus’, cb);监听menus，在程序读取完菜单文件后调用 proxy.trigger(‘menus’, menusTemp);触发cb回调函数，参数为menusTemp。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 Lang</title>
   <link href="http://www.blogways.net/blog/2014/03/10/ApacheCommonsLang.html"/>
   <updated>2014-03-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/03/10/ApacheCommonsLang</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons Lang&lt;/code&gt;库提供了标准Java库函数里所没有提供的Java核心类的操作方法。&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons Lang&lt;/code&gt;为java.lang API提供了大量的辅助工具，尤其是在String操作方法，基础数值方法，对象引用，并发行，创建及序列化，系统属性方面。&lt;/p&gt;

&lt;p&gt;Lang3.0及其后续版本使用的包名为&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.lang3&lt;/code&gt;，而之前的版本为&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.lang&lt;/code&gt;，允许其在被使用的同时作为一个较早的版本。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons Lang 3.3 API&lt;/code&gt;包列表：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;org.apache.commons.lang3&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.builder&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.concurrent&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.event&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.exception&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.math&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.mutable&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.reflect&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.text&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.text.translate&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.time&lt;/li&gt;
    &lt;li&gt;org.apache.commons.lang3.tuple&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;二下载&quot;&gt;二、下载&lt;/h3&gt;
&lt;p&gt;官方下载页:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://http://commons.apache.org/proper/commons-lang/download_lang.cgi 源码:

svn checkout http://svn.apache.org/repos/asf/commons/proper/pool/trunk commons-pool2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Maven工程依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
  		&amp;lt;artifactId&amp;gt;commons-lang3&amp;lt;/artifactId&amp;gt;
  		&amp;lt;version&amp;gt;3.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三使用说明&quot;&gt;三、使用说明&lt;/h3&gt;
&lt;h4 id=&quot;31-orgapachecommonslang3&quot;&gt;3.1 org.apache.commons.lang3&lt;/h4&gt;
&lt;p&gt;此包提供了高度可重用静态的工具方法，主要是对&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang&lt;/code&gt;类的一些补充。&lt;/p&gt;

&lt;p&gt;由于此包中方法绝大多数都为静态的，因此__不需要创建实例化相应的对象__，而是通过类名__直接调用__需要的方法。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayUtils&lt;/code&gt;是一个对数组进行特殊处理的类。当然 &lt;code class=&quot;highlighter-rouge&quot;&gt;jdk&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;Arrays&lt;/code&gt;是有一些功能的，&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;也提供了一些动态访问 &lt;code class=&quot;highlighter-rouge&quot;&gt;java&lt;/code&gt;数组的方法，这里的&lt;code class=&quot;highlighter-rouge&quot;&gt;ArrayUtils&lt;/code&gt;扩展提供了更多的功能。&lt;/p&gt;

&lt;p&gt;下面是&lt;code class=&quot;highlighter-rouge&quot;&gt;indexOf&lt;/code&gt;方法的具体实现，用以从指定的&lt;code class=&quot;highlighter-rouge&quot;&gt;startIndex&lt;/code&gt;开始，从数组&lt;code class=&quot;highlighter-rouge&quot;&gt;array&lt;/code&gt;中返回第一个值为&lt;code class=&quot;highlighter-rouge&quot;&gt;valueToFind&lt;/code&gt;的下标。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static int indexOf(final double[] array, final double valueToFind, int startIndex) {
    if (ArrayUtils.isEmpty(array)) {
        return INDEX_NOT_FOUND;
    }
    if (startIndex &amp;lt; 0) {
        startIndex = 0;
    }
    for (int i = startIndex; i &amp;lt; array.length; i++) {
        if (valueToFind == array[i]) {
            return i;
        }
    }
    return INDEX_NOT_FOUND;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在使用此方法的时候__不应该__：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ArrayUtils au = new ArrayUtils();
au.indexOf(array,valueToFind,startIndex);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;正确的使用方式&lt;/strong&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ArrayUtils.indexOf(array,valueToFind,startIndex);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一个比较完整的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package wz.lang3.test;

import org.apache.commons.lang3.ArrayUtils;
public class arrayutilstest 
{
	public static void main(String[] args)
	{
		double[] array = {1.23,2.34,3.45,4.56,5.67,6.78,7.89,8.90};
		
		int result = ArrayUtils.indexOf(array, 5.67, 3);
		
		System.out.println(result);
	}
} 
//输出结果：4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下是网络实例：
&lt;strong&gt;[ArrayUtils实例][]&lt;/strong&gt;！
&lt;strong&gt;[StringUtils实例][]&lt;/strong&gt;！
[ArrayUtils实例]: http://www.blogjava.net/sean/archive/2005/07/30/8775.html “ArrayUtils实例”
[StringUtils实例]: http://www.blogjava.net/sean/archive/2005/07/30/8776.html “StringUtils实例”&lt;/p&gt;

&lt;p&gt;其他的一些类的用途：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AnnotationUtils&lt;/code&gt;用于辅助处理注释实例。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CharSetUtils&lt;/code&gt;用于操作字符集实例。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CharUtils&lt;/code&gt;用于操作字符基本类型及字符类对象。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StringUtils&lt;/code&gt;用于实现对字符串的操作，处理null输入。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;[其他类][OtherClass]&lt;/strong&gt;。
[OtherClass]: http://commons.apache.org/proper/commons-lang/javadocs/api-release/index.html “Org.apache.commons.lang3类列表”&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;32-orgapachecommonslang3builder&quot;&gt;3.2 org.apache.commons.lang3.builder&lt;/h4&gt;
&lt;p&gt;辅助实现&lt;code class=&quot;highlighter-rouge&quot;&gt;equals(Object)&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;toString()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;hashCode()&lt;/code&gt;, 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo(Object)&lt;/code&gt;方法，
在这个包里面一共有7个类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CompareToBuilder&lt;/code&gt; : 用于辅助实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable.compareTo(Object)&lt;/code&gt;方法；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;EqualsBuilder&lt;/code&gt; : 用于辅助实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.equals(Object)&lt;/code&gt;方法；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;HashCodeBuilder&lt;/code&gt; : 用于辅助实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.hashCode()&lt;/code&gt;方法；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ToStringBuilder&lt;/code&gt; : 用于辅助实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.toString()&lt;/code&gt;方法；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ReflectionToStringBuilder&lt;/code&gt; : 使用反射机制辅助实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.toString()&lt;/code&gt;方法；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ToStringStyle&lt;/code&gt; : 辅助&lt;code class=&quot;highlighter-rouge&quot;&gt;ToStringBuilder&lt;/code&gt;控制输出格式；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StandardToStringStyle&lt;/code&gt; : 辅助&lt;code class=&quot;highlighter-rouge&quot;&gt;ToStringBuilder&lt;/code&gt;控制标准格式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在我们的日常编码过程当中，经常会使用到比较两个对象是否相等、比较大小、取hash、获取对象信息等。但是在实现这些方法的具体代码当中，稍微有点不注意就会出现一些BUG，而且有些往往还非常难以发现，因此&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.lang3.builder&lt;/code&gt;中提供的这些用于辅助实现上述功能的方法就比较好了，有了这些类，就可以更好、更快、更方便的实现上述方法。&lt;/p&gt;

&lt;p&gt;以下例子来自网络：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//利用反射机制的版本自动化实现需要的功能
//比较两个对象
public int compareTo(Object o) {
    return CompareToBuilder.reflectionCompare(this, o);
}
//判断相等
public boolean equals(Object o) {
    return EqualsBuilder.reflectionEquals(this, o);
}
//取hash
public int hashCode() {
    return HashCodeBuilder.reflectionHashCode(this);
}
//获取基本信息
public String toString() {
    return ReflectionToStringBuilder.toString(this);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;详细例子__[请参考][]__！
[请参考]: http://www.blogjava.net/sean/archive/2005/07/30/8781.html “org.apache.commons.lang.builder”&lt;/p&gt;

&lt;h4 id=&quot;33-orgapachecommonslang3time&quot;&gt;3.3 org.apache.commons.lang3.time&lt;/h4&gt;
&lt;p&gt;用于提供操作时间（Date）和日期（Duration）的方法和类，在这个包里面一共有7个类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DateFormatUtils&lt;/code&gt; ： 提供格式化日期和时间的功能及相关常量，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DateUtils&lt;/code&gt; ： 在Calendar和Date的基础上提供更方便的访问，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DurationFormatUtils&lt;/code&gt; ： 提供格式化时间跨度的功能及相关常量，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastDateFormat&lt;/code&gt; ： 为java.text.SimpleDateFormat提供一个的线程安全的替代类，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastDateParser&lt;/code&gt; ： 为java.text.SimpleDateFormat提供一个的线程安全的替代类，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FastDatePrinter&lt;/code&gt; ： 为java.text.SimpleDateFormat提供一个的线程安全的替代类，&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;StopWatch&lt;/code&gt; ： 提供一套方便的计时器的API。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些包除了&lt;code class=&quot;highlighter-rouge&quot;&gt;StopWatch&lt;/code&gt;，其他的因为都是不可变的，所以是__线程安全__的，此包包含了一些操作时间的基础工具。更&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons Lang&lt;/code&gt;中的其他的大部分类一样，此包中的方法基本均为&lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt;方法，应该__直接使用类名调用__相应的方法予以实现相应的功能。&lt;/p&gt;

&lt;p&gt;以下例子来自网络：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package sean.study.jakarta.commons.lang;
import java.util.Calendar;
import java.util.Date;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.time.*;
public class DateTimeUsage 
{
    public static void main(String[] args) 
	{
        demoDateUtils();
        demoStopWatch();
    }
    public static void demoDateUtils() 
	{

        System.out.println(StringUtils.center(&quot; demoDateUtils &quot;, 30, &quot;=&quot;));
        Date date = new Date();
        String isoDateTime = DateFormatUtils.ISO_DATETIME_FORMAT.format(date);
        String isoTime = DateFormatUtils.ISO_TIME_NO_T_FORMAT.format(date);
        FastDateFormat fdf = FastDateFormat.getInstance(&quot;yyyy-MM&quot;);
        String customDateTime = fdf.format(date);
        System.out.println(&quot;ISO_DATETIME_FORMAT: &quot; + isoDateTime);
        System.out.println(&quot;ISO_TIME_NO_T_FORMAT: &quot; + isoTime);
        System.out.println(&quot;Custom FastDateFormat: &quot; + customDateTime);
        System.out.println(&quot;Default format: &quot; + date);
        System.out.println(&quot;Round HOUR: &quot; + DateUtils.round(date, Calendar.HOUR));
        System.out.println(&quot;Truncate HOUR: &quot; + DateUtils.truncate(date, Calendar.HOUR));
        System.out.println();
    }
    public static void demoStopWatch() 
	{

        System.out.println(StringUtils.center(&quot; demoStopWatch &quot;, 30, &quot;=&quot;));
        StopWatch sw = new StopWatch();
        sw.start();
        operationA();
        sw.stop();
        System.out.println(&quot;operationA used &quot; + sw.getTime() + &quot; milliseconds.&quot;);
        System.out.println();
    }
    public static void operationA() 
	{
        try {
            Thread.sleep(999);
        }
        catch (InterruptedException e) {
            // do nothing
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输出结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;======= demoDateUtils ========
ISO_DATETIME_FORMAT: 2005-08-01T12:41:51
ISO_TIME_NO_T_FORMAT: 12:41:51
Custom FastDateFormat: 2005-08
Default format: Mon Aug 01 12:41:51 CST 2005
Round HOUR: Mon Aug 01 13:00:00 CST 2005
Truncate HOUR: Mon Aug 01 12:00:00 CST 2005
======= demoStopWatch ========
operationA used 1000 milliseconds.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 Pool</title>
   <link href="http://www.blogways.net/blog/2014/01/15/apache-commons-pool.html"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/01/15/apache-commons-pool</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons Pool&lt;/code&gt;库提供了一整套用于实现对象池化的API，以及若干种各具特色的对象池实现。2.0版本，并非是对1.x的简单升级，而是一个完全重写的对象池的实现，显著的提升了性能和可伸缩性，并且包含可靠的实例跟踪和池监控。第二版要求JDK1.6+。&lt;/p&gt;

&lt;h3 id=&quot;二下载&quot;&gt;二、下载&lt;/h3&gt;

&lt;p&gt;官方下载页:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://commons.apache.org/proper/commons-pool/download_pool.cgi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/pool/trunk commons-pool2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Maven工程依赖&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-pool2&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三使用说明&quot;&gt;三、使用说明&lt;/h3&gt;

&lt;h4 id=&quot;31-创建池化对象&quot;&gt;3.1 创建池化对象&lt;/h4&gt;

&lt;p&gt;创建池化对象很简单，只要实现&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-pool&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObjectFactory&lt;/code&gt;工厂接口就行了。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObjectFactory&lt;/code&gt;是一个池化对象工厂接口，定义了生成对象、激活对象、钝化对象、销毁对象的方法，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface PooledObjectFactory&amp;lt;T&amp;gt; {
    PooledObject&amp;lt;T&amp;gt; makeObject();
    void activateObject(PooledObject&amp;lt;T&amp;gt; obj);
    void passivateObject(PooledObject&amp;lt;T&amp;gt; obj);
    boolean validateObject(PooledObject&amp;lt;T&amp;gt; obj);
    void destroyObject(PooledObject&amp;lt;T&amp;gt; obj);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;它创建并管理&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObject&lt;/code&gt;。&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObject&lt;/code&gt;包含了池化的对象实例，以及这些实例的池化属性，比如创建时间、最后使用时间等等。&lt;/p&gt;

&lt;p&gt;如果需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Commons-Pool&lt;/code&gt;，那么你就需要提供一个&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObjectFactory&lt;/code&gt;接口的具体实现。一个比较简单的办法就是，继承&lt;code class=&quot;highlighter-rouge&quot;&gt;BasePooledObjectFactory&lt;/code&gt;这个抽象类。而继承这个抽象类，只需要实现两个方法:&lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap(T obj)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;create()&lt;/code&gt;方法很简单，而实现&lt;code class=&quot;highlighter-rouge&quot;&gt;wrap(T obj)&lt;/code&gt;也有捷径，可以使用类&lt;code class=&quot;highlighter-rouge&quot;&gt;DefaultPooledObject &lt;/code&gt;，代码可以参考如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public PooledObject&amp;lt;Foo&amp;gt; wrap(Foo foo) {
    return new DefaultPooledObject&amp;lt;Foo&amp;gt;(foo);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如，一个完整的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package test.test;

import org.apache.commons.pool2.BasePooledObjectFactory;
import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.impl.DefaultPooledObject;

public class StringBufferFactory extends BasePooledObjectFactory&amp;lt;StringBuffer&amp;gt; {

	@Override
	public StringBuffer create() throws Exception {
		return new StringBuffer();
	}

	@Override
	public PooledObject&amp;lt;StringBuffer&amp;gt; wrap(StringBuffer obj) {
		return new DefaultPooledObject&amp;lt;StringBuffer&amp;gt;(obj);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;有时候，单用对池内所有对象一视同仁的对象池，并不能解决问题。例如，有时需要通过key来获取不同的对象，这样，就有可能取出不合用的对象的麻烦。当然，可以通过为每一组参数相同的同类对象建立一个单独的对象池来解决这个问题。但是，如果使用普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;ObjectPool&lt;/code&gt;来实施这个计策的话，因为普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObjectFactory&lt;/code&gt;只能生产出大批设置完全一致的对象，就需要为每一组参数相同的对象编写一个单独的&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObjectFactory&lt;/code&gt;，工作量相当可观。这种时候就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;BaseKeyedPooledObjectFactory&lt;/code&gt;来替代&lt;code class=&quot;highlighter-rouge&quot;&gt;BasePooledObjectFactory&lt;/code&gt;.这个类，实现的是&lt;code class=&quot;highlighter-rouge&quot;&gt;KeyedPooledObjectFactory&lt;/code&gt;接口，和&lt;code class=&quot;highlighter-rouge&quot;&gt;PooledObjectFactory&lt;/code&gt;接口类似，只是在相关的方法中多了&lt;code class=&quot;highlighter-rouge&quot;&gt;Key&lt;/code&gt;参数,定义如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface KeyedPoolableObjectFactory&amp;lt;K,V&amp;gt; {
    PooledObject&amp;lt;V&amp;gt; makeObject(K key);
    void activateObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
    void passivateObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
    boolean validateObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
    void destroyObject(K key, PooledObject&amp;lt;V&amp;gt; obj);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;32-创建对象池&quot;&gt;3.2 创建对象池&lt;/h4&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.pool2.impl&lt;/code&gt;中预设了三个可以直接使用的对象池：&lt;code class=&quot;highlighter-rouge&quot;&gt;GenericObjectPool&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;GenericKeyedObjectPool&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;SoftReferenceObjectPool&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通常使用&lt;code class=&quot;highlighter-rouge&quot;&gt;GenericObjectPool&lt;/code&gt;来创建对象池，如果是对象池是&lt;code class=&quot;highlighter-rouge&quot;&gt;Keyed&lt;/code&gt;的，那么可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;GenericKeyedObjectPool&lt;/code&gt;来创建对象池。这两个类都提供了丰富的配置选项。这两个对象池的特点是可以设置对象池中的对象特征，包括LIFO方式、最大空闲数、最小空闲数、是否有效性检查等等。两者的区别如前面所述，后者支持&lt;code class=&quot;highlighter-rouge&quot;&gt;Keyed&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;SoftReferenceObjectPool&lt;/code&gt;对象池，它利用一个&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.ArrayList&lt;/code&gt;对象来保存对象池里的对象。不过它并不在对象池里直接保存对象本身，而是保存它们的“软引用”（&lt;code class=&quot;highlighter-rouge&quot;&gt;Soft Reference&lt;/code&gt;）。这种对象池的特色是：可以保存任意多个对象，不会有容量已满的情况发生;在对象池已空的时候，调用它的&lt;code class=&quot;highlighter-rouge&quot;&gt;borrowObject&lt;/code&gt;方法，会自动返回新创建的实例;可以在初始化同时，在池内预先创建一定量的对象;当内存不足的时候，池中的对象可以被Java虚拟机回收。&lt;/p&gt;

&lt;p&gt;举个例子:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new GenericObjectPool&amp;lt;StringBuffer&amp;gt;(new StringBufferFactory());
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;GenericObjectPoolConfig&lt;/code&gt;来对上面创建的对象池进行一些参数配置，创建的Config参数，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setConfig&lt;/code&gt;方法传给对象池，也可以在对象池的构造方法中作为参数传入。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GenericObjectPoolConfig conf = new GenericObjectPoolConfig();
conf.setMaxTotal(20);
conf.setMaxIdle(10);
...
GenericObjectPool&amp;lt;StringBuffer&amp;gt; pool = new GenericObjectPool&amp;lt;StringBuffer&amp;gt;(new StringBufferFactory(), conf);

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;33-使用对象池&quot;&gt;3.3 使用对象池&lt;/h4&gt;

&lt;p&gt;对象池使用起来很方便，简单一点就是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;borrowObject&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;returnObject&lt;/code&gt;两个方法，直接给参考代码吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;StringBuffer buf = null;
try { 
    buf = pool.borrowObject();
    ...         
} catch(IOException e) { 
    throw e; 
} catch(Exception e) {
    throw new RuntimeException(&quot;Unable to borrow buffer from pool&quot; + 
          e.toString());
} finally { 
    try {
        if(null != buf) {
            pool.returnObject(buf);
        }
    } catch(Exception e) {
        // ignored
    }
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 CLI</title>
   <link href="http://www.blogways.net/blog/2014/01/15/apache-commons-cli.html"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/01/15/apache-commons-cli</id>
   <content type="html">&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons&lt;/code&gt;的主要目的就是，创建和维护一个可重用的java组件库集合。这样Apache社区的开发者，就可以使用相同的基础组件库来开发不同的Apache项目了。&lt;/p&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons&lt;/code&gt;的开发者们，将尽量减少这些组件对其他外部库的影响，来确保这些组件可以很容易地进行部署。另外，这些组件将尽可能地保证接口稳定，以便Apache用户（包括Apache项目）可以实现这些组件，而不必担心未来发生变化。&lt;/p&gt;

&lt;p&gt;本文将介绍Commons系列中的CLI组件库。&lt;/p&gt;

&lt;h3 id=&quot;一commons-cli-概述&quot;&gt;一、Commons CLI 概述&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons CLI&lt;/code&gt; 库提供API，可以帮助程序去解析传递给程序的命令行参数。他也可以打印帮助信息，来说明可以运用于命令行的有效参数。&lt;/p&gt;

&lt;p&gt;CLI库支持不同格式的选项：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;POSIX格式的选项（比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -zxvf foo.tar.gz&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;GNU格式的长参数选项（比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;du --human-readable --max-depth=1&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;Java格式的属性（比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;java -Djava.awt.headless=true -Djava.net.useSystemProxies=true Foo&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;带值的单选项（比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;gcc -O2 foo.c&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;单&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号的长参数选项（比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;ant -projecthelp&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;CLI库可以提供的帮助信息，类似如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;usage: ls
 -A,--almost-all          do not list implied . and ..
 -a,--all                 do not hide entries starting with .
 -B,--ignore-backups      do not list implied entried ending with ~
 -b,--escape              print octal escapes for nongraphic characters
    --block-size &amp;lt;SIZE&amp;gt;   use SIZE-byte blocks
 -c                       with -lt: sort by, and show, ctime (time of last
                          modification of file status information) with
                          -l:show ctime and sort by name otherwise: sort
                          by ctime
 -C                       list entries by columns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二commons-cli-下载&quot;&gt;二、Commons CLI 下载&lt;/h3&gt;

&lt;p&gt;截止本文撰写时，CLI的最新发布版本为&lt;code class=&quot;highlighter-rouge&quot;&gt;1.2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;官方下载地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://commons.apache.org/proper/commons-cli/download_cli.cgi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/cli/trunk/ commons-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在Maven工程中添加依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
	&amp;lt;groupId&amp;gt;commons-cli&amp;lt;/groupId&amp;gt;
	&amp;lt;artifactId&amp;gt;commons-cli&amp;lt;/artifactId&amp;gt;
	&amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三使用场景&quot;&gt;三、使用场景&lt;/h3&gt;

&lt;h3 id=&quot;31-布尔选项&quot;&gt;3.1 布尔选项&lt;/h3&gt;

&lt;p&gt;布尔选项是命令行最常见的选项，作为开关使用，不带参数。如果命令行中存在该选项，那么选项值就为&lt;code class=&quot;highlighter-rouge&quot;&gt;true&lt;/code&gt;，否则其值为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举例，如果程序需要布尔选项&lt;code class=&quot;highlighter-rouge&quot;&gt;-t&lt;/code&gt;,代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// create Options object
Options options = new Options();

// add t option
options.addOption(&quot;t&quot;, false, &quot;display current time&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如上，必须创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Options&lt;/code&gt;选项，然后为其添加&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;上例中，&lt;code class=&quot;highlighter-rouge&quot;&gt;addOption&lt;/code&gt;方法有三个参数：第一个参数类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;String&lt;/code&gt;，给出参数的名字；第二个参数类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;boolean&lt;/code&gt;，用来标记该选项是否需要参数,在上面例子中，布尔选项不需要参数，所以设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;false&lt;/code&gt;；第三个参数是选项的描述信息，该描述信息在打印命令行帮助信息时，会显示出来。&lt;/p&gt;

&lt;p&gt;另外，&lt;code class=&quot;highlighter-rouge&quot;&gt;addOption&lt;/code&gt;还存在一个四个参数的调用方式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;addOption(String opt, String longOpt, boolean hasArg, String description)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里，多了一个长选项参数，在后面的例子中，我们可以看到具体的使用。&lt;/p&gt;

&lt;h3 id=&quot;32-解析命令行参数&quot;&gt;3.2 解析命令行参数&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineParser&lt;/code&gt;提供的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;parse&lt;/code&gt;，就是用来解析命令行中的参数。接口&lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineParser&lt;/code&gt;存在多种实现类，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicParser&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;PosixParser&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;GnuParser&lt;/code&gt;，可以根据实际需求选择使用.&lt;/p&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;PosixParser&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;GnuParser&lt;/code&gt;，顾名思义，其区别在于，前者把形如&lt;code class=&quot;highlighter-rouge&quot;&gt;-log&lt;/code&gt;的选项作为三个选项(&lt;code class=&quot;highlighter-rouge&quot;&gt;l&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;o&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;g&lt;/code&gt;)处理，而后者作为一个选项处理。&lt;/p&gt;

&lt;p&gt;具体代码，参考如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CommandLineParser parser = new GnuParser();
CommandLine cmd = parser.parse( options, args);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果，我们要检查命令行中&lt;code class=&quot;highlighter-rouge&quot;&gt;t&lt;/code&gt;选项是否被列出，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;hasOption&lt;/code&gt;方法。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if(cmd.hasOption(&quot;t&quot;)) {
    // 存在t选项的处理
}
else {
    // 不存在t选项的处理
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;32-带参数选项&quot;&gt;3.2 带参数选项&lt;/h3&gt;

&lt;p&gt;除了布尔选项外，还有些选项是需要参数的。比如&lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;选项需要参数，那么可以如下设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// add c option
options.addOption(&quot;c&quot;, true, &quot;country code&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;getOptionValue&lt;/code&gt;方法，获取命令行传入的参数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// get c option value
String countryCode = cmd.getOptionValue(&quot;c&quot;);

if(countryCode == null) {
    // print default date
}
else {
    // print date for country specified by countryCode
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;33-ant命令行实例&quot;&gt;3.3 Ant命令行实例&lt;/h3&gt;

&lt;p&gt;在这里，我们使用一个被普遍使用的java应用程序Ant来解释如果使用CLI库的。&lt;/p&gt;

&lt;h4 id=&quot;331-先看看ant的命令帮助&quot;&gt;3.3.1 先看看Ant的命令帮助&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ant [options] [target [target2 [target3] ...]]
  Options: 
  -help                  print this message
  -projecthelp           print project help information
  -version               print the version information and exit
  -quiet                 be extra quiet
  -verbose               be extra verbose
  -debug                 print debugging information
  -emacs                 produce logging information without adornments
  -logfile &amp;lt;file&amp;gt;        use given file for log
  -logger &amp;lt;classname&amp;gt;    the class which is to perform logging
  -listener &amp;lt;classname&amp;gt;  add an instance of class as a project listener
  -buildfile &amp;lt;file&amp;gt;      use given buildfile
  -D&amp;lt;property&amp;gt;=&amp;lt;value&amp;gt;   use value for given property
  -find &amp;lt;file&amp;gt;           search for buildfile towards the root of the
                         filesystem and use it
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;332-创建布尔选项&quot;&gt;3.3.2 创建布尔选项&lt;/h4&gt;

&lt;p&gt;为了代码清晰，在这里我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;的构造方法来创建。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Option help = new Option( &quot;help&quot;, &quot;print this message&quot; );
Option projecthelp = new Option( &quot;projecthelp&quot;, &quot;print project help information&quot; );
Option version = new Option( &quot;version&quot;, &quot;print the version information and exit&quot; );
Option quiet = new Option( &quot;quiet&quot;, &quot;be extra quiet&quot; );
Option verbose = new Option( &quot;verbose&quot;, &quot;be extra verbose&quot; );
Option debug = new Option( &quot;debug&quot;, &quot;print debugging information&quot; );
Option emacs = new Option( &quot;emacs&quot;,
                           &quot;produce logging information without adornments&quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;333-创建带参数的选项&quot;&gt;3.3.3 创建带参数的选项&lt;/h4&gt;

&lt;p&gt;我们使用&lt;code class=&quot;highlighter-rouge&quot;&gt;OptionBuilder&lt;/code&gt;来创建：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Option logfile   = OptionBuilder.withArgName( &quot;file&quot; )
                                .hasArg()
                                .withDescription(  &quot;use given file for log&quot; )
                                .create( &quot;logfile&quot; );

Option logger    = OptionBuilder.withArgName( &quot;classname&quot; )
                                .hasArg()
                                .withDescription( &quot;the class which it to perform &quot;
                                                  + &quot;logging&quot; )
                                .create( &quot;logger&quot; );

Option listener  = OptionBuilder.withArgName( &quot;classname&quot; )
                                .hasArg()
                                .withDescription( &quot;add an instance of class as &quot;
                                                  + &quot;a project listener&quot; )
                                .create( &quot;listener&quot;); 

Option buildfile = OptionBuilder.withArgName( &quot;file&quot; )
                                .hasArg()
                                .withDescription(  &quot;use given buildfile&quot; )
                                .create( &quot;buildfile&quot;);

Option find      = OptionBuilder.withArgName( &quot;file&quot; )
                                .hasArg()
                                .withDescription( &quot;search for buildfile towards the &quot;
                                                  + &quot;root of the filesystem and use it&quot; )
                                .create( &quot;find&quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;334-创建java属性选项&quot;&gt;3.3.4 创建java属性选项&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Option property  = OptionBuilder.withArgName( &quot;property=value&quot; )
                                .hasArgs(2)
                                .withValueSeparator()
                                .withDescription( &quot;use value for given property&quot; )
                                .create( &quot;D&quot; );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;335-创建options&quot;&gt;3.3.5 创建Options&lt;/h4&gt;

&lt;p&gt;上面已经创建了每个选项，下面我们需要创建&lt;code class=&quot;highlighter-rouge&quot;&gt;Options&lt;/code&gt;，然后继续使用&lt;code class=&quot;highlighter-rouge&quot;&gt;addOption&lt;/code&gt;方法，向其中添加每个选项，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Options options = new Options();

options.addOption( help );
options.addOption( projecthelp );
options.addOption( version );
options.addOption( quiet );
options.addOption( verbose );
options.addOption( debug );
options.addOption( emacs );
options.addOption( logfile );
options.addOption( logger );
options.addOption( listener );
options.addOption( buildfile );
options.addOption( find );
options.addOption( property );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;**说明：可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;Option&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;setRequired&lt;/code&gt;方法来设置，选项是否为必输项，默认不是必输项。 **&lt;/p&gt;

&lt;h4 id=&quot;336-解析命令行参数&quot;&gt;3.3.6 解析命令行参数&lt;/h4&gt;

&lt;p&gt;我们需要创建一个&lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineParser&lt;/code&gt;，并用它根据之前设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;Options&lt;/code&gt;来解析命令行参数，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main( String[] args ) {
    // create the parser
    CommandLineParser parser = new GnuParser();
    try {
        // parse the command line arguments
        CommandLine line = parser.parse( options, args );
    }
    catch( ParseException exp ) {
        // oops, something went wrong
        System.err.println( &quot;Parsing failed.  Reason: &quot; + exp.getMessage() );
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;337-获取命令行参数&quot;&gt;3.3.7 获取命令行参数&lt;/h4&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;hasOption&lt;/code&gt;方法来检查命令行是否传入选项，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;getOptionValue&lt;/code&gt;来获取传入的参数值。&lt;/p&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// has the buildfile argument been passed?
if( line.hasOption( &quot;buildfile&quot; ) ) {
    // initialise the member variable
    this.buildfile = line.getOptionValue( &quot;buildfile&quot; );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;338-设置程序用例帮助信息&quot;&gt;3.3.8 设置程序用例/帮助信息&lt;/h4&gt;

&lt;p&gt;CLI库还可以根据&lt;code class=&quot;highlighter-rouge&quot;&gt;Options&lt;/code&gt;来自动显示程序的用例/帮助信息。代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// automatically generate the help statement
HelpFormatter formatter = new HelpFormatter();
formatter.printHelp( &quot;ant&quot;, options, true );
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行后生成下面信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;usage: ant
-D &amp;lt;property=value&amp;gt;     use value for given property
-buildfile &amp;lt;file&amp;gt;       use given buildfile
-debug                  print debugging information
-emacs                  produce logging information without adornments
-file &amp;lt;file&amp;gt;            search for buildfile towards the root of the
                        filesystem and use it
-help                   print this message
-listener &amp;lt;classname&amp;gt;   add an instance of class as a project listener
-logger &amp;lt;classname&amp;gt;     the class which it to perform logging
-projecthelp            print project help information
-quiet                  be extra quiet
-verbose                be extra verbose
-version                print the version information and exit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;34-再来一个ls实例&quot;&gt;3.4 再来一个&lt;code class=&quot;highlighter-rouge&quot;&gt;ls&lt;/code&gt;实例&lt;/h3&gt;

&lt;p&gt;下面是帮助信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Usage: ls [OPTION]... [FILE]...
List information about the FILEs (the current directory by default).
Sort entries alphabetically if none of -cftuSUX nor --sort.

-a, --all                  do not hide entries starting with .
-A, --almost-all           do not list implied . and ..
-b, --escape               print octal escapes for nongraphic characters
    --block-size=SIZE      use SIZE-byte blocks
-B, --ignore-backups       do not list implied entries ending with ~
-c                         with -lt: sort by, and show, ctime (time of last
                           modification of file status information)
                           with -l: show ctime and sort by name
                           otherwise: sort by ctime
-C                         list entries by columns
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// create the command line parser
CommandLineParser parser = new GnuParser();

// create the Options
Options options = new Options();
options.addOption( &quot;a&quot;, &quot;all&quot;, false, &quot;do not hide entries starting with .&quot; );
options.addOption( &quot;A&quot;, &quot;almost-all&quot;, false, &quot;do not list implied . and ..&quot; );
options.addOption( &quot;b&quot;, &quot;escape&quot;, false, &quot;print octal escapes for nongraphic &quot;
                                         + &quot;characters&quot; );
options.addOption( OptionBuilder.withLongOpt( &quot;block-size&quot; )
                                .withDescription( &quot;use SIZE-byte blocks&quot; )
                                .hasArg()
                                .withArgName(&quot;SIZE&quot;)
                                .create() );
options.addOption( &quot;B&quot;, &quot;ignore-backups&quot;, false, &quot;do not list implied entried &quot;
                                                 + &quot;ending with ~&quot;);
options.addOption( &quot;c&quot;, false, &quot;with -lt: sort by, and show, ctime (time of last &quot; 
                               + &quot;modification of file status information) with &quot;
                               + &quot;-l:show ctime and sort by name otherwise: sort &quot;
                               + &quot;by ctime&quot; );
options.addOption( &quot;C&quot;, false, &quot;list entries by columns&quot; );

String[] args = new String[]{ &quot;--block-size=10&quot; };

try {
    // parse the command line arguments
    CommandLine line = parser.parse( options, args );

    // validate that block-size has been set
    if( line.hasOption( &quot;block-size&quot; ) ) {
        // print the value of block-size
        System.out.println( line.getOptionValue( &quot;block-size&quot; ) );
    }
}
catch( ParseException exp ) {
    System.out.println( &quot;Unexpected exception:&quot; + exp.getMessage() );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Apache Commons 系列简介 之 BeanUtils</title>
   <link href="http://www.blogways.net/blog/2014/01/15/apache-commons-beanutils.html"/>
   <updated>2014-01-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2014/01/15/apache-commons-beanutils</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;

&lt;p&gt;大部分Java开发人员都会安装JavaBeans的命名规范为属性创建getter和setter方法，我们可以直接通过getXxx和setXxx方法直接进行调用。但是，也有一些场合我们必须动态访问java对象的属性，比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;为和java对象模型进行交互，而创建的脚本语言（如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Bean Scripting Framework&lt;/code&gt;）&lt;/li&gt;
  &lt;li&gt;为处理WEB展示或者类似需求，而创建的模板语言(如：&lt;code class=&quot;highlighter-rouge&quot;&gt;JSP&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Velocity&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;为JSP和XSP环境创建自定义tag库(如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Taglibs&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Struts&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Cocoon&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;对一些基于XML配置的资源的处理（如：&lt;code class=&quot;highlighter-rouge&quot;&gt;Ant&lt;/code&gt;构建脚本，web应用部署配置文件，Tomcat的&lt;code class=&quot;highlighter-rouge&quot;&gt;server.xml&lt;/code&gt;文件等等）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Java语言提供了反射(&lt;code class=&quot;highlighter-rouge&quot;&gt;Reflection&lt;/code&gt;)和内省(&lt;code class=&quot;highlighter-rouge&quot;&gt;Introspection&lt;/code&gt;&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;)API（见&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.reflect&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;java.beans&lt;/code&gt;这两个包说明），但这些API很难理解并加以应用。而BeanUtils库的目的，就是针对这些能力提供了易用的包装。&lt;/p&gt;

&lt;h3 id=&quot;二下载及源码&quot;&gt;二、下载及源码&lt;/h3&gt;

&lt;p&gt;下载地址：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http://commons.apache.org/proper/commons-beanutils/download_beanutils.cgi
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;源码获取：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;svn checkout http://svn.apache.org/repos/asf/commons/proper/beanutils/trunk/ commons-beanutils
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Github镜像：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;https://github.com/apache/commons-beanutils
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Maven依赖：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;commons-beanutils&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;commons-beanutils&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.9.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三使用说明&quot;&gt;三、使用说明&lt;/h3&gt;

&lt;p&gt;自从&lt;code class=&quot;highlighter-rouge&quot;&gt;1.7.0&lt;/code&gt;版开始，BeanUtils发布三个jar包，供应用调用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-beanutils.jar&lt;/code&gt; 包含所有功能&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-beanutils-core.jar&lt;/code&gt; 包含除&lt;code class=&quot;highlighter-rouge&quot;&gt;Bean Collections&lt;/code&gt;类外的所有功能&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-beanutils-bean-collections.jar&lt;/code&gt; 只包含&lt;code class=&quot;highlighter-rouge&quot;&gt;Bean Collections&lt;/code&gt;类&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用可以根据需求，选择使用。&lt;/p&gt;

&lt;p&gt;在运行时，&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-beanutils&lt;/code&gt;包依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-logging&lt;/code&gt;包，另外，如果使用了下面几个类，则还需要依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;commons-collections&lt;/code&gt;包：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.beanutils.BeanMap&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.beanutils.BeanPredicate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.beanutils.BeanPropertyValueChangeClosure&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.beanutils.BeanPropertyValueEqualsPredicate&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.apache.commons.beanutils.BeanToPropertyValueTransformer&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;31-标准javabeans&quot;&gt;3.1 标准JavaBeans&lt;/h4&gt;

&lt;p&gt;在介绍之前，我们先给一个对象的定义，后面的实例将结合这个对象给出。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Employee {
    public Address getAddress(String type);
    public void setAddress(String type, Address address);
    public Employee getSubordinate(int index);
    public void setSubordinate(int index, Employee subordinate);
    public String getFirstName();
    public void setFirstName(String firstName);
    public String getLastName();
    public void setLastName(String lastName);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;311-基本属性读写&quot;&gt;3.1.1 基本属性读写&lt;/h4&gt;

&lt;p&gt;首先，我们介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;PropertyUtils&lt;/code&gt;类，其作用：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以很容易的读取或者设置简单的属性值&lt;/p&gt;

    &lt;p&gt;所谓“简单”的属性，是指：属性只是一个简单的可被读写的值。这个属性的类型，可能是java语言原生类型（如:&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;或一个简单对象&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.String&lt;/code&gt;等），也可能是一个由程序或者类库定义的复杂的对象&lt;/p&gt;

    &lt;p&gt;对其操作的API有：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //读操作
  PropertyUtils.getSimpleProperty(Object, String)
  //写操作
  PropertyUtils.setSimpleProperty(Object, String, Object)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;例如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Employee employee = ...;
  String firstName = (String)
     PropertyUtils.getSimpleProperty(employee, &quot;firstName&quot;);
  String lastName = (String)
     PropertyUtils.getSimpleProperty(employee, &quot;lastName&quot;);
  ... manipulate the values ...
  PropertyUtils.setSimpleProperty(employee, &quot;firstName&quot;, firstName);
  PropertyUtils.setSimpleProperty(employee, &quot;lastName&quot;, lastName);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对带序列的属性，支持两种操作方式。&lt;/p&gt;

    &lt;p&gt;所谓“带序列”的属性，是指：一组有序的对象集合，可以通过自然数下标单独访问。或者可以如同数组那样进行读写。如果，属性的类型是&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.List&lt;/code&gt;也可以。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;一种方式：将下标使用方括号括起来，然后跟在属性名后，当做属性名使用。&lt;/p&gt;

        &lt;p&gt;其API为：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //读操作
  PropertyUtils.getIndexedProperty(Object, String)
  //取操作
  PropertyUtils.setIndexedProperty(Object, String, Object)
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;例如：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Employee employee = ...;
  int index = ...;
  String name = &quot;subordinate[&quot; + index + &quot;]&quot;;
  Employee subordinate = (Employee)
  PropertyUtils.getIndexedProperty(employee, name);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;另外一种方式：将下标作为一个单独的参数使用。&lt;/p&gt;

        &lt;p&gt;其API：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  PropertyUtils.getIndexedProperty(Object, String, int)
  PropertyUtils.setIndexedProperty(Object, String, int, Object)
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;例如：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Employee employee = ...;
  int index = ...;
  Employee subordinate = (Employee)
  PropertyUtils.getIndexedProperty(employee, &quot;subordinate&quot;, index);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;针对可以Maped的属性，支持两种操作方式，类似上面的带序列属性的读写操作。&lt;/p&gt;

    &lt;p&gt;所谓“可以Maped”的属性值，是指属性类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Map&lt;/code&gt;。可以通过String型的键，对其进行读写。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;一种方式：将键值用圆括号括起来，跟在属性名后面，当做属性名使用。&lt;/p&gt;

        &lt;p&gt;其API：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //读操作
  PropertyUtils.getMappedProperty(Object, String)
  //写操作
  PropertyUtils.setMappedProperty(Object, String, Object)
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;例如：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Employee employee = ...;
  Address address = ...;
  PropertyUtils.setMappedProperty(employee, &quot;address(home)&quot;, address);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;另外一种方式：将键值作为一个单独的参数使用。&lt;/p&gt;

        &lt;p&gt;其API：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  //读操作
  PropertyUtils.getMappedProperty(Object, String, String)
  //写操作
  PropertyUtils.setMappedProperty(Object, String, String, Object)
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;

        &lt;p&gt;例如：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Employee employee = ...;
  Address address = ...;
  PropertyUtils.setMappedProperty(employee, &quot;address&quot;, &quot;home&quot;, address);
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;312-嵌套属性读写&quot;&gt;3.1.2 嵌套属性读写&lt;/h4&gt;

&lt;p&gt;结合上面的例子，如果我们要访问雇员家庭地址中的城市信息，按常规编程方式，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String city = employee.getAddress(&quot;home&quot;).getCity();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;PropertyUtils&lt;/code&gt;来访问类似上面的多层属性，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.&lt;/code&gt;符号将属性名串联起来作为访问路径。使用的API为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PropertyUtils.getNestedProperty(Object, String)
PropertyUtils.setNestedProperty(Object, String, Object)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面实例的等效代码为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String city = (String) PropertyUtils.getNestedProperty(employee, &quot;address(home).city&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;这里再给出一组更简单的常用的API：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//读操作
PropertyUtils.getProperty(Object, String)
//写操作
PropertyUtils.setProperty(Object, String, Object)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用举例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Employee employee = ...;
String city = (String) PropertyUtils.getProperty(employee,
       &quot;subordinate[3].address(home).city&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;32-动态-beans&quot;&gt;3.2 动态 Beans&lt;/h4&gt;

&lt;p&gt;上面介绍的&lt;code class=&quot;highlighter-rouge&quot;&gt;PropertyUtils&lt;/code&gt;类，可以轻松地对已经存在的JavaBean的属性进行访问。但是，有些场合，你需要通过动态计算出来的属性集，来确定一个JavaBean，而不必实际编写某个确定的JavaBean。&lt;/p&gt;

&lt;p&gt;为此目的，BeanUtils提供&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;接口和与之相关的&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;接口。&lt;/p&gt;

&lt;p&gt;我们看看代码，如何使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;来实现前面&lt;code class=&quot;highlighter-rouge&quot;&gt;Employee&lt;/code&gt;类的功能：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DynaBean employee = ...; // 这里的代码，要根据你使用的具体的BynaBean实现来定了
String firstName = (String) employee.get(&quot;firstName&quot;);
Address homeAddress = (Address) employee.get(&quot;address&quot;, &quot;home&quot;);
Object subordinate = employee.get(&quot;subordinate&quot;, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;仅仅是接口，所以可以有不同的实现。可以根据不同的场景，开发不同的实现。下面我们来介绍几个&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanUtils&lt;/code&gt;内置的实现，你也可以根据你的具体需求，来定制自己的实现。&lt;/p&gt;

&lt;h4 id=&quot;321-basicdynabean和basicdynaclass&quot;&gt;3.2.1 &lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaBean&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaClass&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;我们结合前面的&lt;code class=&quot;highlighter-rouge&quot;&gt;Employee&lt;/code&gt;例子，来介绍&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaBean&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaClass&lt;/code&gt;的使用步骤及实例代码如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建属性集&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; DynaProperty[] props = new DynaProperty[]{
      new DynaProperty(&quot;address&quot;, java.util.Map.class),
      new DynaProperty(&quot;subordinate&quot;, Employee[].class),
      new DynaProperty(&quot;firstName&quot;, String.class),
      new DynaProperty(&quot;lastName&quot;,  String.class)
    };
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaClass&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; BasicDynaClass dynaClass = new BasicDynaClass(&quot;employee&quot;, null, props);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;这里&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaClass&lt;/code&gt;构造方法接收的第二个参数是&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;，它内部会作为&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaBean.class&lt;/code&gt;来处理。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;获取&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;实例并操作&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; DynaBean employee = dynaClass.newInstance();
 employee.set(&quot;address&quot;, new HashMap());
 employee.set(&quot;subordinate&quot;, new Employee[0]);
 employee.set(&quot;firstName&quot;, &quot;Fred&quot;);
 employee.set(&quot;lastName&quot;, &quot;Flintstone&quot;);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这里，&lt;code class=&quot;highlighter-rouge&quot;&gt;dynaClass.newInstance()&lt;/code&gt;的返回值的类型为&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;而不是上文中设置的&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaBean&lt;/code&gt;,这是因为，一般情况下，程序是不关心具体实现，而只需要根据&lt;code class=&quot;highlighter-rouge&quot;&gt;BynaBean&lt;/code&gt;的接口进行访问就行了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;322-resultsetdynaclass使用dynabeans去包装resultset&quot;&gt;3.2.2 &lt;code class=&quot;highlighter-rouge&quot;&gt;ResultSetDynaClass&lt;/code&gt;（使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBeans&lt;/code&gt;去包装&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultSet&lt;/code&gt;）&lt;/h4&gt;

&lt;p&gt;将一系列有关系的，但自身又不是JavaBean的数据集合，包装起来，是&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;API的一个最普遍的使用方式。这其中一个经典应用就是，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;去包装，用&lt;code class=&quot;highlighter-rouge&quot;&gt;JDBC&lt;/code&gt;执行一个&lt;code class=&quot;highlighter-rouge&quot;&gt;SELECT&lt;/code&gt;语句返还的结果&lt;code class=&quot;highlighter-rouge&quot;&gt;java.sql.ResultSet&lt;/code&gt;对象。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Connection conn = ...;
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery
     (&quot;select account_id, name from customers&quot;);
Iterator rows = (new ResultSetDynaClass(rs)).iterator();
while (rows.hasNext()) {
    DynaBean row = (DynaBean) rows.next();
    System.out.println(&quot;Account number is &quot; +
                        row.get(&quot;account_id&quot;) +
                        &quot; and name is &quot; + row.get(&quot;name&quot;));
}
rs.close();
stmt.close();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;323-rowsetdynaclass将离线的resultset包装成dynabeans&quot;&gt;3.2.3 &lt;code class=&quot;highlighter-rouge&quot;&gt;RowSetDynaClass&lt;/code&gt;(将离线的&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultSet&lt;/code&gt;包装成&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBeans&lt;/code&gt;)&lt;/h4&gt;

&lt;p&gt;尽管使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ResultSetDynaClass&lt;/code&gt;很方便，但是它要求查询的结果集在数据整个处理过程中一直保持&lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;状态。然而，有时我们需要先将结果集关闭后，再去处理查询结果的内容。不过这种方式的缺点是，我们需要足够的内存存储查询结果，以及存储过程中所需的性能损耗。如果，你能接受这点，那就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;RowSetDynaClass&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Connection conn = ...;  // 从连接池获取连接
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery(&quot;SELECT ...&quot;);
RowSetDynaClass rsdc = new RowSetDynaClass(rs);
rs.close();
stmt.close();
...;                    // 将连接放回连接池
List rows = rsdc.getRows();
...;                    // 处理记录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;RowSetDynaClass&lt;/code&gt;有个额外的好处，由于&lt;code class=&quot;highlighter-rouge&quot;&gt;RowSetDynaClass&lt;/code&gt;实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;java.io.Serializable&lt;/code&gt;，所以可以很容易的序列化和反序列化。这样，使用&lt;code class=&quot;highlighter-rouge&quot;&gt;RowSetDynaClass&lt;/code&gt;就可以很容易地将SQL语句查询结果传输给远程的java端应用。&lt;/p&gt;

&lt;h4 id=&quot;324-wrapdynabean和wrapdynaclass&quot;&gt;3.2.4 &lt;code class=&quot;highlighter-rouge&quot;&gt;WrapDynaBean&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;WrapDynaClass&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;如果，你习惯使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBeans&lt;/code&gt;去通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;get&lt;/code&gt;方法去对&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBeans&lt;/code&gt;进行存取属性。而标准的JavaBean肯定不具备这样的方法。没关系，你可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;WrapDynaBean&lt;/code&gt;让现有的标准JavaBean也可以变得这样更易访问。&lt;/p&gt;

&lt;p&gt;看例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MyBean bean = ...;
DynaBean wrapper = new WrapDynaBean(bean);
String firstName = wrapper.get(&quot;firstName&quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;325-lazy-dynabeans&quot;&gt;3.2.5 &lt;code class=&quot;highlighter-rouge&quot;&gt;Lazy DynaBeans&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;包含有下面几个类：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;LazyDynaBean 一个“懒”动态Bean&lt;/li&gt;
  &lt;li&gt;LazyDynaMap 一个轻量级的可以转换为Map的DynaBean。&lt;/li&gt;
  &lt;li&gt;LazyDynaList 一个可以存放&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaBean&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Map&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;POJO&lt;/code&gt;的”懒”列表&lt;/li&gt;
  &lt;li&gt;LazyDynaClass &lt;code class=&quot;highlighter-rouge&quot;&gt;MutableDynaClass&lt;/code&gt;接口的一个实现&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Lazy DynaBeans&lt;/code&gt;具备下面的特性：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set(name, value)&lt;/code&gt;方法自动添加属性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;Array&lt;/code&gt;的序列不够时，可以自动增长&lt;/li&gt;
  &lt;li&gt;自动实例化，在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setter/getter&lt;/code&gt;方法中，会根据上下文进行实例化，创建对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;Bean&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt;等实例。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;简单举例如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaBean&lt;/code&gt;&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; DynaBean dynaBean = new LazyDynaBean();

 dynaBean.set(&quot;foo&quot;, &quot;bar&quot;);                   // simple

 dynaBean.set(&quot;customer&quot;, &quot;title&quot;, &quot;Mr&quot;);      // mapped
 dynaBean.set(&quot;customer&quot;, &quot;surname&quot;, &quot;Smith&quot;); // mapped

 dynaBean.set(&quot;address&quot;, 0, addressLine1);     // indexed
 dynaBean.set(&quot;address&quot;, 1, addressLine2);     // indexed
 dynaBean.set(&quot;address&quot;, 2, addressLine3);     // indexed
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaMap&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;如果你想将动态Bean转换为Map，可以这样：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; DynaBean dynaBean = new LazyDynaMap();        // create DynaBean

 dynaBean.set(&quot;foo&quot;, &quot;bar&quot;);                   // simple
 dynaBean.set(&quot;customer&quot;, &quot;title&quot;, &quot;Mr&quot;);      // mapped
 dynaBean.set(&quot;address&quot;, 0, addressLine1);     // indexed

 Map myMap = dynaBean.getMap()                 // retrieve the Map
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;如果你想将Map转换为动态Bean，可以这样：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Map myMap = ....                             // exisitng Map
 DynaBean dynaBean = new LazyDynaMap(myMap);  // wrap Map in DynaBean
 dynaBean.set(&quot;foo&quot;, &quot;bar&quot;);                  // set properties
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaList&lt;/code&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;你可以将任意一个&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.Map[]&lt;/code&gt;数值放到&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaList&lt;/code&gt;里面去：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; TreeMap[] myArray = .... // your Map[]
 List lazyList = new LazyDynaList(myArray);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;get(index)&lt;/code&gt;方法将自动增长list的序列：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; DynaBean newElement = (DynaBean)lazyList.get(lazyList.size());
 newElement.put(&quot;someProperty&quot;, &quot;someValue&quot;);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;操作结束后，可以再转换为map:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; TreeMap[] myArray = (TreeMap[])lazyList.toArray());
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;你也可以创建空的列表，指定其中元素的类，&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaList&lt;/code&gt;可以根据指定的类自动填充元素：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; List lazyList = new LazyDynaList(TreeMap.class);
 List lazyList = new LazyDynaList(MyPojo.class);
 List lazyList = new LazyDynaList(MyDynaBean.class);
    
 DynaClass dynaClass = new LazyDynaMap(new HashMap());
 List lazyList = new LazyDynaList(dynaClass);
    
 DynaClass dynaClass = (new WrapDynaBean(myPojo)).getDynaClass();
 List lazyList = new LazyDynaList(dynaClass);
    
 DynaClass dynaClass = new BasicDynaClass(properties);
 List lazyList = new LazyDynaList(dynaClass);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;上面之所以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;来替代普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;Class&lt;/code&gt;，是因为有些DynaBean的实现没有默认的空参数的构造方法，而&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass.newInstance()&lt;/code&gt;方法。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;当然，也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setElementType(Class)&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;setElementDynaClass(DynaClass)&lt;/code&gt;方法来设置元素类型，然后使用普通的&lt;code class=&quot;highlighter-rouge&quot;&gt;java.util.List&lt;/code&gt;接口提供的方法(比如:&lt;code class=&quot;highlighter-rouge&quot;&gt;set/add/addAll&lt;/code&gt;)来填充元素:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; // Create a new LazyDynaList (100 element capacity)
 LazyDynaList lazyList = new LazyDynaList(100);

 // Either Set the element type...
 lazyList.setElementType(TreeMap.class);

 // ...or the element DynaClass...
 lazyList.setElementDynaClass(new MyCustomDynaClass());

 // Populate from a collection
 lazyList.addAll(myCollection);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaClass&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaClass&lt;/code&gt;继承于&lt;code class=&quot;highlighter-rouge&quot;&gt;BasicDynaClass&lt;/code&gt;,实现了&lt;code class=&quot;highlighter-rouge&quot;&gt;MutableDynaClass&lt;/code&gt;接口。我们在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaBean&lt;/code&gt;时，有时不需要关系其内部结构，这样就不需要操作&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;，但有时，我们需要强制其内部成员结构，这样就需要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;。做这种强制内部结构的操作，有两种方式：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;我们可以先创建&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaClass&lt;/code&gt;，设置结构，然后再生成&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaBean&lt;/code&gt;:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; MutableDynaClass dynaClass = new LazyDynaClass();    // create DynaClass

 dynaClass.add(&quot;amount&quot;, java.lang.Integer.class);    // add property
 dynaClass.add(&quot;orders&quot;, OrderBean[].class);          // add indexed property
 dynaClass.add(&quot;orders&quot;, java.util.TreeMapp.class);   // add mapped property

 DynaBean dynaBean = new LazyDynaBean(dynaClass);     // Create DynaBean with associated DynaClass
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;我们也可以先生成&lt;code class=&quot;highlighter-rouge&quot;&gt;LazyDynaBean&lt;/code&gt;,再获取&lt;code class=&quot;highlighter-rouge&quot;&gt;DynaClass&lt;/code&gt;设置结构：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; DynaBean dynaBean = new LazyDynaBean();              // Create LazyDynaBean
 MutableDynaClass dynaClass =
           (MutableDynaClass)dynaBean.getDynaClass();  // get DynaClass

 dynaClass.add(&quot;amount&quot;, java.lang.Integer.class);    // add property
 dynaClass.add(&quot;myBeans&quot;, myPackage.MyBean[].class);  // add 'array' indexed property
 dynaClass.add(&quot;myMap&quot;, java.util.TreeMapp.class);    // add mapped property
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;33-数据类型转换&quot;&gt;3.3 数据类型转换&lt;/h4&gt;

&lt;p&gt;BeanUtils包提供了一系列API和设计模式来解决数据类型转换问题。&lt;/p&gt;

&lt;p&gt;看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HttpServletRequest request = ...; 
MyBean bean = ...; 

BeanUtils.populate(bean, request.getParameterMap()); 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;BeanUtils&lt;/code&gt;是依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertUtils&lt;/code&gt;提供的方法进行数据转换的，&lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertUtils&lt;/code&gt;不推荐直接使用，因为以后的版本中可能会被废弃。&lt;/p&gt;

&lt;p&gt;你也可以定制自己的转换器，方法很简单，两个步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Converter&lt;/code&gt;接口，在其中的&lt;code class=&quot;highlighter-rouge&quot;&gt;convert&lt;/code&gt;方法中实现你的转换规则&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertUtils.register()&lt;/code&gt;方法注册你自己的转换器&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举一个简单的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Person{ 
    private Date birthday; 
    public Date getBirthday() {  
        return birthday;  
	}  
	public void setBirthday(Date birthday) {  
	    this.birthday = birthday;  
	}  
    
    ...
}

//
DateConverter dc = new DateConverter(); 
dc.setPattern(&quot;yyyy-mm-dd&quot;);
ConvertUtils.register(dc, java.util.Date.class); 

//
Person person = new Person();
String bd = &quot;2014-01-15&quot;;
BeanUtils.setProperty(person, &quot;birthday&quot;, bd);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的例子中，如果不定制转换器，那么生日的属性设置会报错。&lt;/p&gt;

&lt;h4 id=&quot;34-集合&quot;&gt;3.4 集合&lt;/h4&gt;

&lt;p&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;Apache Commons Collections&lt;/code&gt;包配合，去实现一些对集合的操作。比如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;根据集合中bean的某个属性值，对集合中得bean进行排序&lt;/p&gt;

    &lt;p&gt;看代码：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Collections.sort(peopleCollection, new BeanComparator(&quot;firstName&quot;));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;上面代码，会根据bean中&lt;code class=&quot;highlighter-rouge&quot;&gt;firstName&lt;/code&gt;属性对集合&lt;code class=&quot;highlighter-rouge&quot;&gt;peopleCollection&lt;/code&gt;进行排序。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Collections.sort(peopleCollection, new BeanComparator(&quot;firstName&quot;, new ReverseComparator(new ComparableComparator())));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;上面代码是做逆序。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改集合中Bean的某属性值&lt;/p&gt;

    &lt;p&gt;看代码：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // create the closure
  BeanPropertyValueChangeClosure closure =
       new BeanPropertyValueChangeClosure( &quot;activeEmployee&quot;, Boolean.TRUE );

  // update the Collection
  CollectionUtils.forAllDo( peopleCollection, closure );
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;上面代码，会将集合&lt;code class=&quot;highlighter-rouge&quot;&gt;peopleCollection&lt;/code&gt;内所有bean的属性&lt;code class=&quot;highlighter-rouge&quot;&gt;activeEmployee&lt;/code&gt;都设置为&lt;code class=&quot;highlighter-rouge&quot;&gt;Boolean.TRUE&lt;/code&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过Bean中某属性值是否相等来对集合进行过滤&lt;/p&gt;

    &lt;p&gt;看代码：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // create the predicate
  BeanPropertyValueEqualsPredicate predicate =
       new BeanPropertyValueEqualsPredicate( &quot;activeEmployee&quot;, Boolean.FALSE );

  // filter the Collection
  CollectionUtils.filter( peopleCollection, predicate );
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;上面代码，会将集合&lt;code class=&quot;highlighter-rouge&quot;&gt;peopleCollection&lt;/code&gt;中属性&lt;code class=&quot;highlighter-rouge&quot;&gt;activeEmployee&lt;/code&gt;不为false的bean都删除。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过Bean的属性路径来获取数据&lt;/p&gt;

    &lt;p&gt;看代码：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  // create the transformer
  BeanToPropertyValueTransformer transformer = new BeanToPropertyValueTransformer( &quot;person.address.city&quot; );

  // transform the Collection
  Collection peoplesCities = CollectionUtils.collect( peopleCollection, transformer );
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;上面代码，会将集合&lt;code class=&quot;highlighter-rouge&quot;&gt;peopleCollection&lt;/code&gt;中所有bean的&lt;code class=&quot;highlighter-rouge&quot;&gt;person.address.city&lt;/code&gt;属性值都收集到集合&lt;code class=&quot;highlighter-rouge&quot;&gt;peoplesCities&lt;/code&gt;中去。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;Java程序可以在运行是加载Class，获取其构造方法的定义，并生成其对象实体、或对其fields设值、或唤起其methods。这种“透视Class”的能力（&lt;code class=&quot;highlighter-rouge&quot;&gt;the ability of the program to examine itself&lt;/code&gt;），被称为&lt;code class=&quot;highlighter-rouge&quot;&gt;Introspection&lt;/code&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx配置及应用场景之lua</title>
   <link href="http://www.blogways.net/blog/2013/10/23/nginx-4.html"/>
   <updated>2013-10-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/23/nginx-4</id>
   <content type="html">&lt;h2 id=&quot;一说明&quot;&gt;一、说明&lt;/h2&gt;
&lt;p&gt;这里不对lua语言本身及其编译器运行环境等做介绍，以下所有介绍前提对lua相关有所了解。&lt;/p&gt;
&lt;h2 id=&quot;二ngx_lua介绍&quot;&gt;二、ngx_lua介绍&lt;/h2&gt;

&lt;h3 id=&quot;原理&quot;&gt;原理&lt;/h3&gt;

&lt;p&gt;ngx_lua将Lua嵌入Nginx，可以让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求。Lua内建协程，这样就可以很好的将异步回调转换成顺序调用的形式。ngx_lua在Lua中进行的IO操作都会委托给Nginx的事件模型，从而实现非阻塞调用。开发者可以采用串行的方式编写程序，ngx_lua会自动的在进行阻塞的IO操作时中断，保存上下文；然后将IO操作委托给Nginx事件处理机制，在IO操作完成后，ngx_lua会恢复上下文，程序继续执行，这些操作都是对用户程序透明的。&lt;/p&gt;

&lt;p&gt;每个NginxWorker进程持有一个Lua解释器或者LuaJIT实例，被这个Worker处理的所有请求共享这个实例。每个请求的Context会被Lua轻量级的协程分割，从而保证各个请求是独立的。&lt;/p&gt;

&lt;p&gt;ngx_lua采用“one-coroutine-per-request”的处理模型，对于每个用户请求，ngx_lua会唤醒一个协程用于执行用户代码处理请求，当请求处理完成这个协程会被销毁。每个协程都有一个独立的全局环境（变量空间），继承于全局共享的、只读的“comman data”。所以，被用户代码注入全局空间的任何变量都不会影响其他请求的处理，并且这些变量在请求处理完成后会被释放，这样就保证所有的用户代码都运行在一个“sandbox”（沙箱），这个沙箱与请求具有相同的生命周期。&lt;/p&gt;

&lt;p&gt;得益于Lua协程的支持，ngx_lua在处理10000个并发请求时只需要很少的内存。根据测试，ngx_lua处理每个请求只需要2KB的内存，如果使用LuaJIT则会更少。所以ngx_lua非常适合用于实现可扩展的、高并发的服务。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;协程类似一种多线程，与多线程的区别有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;协程并非os线程，所以创建、切换开销比线程相对要小。&lt;/li&gt;
  &lt;li&gt;协程与线程一样有自己的栈、局部变量等，但是协程的栈是在用户进程空间模拟的，所以创建、切换开销很小。&lt;/li&gt;
  &lt;li&gt;多线程程序是多个线程并发执行，也就是说在一瞬间有多个控制流在执行。而协程强调的是一种多个协程间协作的关系，只有当一个协程主动放弃执行权，另一个协程才能获得执行权，所以在某一瞬间，多个协程间只有一个在运行。&lt;/li&gt;
  &lt;li&gt;由于多个协程时只有一个在运行，所以对于临界区的访问不需要加锁，而多线程的情况则必须加锁。&lt;/li&gt;
  &lt;li&gt;多线程程序由于有多个控制流，所以程序的行为不可控，而多个协程的执行是由开发者定义的所以是可控的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Nginx的每个Worker进程都是在epoll或kqueue这样的事件模型之上，封装成协程，每个请求都有一个协程进行处理。这正好与Lua内建协程的模型是一致的，所以即使ngx_lua需要执行Lua，相对C有一定的开销，但依然能保证高并发能力。&lt;/p&gt;

&lt;h2 id=&quot;二ngx_lua安装&quot;&gt;二、ngx_lua安装&lt;/h2&gt;

&lt;p&gt;Nginx中安装ngx_lua需要安装LuaJIT，ngx_devel_kit，ngx_lua等安装文件，我们这里用的OpenResty，内部已经集成ngx_lua，无需再安装任何模块。&lt;/p&gt;

&lt;h2 id=&quot;三ngx_lua用法&quot;&gt;三、ngx_lua用法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;嵌套lua脚本&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location /lua {
set $test &quot;hello, world&quot;;
content_by_lua '
    ngx.header.content_type = &quot;text/plain&quot;;
    ngx.say(ngx.var.test);
';
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;$ curl ‘http://134.32.28.134:8888/lua’，输出 hello, world。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;include lua文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nginx中include lua的脚本文件方式，如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; location /mytest {    
	  content_by_lua_file conf/alcache.lua;       
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中在alcache.lua中编写lua脚本即可。&lt;/p&gt;

&lt;h2 id=&quot;四实际运用中通过lua结合分布式缓存对session的处理&quot;&gt;四、实际运用中通过lua结合分布式缓存对session的处理&lt;/h2&gt;

&lt;p&gt;这里redis与memcache的支持不是调用Nginx自带redis与memcache模块，都是调用OpenResty内部集成的第三方模块&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf部分配置&lt;/strong&gt;&lt;/p&gt;

  	location /login {  &lt;br /&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	content_by_lua_file conf/alcache.lua;       
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;alcache.lua配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;local key = tostring(ngx.var.arg_username)
local val = tostring(ngx.var.arg_password)
local passLogin = tostring(ngx.var.arg_passLoginFlag)
local flags = tostring(ngx.var.arg_flags or 0)
local exptime = tostring(ngx.var.arg_exptime or 0)
local sessionId  = tostring(ngx.var.cookie_JSESSIONID)

ngx.say(&quot;sessionId:&quot;,sessionId)
ngx.say(&quot;key:&quot;,key)
ngx.say(&quot;val:&quot;,val)

if (key == nil and val == nil)  then return end
--if (passLogin == nil or sessionId == nil)  then return end

local memcached = require(&quot;resty.memcached&quot;)
--local redis = require(&quot;resty.redis&quot;) 
local cache,err = memcached:new()
--local cache,err = redis.new()

if not cache then
        ngx.say(&quot;failed to instantiate cache: &quot;,err)
        return
end

 
cache:set_timeout(1000)

local ok,err = cache:connect(&quot;134.32.28.134&quot;,11211)
--local ok,err = cache:connect(&quot;134.32.28.134&quot;,6379)
if not ok then
        ngx.say(&quot;failed to connect: &quot;,err)
        return
end


local res,flags,err = cache:get(key)
if err then
        ngx.say(&quot;failed to get &quot;,key,&quot; : &quot;,err)
        return
end
if res and tostring(res) ~= sessionId then
        cache:delete(key)
        cache:set(key,sessionId,exptime,flags)
else
 				cache:set(key,sessionId,exptime,flags)
end


local ok, err = cache:close()  
				if not ok then  
        	ngx.say(&quot;failed to close:&quot;, err)  
        return  
end

local url = ngx.var.uri  
local res = ngx.location.capture(&quot;/proxy&quot;)  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx配置及应用场景之高级配置</title>
   <link href="http://www.blogways.net/blog/2013/10/22/nginx-3.html"/>
   <updated>2013-10-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/22/nginx-3</id>
   <content type="html">&lt;h2 id=&quot;一nginx反向代理&quot;&gt;一、Nginx反向代理&lt;/h2&gt;

&lt;p&gt;反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。&lt;/p&gt;

&lt;p&gt;通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。&lt;/p&gt;

&lt;p&gt;一个通过HttpProxy模块实现反向代理的简单配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	server {
		listen   8888;
		server_name  134.32.28.134;

		location / {
    		proxy_pass http://134.32.28.134:8090;
    		proxy_redirect off;
    		proxy_set_header X-Real-IP $remote_addr;
    		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
		}
	} 此配置实现在ie中输入http://134.32.28.134:8888即会调转到134.32.28.134:8090中
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Upstream模块配置实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
	     server 134.32.28.134:8090;
	}	
	server {
	    listen   8888;
	    server_name  134.32.28.134;
	
	    location / {
	        proxy_pass http://appserver;
	    }
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;HttpRewrite模块配置实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	server {
	    listen   8888;
	    server_name  134.32.28.134;
	    rewrite  http://134.32.28.134:8090/ permanent;
	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;二nginx负载均衡&quot;&gt;二、Nginx负载均衡&lt;/h2&gt;

&lt;p&gt;Nginx本身提供轮询（round robin）、用户IP哈希（ip_hash）和指定权重三种方式负载均衡策略，
另外也出现第三方负载均衡模块fair和url_hash，默认情况下，Nginx以轮询作为负载均衡策略。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;轮询与指定权重策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;简单配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
       server 134.32.28.134:8090 weight=5;
       server 134.32.28.134:8091 weight=2;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;weight是设置权重，用于后端服务器性能不均的情况。
轮询策略的缺点是某一时段内的一连串访问可能都是由同一个用户A发起的，那么第一次A的请求可能是 8090，而下一次是 8091，然后是 8090、8091…… 在大多数应用场景中，这样并不高效，并且如果后台服务器没有实现对session的共享，会导致session没有共享的。当然，也正因如此，Nginx 为你提供了一个按照IP来hash的方式，这样每个客户端的访问请求都会被甩给同一个后端服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IP哈希策略&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
		   ip_hash;
	       server 134.32.28.134:8090;
	       server 134.32.28.134:8091;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种策略中，用于进行hash运算的key是客户端的IP地址。这样的方式保证一个客户端每次请求都将到达同一个后台主机。当然，如果所hash到的后台服务器当前不可用，则请求会被转移到其他服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;down机、重试策略及备份&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;当某个一个服务器暂时性的宕机（down）时，你可以使用“down”来标示出来，并且这样被标示的 、服务器就不会接受请求去处理。如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
       server 134.32.28.134:8090;
       server 134.32.28.134:8091 down;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以为每个 backend 指定最大的重试次数，和重试时间间隔。所使用的关键字是 max_fails 和 fail_timeout。如下所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
       server 134.32.28.134:8090;
       server 134.32.28.134:8091 max_fails=3 fail_timeout=30s;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以使用“backup”关键字。当所有的非备机（non-backup）都宕机（down）或者繁忙（busy）的时候，就只使用由 backup 标注的备机。backup不能和ip_hash关键字一起使用。举例如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
       server 134.32.28.134:8090;
       server 134.32.28.134:8091;
	   server 134.32.28.134:8092 backup;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;fair（Nginx需安装第三方模块，OpenResty已经集成）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;fair按后端服务器的响应时间来分配请求，响应时间短的优先分配，配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
	       server 134.32.28.134:8090;
	       server 134.32.28.134:8091;
		   fair;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;url_hash（Nginx需安装第三方模块）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;url_hash按访问URL的hash结果来分配请求，使每个URL定向到同一个后端服务器，后端服务器为缓存时比较适用。另外，在upstream中加入hash语句后，server语句不能写入weight等其他参数。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	upstream appserver { 
	       server 134.32.28.134:8090;
	       server 134.32.28.134:8091;
		   hash  $request_uri;
		   hash_method  crc32;
	} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;三nginx静态缓存&quot;&gt;三、Nginx静态缓存&lt;/h2&gt;

&lt;p&gt;Nginx过Proxy Cache可以使其对静态资源进行缓存。其原理就是把静态资源按照一定的规则存在本地硬盘，并且会在内存中缓存常用的资源，从而加快静态资源的响应。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;http段设置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_connect_timeout 600;  #nginx跟后端服务器连接超时时间(代理连接超时)
proxy_read_timeout    600;  #连接成功后，后端服务器响应时间(代理接收超时)
proxy_send_timeout    600;  #后端服务器数据回传时间(代理发送超时)
proxy_buffer_size     32k;  #设置代理服务器（nginx）保存用户头信息的缓冲区大小
proxy_buffers         4 32k;#proxy_buffers缓冲区，网页平均在32k以下的话，这样设置
proxy_busy_buffers_size  64k;           #高负荷下缓冲大小（proxy_buffers*2）
proxy_temp_file_write_size  64k;       #设定缓存文件夹大小，大于这个值，将从upstream服务器传
proxy_temp_path /home/spdev/nginx/openresty/local/nginx/proxy_temp;
proxy_cache_path /home/spdev/nginx/openresty/local/nginx/cache levels=1:2 
keys_zone=cache_one:200m inactive=1d max_size=30g;
#levels设置目录层次,keys_zone设置缓存名字和共享内存大小 
#inactive在指定时间内没人访问则被删除在这里是1天,max_size最大缓存空间
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;server段设置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; location ~* \.(gif|jpg|png|htm|html|css|js|flv|ico|swf)$ {
    
     proxy_pass http://appserver;  #动态不缓存  
     proxy_redirect off;
     proxy_set_header Host $host;
     proxy_cache cache_one;
     proxy_cache_valid 200 302 1h;  #哪些状态缓存多长时间
     proxy_cache_valid 301 1d;
     proxy_cache_valid any 1m;      #其他的缓存多长时间   
     expires 30d;   #置失期时间，为30天
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;四ip并发限制带宽限制&quot;&gt;四、IP并发限制、带宽限制&lt;/h2&gt;

&lt;p&gt;nginx可以通过HttpLimitReqModul和HttpLimitZoneModule配置来限制ip在同一时间段的访问次数来防cc攻击。
HttpLimitReqModul用来限制连单位时间内连接数的模块，使用limit_req_zone和limit_req指令配合使用来达到限制。
一旦并发连接超过指定数量，就会返回503错误。HttpLimitConnModul用来限制单个ip的并发连接数，使用limit_zone和limit_conn指令这两个模块的区别前一个是对一段时间内的连接数限制，后者是对同一时刻的连接数限制。&lt;/p&gt;

&lt;h3 id=&quot;设置httplimitreqmodul限制某一段时间内同一ip访问数&quot;&gt;设置HttpLimitReqModul限制某一段时间内同一ip访问数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;http段设置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	#限制同一ip每秒访问20次
	limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里定义一个名为allips的limit_req_zone用来存储session，大小是10M内存，以$binary_remote_addr 为key,限制平均每秒的请求为20个，1M能存储16000个状态，rate的值必须为整数，如果限制两秒钟一个请求，可以设置成30r/m。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;server段设置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	limit_req zone=allips burst=5 nodelay;
	#brust的意思就是，如果第1秒、2,3,4秒请求为19个，第5秒的请求为25个是被允许的。
	#但是如果你第1秒就25个请求后面的5个请求就会被限制，返回503错误。
	#nodelay，如果不设置该选项，严格使用平均速率限制请求数，
	#也就是说如果你设置rate=120r/m,相当于每秒只允许处理2个请求
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;设置httplimitzonemodule-限制并发连接数&quot;&gt;设置HttpLimitZoneModule 限制并发连接数&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;http段设置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	#ip限制并发数
	limit_conn_zone  $binary_remote_addr zone=addr:10m;

	#服务器限制并发总数
	limit_conn_zone $server_name zone=perserver:10m;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;server段设置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	#连接数限制
	limit_conn addr 10;  

	limit_conn perserver 50000;

	#连接限速
	limit_rate 500k;   

	#限制ip
	allow 132.35.75.0/24;
	#deny all;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中allow、deny是HTTP Access模块对应的指令，以下需注意：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、deny 一定要加一个ip，否则直接跳转到403,不往下执行了;如果403默认页是
   同一域名下，会造成死循环访问；

2、allow的ip段从允许访问的段位从小到大排列,如127.0.0.0/24 下面才能是
   10.10.0.0/16
   24表示子网掩码:255.255.255.0
   16表示子网掩码:255.255.0.0
   8表示子网掩码:255.0.0.0；

3、deny all;结尾 表示除了上面allow的其他都禁止
   如：
		 deny 192.168.1.1;
		 allow 127.0.0.0/24;
		 allo w 192.168.0.0/16;
		 allow 10.10.0.0/16;
		 deny all;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;五第三方合并静态文件模块的使用&quot;&gt;五、第三方合并静态文件模块的使用&lt;/h2&gt;

&lt;p&gt;这里介绍的是淘宝开发的nginx_concat_module针对nginx的文件合并模块，主要用于合并前端代码减少http请求数。对于此模块的安装前面已经有过说明，这里不再详细解说。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nginx_concat_module模块配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	# nginx_concat_module 主开关
	concat on;

	# 最大合并文件数
	concat_max_files 10;
	
	# 只允许同类型文件合并
	concat_unique on;
	
	# 允许合并的文件类型，多个以逗号分隔。如：application/x-javascript, text/css
	concat_types text/html;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;举例如：&lt;/p&gt;

&lt;p&gt;http://主机地址/test/??1.css,2.css,3.css…10.css，这里会将1.css，2.css…10.css 是个css文件合并为一个文件从而只需一次请求。&lt;/p&gt;

&lt;h2 id=&quot;六实际应用中配置实例&quot;&gt;六、实际应用中配置实例&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	include  common.conf;
  		include  proxy_cache.conf;
	#设定负载均衡的服务器列表
	upstream appserver { 
	       server 134.32.28.134:8090 weight=5;
	       server 134.32.28.134:8091 weight=2;
	} 

	include limit_common.conf;
	# server虚拟主机配置                         							
	server {
	    listen       8888;
	    server_name  134.32.28.134;
	          
	
		#设置网页的默认编码格式
	    #charset utf8; 		
			
			#根据访问域名生成对应的访问日志
	    access_log  logs/host.access.log  main;     
	    
	    lua_code_cache on; 						
	    
	    
	
	    location / {	    		
	        proxy_pass http://appserver;								
	        include user_agent.conf;
	        include limit_info.conf;
	    }
	    
	    location /mytest {    
	        content_by_lua_file conf/alcache.lua;       
	    }
	    
	    location /proxy {    
	    		include user_agent.conf;										
	        include limit_info.conf;
	        proxy_pass http://appserver$uri;	
	    }
	
	     
	    #静态文件缓存
	    location ~* \.(gif|jpg|png|htm|html|css|js|flv|ico|swf)$ {
	    
	         #防盗链
	    		 #valid_referers none blocked 134.32.28.134;
					 #if ($invalid_referer) {
							#return 403;
					 #}
					 
	    	 proxy_pass http://appserver;
	         proxy_redirect off;
	         proxy_set_header Host $host;
	         proxy_cache cache_one;
	         proxy_cache_valid 200 302 1h;
	         proxy_cache_valid 301 1d;
	         proxy_cache_valid any 1m;
	         expires 30d;
	   	}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处nginx.conf中include了limit_common.conf、user_agent.conf、limit_info.conf与proxy_cache.conf，其中user_agent.conf中配置了客户端信息判断及文件合并等信息，limit_common.conf配置了ip限制相关公用信息，limit_info.conf配置了实际server中限制要求，proxy_cache.conf中配置了静态缓存相关信息，其中静态文件缓存部分为server运用中的配置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;user_agent.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#客户端判断
#if ($http_user_agent ~* &quot;MSIE&quot;) { proxy_pass http://appserver; }
if ($http_user_agent ~* &quot;Nokia&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;Mobile&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;SAMSUNG&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;SonyEricsson&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;MOT&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;BlackBerry&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;LG&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;HTC&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;J2ME&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;Opera Mini&quot;) { rewrite . /404.html break; }
if ($http_user_agent ~* &quot;ipad&quot;) { proxy_pass http://appserver; }
if ($http_user_agent ~* &quot;iphone&quot;) { proxy_pass http://appserver; }
if ($http_user_agent ~* &quot;android&quot;) { proxy_pass http://appserver; }

#只允许访问get、head、post方法
if ($request_method !~* ^(GET|HEAD|POST)$ ) {
		return 403;
}

#js、css文件合并
 	concat on;
 	#concat_max_files 10;
 	#只允许同类型文件合并
 	#concat_unique on;
 	#允许合并的文件类型，多个以逗号分隔。如：application/x-javascript, text/css
 	#concat_types text/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;limit_common.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#限制同一ip每秒访问20次
limit_req_zone $binary_remote_addr zone=allips:10m rate=20r/s;
#ip限制并发数
limit_conn_zone  $binary_remote_addr zone=addr:10m;

#服务器限制并发总数
limit_conn_zone $server_name zone=perserver:10m;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;limit_info.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#brust的意思就是，如果第1秒、2,3,4秒请求为19个，第5秒的请求为25个是被允许的。
#但是如果你第1秒就25个请求后面的5个请求就会被限制，返回503错误。
#nodelay，如果不设置该选项，严格使用平均速率限制请求数，
#也就是说如果你设置rate=120r/m,相当于每秒只允许处理2个请求

limit_req zone=allips burst=5 nodelay;

#连接数限制
limit_conn addr 10;  

limit_conn perserver 50000;

#连接限速
limit_rate 500k;   

#限制ip
allow 132.35.75.0/24;
#deny all;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;proxy_cache.conf配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;proxy_connect_timeout 5;
proxy_read_timeout 60;
proxy_send_timeout 5;
proxy_buffer_size 16k;
proxy_buffers 4 64k;
proxy_busy_buffers_size 128k;
proxy_temp_file_write_size 128k;
proxy_temp_path /home/spdev/nginx/openresty/local/nginx/proxy_temp;
proxy_cache_path /home/spdev/nginx/openresty/local/nginx/cache levels=1:2 
keys_zone=cache_one:200m inactive=1d max_size=30g;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Nginx配置及应用场景之基本配置</title>
   <link href="http://www.blogways.net/blog/2013/10/21/nginx-2.html"/>
   <updated>2013-10-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/21/nginx-2</id>
   <content type="html">&lt;h3 id=&quot;一nginxconf配置说明&quot;&gt;一、nginx.conf配置说明&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;主模块常用指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;daemon&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：设置是否以守护进程模式运行
 语法：daemon on|off
 缺省：on
 示例：daemon off
 注意：生产环境（production mode）中不要使用daemon指令，这些选项仅
 用于开发测试（development mode）。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;debug_points&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：断点调试
 语法：debug_points [stop|abort]
 缺省：none
 示例：debug_points stop;
 注意：在Nginx内有一些assert断言，这些断言允许Nginx，配合调试器中断程序运行、
 停止或创建core文件。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;master_process&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：设置是否启用主进程
 语法：master_process on|off
 缺省：on
 示例：master_process off;
 注意：
 不要在生产环境（production mode）中使用master_process指令，
 这些选项仅用于开发测试（development mode）。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;error_log&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：指定错误日志文件
 语法：error_log file [debug|info|notice|warn|error|crit]
 缺省：${prefix}/logs/error.log
 示例：
 error_log /data/nginx/logs/error.log debug
 注意：	
 该命令并非只有在测试（或称为开发）模式下才可以使用，而是在编译时添加了--with-debug参数时，
 则可以使用error_log指令的额外参数，即：
 error_log file [debug_core|debug_alloc|debug_mutex|debug_event|
 debug_http|debug_imap];
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;include&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：指定所要包含的Nginx配置文件

语法：include &amp;lt;file|*&amp;gt;
缺省：none
示例：include vhosts/*.conf 或 include /home/michael/nginx/conf/nginx-main.conf
注意：
（1）include命令可以指定包含一个文件，比如第二个示例。也可以指定包含一个目录下的所有文件，
    比如第一个示例。	
（2）指定的文件路径的基路径，由编译选项--prefix决定，如果编译时没有指定，
    则默认的路径是/usr/local/nginx。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;pid&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：指定存储进程ID（即PID）的文件。
 语法：pid &amp;lt;file&amp;gt;
 缺省：compile-time option Example
 示例：pid /var/log/nginx.pid;
 注意：可以使用命令kill -HUP cat /var/log/nginx.pid\ 对Nginx进行进程ID文件的重新加载。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;user&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：指定可以使用Nginx的用户	
 语法：user &amp;lt;user&amp;gt; [group]	
 缺省：nobody nobody（第一个nobody是user，第二个nobody是group）	
 示例：user spd spdev;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker_processes&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：指定worker进程数
 语法：worker_processes &amp;lt;number&amp;gt;	
 缺省：1		
 示例：worker_processes 4;	
 注意：最大用户连接数=worker进程数×worker连接数，
      即max_clients=worker_processes*worker_connections。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker_cpu_affinity&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 含义：为worker进程绑定CPU。		
 语法：worker_cpu_affinity cpumask [cpumask...]		
 缺省：none
 示例：
 （1）如果有4个CPU，并且指定4个worker进程，则：
     worker_processes 4;
     worker_cpu_affinity 0001 0010 0100 1000;
 （2）如果有4个CPU，并且指定2个worker进程，则：
     worker_processes 2;
     worker_cpu_affinity 0101 1010;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;注意：只有Linux平台上才可以使用该指令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker_rlimit_nofile&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：worker进程的file descriptor可以打开的最大文件数，最好与与ulimit -n的值保持一致。
语法：worker_rlimit_nofile &amp;lt;number&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;事件模块(events)常用指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;use&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;语法：use [kqueue | rtsig | epoll | /dev/poll | select | poll | eventport];
注意：如果在./configure的时候指定了不止一种事件模型，那么可以设置其中一个，告诉Nginx使用
哪种事件模型。默认情况下，Nginx会在./configure时找出最适合系统的事件模型。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;worker_connections&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;语法：worker_connection &amp;lt;number&amp;gt;;
最大连接数的计算公式如下：	
max_clients = worker_processes * worker_connections;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;accept_mutex&lt;/p&gt;

    &lt;p&gt;含义：设置是否使用连接互斥锁进行顺序的accept()系统调用。
   语法：accept_mutex &amp;lt;on|off&amp;gt;;
   缺省：on
   示例：accept_mutex off;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;accept_mutex_delay&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置获得互斥锁的最少延迟时间。	
语法：accpet_mutex_delay &amp;lt;number of millisecs&amp;gt;		
缺省：500ms		
示例：accpet_mutex_delay 1000ms;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;debug_connection&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置指定的clients产生debug日志。		
语法：debug_connection [ip|CIDR];	
缺省：none		
示例：debug_connection 172.16.44.96;	
一段较完整的事件模块代码如下：	
error_log /data/nginx/log/error.log;
events {	
    debug_connection172.16.44.96;	
}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HTTP模块常用指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;alias&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：指定location使用的路径，与root类似，但不改变文件的跟路径，仅适用文件系统的路径。
语法：alias &amp;lt;file-path | directory-path&amp;gt;		
缺省：N/A		
作用域：http.server.location	
示例：		
location /i/ {
    alias /home/michael/web/i/;		
}		
则请求 /i/logo.png 则返回 /home/michael/web/i/logo.png。	
注意：	
（1）替换路径时，可以使用变量。	
（2）alias无法在正则的location中使用。如果有这种需求，则必须使用rewrite和root。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_body_in_file_only&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：指定是否将用户请求体存储到一个文件里。	
语法：client_body_in_file_only &amp;lt;on | off&amp;gt;	
缺省：off	
作用域：http.server.location		
示例：client_body_in_file_only on;	
注意：	
（1）该指令为on时，用户的请求体会被存储到一个文件中，但是请求结束后，该文件也不会被删除；
（2）该指令一般在调试的时候使用。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_body_buffer_size&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：指定用户请求体所使用的buffer的最大值
语法：client_body_buffer_size &amp;lt;size&amp;gt;	
缺省：两个page的大小，一般为8k或16k	
作用域：http.server.location	
示例：client_body_buffer_size 512k;	
注意：如果用户请求体超过了buffer的大小，则将全部内容或部分内容存储到一个临时文件中。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_body_temp_path&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置存储用户请求体的文件的目录路径
语法：client_body_temp_path &amp;lt;directory path&amp;gt; [level1 | level2 | level3]		
作用域：http.server.location		
示例：client_body_temp_path /spool/nginx/client_temp 1 2;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_body_timeout&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置用户请求体的超时时间。
语法：client_body_timeout &amp;lt;time&amp;gt;	
作用域：http.server.location		
示例：client_body_timeout 120s;	
注意：只有请求体需要被1次以上读取时，该超时时间才会被设置。且如果这个时间后用户什么都没发，
nginx会返回requests time out 408.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_header_buffer_size&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置用户请求头所使用的buffer大小	
语法：client_header_buffer_size &amp;lt;size&amp;gt;		
缺省：1k		
作用域：http.server		
示例：client_header_buffer_size 2k;	
注意：
（1）对绝大多数请求来说，1k足以满足请求头所需的buffer；		
（2）对于携带有较大cookie或来自于wap用户的请求头来说，1k的buffer一般不够，这时可以使用指令
    large_client_header_buffers。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_header_timeout&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置用户请求头的超时时间。
语法：client_header_timeout &amp;lt;time&amp;gt;		
缺省：1m		
作用域：http.server.location		
示例：client_header_timeout 3m;		
注意：只有请求头需要被1次以上读取时，该超时时间才会被设置。且如果这个时间后用户什么都没发，
     nginx会返回requests time out 408.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;client_max_body_size&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：设置所能接收的最大请求体的大小
语法：client_max_body_size &amp;lt;size&amp;gt;		
缺省：1m	
作用域：http.server.location	
示例：client_max_body_size 2m;		
注意：根据请求头中的Content-Length来判断请求体大小是否允许。如果大于设定值，则返回
“ Request Entity Too Large”(413)错误。不过要注意的是，浏览器一般并不对这个错误进行特殊显示。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;send_timeout&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：指定响应客户端的超时时间,单位：秒，默认值为60
语法：send_timeout &amp;lt;time&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;keepalive_timeout&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：保持连接时间，单位:秒,超过该时间，服务器会关闭连接
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tcp_nopush&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：用于控制TCP链接是否推送，默认值是on
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tcp_nodelay&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;含义：用于控制TCP链接是否延迟，默认值是on,将tcp_nopush和tcp_nodelay两个
     指令设置为on用于防止网络阻塞	
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;HTTP模块Location相关指令&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;基本语法&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;语法：location [= | ~ | ~* | ^~] &amp;lt;/uri/&amp;gt; {...}	
缺省：N/A
作用域：server
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;匹配规则&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 四种匹配方式
   = 精确匹配	
   ~ 大小写敏感正则匹配
   ~* 大小写不敏感正则匹配	
   ^~ 前缀匹配

2. location匹配指令的执行顺序	
   首先：= 精确匹配；	
   其次：^~ 前缀匹配；		
   再次：~* 和 ~ 正则匹配，顺序依据出现顺序；
   最后：如果出现正则匹配成功，则采用该正则匹配；如果无可匹配正则，
   则采用前缀匹配结果。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;		location  = / { # 只匹配&quot;/&quot;.}
		location  / {# 匹配任何请求，因为所有请求都是以&quot;/&quot;开始
  				 # 但是更长字符匹配或者正则表达式匹配会优先匹配
					}
		
		location ^~ /images/ {
 					# 匹配任何以 /images/ 开始的请求，并停止匹配
				  其它location
			}

	     location ~* \.(gif|jpg|jpeg)$ {
		  # 匹配以 gif, jpg, or jpeg结尾的请求. 
		  # 但是所有 /images/ 目录的请求将由上面localtion处理.  
		}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;压缩（gzip）模块相关指令&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;gzip(GNU-ZIP)是一种压缩技术。经过gzip压缩后页面大小可以变为原来的30%甚至更小，这样，
用户浏览页面的时候速度会块得多。gzip的压缩页面需要浏览器和服务器双方都支持，实际上就
是服务器端压缩，传到浏览器后浏览器解压并解析。浏览器那里不需要我们担心，因为目前的巨
大多数浏览器都支持解析gzip过的页面。Nginx的压缩输出有一组gzip压缩指令来实现。相关指
令位于http{….}两个大括号之间。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;gzip on&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;该指令用于开启或关闭gzip模块(on/off)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_min_length 1k
    设置允许压缩的页面最小字节数，页面字节数从header头得content-length中进行获取。
    默认值是0，不管页面多大都压缩。建议设置成大于1k的字节数，小于1k可能会越压越大。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_buffers 4 16k
    设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流。4 16k代表以16k为单位，
    安装原始数据大小以16k为单位的4倍申请内存。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_http_version 1.1&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;识别http的协议版本(1.0/1.1)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_comp_level 2&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gzip压缩比，1压缩比最小处理速度最快，9压缩比最大但处理速度最慢(传输快但比较消耗cpu)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_types text/plain application/x-javascript text/css application/xml&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;匹配mime类型进行压缩，无论是否指定,”text/html”类型总是会被压缩的。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_vary on&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，
所以避免浪费不支持的也压缩，所以根据客户端的HTTP头来判断，是否需要压缩
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gzip_disable “MSIE [1-6].”&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;指定版本浏览器不压缩 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二实际应用中配置实例&quot;&gt;二、实际应用中配置实例&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;nginx.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	#user  nobody;
	worker_processes  48;
	worker_rlimit_nofile 1024;                                  
	error_log  logs/error.log  notice;
	#pid        logs/nginx.pid;
	events {
	    use epoll;
	    worker_connections  1024;
	}

	# HTTP服务配置
	http {
	    
	  	include  common.conf;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处nginx.conf中include了common.conf，其中common.conf中配置了http模块中公用信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;common.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	include       mime.types;
	default_type  application/octet-stream;		
	log_format  main  '|$remote_addr|- |$http_cookie| - |$remote_user| [$time_local]| '
	                  '&quot;$request&quot; |$status| $body_bytes_sent| &quot;$http_referer&quot;| '
	                  '|&quot;$http_user_agent&quot;| |&quot;$http_x_forwarded_for&quot;|';
	#access_log  off
	access_log  logs/access.log  main buffer=32K;	
	server_tokens off;
	client_max_body_size  20m;          												
	client_header_buffer_size    32K;   												
	large_client_header_buffers  4 32K;			            							
	sendfile        on;                 												
	tcp_nopush     on;                  												
	tcp_nodelay     on;  								
	client_header_timeout  30;  														
	client_body_timeout    30;  														
	send_timeout          30;
	keepalive_timeout  65;  															
	# HttpGzip模块配置
	include  gzip.conf;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此处common.conf中include了gzip.conf，其中gzip.conf中配置了HttpGzip模块中公用信息&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;其中gzip.conf部分配置&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	# HttpGzip模块配置，这个模块支持在线实时压缩输出数据流
	gzip  on;
	gzip_min_length  1k;
	gzip_proxied     any;
	gzip_buffers     4    16k;
	gzip_http_version    1.1;
	gzip_comp_level    1;
	gzip_types   text/plain application/x-javascript text/css application/xml;
	gzip_vary    on;
	gzip_disable &quot;MSIE [1-6]\.&quot;;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Nginx服务器介绍及扩展</title>
   <link href="http://www.blogways.net/blog/2013/10/18/nginx-1.html"/>
   <updated>2013-10-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/10/18/nginx-1</id>
   <content type="html">&lt;h2 id=&quot;一概述&quot;&gt;一、概述&lt;/h2&gt;
&lt;h3 id=&quot;架构&quot;&gt;架构&lt;/h3&gt;
&lt;p&gt;nginx在启动后，在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。我们也可以手动地关掉后台模式，让nginx在前台运行，nginx是以多进程的方式来工作的，当然nginx也是支持多线程的方式的，只是我们主流的方式还是多进程的方式。&lt;/p&gt;

&lt;p&gt;nginx在启动后，会有一个master进程和多个worker进程。master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。而基本的网络事件，则是放在worker进程中来处理了。多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的。一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，这里面的原因与nginx的进程模型以及事件处理模型是分不开的。nginx的进程模型，可以由下图来表示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chapter-2-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;基本概念&quot;&gt;基本概念&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;connection&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在nginx中connection就是对tcp连接的封装，其中包括连接的socket，读事件，写事件。利用nginx封装的connection，我们可以很方便的使用nginx来处理与连接相关的事情，比如，建立连接，发送与接受数据等。而nginx中的http请求的处理就是建立在connection之上的，所以nginx不仅可以作为一个web服务器，也可以作为邮件服务器。当然，利用nginx提供的connection，我们可以与任何后端服务打交道。&lt;/p&gt;

&lt;p&gt;在nginx中，每个进程会有一个连接数的最大上限，这个上限与系统对fd的限制不一样。在操作系统中，通过ulimit -n，我们可以得到一个进程所能够打开的fd的最大数，即nofile，因为每个socket连接会占用掉一个fd，所以这也会限制我们进程的最大连接数，当然也会直接影响到我们程序所能支持的最大并发数，当fd用完后，再创建socket时，就会失败。不过，这里我要说的nginx对连接数的限制，与nofile没有直接关系，可以大于nofile，也可以小于nofile。nginx通过设置worker_connectons来设置每个进程可使用的连接最大值。nginx在实现时，是通过一个连接池来管理的，每个worker进程都有一个独立的连接池，连接池的大小是worker_connections。这里的连接池里面保存的其实不是真实的连接，它只是一个worker_connections大小的一个ngx_connection_t结构的数组。并且，nginx会通过一个链表free_connections来保存所有的空闲ngx_connection_t，每次获取一个连接时，就从空闲连接链表中获取一个，用完后，再放回空闲连接链表里面。&lt;/p&gt;

&lt;p&gt;一个nginx能建立的最大连接数，应该是worker_connections * worker_processes。这里说的是最大连接数，对于HTTP请求本地资源来说，能够支持的最大并发数量是worker_connections * worker_processes，而如果是HTTP作为反向代理来说，最大并发数量应该是worker_connections * worker_processes/2。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;request&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;request具体到nginx中的数据结构是ngx_http_request_t。ngx_http_request_t是对一个http请求的封装。以下为nginx一个http请求的生命周期图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/chapter-2-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;nginx指令&quot;&gt;Nginx指令&lt;/h3&gt;
&lt;p&gt;nginx的配置系统由一个主配置文件和其他一些辅助的配置文件构成。这些配置文件均是纯文本文件，全部位于nginx安装目录下的conf目录下。配置文件中以#开始的行，或者是前面有若干空格或者TAB，然后再跟#的行，都被认为是注释，也就是只对编辑查看文件的用户有意义，程序在读取这些注释行的时候，其实际的内容是被忽略的。在nginx.conf中，包含若干配置项。每个配置项由配置指令和指令参数2个部分构成。指令参数也就是配置指令对应的配置值。&lt;/p&gt;

&lt;p&gt;配置指令是一个字符串，可以用单引号或者双引号括起来，也可以不括。但是如果配置指令包含空格，一定要引起来。指令的参数使用一个或者多个空格或者TAB字符与指令分开。指令的参数有一个或者多个TOKEN串组成。TOKEN串之间由空格或者TAB键分隔。TOKEN串分为简单字符串或者是复合配置块。复合配置块即是由大括号括起来的一堆内容。一个复合配置块中可能包含若干其他的配置指令。&lt;/p&gt;

&lt;p&gt;如果一个配置指令的参数全部由简单字符串构成，也就是不包含复合配置块，那么我们就说这个配置指令是一个简单配置项，否则称之为复杂配置项。例如下面这个是一个简单配置项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;error_page   500 502 503 504  /50x.html;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对于简单配置，配置项的结尾使用分号结束。对于复杂配置项，包含多个TOKEN串的，一般都是简单TOKEN串放在前面，复合配置块一般位于最后，而且其结尾，并不需要再添加分号。例如下面这个复杂配置项&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;location / {
    root   /home/jizhao/nginx-book/build/html;
    index  index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;nginx模块概述&quot;&gt;Nginx模块概述&lt;/h3&gt;
&lt;p&gt;nginx的内部结构是由核心部分和一系列的功能模块所组成。这样划分是为了使得每个模块的功能相对简单，便于开发，同时也便于对系统进行功能扩展。nginx将各功能模块组织成一条链，当有请求到达的时候，请求依次经过这条链上的部分或者全部模块，进行处理。每个模块实现特定的功能。例如，实现对请求解压缩的模块，实现SSI的模块，实现与上游服务器进行通讯的模块。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模块分类&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;nginx的模块根据其功能基本上可以分为以下几种类型：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;event module&lt;/strong&gt;: 搭建了独立于操作系统的事件处理机制的框架，及提供了各具体事件的处理。包括ngx_events_module， ngx_event_core_module和ngx_epoll_module等。nginx具体使用何种事件处理模块，这依赖于具体的操作系统和编译选项。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;phase handler&lt;/strong&gt;: 此类型的模块也被直接称为handler模块。主要负责处理客户端请求并产生待响应内容，比如ngx_http_static_module模块，负责客户端的静态页面请求处理并将对应的磁盘文件准备为响应内容输出。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;output filter&lt;/strong&gt;: 也称为filter模块，主要是负责对输出的内容进行处理，可以对输出进行修改。例如，可以实现对输出的所有html页面增加预定义的footbar一类的工作，或者对输出的图片的URL进行替换之类的工作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;upstream&lt;/strong&gt;: upstream模块实现反向代理的功能，将真正的请求转发到后端服务器上，并从后端服务器上读取响应，发回客户端。upstream模块是一种特殊的handler，只不过响应内容不是真正有自己产生的，而是从后端服务器上读取的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;load-balancer&lt;/strong&gt;: 负载均衡模块，实现特定的算法，在众多的后端服务器中，选择一个服务器出来作为某个请求的转发服务器。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;handler模块&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Handler模块就是接受来自客户端的请求并产生输出的模块，目前第三方开发模块最可能开发的就是三种类型的模块，即handler，filter和load-balancer。&lt;/p&gt;

&lt;h2 id=&quot;二openresty介绍及安装&quot;&gt;二、OpenResty介绍及安装&lt;/h2&gt;

&lt;h3 id=&quot;openresty介绍&quot;&gt;OpenResty介绍&lt;/h3&gt;
&lt;p&gt;OpenResty （也称为 ngx_openresty）是一个全功能的 Web 应用服务器，它打包了标准的 Nginx 核心，很多的常用的第三方模块，以及它们的大多数依赖项。OpenResty 
通过汇聚各种设计精良的 Nginx 模块。从而将 Nginx 有效的变成一个强大的 Web 应用服务器,这样, Web 开发人员可以使用 Lua 脚本语言调动 Nginx 支持的各种C以及Lua 模块。
OpenResty 的目标是让你的Web服务直接跑在 Nginx 服务内部,充分利用 Nginx 的非阻塞 I/O 模型,不仅仅对 HTTP 客户端请求,甚至于对远程后端诸如MySQL,PostgreSQL,
Memcache 以及 ~Redis 等都进行一致的高性能响应。&lt;/p&gt;

&lt;h3 id=&quot;openresty安装&quot;&gt;OpenResty安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、下载OpenResty http://openresty.org/download/ngx_openresty-1.4.2.8.tar.gz

2、解压openresty   gunzip -c ngx_openresty-1.4.2.8.tar.gz | tar xvf -

3、./configure \
  --prefix=/home/spdev/nginx/openresty/local \
  --sbin-path=/home/spdev/nginx/openresty/sbin \
  --user=spdev\
  --group=spd\
  --with-debug \
  --with-http_dav_module \
  --with-http_ssl_module \
  --with-http_stub_status_module \
  --with-http_addition_module \
  --with-http_flv_module \
  --without-http_memcached_module \
  --without-http_redis2_module \
  --without-http_redis_module  \
  --without-lua_redis_parser  \
  --without-mail_pop3_module \
  --without-mail_imap_module \
  --without-mail_smtp_module \
  
  make
  make install

 其中--with是自定义安装需要模块，--without是不安装默认安装的模块。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;第三方模块安装&quot;&gt;第三方模块安装&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、服务器新建目录如：/home/spdev/nginx/tb_module
  
2、下载第三方模块，如淘宝合并js模块
（svn checkout http://code.taobao.org/svn/nginx_concat_module/trunk/ 
 $NGINX_CONCAT_MODULE）。

3、./configure 中增加参数，--add-module=$NGINX_CONCAT_MODULE

./configure \
  --prefix=/home/spdev/nginx/openresty/local \
  --sbin-path=/home/spdev/nginx/openresty/sbin \
  --user=spdev\
  --group=spd\
  --with-debug \
  --with-http_dav_module \
  --with-http_ssl_module \
  --with-http_stub_status_module \
  --with-http_addition_module \
  --with-http_flv_module \
  --without-http_memcached_module \
  --without-http_redis2_module \
  --without-http_redis_module  \
  --without-lua_redis_parser  \
  --without-mail_pop3_module \
  --without-mail_imap_module \
  --without-mail_smtp_module \
  --add-module=/home/spdev/nginx/tb_module/$NGINX_CONCAT_MODULE \

4、make make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三nginx简单命令&quot;&gt;三、Nginx简单命令&lt;/h3&gt;
&lt;p&gt;Nginx默认配置文件nginx.conf位于nginx安装目录conf目录下，执行命令需切换至对应目录。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nginx    启动Nginx
nginx -c &amp;lt;/path/to/config&amp;gt;  Nginx 指定一个配置文件，来代替缺省的。
nginx -t 不运行，仅仅测试配置文件语法的正确性。
nginx -v 显示 nginx 的版本。
nginx -V 显示 nginx 的版本，编译器版本和配置参数。 
nginx -s reload 更改了配置后无需重启Nginx，平滑重启。
nginx -s stop  停止Nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 实例分析（自定义列表）</title>
   <link href="http://www.blogways.net/blog/2013/09/21/senchatouch-5.html"/>
   <updated>2013-09-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/21/senchatouch-5</id>
   <content type="html">&lt;h2 id=&quot;自定义列表分析&quot;&gt;自定义列表分析&lt;/h2&gt;
&lt;h4 id=&quot;这是一个应用分类软件的截图&quot;&gt;这是一个应用分类软件的截图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-7.png&quot; alt=&quot;应用程序下载页面截图&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;看看-st-里面如何来设计这个界面&quot;&gt;看看 ST 里面如何来设计这个界面&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-8.png&quot; alt=&quot;ST 视图设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;简单来划分，这个视图分为三块，最外面的 TabPanel（id: tp），面板上面的 TitleBar（id: tb）以及下面主要数据展示的 List（id: ll），下面来看看每个模块的代码：&lt;/p&gt;

&lt;h4 id=&quot;tabpanelid-tp&quot;&gt;TabPanel（id: tp）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('myapp.view.MyList', {
    extend: 'Ext.TabPanel',
    xtype: 'mylist',
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '首页',
            iconCls: 'home'
        },
        {
            title: '分类',
            iconCls: 'info'
        },
        {
            title: '达人',
            iconCls: 'locate'
        },
        {
            title: '排行',
            iconCls: 'user'
        },
        {
            title: '管理',
            iconCls: 'settings'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;titlebarid-tb&quot;&gt;TitleBar（id: tb）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xtype:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'titlebar',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;docked:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'top',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;items:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xtype:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'label',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'应用分类'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;iconCls:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'search',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;ui:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'plain',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;align:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'right'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;listid-ll&quot;&gt;List（id: ll）&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xtype:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'list',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;store:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'MyListStore',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;itemTpl:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;['&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mylist&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
                    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mylist-1&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;{img}&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/&amp;gt;&amp;lt;/div&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
                    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mylist-2&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;mylist-2-1&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;{title}&amp;lt;/div&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
                    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mylist-2-2&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;subtitle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mylist-3&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;download&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;lt;/div&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
              &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;/div&amp;gt;'].join(''),&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;flex:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;既然是 list 肯定是有数据源的，这个示例中定义的数据源名是 MyListStore，看下其如何实现的，为了简便起见 model 我没有单独写，跟 store 合到一起了。&lt;/p&gt;

&lt;h4 id=&quot;myappstoremyliststore&quot;&gt;myapp.store.MyListStore&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('myapp.store.MyListStore', {
    extend: 'Ext.data.Store',
    config: {
        // model: 'myapp.model.MyListModel',
        fields: ['title', 'subtitle', 'img', 'download'],
        data: [
           { title: '游戏', subtitle: '体育、战略、休闲', img: 'resources/icons/Icon.png', download: '22889'},
           { title: '电子书', subtitle: '小说、笑话、资料', img: 'resources/icons/Icon.png', download: '18621'},
           { title: '影音播放', subtitle: 'Adobe Flash 播放器', img: 'resources/icons/Icon.png', download: '2088'},
           { title: '交通导航', subtitle: 'Google 地图，高级地图', img: 'resources/icons/Icon.png', download: '685'},
           { title: '生活娱乐', subtitle: '大众点评，我查查', img: 'resources/icons/Icon.png', download: '9184'}
       ]
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看下最后的效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-9.png&quot; alt=&quot;ST 自定义列表效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最后看下合并后整个视图的代码&lt;/p&gt;

&lt;h4 id=&quot;myappviewmylist&quot;&gt;myapp.view.MyList&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('myapp.view.MyList', {
    extend: 'Ext.TabPanel',
    xtype: 'mylist',
    requires: [
        'Ext.Label',
        'Ext.dataview.List'
    ],
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '首页',
            iconCls: 'home',
            layout: 'vbox',
            items: [{
                xtype: 'titlebar',
                docked: 'top',
                items: [
                    {
                        xtype: 'label',
                        html: '应用分类'
                    },
                    {
                        iconCls: 'search',
                        ui: 'plain',
                        align: 'right'
                    }
                ]
            }, {
                xtype: 'list',
                store: 'MyListStore',
                itemTpl: ['&amp;lt;div class=&quot;mylist&quot;&amp;gt;', 
                                '&amp;lt;div class=&quot;mylist-1&quot;&amp;gt;&amp;lt;image src=&quot;{img}&quot;/&amp;gt;&amp;lt;/div&amp;gt;', 
                                '&amp;lt;div class=&quot;mylist-2&quot;&amp;gt;&amp;lt;div class=&quot;mylist-2-1&quot;&amp;gt;{title}&amp;lt;/div&amp;gt;', 
                                '&amp;lt;div class=&quot;mylist-2-2&quot;&amp;gt;{subtitle}&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;',
                                '&amp;lt;div class=&quot;mylist-3&quot;&amp;gt;{download}&amp;lt;/div&amp;gt;', 
                          '&amp;lt;/div&amp;gt;'].join(''),
                flex: 1
            }]
        },
        {
            title: '分类',
            iconCls: 'info'
        },
        {
            title: '达人',
            iconCls: 'locate'
        },
        {
            title: '排行',
            iconCls: 'user'
        },
        {
            title: '管理',
            iconCls: 'settings'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;自定义列表样式&lt;/p&gt;

&lt;h4 id=&quot;maincss&quot;&gt;main.css&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.mylist {
    height: 60px;
}

.mylist-1 {
    display: inline-block;
    float: left;
}

.mylist-2 {
    margin-top: 10px;
    padding-left: 10px;
    display: inline-block;
}

.mylist-2-1 {
    font-size: 1.2em;
}

.mylist-2-2 {
    margin-top: 5px;
    font-size: 0.6em;
}

.mylist-3 {
    display: inline-block;
    float: right;
    padding-top: 20px;
    padding-right: 5px;
    font-size: 0.6em;
}

.x-list .x-list-item .x-list-item-body, .x-list .x-list-item.x-list-item-tpl .x-innerhtml {
    padding: 5px 5px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个示例的选择相对比较简洁，大家有时候会看到更加复杂的列表，或者自己在开发的时候需要展示的数据更多，样式要求更复杂，其实原理都是一样的，通过定义 itemTpl 节点元素来实现自定义的列表项展示。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 实例分析（功能导航）</title>
   <link href="http://www.blogways.net/blog/2013/09/20/senchatouch-4.html"/>
   <updated>2013-09-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/20/senchatouch-4</id>
   <content type="html">&lt;h2 id=&quot;功能导航页面分析&quot;&gt;功能导航页面分析&lt;/h2&gt;
&lt;p&gt;本次分析的是支付宝的一个功能导航页面&lt;/p&gt;

&lt;h4 id=&quot;下面是支付宝导航页面截图&quot;&gt;下面是支付宝导航页面截图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-4.png&quot; alt=&quot;支付宝功能导航页面&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;我们来看看在-st-里面如何设计实现整个页面的部局&quot;&gt;我们来看看在 ST 里面如何设计实现整个页面的部局&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-5.png&quot; alt=&quot;支付宝功能导航页面设计&quot; /&gt;&lt;/p&gt;

&lt;p&gt;整个页面主要是一个 TabPanel（id: tp），里面包含了一个 Container（id: con1）和一个 Carousel（id: car），car 里面包含了一个 Container（id:con2）。&lt;/p&gt;

&lt;h4 id=&quot;下面来看看每个模块如何实现&quot;&gt;下面来看看每个模块如何实现：&lt;/h4&gt;

&lt;h5 id=&quot;tabpanelid-tp&quot;&gt;TabPanel（id: tp）&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('myapp.view.Paypal', {
    extend: 'Ext.TabPanel',
    xtype: 'paypal',
    requires: [],
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '支付宝',
            iconCls: 'home'
        },
        {
            title: '帐单',
            iconCls: 'info'
        },
        {
            title: '我的帐单',
            iconCls: 'locate'
        },
        {
            title: '安全',
            iconCls: 'user'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;containerid-con1&quot;&gt;Container（id: con1）&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xtype:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'container',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;padding:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'15px&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;5px&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;10px',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;style:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'background-color:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;#5E99CC',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;['&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title-1&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;/&amp;gt;&amp;lt;/div&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title-2&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title-2-1&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;4.10&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;元&amp;lt;/div&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;title-2-2&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;备注说明&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;'].join('')&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;carouselid-car&quot;&gt;Carousel（id: car）&lt;/h5&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xtype:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'carousel',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;flex:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;layout:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'fit',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;defaults:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;styleHtmlContent:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;items:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'Item&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;2'&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
            &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;html&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;['&amp;lt;div&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;nav&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;ul&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; 
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;转帐&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;信用卡还款&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;手机充值&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;水电煤&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;扫码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;iReader&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;li&amp;gt;&amp;lt;image&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;resources/icons/Icon.png&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;更多&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
                    &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;'&amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;'].join('')&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
        &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
    &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;看下总体的效果图&quot;&gt;看下总体的效果图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-6.png&quot; alt=&quot;ST 模仿效果图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然我并没有完全按原样的界面去做，毕竟图片跟样式不是我们这节的重点，这个完全是按简化版来设计的，也没有添加任何事件，给大家一个参考，在实际运用的时候大家可以把两部分分成两个单独的文件来开发，通过 xtype 再结合起来。另外当中的九宫图也是比较经典的部分，我是通过 html 的无序列表来实现的，我们知道很多经典的菜单都是通过 ul+css 来实现的，这个地方也不例外，无序列表配合 css 用来实现导航功能还是蛮强大的，当然也可以通 div 来实现九宫格，样式理解起来可能更容易一些，或者直接使用 ST 的 toolbar 来实现也是可以的，这三种方式都是可以动态添加创建的，这个地方不作讨论，如果有需要的话以后来写下这三种动态实现方式。&lt;/p&gt;

&lt;h4 id=&quot;下面来看下完整的代码&quot;&gt;下面来看下完整的代码&lt;/h4&gt;
&lt;p&gt;view&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('myapp.view.Paypal', {
    extend: 'Ext.TabPanel',
    xtype: 'paypal',
    requires: [],
    config: {
        tabBarPosition: 'bottom',
        items: [{
            title: '支付宝',
            iconCls: 'home',
            layout: 'vbox',
            items: [{
                xtype: 'container',
                padding: '15px 5px 5px 10px',
                style: 'background-color: #5E99CC',
                html: ['&amp;lt;div class=&quot;title&quot;&amp;gt;&amp;lt;div class=&quot;title-1&quot;&amp;gt;', 
                        '&amp;lt;image src=&quot;resources/icons/Icon.png&quot;/&amp;gt;&amp;lt;/div&amp;gt;', 
                        '&amp;lt;div class=&quot;title-2&quot;&amp;gt;&amp;lt;div class=&quot;title-2-1&quot;&amp;gt;4.10 元&amp;lt;/div&amp;gt;', 
                        '&amp;lt;div class=&quot;title-2-2&quot;&amp;gt;备注说明&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;'].join('')
            }, {
                xtype: 'carousel',
                flex: 1,
                layout: 'fit',
                defaults: {
                    styleHtmlContent: true
                },
                items: [
                    {
                        html : 'Item 1'
                    },
                    {
                        html : 'Item 2'
                    },
                    {
                        html : ['&amp;lt;div class=&quot;nav&quot;&amp;gt;&amp;lt;ul&amp;gt;', 
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;转帐&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;信用卡还款&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;手机充值&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;水电煤&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;扫码&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;iReader&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                    '&amp;lt;li&amp;gt;&amp;lt;image src=&quot;resources/icons/Icon.png&quot;&amp;gt;&amp;lt;/image&amp;gt;&amp;lt;a&amp;gt;更多&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;',
                                '&amp;lt;/ul&amp;gt;&amp;lt;/div&amp;gt;'].join('')
                    }
                ]
            }]
        },
        {
            title: '帐单',
            iconCls: 'info'
        },
        {
            title: '我的帐单',
            iconCls: 'locate'
        },
        {
            title: '安全',
            iconCls: 'user'
        }]
    }
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;css&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.title {
}

.title-1 {
    float: left;
    display: inline-block;
}

.title-2 {
    display: inline-block;
    margin: 5px;
    padding-top: 5px;
}

.title-2-1 {
    font-size: 1.2em;
}

.title-2-2 {
    font-size: 0.6em;
}

.nav {
    margin: 0;
    padding: 0;
    font-size: 0.6em;
}

.nav {
    margin: 0px;
    padding: 0px;
}

.nav ul {
    margin: 0px;
    padding: 0px;
}

.nav ul li {
    width: 33%;
    height: 80px;
    float: left;
    display: inline;
    text-align: center;
}

.nav ul li img {
    width: 48px;
    height: 48px;
}

.nav ul li a {
    display: block;
    text-decoration: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;方便起见，我把代码合到一个 view 文件里面，如果你还不知道怎么看的话，见意回头看看基础概念，别急于求成。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>构建基于 Sencha Touch MVC 的 web 应用</title>
   <link href="http://www.blogways.net/blog/2013/09/20/senchatouch-3.html"/>
   <updated>2013-09-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/20/senchatouch-3</id>
   <content type="html">&lt;h2 id=&quot;构建基于-sencha-touch-mvc-的-web-应用&quot;&gt;构建基于 Sencha Touch MVC 的 web 应用&lt;/h2&gt;
&lt;h3 id=&quot;mvc-程序结构解析&quot;&gt;MVC 程序结构解析&lt;/h3&gt;
&lt;p&gt;就算以前有 EXT 的编程经验，刚接触 ST MVC 的时候，你可能会被一个个文件夹跟一堆堆的 js 搞得头昏脑涨，建一个视图需要几个文件，每个文件该如何创建，相互之间如何调用。所以开始实践之前有必要来了解下 MVC 的整个程序结构。&lt;/p&gt;

&lt;p&gt;一个应用程序其实就是Models，Views，Controllers，Stores和Profiles的集合，只不过附加了一些特殊的元素，例如程序的图标或者加载图片等等。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-3.png&quot; alt=&quot;ST 应用程序架构&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Model：在应用程序中代表了一个对象类型，简单理解便是数据模型。
View：利用Sencha Touch内部组件，负责向用户显示数据，简单解释便是视图。
Controller：处理应用程序的交互，监听事件并作出响应，简单理解就是控制器。
Store：负责将数据加载到我们的应用程序当中。
Profile：为的是在尽可能多的通用代码下，为手机和平板电脑定制UI。简单理解就是配置文件，如果是手机应该加载怎样的UI，平板电脑则加载什么样的UI。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通常我们在Sencha Touch的应用程序中都会这样编写application：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    models: ['User', 'Product', 'nested.Order'],
    views: ['OrderList', 'OrderDetail', 'Main'],
    controllers: ['Orders'],
    launch: function() {
        Ext.create('MyApp.view.Main');
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么我们就对以上代码进行简单分析：&lt;/p&gt;

&lt;p&gt;name：便是我们定义的命名空间，我们的所有代码都在该空间下编写，类似Java中的顶级包名。在上面的代码中，我们我们知道，在view文件夹下有Main.js文件，就等价于该文件的存在路径为MyApp.view.Main。&lt;/p&gt;

&lt;p&gt;我们通过models,views和controllers来加载相应目录下的文件。&lt;/p&gt;

&lt;p&gt;Controllers&lt;/p&gt;

&lt;p&gt;controller是程序的中心，它把程序的各部分有机的结合在一起，并统一运行控制，使我们的程序正常运行。比如，view中存放的仅仅是页面布局等代码，关于页面逻辑处理的代码几乎都存放在controller中了，实现逻辑代码的统一管理。&lt;/p&gt;

&lt;p&gt;A simple example&lt;/p&gt;

&lt;p&gt;接下来的例子展示给我们如何快速的定义控制器。在这里我们使用两个比较常用的控制器配置项：refs和control。通过refs，我们可以轻松的在一个页面中找到任何的组件。在本例中，我们将匹配xtype为formpanel的组件，并将第一个匹配的作为loginForm，并在doLogin函数之后使用该属性。&lt;/p&gt;

&lt;p&gt;第二件事情便是建立起一个control配置项。就像refs，它使用一个组件查询器来找到所有的formpanel。看看下面具体的代码再说吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('MyApp.controller.Sessions', {
    extend: 'Ext.app.Controller', 
    config: {
        refs: {
            loginForm: 'formpanel'
        },
        control: {
            'formpanel button': {
                tap: 'doLogin'
            }
        }
    },
 
    doLogin: function() {
        var form = this.getLoginForm(),
            values = form.getValues(); 
        MyApp.authenticate(values);
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;doLogin函数本身是很简单的，因为在定义一个loginForm的refs的时候，控制器会自动为我们生成一个getLoginForm的函数，返回我们需要的那个formpanel。简单理解上面代码的作用便是：refs是我们声明的组件的引用，control中是我们对这些组件需要监听的事件以及触发的函数。refs是指向，control是控制。&lt;/p&gt;

&lt;p&gt;Stores&lt;/p&gt;

&lt;p&gt;Stores是Sencha Touch中特别重要的部分，并且大多数的窗体都会绑定数据的。简单来说，store其实就像是model的数据实体。例如List和DataView这些组件，渲染的都是store中的model的实体。因为model的实体被添加或者从store中移除时，都会触发这些组件所绑定的数据监听，达到更新或者其他操作的目的。&lt;/p&gt;

&lt;p&gt;Device Profiles&lt;/p&gt;

&lt;p&gt;我们知道，Sencha Touch程序会运行在不同设备上，这些设备有着不同的功能或者屏幕分辨率。例如一个用户界面可能比较适合于平板电脑，但是在手机中就显得不是那么合适了，反之亦然。然而我们在编写应用程序的时候，并不想为每一设备都单独写一个程序，那样太麻烦了，我们更倾向于写好的程序，本身能够在手机或者平板电脑中运行并根据设备进行不同的加载，显示不同的UI风格，这是我们便要用好profile文件了。profile文件只是简单的告诉程序，如何针对不同的设备进行不同的加载，我们通常在程序开始的时候便声明它：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    profiles: ['Phone', 'Tablet'],
    //as before
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;一旦我们像上面这段代码一样，声明了我们的profile文件，那么程序在加载的过程当中，就会去加载我们app/profile目录下的相应JS文件了。我们可以看看下面这段代码是如何定义一个平板电脑的配置文件的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('MyApp.profile.Tablet', {
    extend: 'Ext.app.Profile',
    config: {
        controllers: ['Groups'],
        views: ['GroupAdmin'],
        models: ['MyApp.model.Group']
    }, 
    isActive: function() {
        return Ext.os.is.Tablet;
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要Sencha Touch认为我们的应用程序是运行在平板电脑上的时候，isActive函数便会返回true。其实这个判断并不是很准确的，因为目前的平板电脑和手机并没有很明显的界限，所有Sencha Touch在进行判断的时候，只识别ipad，对于其他的平板电脑都会返回false的，也就是说除了ipad，其他的都看做是手机。不过你也可在isActive函数中进行细化，来实现你需要的功能。
我们在编写代码的时候，一定要注意，只能有一个true从profile文件中返回，否则的话程序只会识别第一个返回的true，其他的将不会被识别或者被忽略。这时我们应用程序会被设定在当前的配置文件下，并且可以被随时查看。&lt;/p&gt;

&lt;p&gt;如果检测到我们当前的配置文件，定义了额外的models，views，controllers或者stores，这些都会被自动加载的。但是名字可不是随便写的，这些都是有一定关联的，看下面的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;views: ['GroupAdmin'] will load app/view/tablet/GroupAdmin.js
controllers: ['Groups'] will load app/controller/tablet/Groups.js
models: ['MyApp.model.Group'] will load app/model/Group.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果没有完整的名字的话，该文件必须存放在相应目录下的tablet子目录下，例如所有的视图文件都必须存放在app/view/tablet目录下，但是如果指定了完整的路径的话，只要该文件存在于该路径下就OK了。&lt;/p&gt;

&lt;p&gt;大多数情况下，我们只会在profile中定义一些额外的视图或者控制器，共享我们应用程序的数据。&lt;/p&gt;

&lt;p&gt;Launch Process&lt;/p&gt;

&lt;p&gt;我们可以为每一个应用程序定义一个launch函数，负责应用程序的加载，同时这里也是我们设定应用程序启动逻辑，创建主视图的最好位置。除了在该位置之外，我们还有两个地方可以设定我们程序的启动逻辑。首先是每一个控制器中，我们可以定义一个init函数，该函数会在launch函数之前被调用。另一个便是，如果我们使用了设备配置文件，那么每一个profile中都能定义launch函数，该函数会在控制器的init之后，launch之前被调用。&lt;/p&gt;

&lt;p&gt;例如我们为设备定义了不同的profile文件，phone和tablet，并在一个平板电脑中运行我们的应用程序，那么启动顺序如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.控制器的init函数被调用。
2.Profile中的launch函数会被调用。
3.应用程序的launch函数会被调用。
4.控制器中的launch函数会被调用。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当我们使用Profile文件的时候，通常会把启动的逻辑顺序放在Profile的launch中，因为我们会根据不同设备，建立不同的视图启动顺序。&lt;/p&gt;

&lt;h2 id=&quot;管理-mvc-的依赖项&quot;&gt;管理 MVC 的依赖项&lt;/h2&gt;
&lt;p&gt;ST2应用程序用来定义依赖项的地方主要有两个，application本身和应用程序内部类。本指南将给出一些关于应用程序如何放置和在哪里放置依赖项的建议。&lt;/p&gt;

&lt;h4 id=&quot;应用程序依赖项&quot;&gt;应用程序依赖项&lt;/h4&gt;
&lt;p&gt;当你创建一个MVC应用程序时，Ext.application会提供一个直观的方式来设置应用程序会用到的数据模型、视图、控制器、数据存储器和配置文件等，如下例所示：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    views: ['Login'],
    models: ['User'],
    controllers: ['Users'],
    stores: ['Products'],
    profiles: ['Phone', 'Tablet']
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这5个配置项是用来加载应用程序常用文件（数据模型、视图、控制器、存储器、配置文件）的快捷方式。如上的配置意味着应用程序会自动加载下列文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app/view/Login.js
app/model/User.js
app/controller/Users.js
app/store/Products.js
app/profile/Phone.js
app/profile/Tablet.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就加载文件而言，上面的例子跟下面的定义是等价的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.require([
    'MyApp.view.Login',
    'MyApp.model.User',
    'MyApp.controller.Users',
    'MyApp.store.Products',
    'MyApp.profile.Phone',
    'MyApp.profile.Tablet'
]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在你需要加载更多的类文件情况下，这种配置方式就会更有用，它能避免你为每一个文件都拼写又臭又长的完整类名。除了把依赖文件加载进来之外，这几个配置还会做更多的事情：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;profiles 
配置文件 – 实例化每一个Profle并判断哪一个当前可用。当前可用的那个profile中所有依赖项也将被加载

controllers
控制器 – 加载完成后实例化每一个控制器

stores
存储器 – 实例化每一个存储器，没有指定id的存储器会被指定一个默认id
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这意味着，如果你要享受MVC带给你的便利，那么载你定义应用程序依赖项的时候，最好使用配置选项这种方式。&lt;/p&gt;

&lt;h4 id=&quot;配置文件指定的依赖项&quot;&gt;配置文件指定的依赖项&lt;/h4&gt;
&lt;p&gt;当你使用设备配置的时候，可能会有一些类是仅在特定设备上使用的。例如，平板电脑版本的应用程序可能包含比手机版本更多的功能，这当然意味着要加载更多的类。每个Profile都可以在内部定义额外的依赖项。&lt;/p&gt;

&lt;p&gt;Ext.define(‘MyApp.profile.Tablet’, {
    extend: ‘Ext.app.Profile’,
    config: {
        views: [‘SpecialView’],
        controllers: [‘Main’],
        models: [‘MyApp.model.SuperUser’]
    },
    isActive: function() {
        return Ext.os.is.Tablet;
    }
});&lt;/p&gt;

&lt;p&gt;然后每个profile中定义的依赖项都会被加载，不管这个profile是否active，不过尽管都被加载，但应用程序不会去做类似实例化非active状态profile指定的控制器这样的无用功。&lt;/p&gt;

&lt;p&gt;这听起来有点不合常规，为什么要下载那些不会用到的类文件呢？这么做的原因是产生一个可以在任何设备上运行的通用程序版本，然后检测哪一个profile应该被使用，接着从这个profile启动应用程序。与之相对的选择是为每个profile创建一个应用版本，然后启动一个微型加载器来检测哪个profile该被选择，然后去下载该profile需要的代码文件。&lt;/p&gt;

&lt;p&gt;的确这种通用架构的程序会在每个设备上都下载一些根本用不到的代码文件，不过对于绝大多数应用程序来说，你多下载的这点文件影响实在是微乎其微。而对于比较庞大的应用程序来说，这个问题可能更值得注意，所以我们可能在2.0的后续版本对它进行处理。&lt;/p&gt;

&lt;h4 id=&quot;级联依赖&quot;&gt;级联依赖&lt;/h4&gt;

&lt;p&gt;大一些应用通常会把数据模型、视图、控制器分别存储在不同子文件夹下，这样可以让整个项目看起来更清晰明了一些。对于视图来说尤其如此，大型应用拥有上百个独立的视图类并非天方夜谭，因此分文件夹存储几乎不可避免。&lt;/p&gt;

&lt;p&gt;指定子文件夹中的依赖项只需要使用“.”来分割文件夹路径即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.application({
    name: 'MyApp',
    controllers: ['Users', 'nested.MyController'],
    views: ['products.Show', 'products.Edit', 'user.Login']
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上例中将会加载下列5个文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;app/controller/Users.js
app/controller/nested/MyController.js
app/view/products/Show.js
app/view/products/Edit.js
app/view/user/Login.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以混合使用两种方式来定义每个数据模型、视图、控制器、配置文件和存储器：快捷路径方式（符合mvc推荐原则的类只写最后的类名即可）和完整路径方式（自定义路径的类则写完整路径加类名）。&lt;/p&gt;

&lt;h4 id=&quot;外部依赖项&quot;&gt;外部依赖项&lt;/h4&gt;

&lt;p&gt;我们可以通过指定想要加载的完整类名方式来定义应用程序之外的类作为依赖项。这种情况最常见的用途就是在多个应用之间共享认证逻辑。我们可能会有好几个应用程序都要到同一个用户数据库进行验证并实现登录，这时我们当然希望它们能够共享用户登录的代码。比较容易的方式就是在应用程序文件夹之外创建一个单独的文件夹然后把其中的内容作为依赖项添加到应用程序中去。&lt;/p&gt;

&lt;p&gt;我们假定共享的登录代码包含一个login控制器，一个用户model和一个login表单视图。我们要在应用程序中把它们全部用上：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.Loader.setPath({
    'Auth': 'Auth'
});

Ext.application({
    views: ['Auth.view.LoginForm', 'Welcome'],
    controllers: ['Auth.controller.Sessions', 'Main'],
    models: ['Auth.model.User']
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码将加载以下的文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Auth/view/LoginForm.js
Auth/controller/Sessions.js
Auth/model/User.js
app/view/Welcome.js
app/controller/Main.js
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;前面三个文件加载自应用程序外部，后两个则来自应用程序内部。同样我们可以混合调用内外部依赖项。&lt;/p&gt;

&lt;p&gt;想要启用外部依赖项加载，我们只需告诉Loader到哪里可以找到这些文件即可，Ext.Loader.setPath就是干这个的。上例中我们告诉Loader所有以Auth命名空间中的文件都可以到Auth这个文件夹中找到。这样我们就能把应用程序文件夹之外的通用验证代码都拽进来了，其他的事情由ST框架来处理。&lt;/p&gt;

&lt;p&gt;依赖项应该放在哪里&lt;/p&gt;

&lt;p&gt;决定在哪里声明依赖项的一个基本原则就是保证你的类文件完整的内部包含。例如，你有一个视图A包含了几个其他的视图，你就应该在这个A视图内部声明它的依赖项，而不是在application中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.define('MyApp.view.Main', {
    extend: 'Ext.Container',
    requires: [
        'MyApp.view.Navigation',
        'MyApp.view.MainList'
    ],
    config: {
        items: [
            {
                xtype: 'navigation'
            },
            {
                xtype: 'mainlist'
            }
        ]
    }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;App.js中这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.application({
    views: ['Main']
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这才是依赖项的最佳声明方式。两个原因：1、确保app.js干净；2、让你知道主程序依赖MyApp.view.Main就已经足够。不好的方式就是下面这样把视图都罗列在app.js里：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Ext.application({
    views: ['Main', 'Navigation', 'MainList']
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;换种方式来描述这个问题，app.js只需要包含最顶级的视图即可。你在应用程序内部通过Ext.create(‘MyApp.view.SomeView’)来创建的视图就可以视作顶级视图。其他那些仅仅被作为某些视图内部子视图的（比如例子中的MyApp.view.Navigation和MyApp.view.MainList）就不应该出现在app.js里面。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 体验</title>
   <link href="http://www.blogways.net/blog/2013/09/18/senchatouch-2.html"/>
   <updated>2013-09-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/18/senchatouch-2</id>
   <content type="html">&lt;h2 id=&quot;sencha-touch-体验&quot;&gt;Sencha Touch 体验&lt;/h2&gt;

&lt;h3 id=&quot;下载安装&quot;&gt;下载&amp;amp;&amp;amp;安装&lt;/h3&gt;
&lt;p&gt;Sencha Touch 2 SDK ：
http://www.sencha.com/products/touch/&lt;/p&gt;

&lt;p&gt;SDK Tool：
http://www.sencha.com/products/sdk-tools/download&lt;/p&gt;

&lt;p&gt;解压 SDK 后是不能直接打开帮助文档的，需要部署到 web 服务器，通过 WebKit 的浏览器（chrome或者safari等）才能查看自带的帮助文档以及 Demo。&lt;/p&gt;

&lt;p&gt;安装好 SDK Tool，在命令窗口输入 sencha 可以查询到 st cmd 相关信息。&lt;/p&gt;

&lt;h3 id=&quot;创建第一个-sencha-touch-应用&quot;&gt;创建第一个 Sencha Touch 应用&lt;/h3&gt;

&lt;p&gt;命令行格式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sencha generate app 应用的命名空间 app路径
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E:\program\download\Html5\sencha\touch-2.2.1&amp;gt;sencha generate app myapp ../myapp
Sencha Cmd v3.1.2.342
[INF]
[INF] init-plugin:
[INF]
[INF] -before-generate-workspace:
[INF]
[INF] cmd-root-plugin.init-properties:
[INF]
[INF] init-properties:
[INF]
[INF] init-sencha-command:
[INF]
[INF] init:
[INF]
[INF] generate-workspace-impl:
[INF]      [echo] generating into E:\program\download\Html5\sencha\touch-2.2.1\..\myapp from D:\program\Sencha\Cmd\3.1.2.342/templates/workspace
[INF]     [mkdir] Created dir: E:\program\download\Html5\sencha\myapp\packages
[INF]
[INF] cmd-root-plugin.copy-framework-to-workspace-impl:
[INF] [propertyfile] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\workspace\sencha.cfg
[INF]
[INF] copy-framework-to-workspace-impl:
[INF]      [copy] Copying 1862 files to E:\program\download\Html5\sencha\myapp\touch
[INF]      [copy] Copied 218 empty directories to 3 empty directories under E:\program\download\Html5\sencha\myapp\touch
[INF]      [copy] Copying 1 file to E:\program\download\Html5\sencha\myapp\touch
[INF]      [copy] Copying 1 file to E:\program\download\Html5\sencha\myapp\touch
[INF] [propertyfile] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\workspace\sencha.cfg
[INF]
[INF] copy-framework-to-workspace:
[INF]
[INF] generate-workspace:
[INF]
[INF] -after-generate-workspace:
[INF]
[INF] init-plugin:
[INF]
[INF] cmd-root-plugin.init-properties:
[INF]
[INF] init-properties:
[INF]
[INF] init-sencha-command:
[INF]
[INF] init:
[INF]
[INF] before-upgrade:
[INF]
[INF] generate-app-impl:
[INF]
[INF] generate-starter-app:
[INF]     [mkdir] Created dir: E:\program\download\Html5\sencha\myapp\app\profile
[INF]
[INF] copy-sdk:
[INF]      [copy] Copying 1 file to E:\program\download\Html5\sencha\myapp\resources\css
[INF]      [copy] Copying 4 files to E:\program\download\Html5\sencha\myapp\resources\sass\stylesheets
[INF] [x-property-file] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\app\sencha.cfg
[INF]
[INF] after-upgrade:
[INF]
[INF] generate-app:
[INF]
[INF] -after-generate-app:
[INF] [x-property-file] Updating property file: E:\program\download\Html5\sencha\myapp\.sencha\app\sencha.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;将产生的 myapp 项目部署到 web 服务器，通过 chrome 浏览器查看应用是否创建成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-1.png&quot; alt=&quot;第一个 Sencha Touch 应用&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;项目结构分析&quot;&gt;项目结构分析&lt;/h3&gt;
&lt;p&gt;将生成的项目使用 IDE 打开&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/st-2.png&quot; alt=&quot;Sencha Touch 项目结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;app - 目录，MVC 相关程序文件，下一章会做详细介绍
app.js - 应用的 js 入口文件
app.json - 应用配置文件，ST 采用动态加载 js 以及 css 文件机制，在 html 文件里面只需要加载 &lt;code class=&quot;highlighter-rouge&quot;&gt;touch/microloader/development.js&lt;/code&gt; js 文件就可以了，其他的都配在这个文件里面
index.html - 应用入口 index 文件
packager.json - 打包原生程序的配置文件
resources - 目录，项目资源文件
touch - Sencha Touch SDK的副本&lt;/p&gt;

&lt;h3 id=&quot;编译打包&quot;&gt;编译打包&lt;/h3&gt;
&lt;p&gt;这个时候的项目虽然都能正常运行，但项目明显太大了，因为整个 ST sdk 的东西都包含在里面，而且目录也很多，通过打包将代码都打到一个文件夹里面，去除不必要的项目文件，形成最简洁的项目文件。&lt;/p&gt;

&lt;p&gt;命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sencha app build package
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;进入项目根目录下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E:\program\download\Html5\sencha\myapp&amp;gt;sencha app build package
[INF] Saving certificate as D:\Program Files\Sencha\cmd\Sencha\Cmd\repo\pkgs\cer
t.json
[INF] Saving private key as D:\Program Files\Sencha\cmd\Sencha\Cmd\repo\.sencha\
repo\private-key.json
Sencha Cmd v3.1.2.342
[INF]
[INF] init-plugin:
[INF]
[INF] cmd-root-plugin.init-properties:
[INF]
[INF] init-properties:
[INF]
[INF] init-sencha-command:
[INF]
[INF] init:
[INF]
[INF] app-build-impl:
[INF]
[INF] -before-init-local:
[INF]
[INF] -init-local:
[INF]
[INF] -after-init-local:
[INF]
[INF] init-local:
[INF]
[INF] find-cmd:
[INF]
[INF] -before-init:
[INF]
[INF] -init:
[INF] Initializing Sencha Cmd ant environment
[INF] Adding antlib taskdef for com/sencha/command/compass/ant/antlib.xml
[INF] [x-load-properties] Loading optional properties file E:\program\download\H
tml5\sencha\myapp\.sencha\app\package.properties
[INF] [x-load-properties] Loading required properties file E:\program\download\H
tml5\sencha\myapp\.sencha\app\build.properties
[INF]
[INF] -after-init:
[INF]
[INF] -before-init-default:
[INF]
[INF] -init-default:
[INF]
[INF] -after-init-default:
[INF]
[INF] init:
[INF]
[INF] -before-build:
[INF]
[INF] sass:
[INF]
[INF] -before-sass:
[INF]
[INF] -sass:
[INF] executing compass using system installed ruby runtime
Error loading gem paths on load path in gem_prelude
can't modify frozen string
&amp;lt;internal:gem_prelude&amp;gt;:69:in `force_encoding'
&amp;lt;internal:gem_prelude&amp;gt;:69:in `set_home'
&amp;lt;internal:gem_prelude&amp;gt;:38:in `dir'
&amp;lt;internal:gem_prelude&amp;gt;:76:in `set_paths'
&amp;lt;internal:gem_prelude&amp;gt;:47:in `path'
&amp;lt;internal:gem_prelude&amp;gt;:286:in `push_all_highest_version_gems_on_load_path'
&amp;lt;internal:gem_prelude&amp;gt;:355:in `&amp;lt;compiled&amp;gt;'
   remove ../css/app.css
   create ../css/app.css
[INF]
[INF] -after-sass:
[INF]
[INF] page:
[INF]
[INF] -before-page:
[INF]
[INF] -page:
[INF] building application
[INF] Deploying your application to E:\program\download\Html5\sencha\myapp\build
\myapp\package
[INF] Copied E:\program\download\Html5\sencha\myapp\app.js to E:\program\downloa
d\Html5\sencha\myapp\build\myapp\package\app.js
[INF] Copied E:\program\download\Html5\sencha\myapp\resources\css\app.css to E:\
program\download\Html5\sencha\myapp\build\myapp\package\resources\css\app.css
[WRN] File or folder E:\program\download\Html5\sencha\myapp\resources\images not
 found
[INF] Copied E:\program\download\Html5\sencha\myapp\resources\icons
[INF] Copied E:\program\download\Html5\sencha\myapp\resources\startup
[INF] Resolving your application dependencies (file:///E:/program/download/Html5
/sencha/myapp/index.html)
[INF] Compiling app.js and dependencies
[INF] Loading classpath entry E:\program\download\Html5\sencha\myapp\touch\src
[INF] Loading classpath entry E:\program\download\Html5\sencha\myapp\app.js
[INF] Loading classpath entry E:\program\download\Html5\sencha\myapp\app
[INF] Concatenating output to file E:\program\download\Html5\sencha\myapp\build\
myapp\package\app.js
[INF] Completed compilation.
[INF] Processed remote file touch/sencha-touch.js
[INF] Processed local file app.js
[INF] Minified app.js
[INF] Generated app.json
[INF] Embedded microloader into index.html
[INF] Successfully deployed your application to E:\program\download\Html5\sencha
\myapp\build\myapp\package
[INF]
[INF] -after-page:
[INF]
[INF] run:
[INF]
[INF] -build:
[INF]
[INF] -after-build:
[INF]
[INF] build:
[INF]
[INF] app-build:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行有报错，貌似也没什么多大的影响，查看根目录下 build 文件里面会生成打包后的项目文件。&lt;/p&gt;

&lt;p&gt;注意，这个地方的打包并不是说将 web 应用打包成终端的 native 应用，ST 的 cmd 虽然提供打包功能，但打出来的包问题太多，目前并不推荐使用，打包本地应用在后面章节再做介绍，如果实在想看效果的话，网上有几个在线打包工具可以试下。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Sencha Touch 框架简介</title>
   <link href="http://www.blogways.net/blog/2013/09/17/senchatouch-1.html"/>
   <updated>2013-09-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/09/17/senchatouch-1</id>
   <content type="html">&lt;h2 id=&quot;sencha-touch-框架简介&quot;&gt;Sencha Touch 框架简介&lt;/h2&gt;

&lt;p&gt;Sencha Touch（下称ST） 框架是第一个基于 HTML5 的 Mobile App 框架，是 Ext 整合 JQTouch 和 Raphael 而推出的适用于最前沿 Touch Web 的框架，完全基于 HTML5+CSS3 的最新标准，全面兼容 Android 、 Apple IOS 和 BlackBerry 等设备。ST 继承了 Ext 的界面风格，可以让你的 Web App 看起来更像 Native App，其丰富的界面组件、强大的数据管理以及跨浏览器兼容的矢量图将 ST 打造成 Mobile 跨平台开发利器，易扩展，足够应付绝大部分开发需求。&lt;/p&gt;

&lt;p&gt;由于苹果对 Flash 的封杀，使得 Flash 无法进入 IOS 的平台，虽然 Flash 对 Android 系统支持得也不错，但对开发者来说还是有些遗憾，Flash 引以为豪的跨平台特性被中止，随着 Webkit 在移动设备上的流行，越来越多的人开始看好 Html5，后来居上的 ST 得到快速的发展。&lt;/p&gt;

&lt;h3 id=&quot;下面是官方列出的几大特性&quot;&gt;下面是官方列出的几大特性：&lt;/h3&gt;

&lt;h4 id=&quot;1基于最新的-web-标准html5css3javascript&quot;&gt;1、基于最新的 web 标准——HTML5，CSS3，JavaScript&lt;/h4&gt;
&lt;p&gt;整个库压缩和 gzip 后大约 120KB，通过禁用一些组件还会使它更小。&lt;/p&gt;

&lt;h4 id=&quot;2支持目前世界上最好的移动设备&quot;&gt;2、支持目前世界上最好的移动设备&lt;/h4&gt;
&lt;p&gt;Sencha Touch 目前支持 Apple iOS，Android 和 BlackBerry 等目前 3G 市场上最流行的移动设备，它为不同的设备定制了不同的主题，用户可以通过使用这些主题使 web 应用在移动设备上的展现更华丽。&lt;/p&gt;

&lt;h4 id=&quot;3增强的触摸事件&quot;&gt;3、增强的触摸事件&lt;/h4&gt;
&lt;p&gt;除了 touchstart，touchend 等标准事件基础外，Sencha Touch 增加了一组自定义触摸事件，如 tap、double tap、swipe、tap and hold、pinch、rotate 等。&lt;/p&gt;

&lt;h4 id=&quot;4数据集成&quot;&gt;4、数据集成&lt;/h4&gt;
&lt;p&gt;Sencha Touch 提供了强大的数据包，通过 Ajax、JSONP、YQL 等方式用户可以很容易的从各种各样的数据源拿到数据并绑定到组件模板，写入本地离线存储。&lt;/p&gt;

&lt;h3 id=&quot;st-功能模块介绍&quot;&gt;ST 功能模块介绍：&lt;/h3&gt;
&lt;h4 id=&quot;1用户界面组件容器和布局组件&quot;&gt;1、用户界面组件，容器和布局组件&lt;/h4&gt;
&lt;p&gt;Sencha Touch 提供了丰富的用户界面组件，包括常用的按钮，单选框，复选框，文本框，日期选择控件，表格，列表等等，通过运用 Sencha Touch 定制的样式和主题，这些控件在移动设备上看起来和本地应用的 UI 组件没有什么区别。在容器和布局方面，Sencha Touch 也可以和 Adobe 的 Flex 相媲美，不仅提供了基础的 HBoxLayout，VBoxLayout 还提供了 DockLayout，CardLayout，FieldLayout 等更适合开发支持触屏设备的 Mobile web 应用的组件，关于每个组件详细的内容可以参考参考资源中列出的 Sencha Touch 的 API 文档。&lt;/p&gt;

&lt;h4 id=&quot;2webkitcss3-样式技巧增强&quot;&gt;2、WebKit/CSS3 样式技巧增强&lt;/h4&gt;
&lt;p&gt;Sencha Touch 充分运用了 CSS3 的新特性使基于 webKit 浏览器运行的 Sencha Touch 应用更炫更酷。它支持并增强了对 Animations（动画），Transitions（转换效果），Gradients（渐变），shadows（阴影效果），Font Face（用户自定义字库），Marquee（文字移动效果），Multiple Backgrounds（多背景），RGBA（高清色彩显示通道）等样式效果的展示。&lt;/p&gt;

&lt;h4 id=&quot;3数据包&quot;&gt;3、数据包&lt;/h4&gt;
&lt;p&gt;Sencha Touch 的一个最大特性就是提供了功能强大的数据包。在 Ext.data 包中提供了丰富的 API 实现对 AJAX，JSONP，YQL 等数据访问方式的支持，并提供了 API 供用户更简单方便的操作和展现 JSON 数据， XML 数据等。用户还可以扩展基础接口实现对更复杂数据的操作和访问。Ext.data 数据包中最基础的是 Ext.data.Model，它就像 Java 的 Object 类一样是定义所有对象的基础类，代表应用程序中的数据类型：用户，产品，销售等任何东西。&lt;/p&gt;

&lt;h4 id=&quot;4数据验证和数据关联&quot;&gt;4、数据验证和数据关联&lt;/h4&gt;
&lt;p&gt;Sencha Touch 提供了五种基本的数据验证方式，用户可以将验证方式的定义直接和对象的定义绑定，就像定义数据库表的列约束一样方便和简洁。这五种验证方式是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Presence：验证数据不能为空值。
Length：验证数据的长度，可以定义最大长度和最小长度。
Format：Format验证数据的格式是否符合预定义的格式，比如定义某个时间属性的格式是“yyyy-mm-dd”，那么“20110324”这样的值就被认为是不合法的。
Inclusion：验证数据是否属于某个预定义的范围，该范围可以是一个闭合区间，也可以是一些可能值的集合。
Exclusion：验证数据是否不属于某个预定义的范围。 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;st-的缺点&quot;&gt;ST 的缺点：&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1、相比较而言入门门槛较高，有些习惯了 jquery 开发的人不太习惯 st 的编程方式；
2、框架类库文件体积大；
3、执行效率低；
4、有些组件响应有延时；
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;总之，ST 开发简单、兼容性好、支持标准化，提供丰富的界面组件以及强大的数据操作 API，是目前 Mobile Web 开发最成熟的框架，虽然存在一些缺点，相信随着版本的升级会越来越好！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>关于express用到的日志库debug的知识点滴</title>
   <link href="http://www.blogways.net/blog/2013/08/24/debug-in-express.html"/>
   <updated>2013-08-24T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/08/24/debug-in-express</id>
   <content type="html">&lt;p&gt;使用过&lt;code class=&quot;highlighter-rouge&quot;&gt;connect&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;express&lt;/code&gt;的同学必须要知道&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;。这三个的主要作者都是同一个人。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;模块使用起来很方便，可以分为下面三步：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;在程序中引入&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;时，需要配置一个日志名字空间。&lt;/strong&gt;如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; var debug = require('debug')('namespace')
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;代码中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;打印日志。&lt;/strong&gt; 
 debug的内核是使用&lt;code class=&quot;highlighter-rouge&quot;&gt;console.error&lt;/code&gt;来打印日志的。所以，&lt;code class=&quot;highlighter-rouge&quot;&gt;console&lt;/code&gt;支持的通配符&lt;code class=&quot;highlighter-rouge&quot;&gt;debug&lt;/code&gt;都可以使用，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;'%s'&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;'%j'&lt;/code&gt;等等。打印&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;数据就可以使用通配符&lt;code class=&quot;highlighter-rouge&quot;&gt;%j&lt;/code&gt;，比如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; debug(&quot;obj:%j&quot;, {name:'test'})
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;但是，使用通配符&lt;code class=&quot;highlighter-rouge&quot;&gt;%j&lt;/code&gt;打印出来的&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;格式不太漂亮，看不出缩进。如果为了方便阅读，也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;nodeJS&lt;/code&gt;的自带模块&lt;code class=&quot;highlighter-rouge&quot;&gt;util&lt;/code&gt;，举例如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; util = require('util')
 debug(&quot;object:%s&quot;, util.inspect(obj))
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;这种方式打印出来的&lt;code class=&quot;highlighter-rouge&quot;&gt;json&lt;/code&gt;对象，其格式缩进有度，很容易查看。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;配置环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt;.&lt;/strong&gt;如果仅做了上面两步，运行时默认是没有日志的，必须配置环境变量&lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt;.比如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export DEBUG=connect*,express*
 export DEBUG=*,-send,-connect:dispatcher
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;需要简单说明一下，多个日志名字空间可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt;号或空格分隔，也支持使用&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;号来进行通配。日志名字空间前加&lt;code class=&quot;highlighter-rouge&quot;&gt;-&lt;/code&gt;号，标记不打印该类型日志。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;上面内容是不是很简单那就试试吧&quot;&gt;上面内容是不是很简单，那就试试吧！&lt;/h3&gt;
</content>
 </entry>
 
 <entry>
   <title>MongoDB 应用架构之路</title>
   <link href="http://www.blogways.net/blog/2013/07/22/mongodb.html"/>
   <updated>2013-07-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/07/22/mongodb</id>
   <content type="html">&lt;h2 id=&quot;mongodb-应用架构之路&quot;&gt;MongoDB 应用架构之路&lt;/h2&gt;
&lt;p&gt;随着大数据时代的到来，传统的关系型数据库已经无法满足不同的存储需求，短短几年的时间NoSQL大行其道，大有后来居上之势。NoSQL根据不同的数据库类型又可以分为：文件存储、键值存储、列存储、图数据库、RTF存储等。本文我们一起来探索下基于文件存储最流行的NoSQL-MongoDB在实际架构中的应用。&lt;/p&gt;

&lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库中功能最丰富、最像关系数据库的。他支持的数据库结构非常松散，是类似json的bjson格式，可以存储比较复杂的数据类型。Mongo完全遵循javascript语法，语法比较灵活，支持的查询功能非常强大，几乎可以实现关系数据单表查询的绝大部分功能，并且支持对表建立索引。&lt;/p&gt;

&lt;h3 id=&quot;安装部署&quot;&gt;安装部署&lt;/h3&gt;
&lt;h4 id=&quot;下载&quot;&gt;下载&lt;/h4&gt;
&lt;p&gt;根据自己的操作系统从官网下载对应的MongoDB版本（32bit/64bit），32位的最大只能存放2G的数据，64位的则没有限制。下载后解压到安装目录。&lt;/p&gt;
&lt;h4 id=&quot;启动&quot;&gt;启动&lt;/h4&gt;
&lt;p&gt;到bin目录下执行&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --dbpath=..\db&lt;/code&gt;，其中dbpath参数为指定创建数据库文件的目录，该目录一定要存在，否则无法启动，如果嫌每次都输入参数太麻烦的话可以在bin目录下创建一个mongodb.config文件，将参数写到文件里面，下次启动的时候就可以直接执行&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --config mongodb.config&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;p&gt;在浏览器中输入&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:28017/&lt;/code&gt;可以查看mongodb的管理信息。&lt;/p&gt;
&lt;h4 id=&quot;基本数据操作&quot;&gt;基本数据操作&lt;/h4&gt;
&lt;p&gt;在bin目录下执行mongo打开mongodb的客户端，默认连接的是test数据库。注意操作都是js的语法，可以根据自己的习惯来写。&lt;/p&gt;
&lt;h5 id=&quot;insert操作&quot;&gt;insert操作&lt;/h5&gt;
&lt;p&gt;db.user.insert({name:’Jack’,age:30})&lt;/p&gt;
&lt;h5 id=&quot;select操作&quot;&gt;select操作&lt;/h5&gt;
&lt;p&gt;db.user.find({name:’Jack’})&lt;/p&gt;
&lt;h5 id=&quot;update操作&quot;&gt;update操作&lt;/h5&gt;
&lt;p&gt;db.user.update({name:’Jack’},{name:’Jack’,age:20})&lt;/p&gt;
&lt;h5 id=&quot;remove操作&quot;&gt;remove操作&lt;/h5&gt;
&lt;p&gt;db.user.remove({name:’Jack’)}&lt;/p&gt;

&lt;p&gt;这些都是最基本的操作，千万别以为就操作就这么简单，要知道js的语法是非常灵活的，要不然怎么实现关系型数据库的单表的大部分功能，但灵活的代价就是语句写起来比较复杂，高级的增删改查、索引、聚合、分类统计、MapReduce、游标等功能就不逐一介绍了，需要大家自己去多实践。&lt;/p&gt;

&lt;p&gt;本文主要介绍MongoDB在应用架构中很重要的两个特性：主从复制、分片技术。&lt;/p&gt;

&lt;h2 id=&quot;架构应用&quot;&gt;架构应用&lt;/h2&gt;
&lt;p&gt;既然是做应用数据库，我们肯定不希望把鸡蛋全放到一个篮子里面，单点部署是不应该被采用的，要知道如果碰到数据库宕机或者硬盘问题数据被永久破坏影响可想而知。幸好MongoDB可以做到读写分离、双机热备份和集群部署。下面来具体看下如何操作。&lt;/p&gt;
&lt;h4 id=&quot;一主从复制&quot;&gt;一、主从复制&lt;/h4&gt;
&lt;h5 id=&quot;1模型图&quot;&gt;1、模型图&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;/images/nosql-1.png&quot; alt=&quot;主从复制模型&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;2从上面的模型中我们可以分析出这种架构有如下好处&quot;&gt;2、从上面的模型中我们可以分析出这种架构有如下好处：&lt;/h5&gt;

&lt;p&gt;1) 数据备份；&lt;/p&gt;

&lt;p&gt;2) 数据恢复；&lt;/p&gt;

&lt;p&gt;3) 读写分离；&lt;/p&gt;

&lt;h5 id=&quot;3实践&quot;&gt;3、实践&lt;/h5&gt;

&lt;p&gt;1) 我们把前面下载的安装文件再拷贝两份到其他的目录，模拟多服务器情况；&lt;/p&gt;

&lt;p&gt;2) 启动一个作为主服务的mongodb，启动主服务器命令&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --config mongodb.config --master&lt;/code&gt;，原来单启服务加了一个master参数，其他都没有变化，包括端口；&lt;/p&gt;

&lt;p&gt;3) 启动另外一个mongodb服务作为从服务器，可以启多个，注意同一台机器需要换个端口，启动从服务器命令&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --config mongodb.config --port=8888 --slave --source=127.0.0.1:27017&lt;/code&gt;；&lt;/p&gt;

&lt;p&gt;4) 下面可以在两个数据库随便做点操作，我们可以看到数据在两个服务器上是同步更新的；&lt;/p&gt;

&lt;h5 id=&quot;4读写分离&quot;&gt;4、读写分离&lt;/h5&gt;
&lt;p&gt;这种手段在大一点的架构中都有实现，在mongodb中其实很简单，在默认的情况下，从属数据库不支持数据的读取，但是没关系，在驱动中给我们提供了一个叫做“slaveOkay”来让我们可以显示的读取从属数据库来减轻主数据库的性能压力，这里就不演示了。&lt;/p&gt;

&lt;h4 id=&quot;二副本集&quot;&gt;二、副本集&lt;/h4&gt;
&lt;h5 id=&quot;1这个也是很牛的主从集群不过跟上面的主从集群还是有点区别&quot;&gt;1、这个也是很牛的主从集群，不过跟上面的主从集群还是有点区别：&lt;/h5&gt;

&lt;p&gt;1) 该集群没有特定的主数据库；&lt;/p&gt;

&lt;p&gt;2) 如果主数据库宕机了，集群中会推选出一个从属数据库作为主数据库顶上，这就具备了自动故障恢复功能；&lt;/p&gt;
&lt;h5 id=&quot;2实践&quot;&gt;2、实践&lt;/h5&gt;
&lt;p&gt;下面的操作模拟三个mongodb的服务器，为了方便描述，这边起三个名字A（端口2222）、B（端口3333）、C（端口4444），其中设计A为集群主服务器、B为从服务器，C为仲裁服务器，所有操作都是在当前安装路径bin目录下执行的，开始操作如下：&lt;/p&gt;

&lt;p&gt;1) 建立A服务器，&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --config mongodb.config --port 2222 --replSet ailk/127.0.0.1:3333&lt;/code&gt;，replSet参数表示让服务器知道还有其他的数据库，指定端口3333的B服务器为下一个数据库；&lt;/p&gt;

&lt;p&gt;2) 建立B服务器，&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --config mongodb.config --port 3333 --replSet ailk/127.0.0.1:2222&lt;/code&gt;，解释同上；&lt;/p&gt;

&lt;p&gt;3) 工作还没有完成，这个时候看下启动日志发现不停的在报&lt;code class=&quot;highlighter-rouge&quot;&gt;replSet can't get local.system.replSet ...&lt;/code&gt;的错误，我们需要初始化一下“副本集”，随便连一个服务器，进入admin集合。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;D:\Program Files\mongodb-win32-x86_64-2.4.5\bin&amp;gt;mongo 127.0.0.1:2222/admin
MongoDB shell version: 2.4.5
connecting to: 127.0.0.1:2222/admin
&amp;gt; db.runCommand({replSetInitiate:{
... _id:'ailk',
... members:[
... {
... _id:1,
... host:'127.0.0.1:2222'
... },
... {
... _id:2,
... host:'127.0.0.1:3333'
... }
... ]}})
{
        &quot;info&quot; : &quot;Config now saved locally.  Should come online in about a minute.&quot;,
        &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这时候再看日志已经可以发现主从服务器都已经自动创建好了；&lt;/p&gt;

&lt;p&gt;4) 创建仲裁服务器 C，&lt;code class=&quot;highlighter-rouge&quot;&gt;mongod --config mongodb.config --port 4444 --replSet ailk/127.0.0.1:2222&lt;/code&gt;，在A admin集合中执行rs.addArb()追加即可。这里面需要说明下，仲裁服务器只参与投票选举。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; rs.addArb('127.0.0.1:4444')
{ &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5) 现在我们使用rs.status()来看下集群服务器的状态&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ailk:PRIMARY&amp;gt; rs.status()
{
        &quot;set&quot; : &quot;ailk&quot;,
        &quot;date&quot; : ISODate(&quot;2013-07-23T08:29:54Z&quot;),
        &quot;myState&quot; : 1,
        &quot;members&quot; : [
                {
                        &quot;_id&quot; : 1,
                        &quot;name&quot; : &quot;127.0.0.1:2222&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 1,
                        &quot;stateStr&quot; : &quot;PRIMARY&quot;,
                        &quot;uptime&quot; : 1360,
                        &quot;optime&quot; : Timestamp(1374568146, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2013-07-23T08:29:06Z&quot;),
                        &quot;self&quot; : true
                },
                {
                        &quot;_id&quot; : 2,
                        &quot;name&quot; : &quot;127.0.0.1:3333&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 2,
                        &quot;stateStr&quot; : &quot;SECONDARY&quot;,
                        &quot;uptime&quot; : 189,
                        &quot;optime&quot; : Timestamp(1374568146, 1),
                        &quot;optimeDate&quot; : ISODate(&quot;2013-07-23T08:29:06Z&quot;),
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2013-07-23T08:29:53Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2013-07-23T08:29:52Z&quot;),
                        &quot;pingMs&quot; : 0,
                        &quot;syncingTo&quot; : &quot;127.0.0.1:2222&quot;
                },
                {
                        &quot;_id&quot; : 3,
                        &quot;name&quot; : &quot;127.0.0.1:4444&quot;,
                        &quot;health&quot; : 1,
                        &quot;state&quot; : 7,
                        &quot;stateStr&quot; : &quot;ARBITER&quot;,
                        &quot;uptime&quot; : 48,
                        &quot;lastHeartbeat&quot; : ISODate(&quot;2013-07-23T08:29:54Z&quot;),
                        &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2013-07-23T08:29:53Z&quot;),
                        &quot;pingMs&quot; : 0
                }
        ],
        &quot;ok&quot; : 1
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;看下stateStr节点就可以看出谁是主服务器、谁是从服务器、谁是仲裁服务器。&lt;/p&gt;

&lt;p&gt;6) 最后来看下自动故障恢复功能，我们把主服务器 A 停掉，进入 B admin 集合执行 rs.status()，可以发现 B 服务器现在变成了主服务器了。&lt;/p&gt;

&lt;h3 id=&quot;三分片&quot;&gt;三、分片&lt;/h3&gt;
&lt;p&gt;有时候数据量比较大的时候我们需要把数据进行拆分，再把拆分后的数据分摊到每一个片上，这个地方有个“片键”的概念，也就是说拆分集合的依据是什么，按照什么键值进行拆分集合？&lt;/p&gt;

&lt;h4 id=&quot;1-模型图&quot;&gt;1、 模型图&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/images/nosql-2.png&quot; alt=&quot;分片服务器模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说明下：&lt;/p&gt;

&lt;p&gt;mongos：就是一个路由服务器，它会根据管理员设置的“片键”将数据分摊到自己管理的mongod集群，数据和片的对应关系以及相应的配置信息保存在”config服务器”上；&lt;/p&gt;

&lt;p&gt;mongod：就是一个普通的数据库实例。&lt;/p&gt;

&lt;h4 id=&quot;2-实践&quot;&gt;2、 实践&lt;/h4&gt;
&lt;p&gt;根据上图可以看出来，这里需要用到4个mongodb的服务器，mogos服务器、config服务器、两个mogod单服务器；&lt;/p&gt;

&lt;p&gt;1) 开启config服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --config mongodb.config --port 2222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2) 开启mongos服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongos --port 3333 --configdb=127.0.0.1:2222
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3) 启动mogod服务器&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongod --config mongodb.config --port 4444
mongod --config mongodb.config --port 5555
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4) mogos服务器配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;E:\mongodb-win32-x86_64-2.4.5\bin&amp;gt;mongo 127.0.0.1:3333/admin
MongoDB shell version: 2.4.5
connecting to: 127.0.0.1:3333/admin
mongos&amp;gt; db.runCommand({addshard : &quot;localhost:4444&quot;, allowLocal : true})
{ &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 }
mongos&amp;gt; db.runCommand({addshard : &quot;localhost:5555&quot;, allowLocal : true})
{ &quot;shardAdded&quot; : &quot;shard0001&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候已经为mongos服务器成功添加了两个mogod节点。&lt;/p&gt;

&lt;p&gt;5) 开启数据库分片功能，指定集合中分片的片键&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongos&amp;gt; db.runCommand({enablesharding:'test'})
{ &quot;ok&quot; : 1 }
mongos&amp;gt; db.runCommand({shardcollection:'test.person',key:{name:1}})
{ &quot;collectionsharded&quot; : &quot;test.person&quot;, &quot;ok&quot; : 1 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6) 测试分片效果，插入10w条记录&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mongos&amp;gt; use  test
switched to db test
mongos&amp;gt; for(var i = 0; i &amp;lt; 100000; i++) {
... db.person.insert({name:'jacky'+i,age:i})
... }
mongos&amp;gt; db.printShardingStatus()
--- Sharding Status ---
  sharding version: {
        &quot;_id&quot; : 1,
        &quot;version&quot; : 3,
        &quot;minCompatibleVersion&quot; : 3,
        &quot;currentVersion&quot; : 4,
        &quot;clusterId&quot; : ObjectId(&quot;51ee5bc0cdc1e6433d02a9a6&quot;)
}
  shards:
        {  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;localhost:4444&quot; }
        {  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;localhost:5555&quot; }
  databases:
        {  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }
        {  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; }
                test.person
                        shard key: { &quot;name&quot; : 1 }
                        chunks:
                                shard0000       2
                                shard0001       1
                        { &quot;name&quot; : { &quot;$minKey&quot; : 1 } } --&amp;gt;&amp;gt; { &quot;name&quot; : &quot;jacky0&quot; } on : shard0000 Timestamp(2, 1)
                        { &quot;name&quot; : &quot;jacky0&quot; } --&amp;gt;&amp;gt; { &quot;name&quot; : &quot;jacky9999&quot; } on : shard0000 Timestamp(1, 3)
                        { &quot;name&quot; : &quot;jacky9999&quot; } --&amp;gt;&amp;gt; { &quot;name&quot; : { &quot;$maxKey&quot; : 1 } } on : shard0001 Timestamp(2, 0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出shards已经是两个分片了，另外默认集合被分成了三段：无穷小-&amp;gt;jacky0；jacky0-jacky9999；jacky9999-无穷大。但这个结果并不理想，因为他是按字母来排序的，也就是2库只分到了11条记录，绝大部分被分到了一库，不过分片的原理就是这样，具体的应用还是根据实际的需求来规划数据分键。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;大概也讲了不少了，NoSQL的强大也可见一斑，相比较以往关系型数据库而言NoSQL确实有很多优势，存储灵活、操作简单、性能高、易扩展等，但不是不要以为就可以完全替换关系型数据库，毕竟二者的应用场景不一样，没有最好的，只有最合适的。&lt;/p&gt;

&lt;p&gt;另外MongoDB也是有自身的缺点的，下面大概说下他几个主要的缺点：&lt;/p&gt;

&lt;h4 id=&quot;1-mongodb占用存储空间大&quot;&gt;1） mongodb占用存储空间大。&lt;/h4&gt;
&lt;p&gt;这主要是由三个因素决定的。第一，mongodb的空间预分配方式，这样会让mongodb最多浪费不超过2G+2G文件大小的空间。第二，mongodb的字段名占用，即使是相同的字段，mongodb也会在每一个文档中都存储，这里会浪费极大的空间。第三，mongodb删除数据并不会释放空间，而只是将空间记录为删除状态以便重用。&lt;/p&gt;
&lt;h4 id=&quot;2-mongodb没有事务模式&quot;&gt;2） mongodb没有事务模式&lt;/h4&gt;
&lt;p&gt;所以事务要求严格的系统慎用。&lt;/p&gt;
&lt;h4 id=&quot;3-mongodb没有join&quot;&gt;3） mongodb没有join&lt;/h4&gt;
&lt;p&gt;毕竟数据都是有关联的，虽然也能通过一定的方式变向的实现一些简单的连接功能，但对于业务复杂的场景也不适合。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>hp-ux下编译64位Lua</title>
   <link href="http://www.blogways.net/blog/2013/07/18/hp-ux-lua-64.html"/>
   <updated>2013-07-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/07/18/hp-ux-lua-64</id>
   <content type="html">&lt;p&gt;在之前的一篇&lt;a href=&quot;../../06/20/aix-64-lua.html&quot;&gt;文章&lt;/a&gt;中，我们介绍了IBM AIX下编译64为Lua代码。在这里，我们介绍如何在HP-UX下编译64为Lua源码。&lt;/p&gt;

&lt;p&gt;目前，官方默认支持的编译平台是&lt;code class=&quot;highlighter-rouge&quot;&gt;aix ansi bsd freebsd generic linux macosx mingw posix solaris&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;没关系，我们来修改官方的&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;文件，让他支持&lt;code class=&quot;highlighter-rouge&quot;&gt;hp-ux&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;修改一：增加支持的平台代码 &lt;code class=&quot;highlighter-rouge&quot;&gt;hp&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;源码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PLATS= aix ansi bsd freebsd generic linux macosx mingw posix solaris hp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改二：增加编译命令&lt;/p&gt;

&lt;p&gt;在源码中增加：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hp:
	$(MAKE) all CC=&quot;aCC -AC99 +DD64 -z +Z +DSblended&quot; CFLAGS=&quot;-O -DLUA_USE_POSIX -DLUA_USE_DLOPEN&quot; MYLIBS=&quot;-ldl&quot; MYLDFLAGS=&quot;-Wl,+s -Wl,+n&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Ok啦，可以编译了！&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;编译吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make hp
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>jBPM5 vs Actitivi</title>
   <link href="http://www.blogways.net/blog/2013/07/16/activiti-jbpm-compare.html"/>
   <updated>2013-07-16T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/07/16/activiti-jbpm-compare</id>
   <content type="html">&lt;h2 id=&quot;jbpm5-vs-actitivi&quot;&gt;jBPM5 vs Actitivi&lt;/h2&gt;
&lt;p&gt;jBPM是目前市场上主流开源工作引擎之一，在创建者Tom Baeyens离开JBoss后，jBPM的下一个版本jBPM5完全放弃了jBPM4的基础代码，基于Drools Flow重头来过，目前官网已经推出了jBPM6的beta版本；Tom Baeyens加入Alfresco后很快推出了新的基于jBPM4的开源工作流系统Activiti。由此可以推测JBoss内部对jBPM未来版本的架构实现产生了严重的意见分歧。本文试着对二者做一些比较。&lt;/p&gt;

&lt;p&gt;在比较之前先看下两者的安装部署过程：&lt;/p&gt;

&lt;h3 id=&quot;jbpm5安装及开发环境配置&quot;&gt;jBPM5安装及开发环境配置&lt;/h3&gt;

&lt;p&gt;1、安装JBPM之前，要求本机已安装了&lt;code class=&quot;highlighter-rouge&quot;&gt;JDk1.5+&lt;/code&gt;版本和&lt;code class=&quot;highlighter-rouge&quot;&gt;ANT1.7+&lt;/code&gt;版本。&lt;/p&gt;

&lt;p&gt;2、JDK和ANT都安装完毕之后，到&lt;code class=&quot;highlighter-rouge&quot;&gt;http://sourceforge.net/projects/jbpm/files/&lt;/code&gt;下载JBPM-installer,下载完之后，解压到安装目录，jbpm-installer文件夹里有个install.html，里面有英文版的安装教程，可以作为参考。&lt;/p&gt;

&lt;p&gt;3、在CMD下进入刚才的\jbpm-installer目录，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;ant install.demo&lt;/code&gt;，该命令会执行下面一系列的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;下载JBoss AS
下载Eclipse
安装Drools Guvnor 到JBoss AS
安装Oryx Designer 到JBoss AS
安装jBPM Console 到JBoss AS
安装jBPM Eclipse 插件
安装Drools Eclipse 插件
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意：这边下载的东西比较多，有好几百兆，如果本地网络不怎么好或者有些东西机上已经有了的话就可以单独下载需要的&lt;/p&gt;

&lt;p&gt;例：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ant install.jBPM.runtime
ant install.guvnor.into.jboss
ant install.designer.into.jboss
ant install.jBPM-gwt-console.into.jboss
ant install.droolsjbpm-eclipse.into.eclipse
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4、下面可以准备启动JBPM了。CMD到\jbpm-installer目录下，依次运行以下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ant start.h2 （启动h2数据库）
ant start.jboss （启动JBoss AS）
ant start.human.task （启动 task service）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5、Jboss启动之后，可以在http://localhost:8080/访问，jbpm自带的web控制台 http://localhost:8080/jbpm-console，登录的用户名、密码均为krisv，在web控制台中可启动一个新流程、查看正在执行流程的当前状态、查看当前登录人待办任务以及并可以以报表形式查看、跟踪流程状态。
Drools Guvnor的访问地址为：http://localhost:8080/drools-guvnor。&lt;/p&gt;

&lt;p&gt;6、把eclipse目录下的features和plugins中的内容copy到eclipse的相应目录中。启动Eclipse之后，现在可以使用eclipse导入jbpm自带的一个流程。方法为依次点击File -&amp;gt; Import ，在General category下选择“Existing Projects into Workspace”，找到位于jbpm安装根目录/sample/evaluation文件夹，将该项目导入。&lt;/p&gt;

&lt;h3 id=&quot;activiti安装及开发环境配置&quot;&gt;Activiti安装及开发环境配置&lt;/h3&gt;
&lt;p&gt;1、 到&lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.activiti.org/download.html&lt;/code&gt;下载activiti-5.13.zip，解压到安装目录，页面上有个&lt;code class=&quot;highlighter-rouge&quot;&gt;The User Guide&lt;/code&gt;，这个教程比较详细，如需要可深入学习下。&lt;/p&gt;

&lt;p&gt;2、 打开解压目录，\wars下面有两个war包，把&lt;code class=&quot;highlighter-rouge&quot;&gt;activiti-explorer.war&lt;/code&gt;部署到应用服务器中，里面默认的数据源是h2的内存数据库，如需要改成自己的数据库；&lt;/p&gt;

&lt;p&gt;3、 安装完成后可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:8080/activiti-explorer&lt;/code&gt;处访问 Activiti Explorer web 应用程序，id/pwd: kermit/Kermit(这个账号是administrator)，这个程序是流程引擎的用户接口，用户可以使用这个工具来执行启动新流程，分配用户任务，浏览或领取任务等操作。还可以用来执行 Activiti 引擎的管理工作；&lt;/p&gt;

&lt;p&gt;4、 Activiti 提供了基于 Eclipse 插件的开发工具和流程设计工具 ( 需要 Eclipse 的版本为 Helios 或 Indigo，如果尚未安装 Eclipse，请从 http://www.eclipse.org/downloads/下载安装最新版本的 Eclipse 集成开发环境。)。这些工具可以使用 Eclipse 的”Install new software”功能在线安装，安装方法如下：&lt;/p&gt;

&lt;p&gt;在 Eclipse 的 Help 菜单中选择 Install New Software 选项，在弹出菜单中，点击 Add Repository 按钮添加新的远程 Software Repository，如图 3 所示，在 Location 中添加 http://activiti.org/designer/update/ 作为 Repository 的远程地址。当新的 Repository 添加完成后，Eclipse 会自动获取 Repository 中的软件列表。&lt;/p&gt;

&lt;p&gt;5、 现在我们开始创建工作流。右键点击项目根目录，选择new -&amp;gt; others，选择Activiti -&amp;gt; Activiti Diagram。&lt;/p&gt;

&lt;p&gt;流程开发跟部署就不在这边说了，都是界面化的开发工具，两个都可以保存成同样的格式，也可以用同一个插件来开发。&lt;/p&gt;

&lt;h3 id=&quot;jbpm5与activiti5比较&quot;&gt;jBPM5与Activiti5比较&lt;/h3&gt;
&lt;h4 id=&quot;主要相似之处&quot;&gt;主要相似之处：&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;都是BPMN2过程建模和执行环境。
都是BPM系统（符合BPM规范）。
都是开源项目-遵循ASL协议（ Apache的 软件许可）。
都源自JBoss（Activiti5是jBPM4的衍生，jBPM5则基于Drools Flow）。
都很成熟，从无到有，双方开始约始于2年半前。
都有对人工任务的生命周期管理。 Activiti5和jBPM5唯一的区别是jBPM5基于WebService - HumanTask标准来描述人工任务和管理生命周期。 如有兴趣了解这方面的标准及其优点，可参阅WS - HT规范介绍  。
都使用了不同风格的 Oryx 流程编辑器对BPMN2建模。 jBPM5采用的是 Intalio 维护的开源项目分支。 Activiti5则使用了Signavio维护的分支。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;activiti5与jbpm5技术组成对比&quot;&gt;Activiti5与jBPM5技术组成对比&lt;/h4&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;em&gt;序号&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;技术组成&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;Activiti&lt;/em&gt;&lt;/td&gt;&lt;td&gt;&lt;em&gt;jBPM5&lt;/em&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;数据库持久层ORM&lt;/td&gt;&lt;td&gt;MyBatis3&lt;/td&gt;&lt;td&gt;Hibernate3&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;持久化标准&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;td&gt;JPA规范&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;事务管理&lt;/td&gt;&lt;td&gt;MyBatis机制/Spring事务控制&lt;/td&gt;&lt;td&gt;Bitronix，基于JTA事务管理&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;数据库连接方式&lt;/td&gt;&lt;td&gt;Jdbc/DataSource&lt;/td&gt;&lt;td&gt;Jdbc/DataSource&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;5&lt;/td&gt;&lt;td&gt;支持数据库&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL等多数数据库&lt;/td&gt;&lt;td&gt;Oracle、SQL Server、MySQL等多数数据库&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;/td&gt;&lt;td&gt;设计模式&lt;/td&gt;&lt;td&gt;Command模式、观察者模式等&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;7&lt;/td&gt;&lt;td&gt;内部服务通讯&lt;/td&gt;&lt;td&gt;Service间通过API调用&lt;/td&gt;&lt;td&gt;基于Apache Mina异步通讯&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;8&lt;/td&gt;&lt;td&gt;集成接口&lt;/td&gt;&lt;td&gt;SOAP、Mule、RESTful&lt;/td&gt;&lt;td&gt;消息通讯&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;/td&gt;&lt;td&gt;支持的流程格式&lt;/td&gt;&lt;td&gt;BPMN2、xPDL、jPDL等&lt;/td&gt;&lt;td&gt;目前仅只支持BPMN2 xml&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;10&lt;/td&gt;&lt;td&gt;引擎核心&lt;/td&gt;&lt;td&gt;PVM（流程虚拟机）&lt;/td&gt;&lt;td&gt;Drools&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;11&lt;/td&gt;&lt;td&gt;技术前身&lt;/td&gt;&lt;td&gt;jBPM3、jBPM4&lt;/td&gt;&lt;td&gt;Drools Flow&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;12&lt;/td&gt;&lt;td&gt;所属公司&lt;/td&gt;&lt;td&gt;Alfresco&lt;/td&gt;&lt;td&gt;jBoss.org&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Activiti5使用Spring进行引擎配置以及各个Bean的管理，综合使用IoC和AOP技术，使用CXF作为Web Services实现的基础，使用MyBatis进行底层数据库ORM的管理，预先提供Bundle化包能较容易的与OSGi进行集成，通过与Mule ESB的集成和对外部服务（Web Service、RESTful等）的接口可以构建全面的SOA应用；jBPM5使用jBoss.org社区的大多数组件，以Drools Flow为核心组件作为流程引擎的核心构成，以Hibernate作为数据持久化ORM实现，采用基于JPA/JTA的可插拔的持久化和事务控制规范，使用Guvnor作为流程管理仓库，能够与Seam、Spring、OSGi等集成。&lt;/p&gt;

&lt;p&gt;需要指出的是Activiti5是在jBPM3、jBPM4的基础上发展而来的，是原jBPM的延续，而jBPM5则与之前的jBPM3、jBPM4没有太大关联，且舍弃了备受推崇的PVM（流程虚拟机）思想，转而选择jBoss自身产品Drools Flow作为流程引擎的核心实现，工作流最为重要的“人机交互”任务（类似于审批活动）则由单独的一块“Human Task Service”附加到Drools Flow上实现，任务的查询、处理等行为通过Apache Mina异步通信机制完成。&lt;/p&gt;

&lt;h4 id=&quot;优劣对比&quot;&gt;优劣对比：&lt;/h4&gt;

&lt;p&gt;从技术组成来看，Activiti最大的优势是采用了PVM（流程虚拟机），支持除了BPMN2.0规范之外的流程格式，与外部服务有良好的集成能力，延续了jBPM3、jBPM4良好的社区支持，服务接口清晰，链式API更为优雅；劣势是持久化层没有遵循JPA规范。&lt;/p&gt;

&lt;p&gt;jBPM最大的优势是采用了Apache Mina异步通信技术，采用JPA/JTA持久化方面的标准，以功能齐全的Guvnor作为流程仓库，有RedHat(jBoss.org被红帽收购)的专业化支持；但其劣势也很明显，对自身技术依赖过紧且目前仅支持BPMN2。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;虽然是比较，但不一定要有胜负，只有适合自己的才是最好的，要针对具体的项目区别对待。对我们自己的项目，其实我更关注的是流程引擎的执行效率以及性能，每小时几十万甚至上百万的流程需要执行，需要多少个服务，集群、负载的策略是什么，会不会有冲突？目前这方面的资料还是比较少的，很多问题只有实际遇用到的时候才会去想办法解决。不过就我个人的感觉而言，Activiti上手比较快，界面也比较简洁、直观，值得一试，不过jBPM6的beta版也已经出来了，不知道会有什么变化，有兴趣的也可以试下。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;参考&lt;/td&gt;
      &lt;td&gt;推荐文章：&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://blog.csdn.net/howareyoutodaysoft/article/details/8070068 &lt;/code&gt; «BPMN2,activiti,jbpm5学习资料»&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;http://www.infoq.com/cn/articles/rh-jbpm5-activiti5&lt;/code&gt;  «纵观jBPM：从jBPM3到jBPM5以及Activiti5»&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>AIX下安装cppunit记</title>
   <link href="http://www.blogways.net/blog/2013/06/26/aix-cppunit.html"/>
   <updated>2013-06-26T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/26/aix-cppunit</id>
   <content type="html">&lt;h3 id=&quot;一下载&quot;&gt;一、下载&lt;/h3&gt;

&lt;p&gt;从官网下载cppunit，笔者当前使用版本为1.12.1。&lt;/p&gt;

&lt;p&gt;下载地址为：&lt;a href=&quot;http://downloads.sourceforge.net/project/cppunit/cppunit/1.12.1/cppunit-1.12.1.tar.gz&quot;&gt;http://downloads.sourceforge.net/project/cppunit/cppunit/1.12.1/cppunit-1.12.1.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;二解压&quot;&gt;二、解压&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gzip -d cppunit-1.12.1.tar.gz
tar -xvf cppunit-1.12.1.tar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三编译&quot;&gt;三、编译&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#进入解压后的源码目录
cd cppunit-1.12.1

#在aix下面编译，目前不支持生成动态库，仅生成的是静态库。
./configure --disable-shared

#也可以添加prefix参数，指定编译后需要安装的目录
./configure --disable-shared  --prefix=……

#编译
make

#安装
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在执行&lt;code class=&quot;highlighter-rouge&quot;&gt;configure&lt;/code&gt;时，如果出现了&lt;code class=&quot;highlighter-rouge&quot;&gt;configure: error: C compiler cannot create executables&lt;/code&gt;这种错误，需要检查一下&lt;code class=&quot;highlighter-rouge&quot;&gt;config.log&lt;/code&gt;文件，看看是不是参数啥的配置错误了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总的来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;cppunit&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;aix&lt;/code&gt;下面安装还是相当顺利的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;如果想在&lt;code class=&quot;highlighter-rouge&quot;&gt;aix&lt;/code&gt;上编译生成64位的目标，配置命令如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure --disable-shared &quot;LDFLAGS=-q64&quot; &quot;CFLAGS=-q64&quot; &quot;CXXFLAGS=-q64&quot; &quot;AR_FLAGS=-X64 cru&quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是在hp下安装,相关命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;./configure --enable-hpuxshl CC=cc CXX=aCC CXXFLAGS=&quot;-AA&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>AIX下编译redis代码</title>
   <link href="http://www.blogways.net/blog/2013/06/21/aix-redis.html"/>
   <updated>2013-06-21T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/21/aix-redis</id>
   <content type="html">&lt;p&gt;在IBM AIX平台下编译redis还是比较顺利的. 我没有直接使用官方的&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;，参考了下官方&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;中的编译依赖关系，按照平时常用的格式自己写了个&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;文件。&lt;/p&gt;

&lt;p&gt;首先，编译&lt;code class=&quot;highlighter-rouge&quot;&gt;hiredis&lt;/code&gt;时，主要在编译命令中定义了三个宏:&lt;code class=&quot;highlighter-rouge&quot;&gt;__HIREDIS_FMACRO_H&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;_BSD_SOURCE&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;AF_LOCAL=AF_UNIX&lt;/code&gt;,编译就顺利通过了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-D__HIREDIS_FMACRO_H -D_BSD_SOURCE -DAF_LOCAL=AF_UNIX 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译服务器代码，稍微麻烦点，因为编译过程中会提示&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;redis.h&quot;, line 502.9: 1506-275 (S) Unexpected text integer constant encountered.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是因为，&lt;code class=&quot;highlighter-rouge&quot;&gt;redis.h&lt;/code&gt;中结构体&lt;code class=&quot;highlighter-rouge&quot;&gt;redisServer&lt;/code&gt;用到了一个名为&lt;code class=&quot;highlighter-rouge&quot;&gt;hz&lt;/code&gt;的成员,而&lt;code class=&quot;highlighter-rouge&quot;&gt;hz&lt;/code&gt;这玩意在aix平台下被定义过。至此，编译就报错了。&lt;/p&gt;

&lt;p&gt;我在文件中加了&lt;code class=&quot;highlighter-rouge&quot;&gt;#undef hz&lt;/code&gt;，解决了。&lt;/p&gt;

&lt;p&gt;同样，编译服务器代码，采用相同的思路，这次添加了四个宏定义，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-D_XOPEN_SOURCE_EXTENDED=1 -D_ISOC99_SOURCE -D_ALL_SOURCE -DAF_LOCAL=AF_UNIX
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上修改后，redis的服务器代码和客户端代码的编译顺利通过！&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>AIX下编译64位Lua</title>
   <link href="http://www.blogways.net/blog/2013/06/20/aix-64-lua.html"/>
   <updated>2013-06-20T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/20/aix-64-lua</id>
   <content type="html">&lt;p&gt;Lua是一个非常有名的脚本语言，是使用标准C编写而成的，目前官方提供了其在众多平台下的编译的&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;文件，非常强大！&lt;/p&gt;

&lt;p&gt;支持编译的平台有&lt;code class=&quot;highlighter-rouge&quot;&gt;aix ansi bsd freebsd generic linux macosx mingw posix solaris&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我在AIX下小试了一下，非常顺利地就编译通过了。&lt;/p&gt;

&lt;p&gt;不过默认编译出来的是32位的，其库文件不能被64位的程序调用，需要修改一下其&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;文件，就可以编译出64位版本。&lt;/p&gt;

&lt;p&gt;修改&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;需要考虑其原有的结构，不影响其他平台下的命令的执行。&lt;/p&gt;

&lt;p&gt;故此，编辑&lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cd lua-5.2.2/src
vi Makefile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改其中&lt;code class=&quot;highlighter-rouge&quot;&gt;aix&lt;/code&gt;小节如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;aix:
    $(MAKE) $(ALL) CC=&quot;xlc -q64&quot; AR=&quot;ar -X64 rcu&quot; CFLAGS=&quot;-O2 -DLUA_USE_POSIX -DLUA_USE_DLOPEN&quot; SYSLIBS=&quot;-ldl&quot; SYSLDFLAGS=&quot;-brtl -bexpall&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译出来的目标文件就是64位的了！&lt;/p&gt;

&lt;p&gt;后面我们会介绍如何在&lt;a href=&quot;../../07/18/hp-ux-lua-64.html&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;hp-ux&lt;/code&gt;&lt;/a&gt;环境下编译Lua源码。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Junit4测试类中测试方法的执行顺序</title>
   <link href="http://www.blogways.net/blog/2013/06/02/junit-test-execution-order.html"/>
   <updated>2013-06-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/02/junit-test-execution-order</id>
   <content type="html">&lt;p&gt;我正在使用的Junit的版本为4.11,其中测试类的执行顺序有三种指定方式：默认、按方法名顺序和JVM顺序。&lt;/p&gt;

&lt;p&gt;如果你不做任何指定，那么就是由默认顺序来执行，那么默认顺序是怎么确定的？他是由方法名的hash值的大小来确定，如果hash值大小一致，则按名字顺序确定。&lt;/p&gt;

&lt;p&gt;看下面Junit的实现代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * DEFAULT sort order
 */
public static Comparator&amp;lt;Method&amp;gt; DEFAULT = new Comparator&amp;lt;Method&amp;gt;() {
    public int compare(Method m1, Method m2) {
        int i1 = m1.getName().hashCode();
        int i2 = m2.getName().hashCode();
        if (i1 != i2) {
            return i1 &amp;lt; i2 ? -1 : 1;
        }
        return NAME_ASCENDING.compare(m1, m2);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了默认顺序，我们可以指定按方法的名字顺序来执行。指定方法是在测试类上加一个注释&lt;code class=&quot;highlighter-rouge&quot;&gt;FixMethodOrder(MethodSorters.NAME_ASCENDING)&lt;/code&gt;，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class MyTest {
	
	@Test
	public void test2() {
	...
	}
	
	@Test
	public void test1() {
	…
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样执行顺序就是，先&lt;code class=&quot;highlighter-rouge&quot;&gt;test1&lt;/code&gt;再&lt;code class=&quot;highlighter-rouge&quot;&gt;test2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;除了上述两种顺序，还有&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;顺序，&lt;code class=&quot;highlighter-rouge&quot;&gt;JVM&lt;/code&gt;顺序使之按调用反射API的顺序来执行。什么意思？看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Method[] methods = testClass.getDeclaredMethods();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;也即是说,通过上面语句获取测试类的方法，返回的顺序就是测试的顺序。这种顺序，会由JVM的实现不同而顺序不同。一般情况下，是一个未明确的但是固定的顺序。&lt;/p&gt;

&lt;p&gt;使用时,也是在测试类上加一个注释&lt;code class=&quot;highlighter-rouge&quot;&gt;FixMethodOrder(MethodSorters.JVM)&lt;/code&gt;,方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@FixMethodOrder(MethodSorters.JVM)
public class MyTest {
	
	@Test
	public void test2() {
	...
	}
	
	@Test
	public void test1() {
	…
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在我的机器上，上面代码执行顺序是：先&lt;code class=&quot;highlighter-rouge&quot;&gt;test2&lt;/code&gt;再&lt;code class=&quot;highlighter-rouge&quot;&gt;test1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过上面的了解，如果你想指定你的测试类中方法的执行顺序，那么最好使用名字顺序(&lt;code class=&quot;highlighter-rouge&quot;&gt;MethodSorters.NAME_ASCENDING&lt;/code&gt;)，这样最方便最可靠。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis的Java客户端Jedis的八种调用方式(事务、管道、分布式…)介绍</title>
   <link href="http://www.blogways.net/blog/2013/06/02/jedis-demo.html"/>
   <updated>2013-06-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/06/02/jedis-demo</id>
   <content type="html">&lt;p&gt;redis是一个著名的key-value存储系统，而作为其官方推荐的java版客户端jedis也非常强大和稳定，支持事务、管道及有jedis自身实现的分布式。&lt;/p&gt;

&lt;p&gt;在这里对jedis关于事务、管道和分布式的调用方式做一个简单的介绍和对比：&lt;/p&gt;

&lt;h3 id=&quot;一普通同步方式&quot;&gt;一、普通同步方式&lt;/h3&gt;

&lt;p&gt;最简单和基础的调用方式，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test1Normal() {
	Jedis jedis = new Jedis(&quot;localhost&quot;);
	long start = System.currentTimeMillis();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    String result = jedis.set(&quot;n&quot; + i, &quot;n&quot; + i);
	}
	long end = System.currentTimeMillis();
	System.out.println(&quot;Simple SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很简单吧，每次&lt;code class=&quot;highlighter-rouge&quot;&gt;set&lt;/code&gt;之后都可以返回结果，标记是否成功。&lt;/p&gt;

&lt;h3 id=&quot;二事务方式transactions&quot;&gt;二、事务方式(Transactions)&lt;/h3&gt;

&lt;p&gt;redis的事务很简单，他主要目的是保障，一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。&lt;/p&gt;

&lt;p&gt;看下面例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test2Trans() {
	Jedis jedis = new Jedis(&quot;localhost&quot;);
	long start = System.currentTimeMillis();
	Transaction tx = jedis.multi();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    tx.set(&quot;t&quot; + i, &quot;t&quot; + i);
	}
	List&amp;lt;Object&amp;gt; results = tx.exec();
	long end = System.currentTimeMillis();
	System.out.println(&quot;Transaction SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们调用&lt;code class=&quot;highlighter-rouge&quot;&gt;jedis.watch(…)&lt;/code&gt;方法来监控key，如果调用后key值发生变化，则整个事务会执行失败。另外，事务中某个操作失败，并不会回滚其他操作。这一点需要注意。还有，我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;discard()&lt;/code&gt;方法来取消事务。&lt;/p&gt;

&lt;h3 id=&quot;三管道pipelining&quot;&gt;三、管道(Pipelining)&lt;/h3&gt;

&lt;p&gt;有时，我们需要采用异步方式，一次发送多个指令，不同步等待其返回结果。这样可以取得非常好的执行效率。这就是管道，调用方法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test3Pipelined() {
	Jedis jedis = new Jedis(&quot;localhost&quot;);
	Pipeline pipeline = jedis.pipelined();
	long start = System.currentTimeMillis();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    pipeline.set(&quot;p&quot; + i, &quot;p&quot; + i);
	}
	List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
	long end = System.currentTimeMillis();
	System.out.println(&quot;Pipelined SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四管道中调用事务&quot;&gt;四、管道中调用事务&lt;/h3&gt;

&lt;p&gt;就Jedis提供的方法而言，是可以做到在管道中使用事务，其代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test4combPipelineTrans() {
	jedis = new Jedis(&quot;localhost&quot;); 
	long start = System.currentTimeMillis();
	Pipeline pipeline = jedis.pipelined();
	pipeline.multi();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    pipeline.set(&quot;&quot; + i, &quot;&quot; + i);
	}
	pipeline.exec();
	List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
	long end = System.currentTimeMillis();
	System.out.println(&quot;Pipelined transaction: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	jedis.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是经测试（见本文后续部分），发现其效率和单独使用事务差不多，甚至还略微差点。&lt;/p&gt;

&lt;h3 id=&quot;五分布式直连同步调用&quot;&gt;五、分布式直连同步调用&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test5shardNormal() {
	List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
			new JedisShardInfo(&quot;localhost&quot;,6379),
			new JedisShardInfo(&quot;localhost&quot;,6380));
			
	ShardedJedis sharding = new ShardedJedis(shards);
	
	long start = System.currentTimeMillis();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    String result = sharding.set(&quot;sn&quot; + i, &quot;n&quot; + i);
	}
	long end = System.currentTimeMillis();
	System.out.println(&quot;Simple@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	
	sharding.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个是分布式直接连接，并且是同步调用，每步执行都返回执行结果。类似地，还有异步管道调用。&lt;/p&gt;

&lt;h3 id=&quot;六分布式直连异步调用&quot;&gt;六、分布式直连异步调用&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test6shardpipelined() {
	List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
			new JedisShardInfo(&quot;localhost&quot;,6379),
			new JedisShardInfo(&quot;localhost&quot;,6380));
			
	ShardedJedis sharding = new ShardedJedis(shards);
	
	ShardedJedisPipeline pipeline = sharding.pipelined();
	long start = System.currentTimeMillis();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    pipeline.set(&quot;sp&quot; + i, &quot;p&quot; + i);
	}
	List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
	long end = System.currentTimeMillis();
	System.out.println(&quot;Pipelined@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	
	sharding.disconnect();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;七分布式连接池同步调用&quot;&gt;七、分布式连接池同步调用&lt;/h3&gt;

&lt;p&gt;如果，你的分布式调用代码是运行在线程中，那么上面两个直连调用方式就不合适了，因为直连方式是非线程安全的，这个时候，你就必须选择连接池调用。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test7shardSimplePool() {
	List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
			new JedisShardInfo(&quot;localhost&quot;,6379),
			new JedisShardInfo(&quot;localhost&quot;,6380));

	ShardedJedisPool pool = new ShardedJedisPool(new JedisPoolConfig(), shards);

	ShardedJedis one = pool.getResource();
	
	long start = System.currentTimeMillis();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    String result = one.set(&quot;spn&quot; + i, &quot;n&quot; + i);
	}
	long end = System.currentTimeMillis();
	pool.returnResource(one);
	System.out.println(&quot;Simple@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	
	pool.destroy();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是同步方式，当然还有异步方式。&lt;/p&gt;

&lt;h3 id=&quot;八分布式连接池异步调用&quot;&gt;八、分布式连接池异步调用&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void test8shardPipelinedPool() {
	List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
			new JedisShardInfo(&quot;localhost&quot;,6379),
			new JedisShardInfo(&quot;localhost&quot;,6380));

	ShardedJedisPool pool = new ShardedJedisPool(new JedisPoolConfig(), shards);

	ShardedJedis one = pool.getResource();
	
	ShardedJedisPipeline pipeline = one.pipelined();
	
	long start = System.currentTimeMillis();
	for (int i = 0; i &amp;lt; 100000; i++) {
	    pipeline.set(&quot;sppn&quot; + i, &quot;n&quot; + i);
	}
	List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
	long end = System.currentTimeMillis();
	pool.returnResource(one);
	System.out.println(&quot;Pipelined@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	pool.destroy();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;九需要注意的地方&quot;&gt;九、需要注意的地方&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;事务和管道都是异步模式。在事务和管道中不能同步查询结果。比如下面两个调用，都是不允许的：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Transaction tx = jedis.multi();
 for (int i = 0; i &amp;lt; 100000; i++) {
     tx.set(&quot;t&quot; + i, &quot;t&quot; + i);
 }
 System.out.println(tx.get(&quot;t1000&quot;).get());  //不允许
	
 List&amp;lt;Object&amp;gt; results = tx.exec();
	
 …
 …
	
 Pipeline pipeline = jedis.pipelined();
 long start = System.currentTimeMillis();
 for (int i = 0; i &amp;lt; 100000; i++) {
     pipeline.set(&quot;p&quot; + i, &quot;p&quot; + i);
 }
 System.out.println(pipeline.get(&quot;p1000&quot;).get()); //不允许
	
 List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;事务和管道都是异步的，个人感觉，在管道中再进行事务调用，没有必要，不如直接进行事务模式。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分布式中，连接池的性能比直连的性能略好(见后续测试部分)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分布式调用中不支持事务。&lt;/p&gt;

    &lt;p&gt;因为事务是在服务器端实现，而在分布式中，每批次的调用对象都可能访问不同的机器，所以，没法进行事务。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;十测试&quot;&gt;十、测试&lt;/h3&gt;

&lt;p&gt;运行上面的代码，进行测试，其结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Simple SET: 5.227 seconds

Transaction SET: 0.5 seconds
Pipelined SET: 0.353 seconds
Pipelined transaction: 0.509 seconds

Simple@Sharing SET: 5.289 seconds
Pipelined@Sharing SET: 0.348 seconds

Simple@Pool SET: 5.039 seconds
Pipelined@Pool SET: 0.401 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，经测试分布式中用到的机器越多，调用会越慢。上面是2片，下面是5片：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Simple@Sharing SET: 5.494 seconds
Pipelined@Sharing SET: 0.51 seconds
Simple@Pool SET: 5.223 seconds
Pipelined@Pool SET: 0.518 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是10片：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Simple@Sharing SET: 5.9 seconds
Pipelined@Sharing SET: 0.794 seconds
Simple@Pool SET: 5.624 seconds
Pipelined@Pool SET: 0.762 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下面是100片：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Simple@Sharing SET: 14.055 seconds
Pipelined@Sharing SET: 8.185 seconds
Simple@Pool SET: 13.29 seconds
Pipelined@Pool SET: 7.767 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;分布式中，连接池方式调用不但线程安全外，根据上面的测试数据，也可以看出连接池比直连的效率更好。&lt;/p&gt;

&lt;h3 id=&quot;十一完整的测试代码&quot;&gt;十一、完整的测试代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.example.nosqlclient;

import java.util.Arrays;
import java.util.List;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import redis.clients.jedis.Jedis;
import redis.clients.jedis.JedisPoolConfig;
import redis.clients.jedis.JedisShardInfo;
import redis.clients.jedis.Pipeline;
import redis.clients.jedis.ShardedJedis;
import redis.clients.jedis.ShardedJedisPipeline;
import redis.clients.jedis.ShardedJedisPool;
import redis.clients.jedis.Transaction;

import org.junit.FixMethodOrder;
import org.junit.runners.MethodSorters;

@FixMethodOrder(MethodSorters.NAME_ASCENDING)
public class TestJedis {

	private static Jedis jedis;
	private static ShardedJedis sharding;
	private static ShardedJedisPool pool;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		List&amp;lt;JedisShardInfo&amp;gt; shards = Arrays.asList(
				new JedisShardInfo(&quot;localhost&quot;,6379),
				new JedisShardInfo(&quot;localhost&quot;,6379)); //使用相同的ip:port,仅作测试
		
		
		jedis = new Jedis(&quot;localhost&quot;); 
		sharding = new ShardedJedis(shards);
		
		pool = new ShardedJedisPool(new JedisPoolConfig(), shards);
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		jedis.disconnect();
		sharding.disconnect();
		pool.destroy();
	}

	@Test
	public void test1Normal() {
		long start = System.currentTimeMillis();
		for (int i = 0; i &amp;lt; 100000; i++) {
			String result = jedis.set(&quot;n&quot; + i, &quot;n&quot; + i);
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;Simple SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
	
	@Test
	public void test2Trans() {
		long start = System.currentTimeMillis();
		Transaction tx = jedis.multi();
		for (int i = 0; i &amp;lt; 100000; i++) {
			tx.set(&quot;t&quot; + i, &quot;t&quot; + i);
		}
		//System.out.println(tx.get(&quot;t1000&quot;).get());
		
		List&amp;lt;Object&amp;gt; results = tx.exec();
		long end = System.currentTimeMillis();
		System.out.println(&quot;Transaction SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
	
	@Test
	public void test3Pipelined() {
		Pipeline pipeline = jedis.pipelined();
		long start = System.currentTimeMillis();
		for (int i = 0; i &amp;lt; 100000; i++) {
			pipeline.set(&quot;p&quot; + i, &quot;p&quot; + i);
		}
		//System.out.println(pipeline.get(&quot;p1000&quot;).get());
		List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
		long end = System.currentTimeMillis();
		System.out.println(&quot;Pipelined SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
	
	@Test
	public void test4combPipelineTrans() {
		long start = System.currentTimeMillis();
		Pipeline pipeline = jedis.pipelined();
		pipeline.multi();
		for (int i = 0; i &amp;lt; 100000; i++) {
			pipeline.set(&quot;&quot; + i, &quot;&quot; + i);
		}
		pipeline.exec();
		List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
		long end = System.currentTimeMillis();
		System.out.println(&quot;Pipelined transaction: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}

	@Test
	public void test5shardNormal() {
		long start = System.currentTimeMillis();
		for (int i = 0; i &amp;lt; 100000; i++) {
			String result = sharding.set(&quot;sn&quot; + i, &quot;n&quot; + i);
		}
		long end = System.currentTimeMillis();
		System.out.println(&quot;Simple@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
	
	@Test
	public void test6shardpipelined() {
		ShardedJedisPipeline pipeline = sharding.pipelined();
		long start = System.currentTimeMillis();
		for (int i = 0; i &amp;lt; 100000; i++) {
			pipeline.set(&quot;sp&quot; + i, &quot;p&quot; + i);
		}
		List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
		long end = System.currentTimeMillis();
		System.out.println(&quot;Pipelined@Sharing SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
	
	@Test
	public void test7shardSimplePool() {
		ShardedJedis one = pool.getResource();
		
		long start = System.currentTimeMillis();
		for (int i = 0; i &amp;lt; 100000; i++) {
			String result = one.set(&quot;spn&quot; + i, &quot;n&quot; + i);
		}
		long end = System.currentTimeMillis();
		pool.returnResource(one);
		System.out.println(&quot;Simple@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
	
	@Test
	public void test8shardPipelinedPool() {
		ShardedJedis one = pool.getResource();
		
		ShardedJedisPipeline pipeline = one.pipelined();
		
		long start = System.currentTimeMillis();
		for (int i = 0; i &amp;lt; 100000; i++) {
			pipeline.set(&quot;sppn&quot; + i, &quot;n&quot; + i);
		}
		List&amp;lt;Object&amp;gt; results = pipeline.syncAndReturnAll();
		long end = System.currentTimeMillis();
		pool.returnResource(one);
		System.out.println(&quot;Pipelined@Pool SET: &quot; + ((end - start)/1000.0) + &quot; seconds&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>在服务器上创建 git 裸仓库</title>
   <link href="http://www.blogways.net/blog/2013/05/28/git-bare-repo-sever.html"/>
   <updated>2013-05-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/28/git-bare-repo-sever</id>
   <content type="html">&lt;p&gt;git裸仓库，就是指没有工作目录的仓库。简单点说，裸仓库就是你工作目录下面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 子目录里面的内容。&lt;/p&gt;

&lt;p&gt;远程仓库，一般不需要工作目录，所以通常都是裸仓库。&lt;/p&gt;

&lt;p&gt;如何在服务器上创建裸仓库？很简单，跟我来！&lt;/p&gt;

&lt;p&gt;如果你还没有代码，直接在服务器上创建裸仓库很简单，一个命令就够了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init --bare
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是如果在本机，你已经有了一些代码，如何把这些代码部署到服务器上，并且仅仅部署成一个裸仓库呢？其实，也很简单，因为我们了解了 git 裸仓库实际上就是你工作目录下的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 子目录的内容，拷过去就行了。&lt;/p&gt;

&lt;p&gt;所以，下面有三个思路，都可以实现：&lt;/p&gt;

&lt;h3 id=&quot;思路一在本机生成裸仓库把裸仓库部署到服务器上&quot;&gt;思路一：在本机生成裸仓库，把裸仓库部署到服务器上&lt;/h3&gt;

&lt;p&gt;具体步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;本机生成裸仓库&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git clone --bare my_project my_project.git

 $ cp -Rf my_project/.git my_project.git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;上面两个命令结果一样，都可以根据现有的仓库生成一个裸仓库。按喜欢选择一个即可。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;部署到服务器上&lt;/p&gt;

    &lt;p&gt;可以用工具部署到远程服务器上，也可以用命令，命令如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ scp -r my_project.git user@git.example.com:/opt/git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大功告成了&lt;/p&gt;

    &lt;p&gt;可以测试一下，获取远程服务器上的版本&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git clone user@git.example.com:/opt/git/my_project.git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;思路二把本机的git目录部署到服务器上然后改成裸仓库&quot;&gt;思路二：把本机的&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;目录部署到服务器上，然后改成裸仓库&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;将&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;目录部署到服务器上&lt;/p&gt;

    &lt;p&gt;可以用工具部署到远程服务器上，也可以用命令，命令如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ scp -r my_project/.git user@git.example.com:/opt/git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将服务器&lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt;目录改成裸仓库&lt;/p&gt;

    &lt;p&gt;在服务器上执行命令：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cd /opt/git
 mv .git my_project.git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;大功告成了&lt;/p&gt;

    &lt;p&gt;可以测试一下，获取远程服务器上的版本&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git clone user@git.example.com:/opt/git/my_project.git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;思路三git-push-到远程仓库&quot;&gt;思路三：git push 到远程仓库&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;先在远程主机上建个裸仓库&lt;/p&gt;

 	$ mkdir my_project.git
 	$ cd my_project.git
 	$ git init –bare
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;给本地仓库添加一个远程仓库&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; # git remote add &amp;lt;远程仓库名字&amp;gt; &amp;lt;地址&amp;gt;
 $ git remote add ball git@xxx.xxx.xxx.xxx:/path/to/my_project.git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将本地仓库内容上传远程仓库&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; $ git push ball master
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;clone版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git clone -o jQuery https://github.com/jquery/jquery.git
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;注意&quot;&gt;注意：&lt;/h3&gt;

&lt;p&gt;按思路一、思路二创建的远程仓库，如果需要支持其他人&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;数据，需要修改仓库下配置文件&lt;code class=&quot;highlighter-rouge&quot;&gt;config&lt;/code&gt;,添加如下内容：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[receive]
    denyCurrentBranch = ignore
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;否则，可能会遇到在客户端不被允许向裸仓库&lt;code class=&quot;highlighter-rouge&quot;&gt;push&lt;/code&gt;数据。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>在Eclipse中创建Maven多模块工程的例子[20150428更新]</title>
   <link href="http://www.blogways.net/blog/2013/05/13/maven-multi-modules-demo.html"/>
   <updated>2013-05-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/13/maven-multi-modules-demo</id>
   <content type="html">&lt;p&gt;如果，你需要创建多个项目，项目之间即独立又有关系，那么创建一个Maven多模块项目是个非常好的选择，也非常cool！怎么在Eclipse里面创建多模块工程，以及需要注意哪些地方，我在这里做个简单的介绍。&lt;/p&gt;

&lt;h3 id=&quot;一准备&quot;&gt;一、准备&lt;/h3&gt;

&lt;p&gt;若想在Eclipse里面做这些的话，那么在做这一切前，请确认你是否已经在eclipse里面安装了maven插件。如果没有装插件，那只能通过命令行去做了。&lt;/p&gt;

&lt;p&gt;好，现在假设已经在Eclipse里面装了maven插件，那么我们一起用Eclipse来创建Maven多模块项目吧！&lt;/p&gt;

&lt;h3 id=&quot;二先创建父项目&quot;&gt;二、先创建父项目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;在Eclipse里面New -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Maven Project&lt;/code&gt;；&lt;/li&gt;
  &lt;li&gt;在弹出界面中选择“Create a simple project”&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置工程的参数，见下图&lt;br /&gt;&lt;img src=&quot;/images/post/maven-modules1.png&quot; alt=&quot;Params Settings&quot; /&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Group Id: com.example&lt;/li&gt;
      &lt;li&gt;Artifact Id: multi-modules-demo&lt;/li&gt;
      &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;Packaging: pom&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;Name: Multi Modules Demo&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;点击完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样，我们就按常规模版创建了一个Maven工程。我们还需要对这个工程进行修改。&lt;/p&gt;

&lt;p&gt;因为，这是一个父项目，不需要有什么源码，那么，我们在Eclipse中将这个工程下的不用的目录都删除，仅留下&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;文件就行了。&lt;/p&gt;

&lt;h3 id=&quot;三创建子项目&quot;&gt;三、创建子项目&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;选中刚建的父项目，在弹出菜单中点击 New -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;Maven Module&lt;/code&gt;;&lt;/li&gt;
  &lt;li&gt;如图配置&lt;br /&gt;&lt;img src=&quot;/images/post/maven-modules3.png&quot; alt=&quot;child settings&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;使用默认的Archetype（默认：GroupId:org.apache.maven.archetypes,Artifact Id:maven-archetype-quickstart）&lt;/li&gt;
  &lt;li&gt;完成工程配置，见下图&lt;br /&gt;&lt;img src=&quot;/images/post/maven-modules4.png&quot; alt=&quot;Params Settings&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;点击完成&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样一个子项目就创建完成了，在文件系统中，子项目会建在父项目的目录中。在父目录中运行&lt;code class=&quot;highlighter-rouge&quot;&gt;mvn test&lt;/code&gt;等命令，所有的子项目都会按顺序执行。&lt;/p&gt;

&lt;p&gt;细心一点的人，可能会发现，通过这个步骤创建子项目的同时，会修改父项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;，增加了类似下面的信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;modules&amp;gt;
  	    &amp;lt;module&amp;gt;module-children1-demo&amp;lt;/module&amp;gt;
&amp;lt;/modules&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个信息，就是标记有哪些子模块。&lt;/p&gt;

&lt;p&gt;重复创建子项目的步骤，可以创建多个子项目。&lt;/p&gt;

&lt;h3 id=&quot;四优化配置&quot;&gt;四、优化配置&lt;/h3&gt;

&lt;p&gt;虽然上面的步骤，可以完成多模块的创建，但是创建出来的多模块，在一个程序员的眼里，还是挺别扭的，怎么回事呢？对，存在重复。那让我们重构吧。&lt;/p&gt;

&lt;p&gt;按上面步骤创建的子项目，在&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;中有个&lt;code class=&quot;highlighter-rouge&quot;&gt;parent&lt;/code&gt;节点，所以，他可以继承父项目的相关信息。没错，父子项目中存在继承关系。&lt;/p&gt;

&lt;p&gt;在子项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;中，子项目的&lt;code class=&quot;highlighter-rouge&quot;&gt;groupId&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;version&lt;/code&gt;一般和父项目相同，那么可以把子项目的这两个参数删除，这样会自动继承父项目的取值。&lt;/p&gt;

&lt;p&gt;同样，如果其他的一些属性，所有子项目都是一样的，那么可以上移到父项目中设置，子项目中无需重复设置。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;&lt;/code&gt;可以仅在父项目中设置一次。&lt;/p&gt;

&lt;p&gt;除了这种情况以外，还有一种情况，就是依赖和插件。依赖和插件的情况是这样，某一个依赖或插件可能会被大部分子项目所使用，但是也可能有些子项目不需要使用，这样使用上述的方式，简简单单地进行继承就不合适了。&lt;/p&gt;

&lt;p&gt;Manen提供&lt;code class=&quot;highlighter-rouge&quot;&gt;dependencyManagement&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;pluginManagement&lt;/code&gt;两个标签。使用这两个标签，可以在父项目中统一管理依赖和插件的配置参数，比如版本号啥的。而在子项目中，仅需列出需要使用的依赖和插件的&lt;code class=&quot;highlighter-rouge&quot;&gt;groupId&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;artifactId&lt;/code&gt;就可以了，其他信息会自动从父项目管理的信息里面获取。&lt;/p&gt;

&lt;p&gt;看例子，父项目中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependencyManagement&amp;gt;
  &amp;lt;dependencies&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${junit.version}&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-log4j12&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.slf4j&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;slf4j-api&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.7.5&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;   
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/dependencyManagement&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在子项目中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependencies&amp;gt;
  &amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四命令行创建&quot;&gt;四、命令行创建&lt;/h3&gt;

&lt;p&gt;上面就是在Eclipse里面创建多模块的步骤，和一些优化配置。&lt;/p&gt;

&lt;p&gt;其中，具体的步骤可以根据实际情况进行适当的修改，比如选择&lt;code class=&quot;highlighter-rouge&quot;&gt;Archetype&lt;/code&gt;时，可以根据需要，选择适当的&lt;code class=&quot;highlighter-rouge&quot;&gt;Archetype&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上述步骤中的一些环节，也可以先通过命令行来生成雏形，然后再修改&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;来实现。&lt;/p&gt;

&lt;p&gt;相关命令为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mvn archetype:generate -DarchetypeCatalog=internal -DarchetypeGroupId=org.apache.maven.archetypes -DarchetypeArtifactId=maven-archetype-quickstart
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;工程创建后需要修改&lt;code class=&quot;highlighter-rouge&quot;&gt;pom.xml&lt;/code&gt;.修改方式，可以参考上面说到的内容。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis Linux 数据类型</title>
   <link href="http://www.blogways.net/blog/2013/05/05/redis-usage.html"/>
   <updated>2013-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/05/redis-usage</id>
   <content type="html">&lt;h2 id=&quot;数据类型&quot;&gt;数据类型&lt;/h2&gt;
&lt;h3 id=&quot;keys&quot;&gt;keys&lt;/h3&gt;
&lt;p&gt;redis本质上还是一个key-value db，所以我们首先来看看他的key。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;exists key 测试指定的 key 是否存在，真1｜假0
del key1 key2 ... keyn 返回删除的 key 的数目，0表示不存在
type key 返回 key 的 value 类型
keys pattern 返回匹配指定模式的所有 key
randomkey 随机返回一个 key
rename oldkey newkey 重命名一个 key，如果 newkey 存在会被覆盖
renamenx oldkey newkey 同上，如果 newkey 存在返回失败
dbsize 返回当前数据库的 key 数量
expire key seconds 为 key 指定过期时间，单位是秒
ttl key 返回设置过期时间的 key 的剩余过期时间
select db-index 通过索引选择数据库，默认连接的是数据库0，默认数据库数是16个
move key db-index 将 key 从当前数据库移动到指定数据库
flushdb 删除当前数据库里面所有的 key
flushall 删除所有数据库中所有的 key
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; set test 1
OK
redis 127.0.0.1:6479&amp;gt; set tast 2
OK
redis 127.0.0.1:6479&amp;gt; set tist 3
OK
redis 127.0.0.1:6479&amp;gt; exists test
(integer) 1
redis 127.0.0.1:6479&amp;gt; del tist
(integer) 1
redis 127.0.0.1:6479&amp;gt; type test
string
redis 127.0.0.1:6479&amp;gt; keys *
1) &quot;tast&quot;
2) &quot;test&quot;
3) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; keys t*
1) &quot;tast&quot;
2) &quot;test&quot;
3) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; keys t[ia]st
1) &quot;tast&quot;
2) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; keys t?st
1) &quot;tast&quot;
2) &quot;test&quot;
3) &quot;tist&quot;
redis 127.0.0.1:6479&amp;gt; randomkey
&quot;test&quot;
redis 127.0.0.1:6479&amp;gt; rename test tt
OK
redis 127.0.0.1:6479&amp;gt; dbsize
(integer) 2
redis 127.0.0.1:6479&amp;gt; expire tt 30
(integer) 1
redis 127.0.0.1:6479&amp;gt; ttl tt
(integer) 24
redis 127.0.0.1:6479&amp;gt; select 10
OK
redis 127.0.0.1:6479[10]&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;string&quot;&gt;string&lt;/h3&gt;
&lt;p&gt;string 是 redis 最基本的类型，而且 string 类型是二进制安全的，可以包含任何数据，包括图片和序列化的对象，最大可存1G字节。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;set key value 设置 key 对应的 string 类型的值
setnx key value 同上，如果 key 已经存在返回 0
get key 获取 key 对应的 string 值，不存在返回 nil
getset key 设置 key 的新值，并返回旧值
mget key1 key2 ... keyn 一次获取多个 key 值
mset key1 value1 key2 value2 ... keyn valuen 一次设置多个值
incr key 对 key 做 ++ 操作，如果 value 不是 int 类型会返回错误
decr kdy 对 key 做 -- 操作，可以为负 
incrby key integer 对 key 加指定值
decrby key integer 对 key 减指定值
append key value 对 key 的值追加字符串
substr key start end 截取指定 key 的字符串值，下标从0开始
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; flushdb
OK
redis 127.0.0.1:6479&amp;gt; set k1 a k2 b k3 c
(error) ERR syntax error
redis 127.0.0.1:6479&amp;gt; mset k1 a k2 b k3 c
OK
redis 127.0.0.1:6479&amp;gt; mget k1 k2 k3 k4
1) &quot;a&quot;
2) &quot;b&quot;
3) &quot;c&quot;
4) (nil)
redis 127.0.0.1:6479&amp;gt; incr k4
(integer) 1
redis 127.0.0.1:6479&amp;gt; decrby k4 5
(integer) -4
redis 127.0.0.1:6479&amp;gt; set k1 hello
OK
redis 127.0.0.1:6479&amp;gt; append k1 ' world'
(integer) 11
redis 127.0.0.1:6479&amp;gt; mget k1 k2 k3 k4
1) &quot;hello world&quot;
2) &quot;b&quot;
3) &quot;c&quot;
4) &quot;-4&quot;
redis 127.0.0.1:6479&amp;gt; substr k1 2 8
&quot;llo wor&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;list&quot;&gt;list&lt;/h3&gt;
&lt;p&gt;redis的list类型其实就是一个每个子元素都是string类型的双向链表。所以[lr]push和[lr]pop命令的算法时间复杂度都是O(1)
另外list会记录链表的长度。所以llen操作也是O(1).链表的最大长度是(2的32次方-1)。我们可以通过push,pop操作从链表的头部
或者尾部添加删除元素。这使得list既可以用作栈，也可以用作队列。有意思的是list的pop操作还有阻塞版本的。当我们[lr]pop一个
list对象是，如果list是空，或者不存在，会立即返回nil。但是阻塞版本的b[lr]pop可以则可以阻塞，当然可以加超时时间，超时后也会返回nil
。为什么要阻塞版本的pop呢，主要是为了避免轮询。举个简单的例子如果我们用list来实现一个工作队列。执行任务的thread可以调用阻塞版本的pop去
获取任务这样就可以避免轮询去检查是否有任务存在。当任务来时候工作线程可以立即返回，也可以避免轮询带来的延迟。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lpush key string 在 key 对应的 list 头部添加字符串元素，如果 key 不是 list 类型返回错误
rpush key string 同上，在尾部添加
llen key 返回 key 对应的 list 的长度，key 不存在返回0，key 不是 list 类型返回错误
lrange key start end 返回指定区间内的元素，下标从0开始，负数表示从后面开始
ltrim key start end 截取 list，保留指定区间内的元素
lset key index value 设置 list 指定下标的元素值
lrem key count value 从 key 对应的 list 中删除 count 个 和 value 元素相同的元素，count 为0时删除全部
lpop key 从 list 头部删除元素，并返回删除元素
rpop key 同上，从 list 尾部删除
blpop key1 key2 ... keyn timeout 从左到右返回一个非空 list 进行 lpop 操作并返回，如果所有的 list 都为空或者不存在，则会等待 timeout 秒，等待期间有 list 的 push 操作则立即返回，超时则返回 nil
brpop key1 key2 ... keyn timeout 同上，从尾部删除
rpoplpush srckey destkey 从 srckey 对应的 list 的尾部移动元素添加到 destkey 对应的 list 头部，最后返回被移除的元素，srckey 为空或者不存在返回 nil
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; lpush list1 aaa
(integer) 1
redis 127.0.0.1:6479&amp;gt; rpush list1 bbb
(integer) 2
redis 127.0.0.1:6479&amp;gt; lpush list1 ccc
(integer) 3
redis 127.0.0.1:6479&amp;gt; lpush list1 ddd
(integer) 4
redis 127.0.0.1:6479&amp;gt; llen list1
(integer) 4
redis 127.0.0.1:6479&amp;gt; lrange list1 0 2
1) &quot;ddd&quot;
2) &quot;ccc&quot;
3) &quot;aaa&quot;
redis 127.0.0.1:6479&amp;gt; ltrim list1 0 2
OK
redis 127.0.0.1:6479&amp;gt; lrange list1 0 3
1) &quot;ddd&quot;
2) &quot;ccc&quot;
3) &quot;aaa&quot;
redis 127.0.0.1:6479&amp;gt; lset list1 1 eeee
OK
redis 127.0.0.1:6479&amp;gt; lpop list1
&quot;ddd&quot;
redis 127.0.0.1:6479&amp;gt; rpop list1
&quot;aaa&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;set&quot;&gt;set&lt;/h3&gt;
&lt;p&gt;redis的set是string类型的无序集合。set元素最大可以包含(2的32次方-1)个元素。set的是通过hash table实现的，所以添加，删除，查找的复杂度都是O(1)。hash table会随着添加或者删除自动的调整大小。需要注意的是调整hash table大小时候需要同步（获取写锁）会阻塞其他读写操作。可能不久后就会改用跳表（skip list）来实现
跳表已经在sorted set中使用了。关于set集合类型除了基本的添加删除操作，其他有用的操作还包含集合的取并集(union)，交集(intersection)，
差集(difference)。通过这些操作可以很容易的实现sns中的好友推荐和blog的tag功能。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sadd key member 添加一个 string 元素到 key 对应的 set 集合中
srem key member 从 key 对应的 set 中移除给定元素
spop key 删除并返回 key 对应的 set 随机的一个元素
srandmember key 随机获取 set 中的一个元素，不删除
smove srckey destkey member 从 srckey 对应的 set 中移除 member 并添加到 destkey 对应的 set 中
scard key 返回 set 的元素个数
sismember key member 判断 member 是否在 set 中
sinter key1 key2 ... keyn 返回所有 set 的交集
sinterstore destkey key1 key2 ... keyn 同上，并保存交集到 destkey 对应的 set 下
sunion key1 key2 ... keyn 返回所有给定 set 的并集
sunion destkey key1 key2 ... keyn 同上，并同时保存并集到 destkey 对应的 set 下
sdiff key1 key2 ... keyn 返回所有 set 的差集
sdiffstore destkey key1 key2 ... keyn 同上，并保存差集到 destkey 对应的 set 下
smembers key 返回 key 对应的所有元素，结果是无序的
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; sadd set1 aaa
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set1 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set1 ccc
(integer) 1
redis 127.0.0.1:6479&amp;gt; srem set1 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; spop set1
&quot;aaa&quot;
redis 127.0.0.1:6479&amp;gt; scard set1
(integer) 1
redis 127.0.0.1:6479&amp;gt; smembers set1
1) &quot;ccc&quot;
redis 127.0.0.1:6479&amp;gt; sadd set2 aaa
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set2 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; sadd set2 ccc
(integer) 1
redis 127.0.0.1:6479&amp;gt; sinterstore set3 set1 set2
(integer) 1
redis 127.0.0.1:6479&amp;gt; smembers set3
1) &quot;ccc&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;sorted-set&quot;&gt;sorted set&lt;/h3&gt;
&lt;p&gt;和set一样sorted set也是string类型元素的集合，不同的是每个元素都会关联一个double类型的score。sorted set的实现是skip list和hash table的混合体
当元素被添加到集合中时，一个元素到score的映射被添加到hash table中，所以给定一个元素获取score的开销是O(1),另一个score到元素的映射被添加到skip list
并按照score排序，所以就可以有序的获取集合中的元素。添加，删除操作开销都是O(log(N))和skip list的开销一致,redis的skip list实现用的是双向链表,这样就
可以逆序从尾部取元素。sorted set最经常的使用方式应该是作为索引来使用.我们可以把要排序的字段作为score存储，对象的id当元素存储。&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;zadd key score member 添加元素互集合，元素存在只更新对应的 scroe
zrem key member 删除指定元素
zincrby key incr member 增加对应 member 的 scroe 值
zrank key member 返回指定元素在集合中的下标，默认按 score 从小到大排序
zrevrank key member 同上，按 scroe 从大到小排序
zrange key start end 返回指定区间的元素
zrevrange key start end 同上，返回结果按 score 逆序
zrangebystore key min max 返回集合中 score 在给定区间的元素
zcount key min max 返回集合中 score 在给定区间的数量
zcard key 返回集合中元素个数
zscore key element 返回给定元素对应的 score
zremrangebyrank key min max 删除集合中排名在给定区间的元素
zremrangebyscore key min max 删除集合中 score 在给定区间的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; zadd ss1 10000 abc
(integer) 1
redis 127.0.0.1:6479&amp;gt; zadd ss1 20000 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; zadd ss1 30000 ccc
(integer) 1
redis 127.0.0.1:6479&amp;gt; zadd ss1 44000 ddd
(integer) 1
redis 127.0.0.1:6479&amp;gt; zrank ss1 bbb
(integer) 1
redis 127.0.0.1:6479&amp;gt; zrevrank ss1 bbb
(integer) 2
redis 127.0.0.1:6479&amp;gt; zcard ss1
(integer) 4
redis 127.0.0.1:6479&amp;gt; zrangebyscore ss1 20000 40000
1) &quot;bbb&quot;
2) &quot;ccc&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;hash&quot;&gt;hash&lt;/h3&gt;
&lt;p&gt;redis hash是一个string类型的field和value的映射表.它的添加，删除操作都是O(1)（平均）.hash特别适合用于存储对象。相较于将对象的每个字段存成
单个string类型。将一个对象存储在hash类型中会占用更少的内存，并且可以更方便的存取整个对象。省内存的原因是新建一个hash对象时开始是用zipmap（又称为small hash）来存储的。这个zipmap其实并不是hash table，但是zipmap相比正常的hash实现可以节省不少hash本身需要的一些元数据存储开销。尽管zipmap的添加，删除，查找都是O(n)，但是由于一般对象的field数量都不太多。所以使用zipmap也是很快的,也就是说添加删除平均还是O(1)。如果field或者value的大小超出一定限制后，redis会在内部自动将zipmap替换成正常的hash实现. 这个限制可以在配置文件中指定
hash-max-zipmap-entries 64 #配置字段最多64个
hash-max-zipmap-value 512 #配置value最大为512字节&lt;/p&gt;

&lt;p&gt;相关命令&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hset key field value 设置 hash field 指定值
hget key field 获取指定的 hash field 值
hmget key field1 field2 ... fieldn 获取全部指定的值
hmset key field1 value1 field2 value2 ... fieldn valuen 同时设定多个 field 值
hincrby key field integer 将指定的 field 加上给定的值
hexists key field 判断指定的 field 是否存在
hdel key field 删除指定的 field
hlen key 返回指定的 field 数量
hkeys key 返回所有的 field
hvals key 返回所有的 value
hgetall 返回所有的 field 和 value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;示例&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; hmset hash1 field1 aaa field2 bbb field3 ccc
OK
redis 127.0.0.1:6479&amp;gt; hmget hash1 field1 field2 field3
1) &quot;aaa&quot;
2) &quot;bbb&quot;
3) &quot;ccc&quot;
redis 127.0.0.1:6479&amp;gt; hexists hash1 field2
(integer) 1
redis 127.0.0.1:6479&amp;gt; hlen hash1
(integer) 3
redis 127.0.0.1:6479&amp;gt; hkeys hash1
1) &quot;field1&quot;
2) &quot;field2&quot;
3) &quot;field3&quot;
redis 127.0.0.1:6479&amp;gt; hvals hash1
1) &quot;aaa&quot;
2) &quot;bbb&quot;
3) &quot;ccc&quot;
redis 127.0.0.1:6479&amp;gt; hgetall hash1
1) &quot;field1&quot;
2) &quot;aaa&quot;
3) &quot;field2&quot;
4) &quot;bbb&quot;
5) &quot;field3&quot;
6) &quot;ccc&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>Redis Linux Pipeline && 分布式</title>
   <link href="http://www.blogways.net/blog/2013/05/05/redis-usage-2.html"/>
   <updated>2013-05-05T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/05/redis-usage-2</id>
   <content type="html">&lt;h2 id=&quot;事务&quot;&gt;事务&lt;/h2&gt;
&lt;p&gt;redis对事务的支持目前还比较简单。redis只能保证一个client发起的事务中的命令可以连续的执行，而中间不会插入其他client的命令。 由于redis是单线程来处理所有client的请求的所以做到这点是很容易的。一般情况下redis在接受到一个client发来的命令后会立即处理并 返回处理结果，但是当一个client在一个连接中发出multi命令有，这个连接会进入一个事务上下文，该连接后续的命令并不是立即执行，而是先放到一 个队列中。当从此连接受到exec命令后，redis会顺序的执行队列中的所有命令。并将所有命令的运行结果打包到一起返回给client.然后此连接就 结束事务上下文。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; multi
OK
redis 127.0.0.1:6479&amp;gt; incr a
QUEUED
redis 127.0.0.1:6479&amp;gt; incr b
QUEUED
redis 127.0.0.1:6479&amp;gt; get a
QUEUED
redis 127.0.0.1:6479&amp;gt; get b
QUEUED
redis 127.0.0.1:6479&amp;gt; exec
1) (integer) 1
2) (integer) 1
3) &quot;1&quot;
4) &quot;1&quot;
redis 127.0.0.1:6479&amp;gt; get a
&quot;1&quot;
redis 127.0.0.1:6479&amp;gt; get b
&quot;1&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;批量操作效率的确的很大的提高，但同时也会带来其他的问题，因为 redis 本身并不提供同步锁机制，如果在批量执行的过程中另一个客户端对批量里面的元素进行操作，当调用 exec 执行的时候发现结果已经不是我们想要的结果了，还好 redis2.1 后添加了 watch 命令，可以用来实现乐观锁，通过对元素的监控来判断在等待的过程中元素的值有没有发生变化，如果有则执行失败。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; watch a
OK
redis 127.0.0.1:6479&amp;gt; get a
&quot;5&quot;
redis 127.0.0.1:6479&amp;gt; multi
OK
redis 127.0.0.1:6479&amp;gt; set a 2
QUEUED
redis 127.0.0.1:6479&amp;gt; exec
(nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;redis 的事务是如此简单，当然也会存在一些问题，首先 redis 只能保证每个命令连续执行，如果事务中一个命令失败了，并不回滚其他的命令，这样就会导致的事务的完整性无法得到保证。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; set a 5
OK
redis 127.0.0.1:6479&amp;gt; lpush b 5
(integer) 1
redis 127.0.0.1:6479&amp;gt; multi
OK
redis 127.0.0.1:6479&amp;gt; incr a
QUEUED
redis 127.0.0.1:6479&amp;gt; incr b
QUEUED
redis 127.0.0.1:6479&amp;gt; exec
1) (integer) 6
2) (error) ERR Operation against a key holding the wrong kind of value
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;还有一个十分罕见的问题是 当事务的执行过程中，如果redis意外的挂了。很遗憾只有部分命令执行了，后面的也就被丢弃了。当然如果我们使用的append-only file方式持久化，redis会用单个write操作写入整个事务内容。即是是这种方式还是有可能只部分写入了事务到磁盘。发生部分写入事务的情况 下，redis重启时会检测到这种情况，然后失败退出。可以使用redis-check-aof工具进行修复，修复会删除部分写入的事务内容。修复完后就 能够重新启动了。&lt;/p&gt;

&lt;h2 id=&quot;pipeline&quot;&gt;pipeline&lt;/h2&gt;
&lt;p&gt;redis是一个cs模式的tcp server，使用和http类似的请求响应协议。一个client可以通过一个socket连接发起多个请求命令。每个请求命令发出后client通常 会阻塞并等待redis服务处理，redis处理完后请求命令后会将结果通过响应报文返回给client。我们还可以利用pipeline的方式从client打包多条命令一起发出，不需要等待单条命令的响应返回，而redis服务端会处理完多条命令后会将多条命令的处理结果打包到一起返回给客户端。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String host = &quot;127.0.0.1&quot;;
int port = 6479, timeout = 30000;
Jedis jedis = new Jedis(host, port, timeout);
Pipeline p = jedis.pipelined();
for (int i = 1; i &amp;lt;= 500000; i++) {
	String key = &quot;comppara_&quot; + i;
	String value = &quot;{param1: &quot; + i + &quot;, param2: &quot; + i + &quot;, param3: &quot; + i + &quot;}&quot;;
	p.set(key, value);
}
p.sync();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过 pipeline 模式，set 跟 get 效率有了明显的提交，前面测试的50W数据导入只需要不到3秒种，读2秒左右。&lt;/p&gt;

&lt;h2 id=&quot;redis持久化&quot;&gt;redis持久化&lt;/h2&gt;
&lt;p&gt;redis是一个支持持久化的内存数据库，也就是说redis需要经常将内存中的数据同步到磁盘来保证持久化。redis支持两种持久化方式，一种是 Snapshotting（快照）也是默认方式，另一种是Append-only file（缩写aof）的方式。下面分别介绍&lt;/p&gt;

&lt;p&gt;Snapshotting
快照是默认的持久化方式。这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb。可以通过配置设置自动做快照持久 化的方式。我们可以配置redis在n秒内如果超过m个key被修改就自动做快照，下面是默认的快照保存配置&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;save 900 1  #900秒内如果超过1个key被修改，则发起快照保存
save 300 10 #300秒内容如超过10个key被修改，则发起快照保存
save 60 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;分布式&quot;&gt;分布式&lt;/h2&gt;
&lt;p&gt;在jedis的源码里发现了两种hash算法（MD5，MURMUR Hash(默认）），也可以自己实现redis.clients.util.Hashing接口扩展。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;JedisShardInfo&amp;gt; hosts = new ArrayList&amp;lt;JedisShardInfo&amp;gt;();

JedisShardInfo host1 = new JedisShardInfo(&quot;127.0.0.1&quot;, 6479, 3000);
JedisShardInfo host2 = new JedisShardInfo(&quot;192.168.4.17&quot;, 6479, 3000);

hosts.add(host1);
hosts.add(host2);

ShardedJedis jedis = new ShardedJedis(hosts);
ShardedJedisPipeline p = jedis.pipelined();

for (int i = 1; i &amp;lt;= 10000; i++) {
	String key = &quot;shard_&quot; + i;
	String value = &quot;value_&quot; + i;
	p.set(key, value);
}

p.sync();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</content>
 </entry>
 
 <entry>
   <title>Redis Linux 安装 && 测试</title>
   <link href="http://www.blogways.net/blog/2013/05/02/redis.html"/>
   <updated>2013-05-02T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/02/redis</id>
   <content type="html">&lt;h2 id=&quot;redis-linux-安装&quot;&gt;Redis Linux 安装&lt;/h2&gt;
&lt;p&gt;由于 Redis 并没有发布 windows 的官方版本，windows 的安装使用不作介绍，只介绍 Linux 下的安装使用。
下载地址：&lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/dmajkic/redis/downloads&lt;/code&gt; 下载最新版本&lt;/p&gt;

&lt;p&gt;然后tar, make,即可。(make前，如果确认自己的测试机是32位linux，在src/Makefile文件中的头部加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;CFLAGS= -march=i686&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;redis 2.6.9 安装报错&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Jimmy 2013-01-21 11:53
zmalloc.h:50:31: error: jemalloc/jemalloc.h: No such file or directory
zmalloc.h:55:2: error: #error &quot;Newer version of jemalloc required&quot;
make[1]: *** [adlist.o] Error 1
make[1]: Leaving directory `/data0/src/redis-2.6.2/src'
make: *** [all] Error 2
解决办法是：
make MALLOC=libc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动 server：
根目录下执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;nohup src/redis-server redis.conf &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果端口有冲突改下 redis.conf 里面的 port 配置&lt;/p&gt;

&lt;p&gt;启动客户端 
&lt;code class=&quot;highlighter-rouge&quot;&gt;src/redis-cli&lt;/code&gt; 
端口有变化 
&lt;code class=&quot;highlighter-rouge&quot;&gt;src/redis-cli -p 6479&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;测试下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;redis 127.0.0.1:6479&amp;gt; set test hello
OK
redis 127.0.0.1:6479&amp;gt; get test
&quot;hello&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。
在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是0。如果你想切换到一个不同的数据库，你可以使用select命令来实现。在命令行界面里键入&lt;code class=&quot;highlighter-rouge&quot;&gt;select 1&lt;/code&gt;，Redis应该会回复一条OK的信息，然后命令行界面里的提示符会变成类似&lt;code class=&quot;highlighter-rouge&quot;&gt;redis 127.0.0.1:6379[1]&amp;gt;&lt;/code&gt;这样。如果你想切换回默认数据库，只要在命令行界面键入&lt;code class=&quot;highlighter-rouge&quot;&gt;select 0&lt;/code&gt;即可。&lt;/p&gt;
&lt;blockquote&gt;

  &lt;h2 id=&quot;redis-客户端测试&quot;&gt;Redis 客户端测试&lt;/h2&gt;
  &lt;p&gt;Java 官方推荐客户端
Jedis&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.Date;
import redis.clients.jedis.Jedis;

public class RedisTest {
	
	public static void main(String[] args) {
		long start = System.currentTimeMillis();
		String host = &quot;127.0.0.1&quot;;
		int port = 6479, timeout = 30000;
		Jedis jedis = new Jedis(host, port, timeout);
		for (int i = 1; i &amp;lt;= 500000; i++) {
			String key = &quot;comppara_&quot; + i;
			String value = &quot;{param1: &quot; + i + &quot;, param2: &quot; + i + &quot;, param3: &quot; + i + &quot;}&quot;;
			jedis.set(key, value);
		}
		long end = System.currentTimeMillis();
		System.out.println(Thread.currentThread().getName() + &quot; insert times &quot; + (end - start));
		
		long s = System.currentTimeMillis();
		for (int i = 0; i &amp;lt;= 500000; i++) {
			String key = &quot;comppara_&quot; + i;
			jedis.get(key);
		}
		long e = System.currentTimeMillis();
		System.out.println(Thread.currentThread().getName() + &quot; read times &quot; + (e - s));
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;C 官方推荐客户端 
hiredis&lt;/p&gt;

&lt;p&gt;C 也不怎么会用，就改的 hiredis 自带的 example.c 示例，编译完了直接执行 ./hiredis-example&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &quot;time.h&quot;
#include &quot;hiredis.h&quot;

void get_time() {
        time_t rawtime;
        struct tm * timeinfo;
        time ( &amp;amp;rawtime );
        timeinfo = localtime ( &amp;amp;rawtime );
        printf ( &quot;\007The current date/time is: %s&quot;, asctime (timeinfo) );
}
int main(void) {
    unsigned int j;
    redisContext *c;
    redisReply *reply;

    struct timeval timeout = { 1, 500000 }; // 1.5 seconds
    c = redisConnectWithTimeout((char*)&quot;127.0.0.1&quot;, 6479, timeout);
    if (c == NULL || c-&amp;gt;err) {
        if (c) {
            printf(&quot;Connection error: %s\n&quot;, c-&amp;gt;errstr);
            redisFree(c);
        } else {
            printf(&quot;Connection error: can't allocate redis context\n&quot;);
        }
        exit(1);
    }

        get_time();
        printf(&quot;test_bach start&quot;);
        for (int i = 1; i &amp;lt;= 500000; i++) {
redisCommand(c,&quot;SET param_%d {param1:param%d,param2:param%d,param3:param%d,param4:param%d}&quot;, i, i, i, i, i);
        }
        printf(&quot;test_bach end&quot;);
        get_time();

        for (int j = 1; j &amp;lt;= 500000; j++) {
redisCommand(c,&quot;GET param_%d&quot;, j);
        }
        get_time();

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试主机配置：8CPU32G内存，测试结果 C 插入 50W 记录大概在31秒左右，JAVA 34秒左右；读 50W 的速度 C 大概需要 29 s 左右，JAVA 需要 31s 左右。如果是远程机器调用JAVA速度基本跟C相差无几。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>MAC OSX 环境下搭建 memcached 环境</title>
   <link href="http://www.blogways.net/blog/2013/05/01/demo-libmemcached-at-mac.html"/>
   <updated>2013-05-01T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/05/01/demo-libmemcached-at-mac</id>
   <content type="html">&lt;p&gt;在MAC OSX下搭建 memcached 环境，那是轻松的一塌糊涂啊。整个过程几分钟就搞定了，让我再次感叹，MacBook 就是为 *nux 下程序员量身定制的！&lt;/p&gt;

&lt;p&gt;我是使用 brew 来安装的，让我们再回顾一下整个过程吧。如果你没有装 brew ,先看步骤一，否则直接看步骤二。&lt;/p&gt;

&lt;h3 id=&quot;步骤一安装-homebrew&quot;&gt;步骤一：安装 Homebrew&lt;/h3&gt;

&lt;p&gt;先看看是否满足下面条件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Intel 的 CPU
OS X 10.5 或者更高
安装了XCode 或者 XCode命令行工具
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;满足了，就可以安装 Homebrew，命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打开Terminal, 粘贴上面的语句.该脚本首先将会解释它要做什么, 然后暂停下来, 直到您确认继续. 更多的安装选项在&lt;a href=&quot;https://github.com/mxcl/homebrew/wiki/Installation&quot;&gt;这里&lt;/a&gt;可以看到 .&lt;/p&gt;

&lt;h3 id=&quot;步骤二安装-memcached&quot;&gt;步骤二：安装 memcached&lt;/h3&gt;

&lt;p&gt;安装前，可以先查找一下，看看有没有：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew search memcache
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;返回结果:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;libmemcached	memcache-top	memcached	memcacheq
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明和关键字&lt;code class=&quot;highlighter-rouge&quot;&gt;memcache&lt;/code&gt;相关的有上面这四个，这样就确认了，有我们需要的东西，第一个是客户端，第三个是服务器。&lt;/p&gt;

&lt;p&gt;那么安装吧！&lt;/p&gt;

&lt;p&gt;先装服务器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew install memcached
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装日志：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;==&amp;gt; Installing memcached dependency: libevent
==&amp;gt; Downloading https://github.com/downloads/libevent/libevent/libevent-2.0.21-s
######################################################################## 100.0%
==&amp;gt; ./configure --disable-debug-mode --prefix=/usr/local/Cellar/libevent/2.0.21
==&amp;gt; make
==&amp;gt; make install
🍺  /usr/local/Cellar/libevent/2.0.21: 48 files, 1.8M, built in 84 seconds
==&amp;gt; Installing memcached
==&amp;gt; Downloading http://memcached.googlecode.com/files/memcached-1.4.15.tar.gz
######################################################################## 100.0%
==&amp;gt; ./configure --prefix=/usr/local/Cellar/memcached/1.4.15 --disable-coverage
==&amp;gt; make install
==&amp;gt; Caveats
To have launchd start memcached at login:
    ln -sfv /usr/local/opt/memcached/*.plist ~/Library/LaunchAgents
Then to load memcached now:
    launchctl load ~/Library/LaunchAgents/homebrew.mxcl.memcached.plist
Or, if you don't want/need launchctl, you can just run:
    /usr/local/opt/memcached/bin/memcached
==&amp;gt; Summary
🍺  /usr/local/Cellar/memcached/1.4.15: 10 files, 176K, built in 8 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面安装日志，可以看出:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安装 memcached 前，先安装了其所依赖的 libevent 库&lt;/li&gt;
  &lt;li&gt;下载的libevent和memcached，被安装到/usr/local/Cellar下面，但是又自动在/usr/local/bin下面建立了软连接，方便使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装后可以查看安装的结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ which memcached
/usr/local/bin/memcached

$ memcached -h
memcached 1.4.15
...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;步骤二安装-libmemcached&quot;&gt;步骤二：安装 libmemcached&lt;/h3&gt;

&lt;p&gt;继续安装客户端库：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew install libmemcached
==&amp;gt; Downloading https://launchpad.net/libmemcached/1.0/1.0.16/+download/libmemca
######################################################################## 100.0%
==&amp;gt; ./configure --prefix=/usr/local/Cellar/libmemcached/1.0.16
==&amp;gt; make install
🍺  /usr/local/Cellar/libmemcached/1.0.16: 110 files, 1.4M, built in 108 seconds
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;步骤三启动服务器&quot;&gt;步骤三：启动服务器&lt;/h3&gt;

&lt;p&gt;先默认参数启动吧：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ /usr/local/bin/memcached -d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;步骤四编写客户端测试程序并运行&quot;&gt;步骤四：编写客户端测试程序并运行&lt;/h3&gt;

&lt;p&gt;编写程序文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;example.cpp&lt;/code&gt; :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;libmemcached/memcached.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;

#define TEST_NUM 500000

void printNowTime() {
    struct timeval current;
    
    gettimeofday(&amp;amp; current, NULL);
    struct tm * mtm = localtime(&amp;amp; current.tv_sec);
    
    printf(&quot;[%04d-%02d-%02d %02d:%02d:%02d.%03d] &quot;, mtm-&amp;gt;tm_year+1900, mtm-&amp;gt;tm_mon + 1, mtm-&amp;gt;tm_mday, mtm-&amp;gt;tm_hour, mtm-&amp;gt;tm_min, mtm-&amp;gt;tm_sec, current.tv_usec / 1000);
}

int main() {

    const char *config_string = &quot;--SERVER=localhost&quot;;
    memcached_st *memc= memcached(config_string, strlen(config_string));
    
    //const char  *keys[]= {&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;,&quot;key4&quot;};
    const  size_t key_length[]= {4, 4, 4, 4};   
    const char *values[] = {&quot;This is 1 first value&quot;, &quot;This is 2 second value&quot;, &quot;This is 3 third value&quot;,&quot;this is 4 forth value&quot;};   
    size_t val_length[]= {21, 22, 21, 21};  
    
    char keys[TEST_NUM][10];
    
    printNowTime();
    printf(&quot;start init keys.\n&quot;);
    
    for(int i=0; i&amp;lt;TEST_NUM; ++i) {
        sprintf(keys[i], &quot;key%06d&quot;, i);
    }
    
    printNowTime();
    printf(&quot;end init keys.\n\n&quot;);
    
    
    memcached_return_t rc;
    
    printNowTime();
    printf(&quot;start set value.\n&quot;);
    
    for (int i=0; i &amp;lt; TEST_NUM; i++)        
    {  
        rc = memcached_set(memc, keys[i], 9, values[i%4], val_length[i%4], (time_t)180,(uint32_t)0);
        //printf(&quot;key: %s  rc:%s\n&quot;, keys[i], memcached_strerror(memc, rc));   // 输出状态
    }
    
    printNowTime();
    printf(&quot;end set value.\n\n&quot;);
    
    
    char * result;
    uint32_t flags;
    size_t value_length;
    
    
    
    printNowTime();
    printf(&quot;start read value.\n&quot;);
    
    for(int i=0; i &amp;lt; TEST_NUM; i++)
    {  
        result = memcached_get(memc, keys[i], 9, &amp;amp;value_length, &amp;amp;flags, &amp;amp;rc);
        
        //if (i%10000 == 0)
        //    printf(&quot;key: %s, value: %s.\n&quot;, keys[i], result);
    } 
    
    printNowTime();
    printf(&quot;end read value.\n&quot;);
    
    memcached_free(memc);

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编写 &lt;code class=&quot;highlighter-rouge&quot;&gt;Makefile&lt;/code&gt; 文件:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example: example.cpp
	gcc -o example example.cpp -lmemcached

clean:
	rm example
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;编译：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ make
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行测试:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ./example
[2013-05-01 20:20:39.500] start init keys.
[2013-05-01 20:20:39.593] end init keys.

[2013-05-01 20:20:39.593] start set value.
[2013-05-01 20:21:04.527] end set value.

[2013-05-01 20:21:04.527] start read value.
[2013-05-01 20:21:26.959] end read value.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整个过程结束！&lt;/p&gt;

&lt;p&gt;确实很简单吧！&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>TDD 读后心得</title>
   <link href="http://www.blogways.net/blog/2013/04/28/tdd-impression.html"/>
   <updated>2013-04-28T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/28/tdd-impression</id>
   <content type="html">&lt;p&gt;在拜读Kent Beck（也是JUnit的联合作者）的大作《Test-Driven Development By Example》（测试驱动开发）之后，内心颇为震撼。也可以算是对自己原有认知的一种思想层面的颠覆。震撼之余，感觉很有必要把自己的一些心得分享出来。&lt;/p&gt;

&lt;p&gt;书中表述的信息量很大，并且配合了丰富的代码实例，然而由于鄙人理解有限，一遍阅读之后，能够摄取的知识点可能也就是书中内容的三四成。&lt;/p&gt;

&lt;p&gt;下面仅将最震撼&lt;a href=&quot;http://www.blogways.net&quot;&gt;自己&lt;/a&gt;的几点内容分享如下：&lt;/p&gt;

&lt;h3 id=&quot;心得一先写测试再写实现&quot;&gt;心得一：先写测试，再写实现&lt;/h3&gt;

&lt;p&gt;对，你没看错。&lt;/p&gt;

&lt;p&gt;按我们的常规，可能都是先写代码，再写测试。至少我本人以前这么干过。也因为以前是先写代码，再写测试，所以，常常感觉没必要写测试。因为代码是怎么实现的，心里明镜似的，写出来的测试代码，意义也不大。除非是开发中有些拿不准的地方，需要写测试来验证，除此之外，基本就不需要写测试。&lt;/p&gt;

&lt;p&gt;然而，TDD的精华就是先写测试，再写代码。&lt;/p&gt;

&lt;p&gt;只所以这样，我觉得和TDD内在的思想有关，他包含“简单设计”这么一个思想。&lt;/p&gt;

&lt;h3 id=&quot;心得二简单设计&quot;&gt;心得二：简单设计&lt;/h3&gt;

&lt;p&gt;我们之前做的设计，基本都是大而全的设计，这个不是TDD所提倡的。TDD所提倡的是“简单设计”，即设计以致用，或者说测试以致用。&lt;/p&gt;

&lt;p&gt;你目前需要什么功能，就做怎样的设计，或者说体现为写怎样的测试代码。&lt;/p&gt;

&lt;p&gt;这样，也就有了“先写测试，再写实现”，所以，从某种角度上来说，我觉得先写的测试，其实上是设计的一种变相表现。&lt;/p&gt;

&lt;p&gt;对，我是这么理解的，“测试”是一种“设计”。并且，这种设计不是大而全的设计，而是一种“设以致用”的“简单设计”。&lt;/p&gt;

&lt;p&gt;那么，怎么去做到“简单设计”呢？他需要我们，“积跬步，以至千里”。&lt;/p&gt;

&lt;h3 id=&quot;心得三积跬步以至千里&quot;&gt;心得三：积跬步，以至千里&lt;/h3&gt;

&lt;p&gt;关于“积跬步，以至千里”，书中给出了一个非常详细的实践例子。这个例子，给我的感觉，也是相当震撼的，原来居然可以这样来…&lt;/p&gt;

&lt;p&gt;我想，这应该也是敏捷开发的一个思想吧，回顾前段时间学习的“scrum”方法，其实，也是对这种“积跬步，以至千里”的思想进行的实践。&lt;/p&gt;

&lt;p&gt;但是，怎么去做到“积跬步，以至千里”，我觉得这也是一个技术活，需要好好体会书中的例子，并在实践中加以运用。运用好了，才能把测试当做设计。&lt;/p&gt;

&lt;p&gt;当然了，在“积跬步，以至千里”的过程中，必不可少的就是“重构”。&lt;/p&gt;

&lt;h3 id=&quot;心得四重构&quot;&gt;心得四：重构&lt;/h3&gt;

&lt;p&gt;在“积跬步”的过程中，必须不断的做重构，否则代码就会凌乱。而且，不仅需要不断地重构实现代码，也需要不断地重构测试代码。这一点，书中也有实例，很好地进行了佐证。&lt;/p&gt;

&lt;p&gt;“简单设计”（或者说测试体现设计）——“积跬步”——“重构”，这是一条线，是一个整体。线上的每个环节，都缺一不可。这条整线，我理解就是本书的最大精华了。&lt;/p&gt;

&lt;p&gt;除了这些外，书中还讲了一些方法论，这些方法论包括：“可运行模式”、“测试模式”、“设计模式”、“重构”，这些方法论中，给我感触最深的是“可运行模式”和“测试模式”。这两个模式，也是在“测试”中不可少的两个环节。&lt;/p&gt;

&lt;p&gt;要真正做到前面所说的——“简单设计、积跬步”，必须要了解“可运行模式”。&lt;/p&gt;

&lt;h3 id=&quot;心得五可运行模式&quot;&gt;心得五：可运行模式&lt;/h3&gt;

&lt;p&gt;可运行模式中包含四种方法：“伪实现”、“三角法”、“显明实现”、“从一到多”。个人认为，虽然这些内容很简单，但是，这些都是必须要掌握的细节。&lt;/p&gt;

&lt;p&gt;这有掌握了这些，并在实践中加以应用，才能做的“积跬步，以至千里”。&lt;/p&gt;

&lt;h3 id=&quot;心得六测试模式&quot;&gt;心得六:测试模式&lt;/h3&gt;

&lt;p&gt;测试模式实际上就是测试方法，其实，不用看书，我们或多或少，都已经在之前的实践中进行应用了，只是作者做了一个相对来说，比较全面的总结。&lt;/p&gt;

&lt;p&gt;如果，你想做好测试，这些模式也需要掌握，至少其中的部分，需要成为我们以后测试中的利器。&lt;/p&gt;

&lt;p&gt;这些方法，包含有：“子测试”、“模拟对象”、“自分流”、“日志字符串”、“清扫测试死角”、“不完整测试”等等。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;以上六点，是我读后的一些心得，记之以分享！&lt;/p&gt;

&lt;p&gt;BTW：关于《测试驱动开发》这本书，我读的是网上流传的一个pdf版的中文译本。可能不是最新版，也可能由于是译本，对作者的本意存在理解偏差。不当之处，请指教。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>memcache NOSQL服务器安装及使用</title>
   <link href="http://www.blogways.net/blog/2013/04/27/memcache.html"/>
   <updated>2013-04-27T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/27/memcache</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;Memcache是danga的一个项目，最早是LiveJournal 服务的，最初为了加速 LiveJournal 访问速度而开发的，后来被很多大型的网站采用。Memcached是以守护程序方式运行于一个或多个服务器中，随时会接收客户端的连接和操作。&lt;/p&gt;

&lt;p&gt;在 Memcached中可以保存的item数据量是没有限制的，只要内存足够。Memcached单进程最大使用内存为2G，要使用更多内存，可以分多个端口开启多个Memcached进程，最大30天的数据过期时间,设置为永久的也会在这个时间过期，常量REALTIME_MAXDELTA 
60&lt;em&gt;60&lt;/em&gt;24*30控制，最大键长为250字节，大于该长度无法存储，常量KEY_MAX_LENGTH 250控制，单个item最大数据是1MB，超过1MB数据不予存储，常量POWER_BLOCK 1048576进行控制（可以修改slabs.c：POWER_BLOCK的值，然后重新编译memcached），它是默认的slab大小，最大同时连接数是200，通过 conn_init()中的freetotal进行控制，最大软连接数是1024，通过settings.maxconns=1024 进行控制，跟空间占用相关的参数：settings.factor=1.25, settings.chunk_size=48,影响slab的数据占用和步进方式。memcached是一种无阻塞的socket通信方式服务，基于libevent库，由于无阻塞通信，对内存读写速度非常之快。memcached分服务器端和客户端，可以配置多个服务器端和客户端，应用于分布式的服务非常广泛。memcached作为小规模的数据分布式平台是十分有效果的。&lt;/p&gt;

&lt;p&gt;memcached是键值一一对应，key默认最大不能超过128个字 节，value默认大小是1M，也就是一个slabs，如果要存2M的值（连续的），不能用两个slabs，因为两个slabs不是连续的，无法在内存中 存储，故需要修改slabs的大小，多个key和value进行存储时，即使这个slabs没有利用完，那么也不会存放别的数据。&lt;/p&gt;

&lt;p&gt;目前memcached支持C/C++、Perl、PHP、Python、Ruby、Java、C#、Postgres、Chicken Scheme、Lua、MySQL和Protocol等语言客户端。&lt;/p&gt;

&lt;h3 id=&quot;二memcache和memcached&quot;&gt;二、Memcache和memcached&lt;/h3&gt;
&lt;p&gt;其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名，知道我的意思了吧。一个是项目名称，一个是主程序文件名，在网上看到了很多人不明白，于是混用了。&lt;/p&gt;

&lt;h3 id=&quot;三memcached-安装&quot;&gt;三、Memcached 安装&lt;/h3&gt;

&lt;p&gt;1.在Linux环境下应用Memcache时，Memcache用到了libevent这个库，用于Socket的处理，所以还需要安装libevent。这里用的libevent的版本是libevent-1.4.9。下载地址&lt;a href=&quot;http://www.monkey.org/~provos/libevent/&quot;&gt;http://www.monkey.org/~provos/libevent/&lt;/a&gt;（如果你的系统已经安装了libevent，可以不用安装）。&lt;/p&gt;

&lt;p&gt;2.Memcached 下载地址&lt;a href=&quot;https://code.google.com/p/memcached/&quot;&gt;https://code.google.com/p/memcached/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3.这里我运用了Magent作为Memcached代理服务器软件，它可以搭建高可用性的集群应用的Memcached服务，magent采用的是：Consistent Hashing原理，Consistent Hashing如下所示：首先求出memcached服务器（节点）的哈希值， 并将其配置到0～232的圆（continuum）上。然后用同样的方法求出存储数据的键的哈希值，并映射到圆上。然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。 如果超过232仍然找不到服务器，就会保存到第一台memcached服务器上，magent下载地址为：&lt;a href=&quot;http://code.google.com/p/memagent/&quot;&gt;http://code.google.com/p/memagent/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;4.编译安装libevent&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar zxvf libevent-1.4.9-stable.tar.gz
cd libevent-1.4.9-stable/
./configure --prefix=/usr
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;5.编译安装Memcached&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;tar zxvf memcached-1[1].4.5.tar.gz
cd memcached-1.4.5/
./configure --with-libevent=/usr
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;6.编译安装magent&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir magent
cd magent/
tar zxvf magent-0.5.tar.gz
/sbin/ldconfig
sed -i &quot;s#LIBS = -levent#LIBS = -levent -lm#g&quot; Makefile
make
cp magent /usr/bin/magent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在安装magent过程中可能遇到一些问题，下面列举几个可能出现的问题及解决方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -Wall -g -O2 -I/usr/local/include -m64 -c -o magent.o magent.c
magent.c: In function 'writev_list':
magent.c:729: error: 'SSIZE_MAX' undeclared (first use in this function)
magent.c:729: error: (Each undeclared identifier is reported only once
magent.c:729: error: for each function it appears in.)
make: *** [magent.o] Error 1

解决办法：
[spdev@slave2 magent]# vi ketama.h 
#在开头加入
#ifndef SSIZE_MAX
#define SSIZE_MAX      32767
#endif

gcc -Wall -g -O2 -I/usr/local/include -m64 -c -o magent.o magent.c
gcc -Wall -g -O2 -I/usr/local/include -m64 -c -o ketama.o ketama.c
gcc -Wall -g -O2 -I/usr/local/include -m64 -o magent magent.o ketama.o
/usr/lib64/libevent.a /usr/lib64/libm.a 
gcc: /usr/lib64/libevent.a: No such file or directory
gcc: /usr/lib64/libm.a: No such file or directory
解决办法：
[spdev@slave2 magent]#  ln -s /usr/lib/libevent*  /usr/lib64/

gcc -Wall -g -O2 -I/usr/local/include -m64 -o magent magent.o ketama.o 
/usr/lib64/libevent.a /usr/lib64/libm.a 
gcc: /usr/lib64/libm.a: No such file or directory
make: *** [magent] Error 1
解决办法：
[spdev@slave2 magent]# cp /usr/lib64/libm.so /usr/lib64/libm.a

gcc -Wall -g -O2 -I/usr/local/include -m64 -o magent magent.o ketama.o 
/usr/lib64/libevent.a /usr/lib64/libm.a 
/usr/lib64/libevent.a(event.o): In function `detect_monotonic':
event.c:(.text+0xc79): undefined reference to `clock_gettime'
/usr/lib64/libevent.a(event.o): In function `gettime':
event.c:(.text+0xd60): undefined reference to `clock_gettime'
collect2: ld returned 1 exit status
make: *** [magent] Error 1
解决办法：
[spdev@slave2 magent]#vi Makefile 
CFLAGS = -Wall -g -O2 -I/usr/local/include $(M64)
改为：    
CFLAGS = -lrt -Wall -g -O2 -I/usr/local/include $(M64)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四启动和结束服务&quot;&gt;四、启动和结束服务&lt;/h3&gt;
&lt;p&gt;1.启动一个Memcache的服务器端：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;memcached -d -m 10 -u spdev -l 192.168.4.19 -p 11211 -c 256 -P /tmp/memcached.pid
? -d 选项是启动一个守护进程，
? -m 是分配给Memcache使用的内存数量，单位是MB，我这里是10MB，
? -u 是运行Memcache的用户，我这里是spdev，
? -l 是监听的服务器IP地址，我这里指定了服务器的IP地址192.168.4.19，
? -p 是设置Memcache监听的端口，我这里设置了11211，最好是1024以上的端口，
? -c 是最大运行的并发连接数，默认1024，这里设置了256，按照服务器的负载量来设定，
? -P 是设置保存Memcache的pid文件，我这里是保存在/tmp/memcached.pid。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2.结束一个Memcache进程&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果要结束Memcache进程，执行：
# kill `cat /tmp/memcached.pid`
? 注意，上面命令中的符号是 `，不是单引号’
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3.启动Magent代理&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;magent -u spdev -n 51200 -l 192.168.4.19 -p 12000 -s 192.168.4.19:11211 
-s 192.168.4.19:11212 -b 192.168.4.19:11213 

-h this message
-u uid
-g gid
-p port, default is 11211. (0 to disable tcp support)
-s ip:port, set memcached server ip and port
-b ip:port, set backup memcached server ip and port
-l ip, local bind ip address, default is 0.0.0.0
-n number, set max connections, default is 4096
-D don't go to background
-k use ketama key allocation algorithm
-f file, unix socket path to listen on. default is off
-i number, max keep alive connections for one memcached server, default is 20
-v verbose

启动magent代理服务器，端口为12000.代理服务器ip端口192.168.4.19:11211、
192.168.4.19:11212，备份主机ip端口为192.168.4.19:11213
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五telnet-memcache服务器及magent代理服务器测试&quot;&gt;五、telnet memcache服务器及magent代理服务器测试&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;telnet memcache 192.168.4.19:11211服务器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; C:\Users\Administrator&amp;gt;telnet 192.168.4.19:11211
 set key 0 0 8
 88888888
 STORED
 quit

 遗失对主机的连接。
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;telnet magent 192.168.4.19:12000代理服务器&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; C:\Users\Administrator&amp;gt;telnet 192.168.4.19:12000
 get key
 VALUE key 0 8
 88888888
 END
 quit
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

   	遗失对主机的连接。
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里可以发现在服务器上set的值，在代理服务器上可以取到。&lt;/p&gt;

&lt;h3 id=&quot;六运用libmemcached-c客户端编写客户端测试程序&quot;&gt;六、运用libmemcached c++客户端编写客户端测试程序&lt;/h3&gt;

&lt;p&gt;libmemcached下载地址:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://launchpad.net/libmemcached/+download/&quot;&gt;https://launchpad.net/libmemcached/+download/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;此处要注意，libmemcached 1.0以上版本需要gcc4.2以上版本才能支持，这里我用的是最新版libmemcached-1.0.17，而16主机上gcc版本为4.12,所以我升级了gcc，升级gcc步骤这里就不做介绍&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;libmemcached客户端程序连接magent代理服务器测试&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
 192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
 调用时间如下：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Save data:begin
  2013-04-29 15:39:32.129
  2013-04-29 15:41:43.406
  Save data:end 从上面数据看出set 500000数据用了2分多钟
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  2013-04-29 15:41:43.406
  2013-04-29 15:41:45.899 由此看出随机取10000条数据用了两秒多的时间
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.libmemcached客户端程序直接连接memcache服务器测试&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
调用时间如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  Save data:begin
  2013-04-29 20:28:42.439
  2013-04-29 20:30:10.462
  Save data:end 从上面数据看出set 500000数据用了1分多钟
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  2013-04-29 20:30:10.462
  2013-04-29 20:30:12.085 由此看出随机取10000条数据用了1秒多的时间
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;七运用memcached-client-for-java客户端编写客户端测试程序&quot;&gt;七、运用memcached client for java客户端编写客户端测试程序&lt;/h3&gt;

&lt;p&gt;memcached client for java下载地址为：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://github.com/gwhalin/Memcached-Java-Client/&quot;&gt;http://github.com/gwhalin/Memcached-Java-Client/&lt;/a&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;java客户端程序连接magent代理服务器测试&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
 192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
 调用时间如下：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  save begin:2013-04-29 10:09:04:0790
  save end:2013-04-29 10:13:11:0721 从上面数据看出set 500000数据用了4分多钟
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  get begin:2013-04-29 10:13:11:0722
  get end:2013-04-29 10:13:16:0678 由此看出随机取10000条数据用了4秒多的时间
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.java客户端程序直接连接memcache服务器测试&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;循环500000次向memcache服务器set 500000条值，本次测试是ip为
192.168.4.16的主机调ip为192.168.4.19的memcache服务器，具体
调用时间如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  save begin:2013-04-29 20:21:46:0195
  save end:2013-04-29 20:25:06:0365 从上面数据看出set 500000数据用了3分多钟
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;循环10000次，每次随机取1-500000中任意一个随机数，然后从上面set的值中get对应
数据，具体调用时间如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  get begin:2013-04-29 20:25:06:0366
  get end:2013-04-29 20:25:10:0357 由此看出随机取10000条数据用了接近4秒的时间
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;八说明&quot;&gt;八、说明&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;从步骤七中测试结果可以看出，c++客户端调用memcache服务器在性能上明显优于java客户端，同时运用magent代理服务器时性能上还是有所降低&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;至于redis与memcache性能差异本文没有做对比，可参照redis文档中列出的测试数据加以对比，这里列下在网上看到一些大拿们列出的对比：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;性能对比：由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起Memcached，还是稍有逊色&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;内存使用效率对比：使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Redis支持服务器端的数据操作：Redis相比Memcached来说，拥有更多的数据结构和并支持更丰富的数据操作，通常在Memcached里，你需要将数据拿到客户端来进行类似的修改再set回去。这大大增加了网络IO的次数和数据体积。在Redis中，这些复杂的操作通常和一般的GET/SET一样高效。所以，如果需要缓存能够支持更复杂的结构和操作，那么Redis会是不错的选择&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>2013年待研究学习事项</title>
   <link href="http://www.blogways.net/blog/2013/04/25/2013-todo-list.html"/>
   <updated>2013-04-25T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/25/2013-todo-list</id>
   <content type="html">&lt;h3 id=&quot;列表&quot;&gt;列表：&lt;/h3&gt;

&lt;table&gt;

    &lt;thead&gt;
        &lt;tr&gt;
            &lt;th&gt; 序号 &lt;/th&gt;
            &lt;th&gt; 研究内容 &lt;/th&gt;
            &lt;th&gt; 子内容 &lt;/th&gt;
            &lt;th&gt; 优先级 &lt;/th&gt;
            &lt;th&gt; 添加人 &lt;/th&gt;
        &lt;/tr&gt;
    &lt;/thead&gt;

    &lt;tbody&gt;
        &lt;tr&gt;
            &lt;td&gt; 1 &lt;/td&gt;
            &lt;td&gt; 敏捷开发环境搭建  &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; 100 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.1 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; GIT环境搭建 &lt;/td&gt;
            &lt;td&gt; 100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.2 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; Maven环境搭建 &lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.3 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; jenkins环境搭建 &lt;/td&gt;
            &lt;td&gt; 100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.4 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; 测试驱动开发(TDD)学习&lt;/td&gt;
            &lt;td&gt; 100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 1.5&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; Scrum方法学习&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 2 &lt;/td&gt;
            &lt;td&gt; NoSQL研究 &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;2.1&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;memcached研究&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;2.2&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;redis研究&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;2.3&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;mongodb研究&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        
        &lt;tr&gt;
            &lt;td&gt; 3 &lt;/td&gt;
            &lt;td&gt; 手机应用研究 &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 3.1 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; Sencha框架研究 &lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        
        &lt;tr&gt;
            &lt;td&gt; 4 &lt;/td&gt;
            &lt;td&gt; 云化 &lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt; 4.1 &lt;/td&gt;
            &lt;td&gt; &lt;/td&gt;
            &lt;td&gt; U-Cloud研究学习 &lt;/td&gt;
            &lt;td&gt;100&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;!--  在这里继续添加内容 BEGIN --&gt;
        
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;待添加&lt;/td&gt;
        &lt;/tr&gt;
        
        
        
        &lt;!--  在这里继续添加内容 END --&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9&lt;/td&gt;
            &lt;td&gt;杂记&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.1&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;OSGi学习&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.2&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;工作流引擎——jBPM5/Activiti&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.3&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;规则引擎——drools&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.4&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;EAI/ESB组件研究&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.4&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;HTML5/CSS3特性学习&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
		
		&lt;tr&gt;
            &lt;td&gt;9.5&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;去 IOE 之 关系数据库MySQL化&lt;/td&gt;
            &lt;td&gt;80&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.6&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;实时/准实时数据同步实现&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;tr&gt;
            &lt;td&gt;9.7&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;ArcGIS学习和研究&lt;/td&gt;
            &lt;td&gt;50&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
        &lt;/tr&gt;
        
        
		
		&lt;!--  在这里继续添加内容 BEGIN --&gt;
        
        &lt;tr&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;&lt;/td&gt;
            &lt;td&gt;待添加&lt;/td&gt;
        &lt;/tr&gt;
        
        &lt;!--  在这里继续添加内容 END --&gt;
      	
        
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;说明&quot;&gt;说明&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;上表为大家共同维护，发现有什么好的东西就向里面添加。根据工作要求，定期讨论后续研究内容的优先级。&lt;/li&gt;
  &lt;li&gt;序号 9 开始为杂记，根据工作要求，定期调整 9 中的内容至序号 1-8 内。&lt;/li&gt;
  &lt;li&gt;优先级说明：100为分界线。100及其以上为需优先研究学习内容。&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Maven 环境搭建</title>
   <link href="http://www.blogways.net/blog/2013/04/23/maven.html"/>
   <updated>2013-04-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/23/maven</id>
   <content type="html">&lt;h2 id=&quot;maven-安装-简介&quot;&gt;Maven 安装 简介&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Maven 安装&lt;/p&gt;

    &lt;p&gt;下载安装包
  地址：http://maven.apache.org/download.html&lt;/p&gt;

    &lt;p&gt;Windows 安装：
  本机jdk必需是1.5或者以上版本&lt;/p&gt;

    &lt;p&gt;解压安装包&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  目录结构：
  bin   Maven的运行脚本
  boot  Maven自己的类装载器
  conf  该目录下包含了全局行为定制文件setting.xml
  lib   Maven运行时所需的类库
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置环境变量&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  M2_HOME=安装目录
  在path变量中增加%M2_HOME%\bin
  检查安装是否正确
  Mvn –v
  能看到Maven和JDK的版本号为安装正确
  试运行maven命令
  mvn help:system
  该命令将会下载help插件并运行它，且打印出Java系统属性和环境变量
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Maven名词解释&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;Project：任何您想build的事物，Maven都可以认为它们是工程。这些工程被定义为工程对象模型(POM，Poject Object Model)。一个工程可以依赖其它的工程；一个工程也可以由多个子工程构成。&lt;/li&gt;
      &lt;li&gt;POM：POM(pom.xml)是Maven的核心文件，它是指示Maven如何工作的元数据文件，类似于Ant中的build.xml文件。POM文件位于每个工程的根目录中。&lt;/li&gt;
      &lt;li&gt;GroupId：groupId是一个工程的在全局中唯一的标识符，一般地，它就是工程名。groupId有利于使用一个完全的包名，将一个工程从其它有类似名称的工程里区别出来。&lt;/li&gt;
      &lt;li&gt;Artifact：artifact 是工程将要产生或需要使用的文件，它可以是jar文件，源文件，二进制文件，war文件，甚至是pom文件。每个artifact都由groupId和 artifactId组合的标识符唯一识别。需要被使用(依赖)的artifact都要放在仓库(见Repository)中，否则Maven无法找到 (识别)它们。&lt;/li&gt;
      &lt;li&gt;Dependency：为了能够build或运行，一个典型的Java工程会依赖其它的包。在Maven中，这些被依赖的包就被称为dependency。dependency一般是其它工程的artifact。&lt;/li&gt;
      &lt;li&gt;Plug-in：Maven是由插件组织的，它的每一个功能都是由插件提供的。插件提供goal(类似于Ant中的target)，并根据在POM中找到的元数据去完成工作。主要的Maven插件要是由Java写成的，但它也支持用Beanshell或Ant脚本写成的插件。&lt;/li&gt;
      &lt;li&gt;Repository：仓库。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置文件&lt;/p&gt;

    &lt;p&gt;$user.home/.m2/repository/setting.xml 
  为用户范围的配置文件
  $M2_HOME/conf/setting.xml 
  为全局范围的配置文件，修改后将影响本机所有用户的配置
  建议：只修改用户级别的配置，既不影响其它用户，也不影响后期升级。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置介绍&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;localRepository： 自定义本地库路径，默认在$user.home/.m2中&lt;/li&gt;
      &lt;li&gt;interactiveMode：&lt;/li&gt;
      &lt;li&gt;offline：是否每次编译都去查找远程中心库&lt;/li&gt;
      &lt;li&gt;pluginGroups：插件组，例如org.mortbay.jetty&lt;/li&gt;
      &lt;li&gt;proxies：通过代理访问外部库&lt;/li&gt;
      &lt;li&gt;servers：集成认证服务，例如集成Tomcat&lt;/li&gt;
      &lt;li&gt;mirrors：镜像库，可以指定内部中心库&lt;/li&gt;
      &lt;li&gt;profiles：个性配置，需要在Activation标签中激活&lt;/li&gt;
      &lt;li&gt;activeProfiles：表示激活的profile&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;maven仓库&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;远程公用仓库 
  Maven内置了远程公用仓库：http://repo1.maven.org/maven2这个公共仓库是由Maven自己维护，里面有大量的常用类库，并包含了世界上大部分流行的开源项目构件。目前是以java为主。&lt;/li&gt;
      &lt;li&gt;内部中心仓库
  也称私有共享仓库(私服)。一般是由公司自己设立的，只为本公司内部共享使用。它既可以作为公司内部构件协作和存档，也可作为公用类库镜像缓存，减少在外部访问和下载的频率。Nexus和Artifactory均可搭建仓库服务器。但后者支持LDAP认证，这样就可以将私有仓库的认证集成到公司已经有的LDAP认证服务器。内部中心库又可以连接第三方库，例如Jboss中心库、Spring中心库，以随时获得最新版本的第三方构件。&lt;/li&gt;
      &lt;li&gt;本地仓库
  Maven会将工程中依赖的构件(Jar包)从远程下载到本机一个目录下管理，通常默认在$user.home/.m2/repository下。
  修改本地库位置：在$M2_HOME/conf/setting.xml文件的&lt;localRepository&gt;元素中指定路径，例如：&lt;localRepository&gt;D:/my_repository&lt;/localRepository&gt;&lt;/localRepository&gt;&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Maven常用命令&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;检测Maven、JDK版本
  mvn –v  或者  mvn -version&lt;/li&gt;
      &lt;li&gt;获取帮助选项
  mvn –h  或者  mvn –help&lt;/li&gt;
      &lt;li&gt;显示详细错误信息
  mvn –e&lt;/li&gt;
      &lt;li&gt;创建Java项目
  mvn archetype:create -DgroupId=${groupId} -DartifactId=${artifactId}
  示例：mvn archetype:create -DgroupId=com.howsun -DartifactId=myApp-Dversion=0.1&lt;/li&gt;
      &lt;li&gt;创建Web项目
  mvn archetype:create -DgroupId=${packageName}    -DartifactId=${webappName} -DarchetypeArtifactId=maven-archetype-webapp&lt;/li&gt;
      &lt;li&gt;创建其它项目(例如SSH、JPA、JSF、Seam…)
  mvn archetype:generate然后根据提示选择项目骨架、groupid、artifactid、版本号…Maven3已有上百个项目骨架&lt;/li&gt;
      &lt;li&gt;转换成Eclipse工程
  mvn eclipse:eclipse
  mvn eclipse:clean  //清除Eclipse设置信息
  转换成idea项目：mvn idea:ide&lt;/li&gt;
      &lt;li&gt;编译
  mvn compile&lt;/li&gt;
      &lt;li&gt;编译测试代码
  mvn test-compile&lt;/li&gt;
      &lt;li&gt;产生Site：
  mvn site&lt;/li&gt;
      &lt;li&gt;测试
  mvn test  //运行测试
  mvn test -Dtest=${类名} //单独运行测试类&lt;/li&gt;
      &lt;li&gt;清除
  mvn clean  //将清除原来编译的结果&lt;/li&gt;
      &lt;li&gt;打包
  mvn packagemvn package –Dmaven.test.skip=true //打包时不执行测试&lt;/li&gt;
      &lt;li&gt;发布
  mvn install //将项目打包成构件安装到本地仓库
  mvn deploy  //发布到本地仓库或服务器(例如Tomcat、Jboss)&lt;/li&gt;
      &lt;li&gt;手动添加构件到仓库
  mvn install:install-file -Dfile=${jar包文件位置} -DgroupId=${groupId} -DartifactId=${artifactId} -Dversion=${版本号} -Dpackaging=jar -DgeneratePom=${是否同时创建pom文件}&lt;/li&gt;
      &lt;li&gt;复制依赖构件到相应目录
  mvn dependency:copy-dependencies -DoutputDirectory=${目标目录} -DexcludeScope=${scope} -Dsilent=true
  示例：
  mvn dependency:copy-dependencies 
     -DoutputDirectory=WebRoot/WEB-INF/lib 
     -Dsilent=true 
     -DincludeScope=runtime&lt;/li&gt;
      &lt;li&gt;显示一个插件的详细信息(configuration, goals等):
  mvn help:describe -Dplugin=pluginName –Ddetail&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工程配置文件 pom.xml&lt;/p&gt;

    &lt;p&gt;是Maven项目的核心配置文件，位于每个工程的根目录，指示Maven工作的元数据文件。
  节点介绍&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;
        &lt;project&gt; ：文件的根节点 .
&lt;/project&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;modelversion&gt; ： pom.xml使用的对象模型版本 .
&lt;/modelversion&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;groupId&gt; ：创建项目的组织或团体的唯一 Id.
&lt;/groupId&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;artifactId&gt; ：项目的唯一 Id, 可视为项目名 .
&lt;/artifactId&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;packaging&gt; ：打包类型，一般有JAR,WAR,EAR 等 
&lt;/packaging&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;version&gt; ：产品的版本号 .
&lt;/version&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;name&gt; ：项目的显示名，常用于 Maven 生成的文档。 
&lt;/name&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;url&gt; ：组织的站点，常用于 Maven 生成的文档。 
&lt;/url&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;description&gt; ：项目描述，常用于 Maven 生成的文档。 
&lt;/description&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;dependencies&gt;：构件依赖&lt;parent&gt;：模型继承 
&lt;/parent&gt;&lt;/dependencies&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;dependencyManagement&gt;：依赖管理  
&lt;/dependencyManagement&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;reporting&gt;：创建报告 
&lt;/reporting&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;build&gt;：构建 
&lt;/build&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;repositories&gt;：引用第三方仓库 
&lt;/repositories&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;licenses&gt;：许可

&lt;/licenses&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Eclipse中使用maven&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;安装M2Eclipse插件
  Help -&amp;gt; InstallNewSoftware -&amp;gt; Work with -&amp;gt; Add
  核心组件：&lt;/li&gt;
      &lt;li&gt;Name：m2e
  Location：http://m2eclipse.sonatype.org/sites/m2e&lt;/li&gt;
      &lt;li&gt;扩展组件：
  Name： m2e-extras
  Location：http://m2eclipse.sonatype.org/sites/m2e-extras&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令行创建java工程&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;command 窗口执行&lt;/p&gt;

        &lt;p&gt;F:\maven&amp;gt;mvn archetype:create -DgroupId=com.ailk.test -DartifactId=hello -DpackageName=com.ailk.test -Dversion=1.0
 目录会下生成一个 hello 的文件夹
 Hello/src/main/java 是源文件目录
 Hello/src/test/java 是测试文件目录
 Hello/target 是编译目标文件夹
 Hello/pom.xml 是工程的 maven 配置文件&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Setting 配置&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
 &amp;lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot; 
           xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; 
           xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&amp;gt;
   &amp;lt;localRepository&amp;gt;F:\maven\repo&amp;lt;/localRepository&amp;gt;
   &amp;lt;pluginGroups&amp;gt;
   &amp;lt;/pluginGroups&amp;gt;
   &amp;lt;proxies&amp;gt;
   &amp;lt;/proxies&amp;gt;
   &amp;lt;servers&amp;gt;
   	&amp;lt;server&amp;gt;
             &amp;lt;id&amp;gt;sphost&amp;lt;/id&amp;gt;
             &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
             &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
         &amp;lt;/server&amp;gt;
         &amp;lt;server&amp;gt;
             &amp;lt;id&amp;gt;spsnap&amp;lt;/id&amp;gt;
             &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
             &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
         &amp;lt;/server&amp;gt;
   &amp;lt;/servers&amp;gt;
   &amp;lt;mirrors&amp;gt;
   	&amp;lt;mirror&amp;gt;
             &amp;lt;id&amp;gt;nexus-public&amp;lt;/id&amp;gt;
             &amp;lt;mirrorOf&amp;gt;public&amp;lt;/mirrorOf&amp;gt;
             &amp;lt;!--url&amp;gt;http://127.0.0.1:8081/nexus/content/groups/mygroup&amp;lt;/url--&amp;gt;
             &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/groups/spgroup/&amp;lt;/url&amp;gt;
         &amp;lt;/mirror&amp;gt;
   &amp;lt;/mirrors&amp;gt;
   &amp;lt;profiles&amp;gt;
   	&amp;lt;profile&amp;gt;
     &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
     &amp;lt;repositories&amp;gt;
         &amp;lt;repository&amp;gt;
             &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
             &amp;lt;name&amp;gt;local private nexus&amp;lt;/name&amp;gt;
             &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/groups/spgroup/&amp;lt;/url&amp;gt;
             &amp;lt;releases&amp;gt;
                 &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
             &amp;lt;/releases&amp;gt;
             &amp;lt;snapshots&amp;gt;
                 &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
             &amp;lt;/snapshots&amp;gt;
         &amp;lt;/repository&amp;gt;
     &amp;lt;/repositories&amp;gt;
     &amp;lt;pluginRepositories&amp;gt;
         &amp;lt;pluginRepository&amp;gt;
             &amp;lt;id&amp;gt;nexus&amp;lt;/id&amp;gt;
             &amp;lt;name&amp;gt;local private nexus&amp;lt;/name&amp;gt;
             &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/groups/spgroup/&amp;lt;/url&amp;gt;
             &amp;lt;releases&amp;gt;
                 &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
             &amp;lt;/releases&amp;gt;
             &amp;lt;snapshots&amp;gt;
                 &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
             &amp;lt;/snapshots&amp;gt;
         &amp;lt;/pluginRepository&amp;gt;
     &amp;lt;/pluginRepositories&amp;gt;
 &amp;lt;/profile&amp;gt;
   &amp;lt;/profiles&amp;gt;
		  
   &amp;lt;activeProfiles&amp;gt;
         &amp;lt;activeProfile&amp;gt;nexus&amp;lt;/activeProfile&amp;gt;
     &amp;lt;/activeProfiles&amp;gt;
 &amp;lt;/settings&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Pom 配置&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
   xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
   &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
   &amp;lt;groupId&amp;gt;com.ailk.test&amp;lt;/groupId&amp;gt;
   &amp;lt;artifactId&amp;gt;hello&amp;lt;/artifactId&amp;gt;
   &amp;lt;version&amp;gt;1.0&amp;lt;/version&amp;gt;
   &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;
   &amp;lt;name&amp;gt;hello&amp;lt;/name&amp;gt;
   &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt;
   &amp;lt;properties&amp;gt;
     &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
   &amp;lt;/properties&amp;gt;
   &amp;lt;dependencies&amp;gt;
     &amp;lt;dependency&amp;gt;
       &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
       &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
       &amp;lt;version&amp;gt;4.8.1&amp;lt;/version&amp;gt;
       &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
     &amp;lt;/dependency&amp;gt;
   &amp;lt;/dependencies&amp;gt;
   &amp;lt;build&amp;gt;
         &amp;lt;pluginManagement&amp;gt;
             &amp;lt;plugins&amp;gt;
                 &amp;lt;plugin&amp;gt;
                     &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
                     &amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;
                     &amp;lt;configuration&amp;gt;
                         &amp;lt;source&amp;gt;1.5&amp;lt;/source&amp;gt;
                         &amp;lt;target&amp;gt;1.5&amp;lt;/target&amp;gt;
                     &amp;lt;/configuration&amp;gt;
                 &amp;lt;/plugin&amp;gt;
             &amp;lt;/plugins&amp;gt;
         &amp;lt;/pluginManagement&amp;gt;
         &amp;lt;extensions&amp;gt;
             &amp;lt;extension&amp;gt;
                 &amp;lt;groupId&amp;gt;org.apache.maven.wagon&amp;lt;/groupId&amp;gt;
                 &amp;lt;artifactId&amp;gt;wagon-ftp&amp;lt;/artifactId&amp;gt;
                 &amp;lt;version&amp;gt;1.0-alpha-6&amp;lt;/version&amp;gt;
             &amp;lt;/extension&amp;gt;
         &amp;lt;/extensions&amp;gt;
     &amp;lt;/build&amp;gt;
     &amp;lt;!-- 配置远程发布到私服，mvn deploy --&amp;gt;
     &amp;lt;distributionManagement&amp;gt;
         &amp;lt;repository&amp;gt;
             &amp;lt;id&amp;gt;sphost&amp;lt;/id&amp;gt;
             &amp;lt;name&amp;gt;Nexus Release Repository&amp;lt;/name&amp;gt;
             &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/repositories/sphost/&amp;lt;/url&amp;gt;
         &amp;lt;/repository&amp;gt;
         &amp;lt;snapshotRepository&amp;gt;
             &amp;lt;id&amp;gt;spsnap&amp;lt;/id&amp;gt;
             &amp;lt;name&amp;gt;Nexus Snapshot Repository&amp;lt;/name&amp;gt;
             &amp;lt;url&amp;gt;http://192.168.4.19:8081/nexus/content/repositories/spsnap/&amp;lt;/url&amp;gt;
         &amp;lt;/snapshotRepository&amp;gt;
     &amp;lt;/distributionManagement&amp;gt;
 &amp;lt;/project&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;清除、编译、测试、打包、安装到本机、发布到远程仓库&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; F:\maven&amp;gt;cd hello
 F:\maven\hello&amp;gt;mvn clean compile test package install deploy
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Eclipse创建web工程&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;创建 maven web 工程&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; File/new/project/maven project/next/next
 选择创建maven web项目（maven-archetype-webapp）
 Group id: com.ailk.web.test
 Artiface id: hello
 Version: 0.0.1-SNAPSHOT
 Package: com.ailk.web.test.hello
 创建完按下面目录添加serverlet、struts.xml、web.xml以及一些页面
 src/main/java java源文件
 src/main/resources struts等配置文件目录
 src/main/webapp 页面以及web.xml文件目录
 target 编译和打包目录
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;setting.xml 配置&lt;/p&gt;

        &lt;p&gt;添加一个 tomcat server&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &amp;lt;servers&amp;gt;
   	&amp;lt;server&amp;gt;
             &amp;lt;id&amp;gt;sphost&amp;lt;/id&amp;gt;
             &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
             &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
         &amp;lt;/server&amp;gt;
         &amp;lt;server&amp;gt;
             &amp;lt;id&amp;gt;spsnap&amp;lt;/id&amp;gt;
             &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
             &amp;lt;password&amp;gt;admin123&amp;lt;/password&amp;gt;
         &amp;lt;/server&amp;gt;
         &amp;lt;server&amp;gt;
             &amp;lt;id&amp;gt;tomcat&amp;lt;/id&amp;gt;
             &amp;lt;username&amp;gt;admin&amp;lt;/username&amp;gt;
             &amp;lt;password&amp;gt;admin&amp;lt;/password&amp;gt;
         &amp;lt;/server&amp;gt;
   &amp;lt;/servers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;pom.xml 配置&lt;/p&gt;

        &lt;p&gt;添加编译 tomcat 插件&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &amp;lt;build&amp;gt;
     &amp;lt;finalName&amp;gt;hello&amp;lt;/finalName&amp;gt;
     &amp;lt;plugins&amp;gt;
         &amp;lt;plugin&amp;gt;
             &amp;lt;groupId&amp;gt;org.codehaus.mojo&amp;lt;/groupId&amp;gt;
             &amp;lt;artifactId&amp;gt;tomcat-maven-plugin&amp;lt;/artifactId&amp;gt;
             &amp;lt;version&amp;gt;1.0-beta-1&amp;lt;/version&amp;gt;
             &amp;lt;configuration&amp;gt;
                 &amp;lt;url&amp;gt;http://localhost:8080/manager/text&amp;lt;/url&amp;gt;
                 &amp;lt;server&amp;gt;tomcat&amp;lt;/server&amp;gt;
             &amp;lt;/configuration&amp;gt;
         &amp;lt;/plugin&amp;gt;
     &amp;lt;/plugins&amp;gt;
 &amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;清除、编译、测试、打包、安装本地仓库、发布远程仓库、部署 tomcat 服务器&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 项目右键/run as/maven build.../goals:clean compile test package install deploy site/run
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Jenkins+git+maven+junit 二</title>
   <link href="http://www.blogways.net/blog/2013/04/23/jenkins-git-maven-junit-2.html"/>
   <updated>2013-04-23T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/23/jenkins-git-maven-junit-2</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;对于可持续集成描述及Jenkins介绍及安装在前面文档中有所介绍，本文就不做说明，本文只介绍如何实现Jenkins如何自动取git上web工程代码，maven实现编译及打包，最后Jenkins负责将war包发布到tomcat中&lt;/p&gt;

&lt;h3 id=&quot;二jenkins配置及使用&quot;&gt;二、Jenkins配置及使用&lt;/h3&gt;

&lt;p&gt;tomcat中tomcat-users.xml文件添加如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;role rolename=&quot;manager-gui&quot;/&amp;gt;
&amp;lt;role rolename=&quot;manager-script&quot;/&amp;gt;   
&amp;lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,
 manager-script&quot;/&amp;gt;   更改git仓库中pom.xml 文件，添加如下内容：

&amp;lt;plugin&amp;gt;
     &amp;lt;groupId&amp;gt;org.apache.tomcat.maven&amp;lt;/groupId&amp;gt;
     &amp;lt;artifactId&amp;gt;tomcat6-maven-plugin&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.0&amp;lt;/version&amp;gt;
      &amp;lt;configuration&amp;gt;
			&amp;lt;url&amp;gt;http://localhost:8080/manager&amp;lt;/url&amp;gt;
			&amp;lt;server&amp;gt;tomcat&amp;lt;/server&amp;gt;
			&amp;lt;!--  &amp;lt;uriEncoding&amp;gt;utf-8&amp;lt;/uriEncoding&amp;gt; --&amp;gt;
    		&amp;lt;warSourceDirectory&amp;gt;WebContent&amp;lt;/warSourceDirectory&amp;gt; 
			
	  &amp;lt;/configuration&amp;gt;
&amp;lt;/plugin&amp;gt; Maven安装目录下settings.xml文件添加如下：

  &amp;lt;server&amp;gt;
	&amp;lt;id&amp;gt;tomcat&amp;lt;/id&amp;gt;
	&amp;lt;username&amp;gt;tomcat&amp;lt;/username&amp;gt;
	&amp;lt;password&amp;gt;tomcat&amp;lt;/password&amp;gt;
  &amp;lt;/server&amp;gt;    其中&amp;lt;id&amp;gt;tomcat&amp;lt;/id&amp;gt; 与pom.xml 文件中&amp;lt;server&amp;gt;tomcat&amp;lt;/server&amp;gt; 要一致
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进入“系统管理”-&amp;gt;“插件管理”&lt;/p&gt;

    &lt;p&gt;1.选择“可选插件”tab页，找到“Deploy to container Plugin”插件并安装，为
   Jenkins部署tomcat工程所用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;回到Jenkins首页，点击“新Job”，输入job名称如：MavenWeb，选择“构建一个maven2/3项目”&lt;/li&gt;
  &lt;li&gt;选择任务“MavenWeb”，点击“配置”进入任务配置界面，源代码管理中选择git,并输入仓库路径如：/home/git/MavenWeb/mytest，Branches to build根据自己需要输入，这里我取得主分支代码，输入的为master&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;“构建触发器”选择项下我选择的为“Poll SCM”，含义为在指定作业时间内有代码更新的时候去取代码，这里”Build periodically“含义为不管是否有代码更新在指定作业时间内都去取代码，”Build whenever a SNAPSHOT dependency is built“含义为当构建成功后，项目jar包会发到maven二方库上去
-”日程表“我这里配的是&lt;em&gt;/1 * * * *，代表每隔一分钟取一次，这里五个 * 号从左到右分别
分 时 日 月 年，相同 * 号段内用”,“号隔开，如：&lt;/em&gt; * 8,20 * * *含义为每天8点、20点取代码
-”构建后操作“Editable Email NOtification” 其中Project Recipient List
 可以配置收件人信箱，点击“高级”，“Add a Trigger”中可以选择对应触发器，我这里用到了构建失败(Failure),和测试报错(系统不稳定Unstable)两项，收件人选择了“Send To Recipient List”和提交者“Send To Committers”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;“Deploy war/ear to a container” 中“WAR/EAR files”输入target/mytest.war，“Context path”输入MyApp（为项目访问contextPath），“Container”我这里用的tomcat6，所以选择tomcat6，“Tomcat URL”中输入tomcat访问地址如：http://192.168.4.19:8001&lt;/li&gt;
  &lt;li&gt;git上建立仓库将本地现有Maven+junit web项目push到git仓库，打开Jenkins主页进入MavenPrj任务，几分钟后就能看到构建任务及结果，&lt;/li&gt;
  &lt;li&gt;构建成功后输入http://192.168.4.19:8001/MyApp即可访问项目首页&lt;/li&gt;
&lt;/ul&gt;
</content>
 </entry>
 
 <entry>
   <title>Nexus 环境搭建</title>
   <link href="http://www.blogways.net/blog/2013/04/22/nexus.html"/>
   <updated>2013-04-22T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/22/nexus</id>
   <content type="html">&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;下载：http://nexus.sonatype.org/downloads/&lt;/p&gt;

&lt;p&gt;解压到服务器上&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;unix 启动：&lt;/p&gt;

    &lt;p&gt;目录：./nexus-2.3.1-01-bundle/nexus-2.3.1-01/bin/jsw/linux-x86-64&lt;/p&gt;

    &lt;p&gt;启动 nexus 服务：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [spdev@slave2 linux-x86-64]$ sh nexus start
 	Starting Nexus OSS... 
 	Started Nexus OSS
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;从控制台可以看到 nexus 已经启动成功，可以在浏览器中访问&lt;/p&gt;

    &lt;p&gt;http://192.168.4.19:8081/nexus/index.html#view-repositories&lt;/p&gt;

    &lt;p&gt;login：admin/admin123&lt;/p&gt;

    &lt;p&gt;里面自带一些已经创建好的仓库供参考&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;window 启动：&lt;/p&gt;

    &lt;p&gt;目录：\nexus-2.3.1-01-bundle\nexus-2.3.1-01\bin\jsw\windows-x86-64&lt;/p&gt;

    &lt;p&gt;启动 nexus 服务:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; start-nexus.bat
 wrapper  | The nexus service is already running with status: RUNNING
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;访问同上，nexus 默认端口是 8081 ，如果有冲突可以在 \nexus-2.3.1-01-bundle\nexus-2.3.1-01\conf\nexus.properties 配置文件里面修改&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;创建我们自己的仓库&quot;&gt;创建我们自己的仓库&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建主机仓库&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Add/Hosted Repository
 Repository ID: Sphost
 Repository Name: SP Host
 Repository Policy: Release
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建代理仓库&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Add/Proxy Repository
 Repository ID: spproxy
 Repository Name: SP Proxy
 Remote Storage Location: http://repo1.maven.org/maven2/
 Download remote indexes: true
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建快照仓库&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Add/Hosted Repository
 Repository ID: Spsnap
 Repository Name: SP Snap
 Repository Policy: snapshot
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建仓库组&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; add/Repository Group
 Group ID:spgroup
 Group Name: SP Group
 Publish URL: TRUE
 Ordered group repositories: SP Host、SP Proxy、SP Snap
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;每个仓库后面都对应一个 repository path，这个地址在配 maven 的 setting.xml 跟项目的 pom.xml 文件里面的地址要对应上，否则会下载不走主机仓库或者没法发布到主机仓库。由于现在主机连不上网，代理仓库无法连到网上下载，本地maven从代理仓库下不了的时候会默认自动从中心库上下载所需要的jar包。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</content>
 </entry>
 
 <entry>
   <title>windows 下安装jekyll</title>
   <link href="http://www.blogways.net/blog/2013/04/18/install-jekyll-on-windows.html"/>
   <updated>2013-04-18T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/18/install-jekyll-on-windows</id>
   <content type="html">&lt;h3 id=&quot;一ruby安装&quot;&gt;一、ruby安装&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;下载 &lt;a href=&quot;http://www.ruby-lang.org/en/&quot;&gt;ruby&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;配置环境变量，path中添加ruby安装环境变量&lt;/li&gt;
  &lt;li&gt;执行 ruby –version 检查ruby是否安装成功&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;二devkit&quot;&gt;二、DevKit&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;下载 &lt;a href=&quot;https://github.com/oneclick/rubyinstaller/downloads/&quot;&gt;DevKit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;解压DevKit，命令行下到DevKit目录，执行ruby dk.rb init    ruby dk.rb install&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三安装jekyll&quot;&gt;三、安装jekyll&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;执行gem install jekyll&lt;/li&gt;
  &lt;li&gt;执行gem install rdiscount&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;打开命令窗口到博客工程根目录下执行jekyll –server，如果此处报字符集错误，请先设置环境变量执行
set LC_ALL=en_US.UTF-8，set  LANG=en_US.UTF-8，2.0及以后版本此方法不行，需修将ruby安装
目录下lib\ruby\gems\2.0.0\gems\jekyll-1.2.0\lib\jekyll下convertible.rb文件中
self.content = File.read(File.join(base, name))改为
self.content = File.read(File.join(base, name), :encoding =&amp;gt; “utf-8”)，lib\ruby\gems\2.0.0\gems\jekyll-1.2.0\lib\jekyll\tags下include.rb文件中
source = File.read(File.join(includes_dir, @file))改为
source = File.read(File.join(includes_dir, @file), :encoding =&amp;gt; “utf-8”)，然后再执行jekyll –server&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;服务启动成功后，在浏览器访问&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:4000&lt;/code&gt;，显示博客列表&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>Jenkins+git+maven+junit 一</title>
   <link href="http://www.blogways.net/blog/2013/04/17/jenkins-git-maven-junit.html"/>
   <updated>2013-04-17T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/17/jenkins-git-maven-junit</id>
   <content type="html">&lt;h3 id=&quot;一持续集成概述&quot;&gt;一、持续集成概述&lt;/h3&gt;
&lt;p&gt;随着软件开发复杂度的不断提高，团队开发成员间如何更好地协同工作以确保软件开发的质量已经慢慢成为开发过程中不可回避的问题。尤其是近些年来，敏捷（Agile） 在软件工程领域越来越红火，如何能再不断变化的需求中快速适应和保证软件的质量也显得尤其的重要。
持续集成正是针对这一类问题的一种软件开发实践。它倡导团队开发成员必须经常集成他们的工作，甚至每天都可能发生多次集成。而每次的集成都是通过自动化的构建来验证，包括自动编译、发布和测试，从而尽快地发现集成错误，让团队能够更快的开发内聚的软件。
持续集成的核心价值在于：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.持续集成中的任何一个环节都是自动完成的，无需太多的人工干预，有利于减少重复过程以节省时间、
  费用和工作量；
2.持续集成保障了每个时间点上团队成员提交的代码是能成功集成的。换言之，任何时间点都能第一时
  间发现软件的集成问题，使任意时间发布可部署的软件成为了可能；
3.持续集成还能利于软件本身的发展趋势，这点在需求不明确或是频繁性变更的情景中尤其重要，持
  续集成的质量能帮助团队进行有效决策，同时建立团队对开发产品的信心。 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二持续集成的原则&quot;&gt;二、持续集成的原则&lt;/h3&gt;

&lt;p&gt;业界普遍认同的持续集成的原则包括：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.需要版本控制软件保障团队成员提交的代码不会导致集成失败。常用的版本控制软件有 CVS、
  Subversion、git 等，本文中用的是git；
2.开发人员必须及时向版本控制库中提交代码，也必须经常性地从版本控制库中更新代码到本地；
3.需要有专门的集成服务器来执行集成构建。根据项目的具体实际，集成构建可以被软件的修改来
  直接触发，也可以定时启动，如每半个小时构建一次；
4.必须保证构建的成功。如果构建失败，修复构建过程中的错误是优先级最高的工作。一旦修复，
  需要手动启动一次构建。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三持续集成系统的组成&quot;&gt;三、持续集成系统的组成&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.一个自动构建过程，包括自动编译、分发、部署和测试等，本文中用的是maven+junit。 
2.一个代码存储库，即需要版本控制软件来保障代码的可维护性，同时作为构建过程的素材库，
  本文中用的是git。 
3.一个持续集成服务器。本文中用到的是jenkins。 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四jenkins简介及安装&quot;&gt;四、Jenkins简介及安装&lt;/h3&gt;
&lt;p&gt;git、maven、junit本博客其他篇章中都有所介绍，所以今天我们主要介绍Jenkins的应用：
Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，
专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文
件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;下载Jenkins，&lt;a href=&quot;http://jenkins-ci.org/&quot;&gt;http://jenkins-ci.org/ &lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Jenkins 安装：本文介绍安装在linux主机上通过命令行安装&lt;/p&gt;

    &lt;p&gt;1.将下载的jenkins.war文件上传到linux主机安装目录下
     如：/home/spdev
  2.执行java -jar jenkins.war
  3.打开ie输入地址 http://hoestname:8080 （hostname为主机  ip）即能访问Jenkins,如自己设定端口可执行：java -jar jenkins.war –httpPort= port&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;五jenkins配置及使用&quot;&gt;五、Jenkins配置及使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;进入“系统管理”-&amp;gt;“插件管理”&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1.选择“已安装”tab页查看发下maven插件已经安装，git、junit插件没有安装
  2.选择“可选插件”tab页，在Filter输入框输入git，过滤条件后将git相关插件安装，同样
     操作安装junit插件
  3.选择“可选插件”tab页，找到“Jenkins Email Extension Plugin”插件并安装，此插件
     是后面发布及测试法邮件使用
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进入“系统管理”-&amp;gt;“系统设置”&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  1.选择“JDK”安装，定义别名，JAVA_HOME输入JDK安装目录
  2.选择“Git”安装，定义别名，安装目录输入Git安装目录
  3.选择“Maven”安装，定义别名，安装目录输入MAVEN_HOME安装目录
  4.“System Admin e-mail address”输入系统管理员邮箱地址
  5.“Extended E-mail Notification”标签为插件“Jenkins Email Extension Plugin“里
      内容，为邮件通知设置，这里我的配置如下图： &amp;lt;img src=&quot;/images/post/jenkins-setting.jpg&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;image&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;回到Jenkins首页，点击“新Job”，输入job名称如：MavenPrj，选择“构建一个maven2/3项目”&lt;/li&gt;
  &lt;li&gt;选择任务“MavenPrj”，点击“配置”进入任务配置界面，源代码管理中选择git,并输入仓库路径如：/home/git/MavenPrj/mytest，Branches to build根据自己需要输入，这里我取得主分支代码，输入的为master&lt;/li&gt;
  &lt;li&gt;“构建触发器”选择项下我选择的为“Poll SCM”，含义为在指定作业时间内有代码更新的时候去取代码，这里”Build periodically“含义为不管是否有代码更新在指定作业时间内都去取代码，”Build whenever a SNAPSHOT dependency is built“含义为当构建成功后，项目jar包会发到maven二方库上去&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;”日程表“我这里配的是&lt;em&gt;/1 * * * *，代表每隔一分钟取一次，这里五个 * 号从左到右分别
分 时 日 月 年，相同 * 号段内用”,“号隔开，如：&lt;/em&gt; * 8,20 * * *含义为每天8点、20点取代码
-”构建后操作“Editable Email NOtification” 其中Project Recipient List
 可以配置收件人信箱，点击“高级”，“Add a Trigger”中可以选择对应触发器，我这里用到了构建失败(Failure),和测试报错(系统不稳定Unstable)两项，收件人选择了“Send To Recipient List”和提交者“Send To Committers”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;git上建立仓库将本地现有Maven+junit java项目push到git仓库，打开Jenkins主页进入MavenPrj任务，几分钟后就能看到构建任务及测试结果了，下面是构建完的效果图：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/post/jenkins-setting2.jpg&quot; width=&quot;400&quot; height=&quot;300&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶五</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-5.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-5</id>
   <content type="html">&lt;p&gt;在&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;中，我们介绍了&lt;code class=&quot;highlighter-rouge&quot;&gt;@Rule&lt;/code&gt;的两个用法，对异常进行检查和对超时时间的设定。其实，Rule还有很多用途，本文将做进一步介绍。&lt;/p&gt;

&lt;h3 id=&quot;rule的应用&quot;&gt;Rule的应用&lt;/h3&gt;

&lt;p&gt;Rule将在框架的很多方面提供解决方案。下面一一举例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TemporaryFolder&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TemporaryFolder&lt;/code&gt;作为Rule，可以运行在测试过程中创建临时文件或者临时目录，当测试结束后，框架会自动删除。&lt;/p&gt;

    &lt;p&gt;见实例：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   public static class HasTempFolder {
   @Rule
   public TemporaryFolder folder = new TemporaryFolder();
    
   @Test
   public void testUsingTempFolder() throws IOException {
     File createdFile = folder.newFile(&quot;myfile.txt&quot;);
     File createdFolder = folder.newFolder(&quot;subfolder&quot;);
     // ...
   }
 } 
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TemporaryFolder#newFolder(String... folderNames)&lt;/code&gt;可以根据输入的参数创建目录。如果是多级目录，可以递归创建。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TemporaryFolder#newFile()&lt;/code&gt;可以创建一个随机名字的临时文件；&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TemporaryFolder##newFolder()&lt;/code&gt; 可以创建一个随机名字的临时目录。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ExternalResource&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExternalResource&lt;/code&gt;可以设置测试前后需要做的事情（比如：文件、socket、服务、数据库的连接与关闭）。这个我们在之前的&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;中稍有提及。&lt;/p&gt;

    &lt;p&gt;见实例：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public static class UsesExternalResource {
   Server myServer = new Server();
      
   @Rule
   public ExternalResource resource = new ExternalResource() {
     @Override
     protected void before() throws Throwable {
       myServer.connect();
     };
        
     @Override
     protected void after() {
       myServer.disconnect();
     };
   };
      
   @Test
   public void testFoo() {
     new Client().run(myServer);
   }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ExternalResource#before&lt;/code&gt;会在每个测试之前处理；&lt;code class=&quot;highlighter-rouge&quot;&gt;#after&lt;/code&gt;会在每个测试之后处理；&lt;/li&gt;
      &lt;li&gt;关于&lt;code class=&quot;highlighter-rouge&quot;&gt;ExternalResource&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;@Before&lt;/code&gt;已经&lt;code class=&quot;highlighter-rouge&quot;&gt;@After&lt;/code&gt;等标记步骤的执行顺序，我们会在本文后面部分介绍。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ErrorCollector&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ErrorCollector&lt;/code&gt;这个Rule，在出现一个错误后，还可以让测试继续进行下去。&lt;/p&gt;

    &lt;p&gt;他提供三个方法：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; checkThat(final T value, Matcher&amp;lt;T&amp;gt; matcher)
 checkSucceeds(Callable&amp;lt;Object&amp;gt; callable)
 addError(Throwable error)
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;前面两个是用来处理断言的，最后一个是添加错误至错误列表中。&lt;/p&gt;

    &lt;p&gt;看下面例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; package mytest;
    
 import static org.hamcrest.CoreMatchers.is;
 import static org.junit.Assert.assertThat;
     
 import java.util.concurrent.Callable;
     
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ErrorCollector;
     
 public class JUnitCoreErrorControllerRuleTest {
     
   private final int multiplesOf2[] = { 0, 2, 4, 7, 8, 11, 12 };
     
   @Rule
   public ErrorCollector errorCollector = new ErrorCollector();
     
   /*
    * 下面这个测试，会报告两个failures。这一点和下面的checkSucceeds测试不同
    */
   @Test
   public void testMultiplesOf2() {
     int multiple = 0;
     for (int multipleOf2 : multiplesOf2) {
       // Will count the number of issues in this list
       // - 3*2 = 6 not 7, 5*2 = 10 not 11 : 2 Failures
       errorCollector.checkThat(2 * multiple, is(multipleOf2));
       multiple++;
     }
   }
     
   /*
    * 下面代码中有两个断言会失败，但每次运行JUnit框架只会报告一个。这一点和上面的checkThat测试不同，可以对比一下。
    */
   @Test
   public void testCallableMultiples() {
     errorCollector.checkSucceeds(new Callable&amp;lt;Object&amp;gt;() {
       public Object call() throws Exception {
         assertThat(2 * 2, is(5));
         assertThat(2 * 3, is(6));
         assertThat(2 * 4, is(8));
         assertThat(2 * 5, is(9));
         return null;
       }
     });
   }
     
   /*
    * 下面运行时，会报告2个错误
    */
   @Test
   public void testAddingAnError() {
     assertThat(2 * 2, is(4));
     errorCollector.addError(new Throwable(&quot;Error Collector added an error&quot;));
     assertThat(2 * 3, is(6));
     errorCollector.addError(new Throwable(
         &quot;Error Collector added a second error&quot;));
   }
     
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;运行结果，类似下面：&lt;/p&gt;

 	Failed tests: 

 	testCallableMultiples(mytest.JUnitCoreErrorControllerRuleTest): 
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Expected: is &amp;lt;5&amp;gt;
  		but: was &amp;lt;4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

  		testMultiplesOf2(mytest.JUnitCoreErrorControllerRuleTest): 
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Expected: is &amp;lt;7&amp;gt;
 		but: was &amp;lt;6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

  		testMultiplesOf2(mytest.JUnitCoreErrorControllerRuleTest): 
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	Expected: is &amp;lt;11&amp;gt;
 		but: was &amp;lt;10&amp;gt;
 		
 	Tests in error: 
  		testAddingAnError(tangzhi.mytest.JUnitCoreErrorControllerRuleTest): Error Collector added an error
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

  		testAddingAnError(tangzhi.mytest.JUnitCoreErrorControllerRuleTest): Error Collector added a second error

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;从这个例子，可以看出：

* `ErrorCollector#checkThat` 会报告测试中的每一个failures
* `ErrorCollector#checkSucceeds` 只会检查是否成功，如果不成功，只报告第一个导致不成功的failure
* `ErrorCollector#addError` 是添加一个错误(error)。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Verifier&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果，你想在每个测试之后，甚至是在&lt;code class=&quot;highlighter-rouge&quot;&gt;@After&lt;/code&gt;之后，想检查些什么，就可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Verifier&lt;/code&gt;这个Rule.&lt;/p&gt;

    &lt;p&gt;看例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; private static String sequence;
    
 public static class UsesVerifier {
   @Rule
   public Verifier collector = new Verifier() {
       @Override
       protected void verify() {
           sequence += &quot; verify &quot;;
       }
   };
    
   @Test
   public void example() {
       sequence += &quot;test&quot;;
   }
      
   @Test
   public void example2() {
       sequence += &quot;test2&quot;;
   }
      
   @After
   public void after() {
 	  sequence += &quot; after&quot;;
   }
 }
    
 @Test
 public void verifierRunsAfterTest() {
   sequence = &quot;&quot;;
   assertThat(testResult(UsesVerifier.class), isSuccessful());
   assertEquals(&quot;test after verify test2 after verify &quot;, sequence);
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;从上面例子可以看出:&lt;code class=&quot;highlighter-rouge&quot;&gt;Verifier#verify&lt;/code&gt;针对每个测试都会运行一次，并且运行在&lt;code class=&quot;highlighter-rouge&quot;&gt;@After&lt;/code&gt;步骤之后。&lt;/p&gt;

    &lt;p&gt;需要说明：如果某测试出现失败(fail)，那么这个测试之后就不会做&lt;code class=&quot;highlighter-rouge&quot;&gt;verify&lt;/code&gt;,这一点，可以结合下面的例子看出。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TestWatcher&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;对测试的每个步骤进行监控。&lt;/p&gt;

    &lt;p&gt;看例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; package tangzhi.mytest;
    
 import static org.junit.Assert.*;  
 import static org.hamcrest.CoreMatchers.*;
    
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.TestRule;
 import org.junit.rules.TestWatcher;
 import org.junit.rules.Verifier;
 import org.junit.runner.Description;
 import org.junit.runners.model.Statement;
    
 public class WatchmanTest {
 	private static String watchedLog;
    
 	  @Rule
 	  public TestRule watchman = new TestWatcher() {
 	    @Override
 	    public Statement apply(Statement base, Description description) {
 	    	Statement s = super.apply(base, description);
 	    	watchedLog=&quot;&quot;;
 	    	System.out.println(&quot;watch apply.&quot;);
 	    	return s;
 	    }
    
 	    @Override
 	    protected void succeeded(Description description) {
 	    	watchedLog += description.getDisplayName() + &quot; &quot; + &quot;success!&quot;;
 	    	System.out.println(&quot;watch succeed:&quot;+watchedLog);
    	    	
 	    }
    
 	    @Override
 	    protected void failed(Throwable e, Description description) {
 	    	watchedLog += description.getDisplayName() + &quot; &quot; + e.getClass().getSimpleName();
 	    	System.out.println(&quot;watch failed:&quot;+watchedLog);
    	    	
 	    }
    
 	    @Override
 	    protected void starting(Description description) {
 	      super.starting(description);
 	      System.out.println(&quot;watch starting.&quot;);
 	    }
    
 	    @Override
 	    protected void finished(Description description) {
 	      super.finished(description);
 	      System.out.println(&quot;watch finished.&quot;);
 	    }
 	  };
    	  
 	  @Rule
       public Verifier collector = new Verifier() {
           @Override
           protected void verify() {
         	  System.out.println(&quot;@Verify:&quot;+watchedLog);
           }
 	  };
    
 	  @Test
 	  public void fails() {
 		  System.out.println(&quot;in fails&quot;);
 		  assertThat(&quot;ssss&quot;, is(&quot;sss&quot;));
 	  }
    
 	  @Test
 	  public void succeeds() {
 		  System.out.println(&quot;in succeeds&quot;);
 	  }
    	  
 	  @After
 	  public void after() {
 		  System.out.println(&quot;@After&quot;);
 	  }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;运行后，日志如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; watch apply.
 watch starting.
 in succeeds
 @After
 watch succeed:succeeds(tangzhi.mytest.WatchmanTest) success!
 watch finished.
 @Verify:succeeds(tangzhi.mytest.WatchmanTest) success!
 watch apply.
 watch starting.
 in fails
 @After
 watch failed:fails(tangzhi.mytest.WatchmanTest) AssertionError
 watch finished.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;TestName&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TestName&lt;/code&gt;可以获取当前测试方法的名字。&lt;/p&gt;

    &lt;p&gt;看例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; public class NameRuleTest {
   @Rule
   public TestName name = new TestName();
      
   @Test
   public void testA() {
     assertEquals(&quot;testA&quot;, name.getMethodName());
   }
      
   @Test
   public void testB() {
     assertEquals(&quot;testB&quot;, name.getMethodName());
   }
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;如果，是在参数化测试(Parameterized)中，使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;@Parameters&lt;/code&gt;，那么其&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;属性定义的方法名也将会被&lt;code class=&quot;highlighter-rouge&quot;&gt;TestName#getMethodName&lt;/code&gt;获取。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Timeout&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个我们在前面介绍过，可以设置某个测试类，所有测试方法的超时时间。详见&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ExpectedException&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个也在&lt;a href=&quot;junit-usage-2.html&quot;&gt;进阶二&lt;/a&gt;中有介绍。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ClassRule&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;注释&lt;code class=&quot;highlighter-rouge&quot;&gt;@ClassRule&lt;/code&gt;是类级别的，而不是方法级别的。&lt;/p&gt;

    &lt;p&gt;见下面例子：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; @RunWith(Suite.class)
 @SuiteClasses({A.class, B.class, C.class})
 public class UsesExternalResource {
   public static Server myServer= new Server();
    
   @ClassRule
   public static ExternalResource resource= new ExternalResource() {
     @Override
     protected void before() throws Throwable {
       myServer.connect();
     };
    
     @Override
     protected void after() {
       myServer.disconnect();
     };
   };
 }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;在Suite所打包的几个类测试前后，会执行一遍&lt;code class=&quot;highlighter-rouge&quot;&gt;ClassRule&lt;/code&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RuleChain&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

 	见例子：

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	public static class UseRuleChain {
        @Rule
        public TestRule chain= RuleChain
                               .outerRule(new LoggingRule(&quot;outer rule&quot;)
                               .around(new LoggingRule(&quot;middle rule&quot;)
                               .around(new LoggingRule(&quot;inner rule&quot;);
    
        @Test
        public void example() {
            assertTrue(true);
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

 	执行后，日志如下：

 	    starting outer rule
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    starting middle rule
    starting inner rule
    finished inner rule
    finished middle rule
    finished outer rule
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶四</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-4.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-4</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Suite测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;Parameterized测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;Categories测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;Theories测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;第三方的Runner&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;a href=&quot;junit-usage-1.html&quot;&gt;进阶一&lt;/a&gt;，我们介绍了默认的JUnit4默认的运行器是&lt;code class=&quot;highlighter-rouge&quot;&gt;JUnit4&lt;/code&gt;。本文，我们将继续向大家介绍JUnit4框架提供的另外几个非常实用的运行器(Runner)：&lt;code class=&quot;highlighter-rouge&quot;&gt;Suite&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Parameterized&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Categories&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Enclosed&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Theories&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在测试中，可以使用注释&lt;code class=&quot;highlighter-rouge&quot;&gt;@RunWith&lt;/code&gt;来指定这些运行器，比如:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class MyTest { …
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好吧，下面我们来一一介绍吧！&lt;/p&gt;

&lt;h3 id=&quot;一suite测试&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、Suite测试&lt;/h3&gt;

&lt;p&gt;进行&lt;code class=&quot;highlighter-rouge&quot;&gt;Suite&lt;/code&gt;测试可以将多个待测试的类，打包(Suite)一起测试。在入口测试类上加两个注释:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Suite.class)
@SuiteClasses(TestClass1.class, ...)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当你运行这个入口测试类，框架就会把打包在一起的所有待测试类都测试一遍。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import org.junit.runner.RunWith;
import org.junit.runners.Suite;

@RunWith(Suite.class)
@Suite.SuiteClasses({
  		TestFeatureLogin.class,
	TestFeatureLogout.class,
  		TestFeatureNavigate.class,
  		TestFeatureUpdate.class
})

public class FeatureTestSuite {
  // the class remains empty,
  // used only as a holder for the above annotations
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;框架运行那些待测试的类，是按他们在&lt;code class=&quot;highlighter-rouge&quot;&gt;@Suite.SuiteClasses&lt;/code&gt;中罗列的顺序开始测试。&lt;/p&gt;

&lt;h3 id=&quot;二parameterized测试&quot;&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、Parameterized测试&lt;/h3&gt;

&lt;p&gt;很多时候，需要用很多测试数据进行多次测试。怎么办？通过复制粘贴代码来实现？累…&lt;/p&gt;

&lt;p&gt;针对这种情况，JUnit4框架提供&lt;code class=&quot;highlighter-rouge&quot;&gt;Parameterized&lt;/code&gt;测试器(&lt;code class=&quot;highlighter-rouge&quot;&gt;Runner&lt;/code&gt;)来实现这种需求。&lt;/p&gt;

&lt;p&gt;看下面这个例子:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package mytest;

import static org.junit.Assert.*;

import java.util.Arrays;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Iterable&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },
                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }
    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;很简单，很方便是吧！&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Parameters&lt;/code&gt;来标记，我们为测试准备的数据&lt;/li&gt;
  &lt;li&gt;定义一个构造函数，构造函数的参数顺序和准备数据的顺序一致&lt;/li&gt;
  &lt;li&gt;写你需要的测试方法，用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Test&lt;/code&gt;注释&lt;/li&gt;
  &lt;li&gt;运行起来，每个数据都会测试一遍&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果，你不习惯去写那样一个构造函数，也可以用下面的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters
    public static Iterable&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 2 },
                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });
    }

    @Parameter(0)
    public int fInput;

    @Parameter(1)
    public int fExpected;

    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行起来是不是很爽！&lt;/p&gt;

&lt;p&gt;可能，你是一个完美主义者，对运行后报错信息不是很满意，现在报错时反馈的信息可能是这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test[3](mytest.FibonacciTest): expected:&amp;lt;2&amp;gt; but was:&amp;lt;0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你想报错时显示测试的输入数据，希望报错类似如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;test[the 3 test, input:3,2](mytest.FibonacciTest): expected:&amp;lt;2&amp;gt; but was:&amp;lt;0&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;要实现这点很简单，给&lt;code class=&quot;highlighter-rouge&quot;&gt;@Parameters&lt;/code&gt;加个参数&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;，整个代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package mytest;

import static org.junit.Assert.*;

import java.util.Arrays;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.junit.runners.Parameterized.Parameters;

@RunWith(Parameterized.class)
public class FibonacciTest {
    @Parameters(name=&quot;the {index} test, input:{0},{1}&quot;)
    public static Iterable&amp;lt;Object[]&amp;gt; data() {
        return Arrays.asList(new Object[][] { { 0, 0 }, { 1, 1 }, { 2, 1 },
                { 3, 2 }, { 4, 3 }, { 5, 5 }, { 6, 8 } });
    }

    private int fInput;

    private int fExpected;

    public FibonacciTest(int input, int expected) {
        fInput= input;
        fExpected= expected;
    }
    @Test
    public void test() {
        assertEquals(fExpected, Fibonacci.compute(fInput));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这里需要稍微解释一下&lt;code class=&quot;highlighter-rouge&quot;&gt;name&lt;/code&gt;中的几个参数的含义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表示序号，测试数据在整个数据列表中的序号&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表示第一个参数&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表示第二个参数&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;...&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;表示第n+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;个参数&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三categories测试&quot;&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、Categories测试&lt;/h3&gt;

&lt;p&gt;一个测试类里面包含很多待测试的方法，很多时候，我们需要把这些待测试的方法分类，某些时候测试某类方法，那么需要怎么做呢？&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface FastTests { /* category marker */ }
public interface SlowTests { /* category marker */ }

public class A {
  @Test
  public void a() {
    fail();
  }

  @Category(SlowTests.class)
  @Test
  public void b() {
  }
}

@Category({SlowTests.class, FastTests.class})
public class B {
  @Test
  public void c() {

  }
}

@RunWith(Categories.class)
@IncludeCategory(SlowTests.class)
@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite
public class SlowTestSuite {
  // Will run A.b and B.c, but not A.a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的例子中，将会测试&lt;code class=&quot;highlighter-rouge&quot;&gt;A.b&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;B.c&lt;/code&gt;两个方法，不会测试&lt;code class=&quot;highlighter-rouge&quot;&gt;A.a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;再看下面：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Categories.class)
@IncludeCategory(SlowTests.class)
@ExcludeCategory(FastTests.class)
@SuiteClasses( { A.class, B.class }) // Note that Categories is a kind of Suite
public class SlowTestSuite {
  // Will run A.b, but not A.a or B.c
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这次，只会运行&lt;code class=&quot;highlighter-rouge&quot;&gt;A.b&lt;/code&gt;，而不会运行&lt;code class=&quot;highlighter-rouge&quot;&gt;A.a&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;B.c&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;四theories测试&quot;&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、Theories测试&lt;/h3&gt;

&lt;p&gt;结合前面&lt;a href=&quot;junit-usage-3.html&quot;&gt;进阶三&lt;/a&gt;中介绍的假设(assumeThat)，我们可以对大量的测试数据做一些理论测试。&lt;/p&gt;

&lt;p&gt;先看例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@RunWith(Theories.class)
public class UserTest {
    @DataPoint
    public static String GOOD_USERNAME = &quot;optimus&quot;;
    @DataPoint
    public static String USERNAME_WITH_SLASH = &quot;optimus/prime&quot;;

    @Theory
    public void filenameIncludesUsername(String username) {
        assumeThat(username, not(containsString(&quot;/&quot;)));
        assertThat(new User(username).configFileName(), containsString(username));
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是看得有点苦涩难懂，没关系，我来给你一一讲解：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@RunWith(Theories.class)&lt;/code&gt; 是告诉框架，下面的测试类将要做理论测试；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@DataPoint&lt;/code&gt; 告诉框架，标注的这些数据都是准备用来测试的数据；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Theory&lt;/code&gt;标注的方法，是需要进行理论测试的方法；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assumeThat&lt;/code&gt; 是对待测试的数据(&lt;code class=&quot;highlighter-rouge&quot;&gt;@DataPoint&lt;/code&gt;标注的数据)进行检查，符合的数据继续往下走，不符合的数据忽略掉.如果，所有的数据都不符合，那么&lt;code class=&quot;highlighter-rouge&quot;&gt;@Theory&lt;/code&gt;标注的测试，则算失败(fail)。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;关于理论测试，也可以扩展更多的功能，网上已经有人做了一些扩展，比如&lt;a href=&quot;http://web.archive.org/web/20071012143326/popper.tigris.org/tutorial.html&quot;&gt;这里&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;五第三方的runner&quot;&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、第三方的Runner&lt;/h3&gt;

&lt;p&gt;我们也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;@RunWith&lt;/code&gt;来标注一些第三方的Runner，比如：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;SpringJUnit4ClassRunner&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/test/context/junit4/SpringJUnit4ClassRunner.html&quot;&gt;http://static.springsource.org/spring/docs/3.0.x/javadoc-api/org/springframework/test/context/junit4/SpringJUnit4ClassRunner.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MockitoJUnitRunner&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://docs.mockito.googlecode.com/hg/latest/org/mockito/runners/MockitoJUnitRunner.html&quot;&gt;http://docs.mockito.googlecode.com/hg/latest/org/mockito/runners/MockitoJUnitRunner.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;六小结&quot;&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;六、小结&lt;/h3&gt;

&lt;p&gt;让我们回顾一下，本文介绍了JUnit4里面内置的几个特色运行器（Runner），包括：将多个测试类打包一起测试的Suite、可以实现参数化测试的Parameterized、可以实现分类测试的Categories、可以实现理论测试的Theories，还有网络上的一些第三方Runner。&lt;/p&gt;

&lt;p&gt;根据实际情况的需要，合理的利用这些Runner，可以达到事半功倍的效果。&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶三</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-3.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-3</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;不得不说的`assertThat`方法&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;还有个`assumeThat`方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;a href=&quot;junit-usage-1.html&quot;&gt;JUnit4 使用进阶一&lt;/a&gt;中，我们介绍了JUnit4中断言的基本用法，在本文我们要做深入的介绍。当前JUnit4框架已经引入了 Hamcrest 匹配机制，使得程序员在编写单元测试的 assert 语句时，可以具有更强的可读性，而且也更加灵活。&lt;/p&gt;

&lt;h3 id=&quot;一不得不说的assertthat方法&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、不得不说的&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat&lt;/code&gt;方法&lt;/h3&gt;

&lt;p&gt;JUnit4 结合 Hamcrest 提供了一个全新的断言语法——&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat&lt;/code&gt;。程序员可以只使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat&lt;/code&gt; 一个断言语句，结合 Hamcrest 提供的匹配符，就可以表达全部的测试思想。&lt;/p&gt;

&lt;p&gt;其基本语法为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assertThat([message,] value, matcher-statement);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;第一个参数&lt;code class=&quot;highlighter-rouge&quot;&gt;message&lt;/code&gt;，为可选参数，为出错是的提示信息；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;value&lt;/code&gt;为想要测试的变量；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;matcher-statement&lt;/code&gt;为使用 Hamcrest 匹配符来表达的对前面变量所期望的值的声明，如果 value 值与 &lt;code class=&quot;highlighter-rouge&quot;&gt;matcher-statement&lt;/code&gt; 所表达的期望值相符，则测试成功，否则测试失败。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;开发人员可以通过实现 Matcher 接口，定制自己想要的匹配符。当开发人员发现自己的某些测试代码在不同的测试中重复出现，经常被使用，这时用户就可以自定义匹配符，将这些代码绑定在一个断言语句中，从而可以达到减少重复代码并且更加易读的目的。&lt;/p&gt;

&lt;p&gt;目前，JUnit提供的匹配符，定义在两个类里面:&lt;code class=&quot;highlighter-rouge&quot;&gt;org.junit.matchers.JUnitMatchers&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;org.hamcrest.CoreMatchers&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;org.junit.matchers.JUnitMatchers&lt;/code&gt;提供的匹配符，目前有两个：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;isThrowable(Matcher&amp;lt;T&amp;gt; throwableMatcher);
isException(Matcher&amp;lt;T&amp;gt; exceptionMatcher);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;org.hamcrest.CoreMatchers&lt;/code&gt;提供的匹配符就很多了，常用的有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;核心&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;anything - 总是匹配,如果你不关心测试下的对象是什么是有用的&lt;/li&gt;
      &lt;li&gt;describedAs - 添加一个定制的失败表述装饰器&lt;/li&gt;
      &lt;li&gt;is - 改进可读性的装饰器&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;逻辑&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;allOf - 如果所有匹配器都匹配才匹配, short circuits (很难懂的一个词,意译是短路,感觉不对,就没有翻译)(像 Java &amp;amp;&amp;amp;)&lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;anyOf - 如果任何匹配器匹配就匹配, short circuits (像 Java&lt;/td&gt;
              &lt;td&gt; &lt;/td&gt;
              &lt;td&gt;)&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;not - 如果包装的匹配器不匹配器时匹配,反之亦然&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对象&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;equalTo - 测试对象相等使用Object.equals方法&lt;/li&gt;
      &lt;li&gt;hasToString - 测试Object.toString方法&lt;/li&gt;
      &lt;li&gt;instanceOf, isCompatibleType - 测试类型&lt;/li&gt;
      &lt;li&gt;notNullValue, nullValue - 测试null&lt;/li&gt;
      &lt;li&gt;sameInstance - 测试对象实例&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Beans&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;hasProperty - 测试JavaBeans属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;集合
    &lt;ul&gt;
      &lt;li&gt;array - 测试一个数组元素test an array’s elements against an array of matchers&lt;/li&gt;
      &lt;li&gt;hasEntry, hasKey, hasValue - 测试一个Map包含一个实体,键或者值&lt;/li&gt;
      &lt;li&gt;hasItem, hasItems - 测试一个集合包含一个元素&lt;/li&gt;
      &lt;li&gt;hasItemInArray - 测试一个数组包含一个元素&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数字
    &lt;ul&gt;
      &lt;li&gt;closeTo - 测试浮点值接近给定的值&lt;/li&gt;
      &lt;li&gt;greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo - 测试次序&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文本
    &lt;ul&gt;
      &lt;li&gt;equalToIgnoringCase - 测试字符串相等忽略大小写&lt;/li&gt;
      &lt;li&gt;equalToIgnoringWhiteSpace - 测试字符串忽略空白&lt;/li&gt;
      &lt;li&gt;containsString, endsWith, startsWith - 测试字符串匹配&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;如何自定义一个匹配符呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;看代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package mytest;

import org.hamcrest.Description;
import org.hamcrest.Factory;
import org.hamcrest.Matcher;
import org.hamcrest.TypeSafeMatcher;

public class IsNotANumber extends TypeSafeMatcher&amp;lt;Double&amp;gt; {

  @Override
  public boolean matchesSafely(Double number) {
    return number.isNaN();
  }

  public void describeTo(Description description) {
    description.appendText(&quot;not a number&quot;);
  }

  @Factory
  public static &amp;lt;T&amp;gt; Matcher&amp;lt;Double&amp;gt; notANumber() {
    return new IsNotANumber();
  }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以这样用于测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test
public void testSquareRootOfMinusOneIsNotANumber() {
  		assertThat(Math.sqrt(-1), is(notANumber()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;一还有个assumethat方法&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、还有个&lt;code class=&quot;highlighter-rouge&quot;&gt;assumeThat&lt;/code&gt;方法&lt;/h3&gt;

&lt;p&gt;理想情况下，写测试用例的开发人员可以明确的知道所有导致他们所写的测试用例不通过的地方，但是有的时候，这些导致测试用例不通过的地方并不是很容易的被发现，可能隐藏得很深，从而导致开发人员在写测试用例时很难预测到这些因素，而且往往这些因素并不是开发人员当初设计测试用例时真正目的，他们的测试点是希望测试出被测代码中别的出错地方。&lt;/p&gt;

&lt;p&gt;比如，一个测试用例运行的 locale（如：Locale.US）与之前开发人员设计该测试用例时所设想的不同（如：Locale.UK），这样会导致测试不通过，但是这可能并不 是开发人员之前设计测试用例时所设想的测试出来的有用的失败结果（测试点并不是此，比如测试的真正目的是想判断函数的返回值是否为 true，返回 false 则测试失败），这时开发人员可以通过编写一些额外的代码来消除这些影响（比如将 locale 作为参数传入到测试用例中，每次运行测试用例时，明确指定 locale），但是花费时间和精力来编写这些不是测试用例根本目的的额外代码其实是种浪费，这时就可以使用 Assumption 假设机制来轻松达到额外代码的目的。编写该测试用例时，首先假设 locale 必须是 Locale.UK，如果运行时 locale 是 Locale.UK，则继续执行该测试用例函数，如果是其它的 locale，则跳过该测试用例函数，执行该测试用例函数以外的代码，这样就不会因为 locale 的问题导致测试出错。&lt;/p&gt;

&lt;p&gt;JUnit4 结合 Hamcrest 库提供了 assumeThat 语句，开发人员可以使用其配合匹配符 Matcher 设计所有的假设条件（语法和 assertThat 一样）。&lt;/p&gt;

&lt;p&gt;看下面例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import static org.junit.Assume.*
@Test public void filenameIncludesUsername() {
    assumeThat(File.separatorChar, is('/'));
    assertThat(new User(&quot;optimus&quot;).configFileName(), is(&quot;configfiles/optimus.cfg&quot;));
}

@Test public void correctBehaviorWhenFilenameIsNull() {
    assumeTrue(bugFixed(&quot;13356&quot;));  // bugFixed is not included in JUnit
    assertThat(parse(null), is(new NullDocument()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;JUnit自带的运行器(Runner)会忽略那些假设不成立的测试数据，而自定义运行器的处理逻辑可能会不一样。&lt;/p&gt;

&lt;p&gt;上面这个例子，也可以结合&lt;a href=&quot;junit-usage-4.html&quot;&gt;进阶四&lt;/a&gt;中的理论测试来一起理解。&lt;/p&gt;

&lt;p&gt;另外，假设也可以用在&lt;code class=&quot;highlighter-rouge&quot;&gt;@Before&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;@BeforeClass&lt;/code&gt;这两个步骤里面。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶二</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-2.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-2</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;忽略某个测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;对异常的测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;测试的超时时间&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;测试前后&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;p&gt;在&lt;a href=&quot;junit-usage-1.html&quot;&gt;JUnit4 使用进阶一&lt;/a&gt;中，我们介绍了JUnit4的下载安装，简单调用及运行测试方法，在本文中将继续对JUnit4提供的一些常用功能（忽略某个测试、对异常进行测试、设置超时时间、测试前后及顺序）进行介绍。&lt;/p&gt;

&lt;h3 id=&quot;一忽略某个测试&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、忽略某个测试&lt;/h3&gt;

&lt;p&gt;在测试过程中，我们可能需要临时禁止某个方法或者某个测试类的测试，比如：由于没完全准备好或者平台差异。这时，我们需要有一个方法可以告诉JUnit4框架，不要对这些方法或者类进行测试。&lt;/p&gt;

&lt;p&gt;基于这个需要，JUnit4提供了一个注释&lt;code class=&quot;highlighter-rouge&quot;&gt;@Ignore&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;举个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Ignore 
@Test 
public void something() { ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Ignore&lt;/code&gt;也可以添加一个可选的字符串参数，来说明为什么要忽略这个测试，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Ignore(&quot;还没准备好&quot;) 
@Test 
public void something() { ...
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，&lt;code class=&quot;highlighter-rouge&quot;&gt;@Ignore&lt;/code&gt;也可以直接作用在一个测试类上，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Ignore 
public class IgnoreMe {
	@Test 
	public void test1() { ... }
	
	@Test 
	public void test2() { ... }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二对异常的测试&quot;&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、对异常的测试&lt;/h3&gt;

&lt;p&gt;程序是否会按照我们所期待的，在运行过程中抛出异常呢？比如下面这个语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new ArrayList&amp;lt;Object&amp;gt;().get(0);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的代码将会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IndexOutOfBoundsException&lt;/code&gt;异常，&lt;code class=&quot;highlighter-rouge&quot;&gt;@Test&lt;/code&gt;注释有一个可选参数&lt;code class=&quot;highlighter-rouge&quot;&gt;expected&lt;/code&gt;,这个参数的取值是&lt;code class=&quot;highlighter-rouge&quot;&gt;Throwable&lt;/code&gt;的子类。如果我们想判断上面的代码是否抛出正确的异常，测试代码可以这样写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test(expected= IndexOutOfBoundsException.class) 
public void empty() { 
	new ArrayList&amp;lt;Object&amp;gt;().get(0); 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;JUnit4框架会对上面&lt;code class=&quot;highlighter-rouge&quot;&gt;expected&lt;/code&gt;参数值进行检查，被测试的方法中如果抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;IndexOutOfBoundsException&lt;/code&gt;异常，那么测试就通过了。&lt;/p&gt;

&lt;p&gt;一般，对异常的简单的测试，使用上面的方法就够了，但是有时，我们需要检查异常所包含的提示信息，那么我们就需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;ExpectedException&lt;/code&gt;规则，来帮助我们实现了。&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Rule
public ExpectedException thrown = ExpectedException.none();

@Test
public void shouldTestExceptionMessage() throws IndexOutOfBoundsException {
    List&amp;lt;Object&amp;gt; list = new ArrayList&amp;lt;Object&amp;gt;();

    thrown.expect(IndexOutOfBoundsException.class);
    thrown.expectMessage(&quot;Index: 0, Size: 0&quot;);
    list.get(0); // execution will never get past this line
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;利用&lt;code class=&quot;highlighter-rouge&quot;&gt;@Rule&lt;/code&gt;，我们可以对异常的提示信息进行检查。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expectMessage&lt;/code&gt;方法还支持使用&lt;code class=&quot;highlighter-rouge&quot;&gt;CoreMatchers.containsString&lt;/code&gt;来进行提示信息的匹配判断,如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; thrown.expectMessage(CoreMatchers.containsString(&quot;Size: 0&quot;));
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三测试的超时时间&quot;&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、测试的超时时间&lt;/h3&gt;

&lt;p&gt;有时，我们需要控制程序的执行时间，当超出预设的超时时间，那么就判断测试失败。JUnit4框架也提供了这种检查，看下面例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Test(timeout=1000)
public void testWithTimeout() {
  ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Test&lt;/code&gt;注释的一个可选参数&lt;code class=&quot;highlighter-rouge&quot;&gt;timeout&lt;/code&gt;的数值(单位毫秒)，我们可以告诉框架，预设的超时时间是多少。当测试运行中，执行时间超出了这个预设值，框架就会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;TimeoutException&lt;/code&gt;异常，标记这个测试失败了。&lt;/p&gt;

&lt;p&gt;我们也可以使用规则，来为整个测试类里面所有测试方法设置一个统一的超时时间，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class HasGlobalTimeout {
    public static String log;

    @Rule
    public Timeout globalTimeout = new Timeout(10000); // 10 seconds max per method tested

    @Test
    public void testInfiniteLoop1() {
        log += &quot;ran1&quot;;
        for (;;) {
        }
    }

    @Test
    public void testInfiniteLoop2() {
        log += &quot;ran2&quot;;
        for (;;) {
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;四测试前后&quot;&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、测试前后&lt;/h3&gt;

&lt;p&gt;每个测试之前，我们可能需要做一些数据准备操作，再每个测试之后，我们可能需要将测试数据进行恢复。那么，JUnit4框架如何提供什么样的方式，来实现我们的需求呢？&lt;/p&gt;

&lt;p&gt;没错，JUnit4提供了四个注释，来标注测试类中的某些方法，是用来做测试前后的准备或者恢复操作的。这四个注释分别为:&lt;code class=&quot;highlighter-rouge&quot;&gt;@Before&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;@After&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;@BeforeClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@AfterClass&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;看下面这个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package test;

import java.io.Closeable;
import java.io.IOException;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

public class TestFixturesExample {
  static class ExpensiveManagedResource implements Closeable {
    @Override
    public void close() throws IOException {}
  }

  static class ManagedResource implements Closeable {
    @Override
    public void close() throws IOException {}
  }

  @BeforeClass
  public static void setUpClass() {
    System.out.println(&quot;@BeforeClass setUpClass&quot;);
    MyExpensiveManagedResource = new ExpensiveManagedResource();
  }

  @AfterClass
  public static void tearDownClass() throws IOException {
    System.out.println(&quot;@AfterClass tearDownClass&quot;);
    MyExpensiveManagedResource.close();
    MyExpensiveManagedResource = null;
  }

  private ManagedResource myManagedResource;
  private static ExpensiveManagedResource MyExpensiveManagedResource;

  private void println(String string) {
    System.out.println(string);
  }

  @Before
  public void setUp() {
    this.println(&quot;@Before setUp&quot;);
    this.myManagedResource = new ManagedResource();
  }

  @After
  public void tearDown() throws IOException {
    this.println(&quot;@After tearDown&quot;);
    this.myManagedResource.close();
    this.myManagedResource = null;
  }

  @Test
  public void test1() {
    this.println(&quot;@Test test1()&quot;);
  }

  @Test
  public void test2() {
    this.println(&quot;@Test test2()&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个例子的执行结果，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@BeforeClass setUpClass
@Before setUp
@Test test2()
@After tearDown
@Before setUp
@Test test1()
@After tearDown
@AfterClass tearDownClass
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@Before&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@After&lt;/code&gt;定义的方法，会在每个测试方法运行的前后执行一遍；&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;@BeforeClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@AfterClass&lt;/code&gt;定义的方法，会在整个测试类运行的开始和结束执行且仅执行一遍。&lt;/li&gt;
  &lt;li&gt;一般来说，&lt;code class=&quot;highlighter-rouge&quot;&gt;@Before&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;@After&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;@BeforeClass&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;@AfterClass&lt;/code&gt;提供的方法，是在某个测试类里面所使用的，无法被另外的测试类所公用，如果你想写一个类来处理数据，并被几个测试类所使用，那么你可以使用规则来实现。关于这一点，你可以看看我们后面的教程。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;五小结&quot;&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、小结&lt;/h3&gt;

&lt;p&gt;在本文中，我们进一步介绍了JUnit4框架提供的一些功能，在继续的教程中，我们将介绍几个有特色的运行器，来提高测试效率。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>JUnit4 使用进阶一</title>
   <link href="http://www.blogways.net/blog/2013/04/15/junit-usage-1.html"/>
   <updated>2013-04-15T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/15/junit-usage-1</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;下载安装&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;一个简单的模版&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;运行测试&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#5&quot;&gt;JUnit4的核心之一是断言&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#6&quot;&gt;小结&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;h3 id=&quot;一简介&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、简介&lt;/h3&gt;

&lt;p&gt;JUnit是一个Java语言的单元测试框架。它由Kent Beck和Erich Gamma建立，逐渐成为源于Kent Beck的sUnit的xUnit家族中为最成功的一个。来自JUnit的体验对测试驱动开发是很重要的，所以一些 JUnit知识经常 和测试驱动开发的讨论融合在一起。可以参考Kent Beck的 &lt;a href=&quot;http://book.douban.com/subject/1771049/&quot;&gt;《Test-Driven Development: By Example》&lt;/a&gt;一书（有中文版和影印版）。&lt;/p&gt;

&lt;p&gt;本文，对JUnit4的下载安装、基本测试方法及运行，配合实例进行基础介绍。帮助读者看完之后，就可以将JUnit4运用到单元测试中去。而JUnit4的更多功能可以参考后续的&lt;a href=&quot;junit-usage-2.html&quot;&gt;JUnit4使用进阶二&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;二下载安装&quot;&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、下载安装&lt;/h3&gt;

&lt;p&gt;JUnit当前版本是4.11，如果，你的工程是使用Maven进行管理构建，那么只需要在工程的pom.xml文件中添加如下依赖信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;
  		&amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
  		&amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
  		&amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
  		&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;否则，在你的测试classpath中放置下面两个jar:&lt;code class=&quot;highlighter-rouge&quot;&gt;junit.jar&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hamcrest-core.jar&lt;/code&gt;，这两个jar可以在&lt;a href=&quot;http://search.maven.org/&quot;&gt;这里&lt;/a&gt;找到并下载。&lt;/p&gt;

&lt;h3 id=&quot;三一个简单的模版&quot;&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、一个简单的模版&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package com.example.foo;

import static org.junit.Assert.assertEquals;

import org.junit.Test;
import org.junit.Ignore;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;

/**
 * Tests for {@link Foo}.
 *
 * @author user@example.com (John Doe)
 */
@RunWith(JUnit4.class)
public class FooTest {

	@Test
	public void thisAlwaysPasses() {
	}

	@Test
	@Ignore
	public void thisIsIgnored() {
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个模版是不是很简单！&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要测试的方法，只需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;@Test&lt;/code&gt;标注出来就可以了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试类只需要添加&lt;code class=&quot;highlighter-rouge&quot;&gt;@RunWith&lt;/code&gt;注释，不再需要继承&lt;code class=&quot;highlighter-rouge&quot;&gt;junit.framework.TestCase&lt;/code&gt;这个父类了。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然了，JUnit4还提供了很多特色功能，后面我们会一一介绍。&lt;/p&gt;

&lt;h3 id=&quot;四运行测试&quot;&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、运行测试&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在命令行，对写好的测试类，进行测试很简单，只需要下面一个命令就ok了：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  java -cp .:/usr/share/java/junit.jar org.junit.runner.JUnitCore [test class name]
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在IDE里面进行测试就更简单了，&lt;code class=&quot;highlighter-rouge&quot;&gt;Netbeans&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;Eclipse&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;IntelliJ Idea&lt;/code&gt;都内置了图形化的测试运行器。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;测试类如何运行，是由&lt;code class=&quot;highlighter-rouge&quot;&gt;@RunWith&lt;/code&gt;注释来决定。JUnit4当前版本的默认基本测试方式是&lt;code class=&quot;highlighter-rouge&quot;&gt;JUnit4.class&lt;/code&gt;。除此之外，还有一些其他特殊的，我们将在&lt;a href=&quot;junit-usage-4.html&quot;&gt;JUnit4 使用进阶四&lt;/a&gt;中进行介绍。&lt;/p&gt;

&lt;h3 id=&quot;五junit4的核心之一是断言&quot;&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、JUnit4的核心之一是断言&lt;/h3&gt;

&lt;p&gt;JUnit4框架主要是通过断言来判断运行结果正确与否，针对Java的原生类型(long,boolean,float…)或者Objects或者数组，JUnit都提供了对应的断言方法。&lt;/p&gt;

&lt;p&gt;下面，我们先来看个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.junit.matchers.JUnitMatchers.everyItem;
import static org.junit.matchers.JUnitMatchers.hasItems;

import java.util.Arrays;

import org.hamcrest.core.CombinableMatcher;
import org.junit.Test;

public class AssertTests {
  @Test
  public void testAssertArrayEquals() {
    byte[] expected = &quot;trial&quot;.getBytes();
    byte[] actual = &quot;trial&quot;.getBytes();
    org.junit.Assert.assertArrayEquals(&quot;failure - byte arrays not same&quot;, expected, actual);
  }

  @Test
  public void testAssertEquals() {
    org.junit.Assert.assertEquals(&quot;failure - strings not same&quot;, 5l, 5l);
  }

  @Test
  public void testAssertFalse() {
    org.junit.Assert.assertFalse(&quot;failure - should be false&quot;, false);
  }

  @Test
  public void testAssertNotNull() {
    org.junit.Assert.assertNotNull(&quot;should not be null&quot;, new Object());
  }

  @Test
  public void testAssertNotSame() {
    org.junit.Assert.assertNotSame(&quot;should not be same Object&quot;, new Object(), new Object());
  }

  @Test
  public void testAssertNull() {
    org.junit.Assert.assertNull(&quot;should be null&quot;, null);
  }

  @Test
  public void testAssertSame() {
    Integer aNumber = Integer.valueOf(768);
    org.junit.Assert.assertSame(&quot;should be same&quot;, aNumber, aNumber);
  }

  // JUnit Matchers assertThat
  @Test
  public void testAssertThatBothContainsString() {
    org.junit.Assert.assertThat(&quot;albumen&quot;, both(containsString(&quot;a&quot;)).and(containsString(&quot;b&quot;)));
  }

  @Test
  public void testAssertThathasItemsContainsString() {
    org.junit.Assert.assertThat(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), hasItems(&quot;one&quot;, &quot;three&quot;));
  }

  @Test
  public void testAssertThatEveryItemContainsString() {
    org.junit.Assert.assertThat(Arrays.asList(new String[] { &quot;fun&quot;, &quot;ban&quot;, &quot;net&quot; }), everyItem(containsString(&quot;n&quot;)));
  }

  // Core Hamcrest Matchers with assertThat
  @Test
  public void testAssertThatHamcrestCoreMatchers() {
    assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;)));
    assertThat(&quot;good&quot;, not(allOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;))));
    assertThat(&quot;good&quot;, anyOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;)));
    assertThat(7, not(CombinableMatcher.&amp;lt;Integer&amp;gt; either(equalTo(3)).or(equalTo(4))));
    assertThat(new Object(), not(sameInstance(new Object())));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;assertEquals&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;assertSame&lt;/code&gt; 的区别在于，前者是调用&lt;code class=&quot;highlighter-rouge&quot;&gt;期待值&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;equals&lt;/code&gt;方法来判断&lt;code class=&quot;highlighter-rouge&quot;&gt;真实值&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;expected.equals(actual)&lt;/code&gt;)，而后者是判断&lt;code class=&quot;highlighter-rouge&quot;&gt;期待值&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;真实值&lt;/code&gt;是否是同一个对象(&lt;code class=&quot;highlighter-rouge&quot;&gt;expected == actual&lt;/code&gt;)。&lt;/li&gt;
  &lt;li&gt;例子中，这样调用&lt;code class=&quot;highlighter-rouge&quot;&gt;org.junit.Assert.assertEquals(&quot;failure - strings not same&quot;, 5l, 5l);&lt;/code&gt;是不是觉得有点累，没关系，我们可以通过JDK1.5中的静态导入(&lt;code class=&quot;highlighter-rouge&quot;&gt;import static&lt;/code&gt;)来简化这一切，看下面的代码。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简化后的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package tangzhi.mytest;

import static org.hamcrest.CoreMatchers.allOf;
import static org.hamcrest.CoreMatchers.anyOf;
import static org.hamcrest.CoreMatchers.equalTo;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers.sameInstance;
import static org.hamcrest.CoreMatchers.startsWith;
import static org.junit.Assert.assertThat;
import static org.junit.matchers.JUnitMatchers.both;
import static org.junit.matchers.JUnitMatchers.containsString;
import static org.junit.matchers.JUnitMatchers.everyItem;
import static org.junit.matchers.JUnitMatchers.hasItems;

import static org.junit.Assert.*;
    
import java.util.Arrays;

import org.hamcrest.core.CombinableMatcher;
import org.junit.Test;

public class AppTest {
  @Test
  public void testAssertArrayEquals() {
    byte[] expected = &quot;trial&quot;.getBytes();
    byte[] actual = &quot;trial&quot;.getBytes();
    assertArrayEquals(&quot;failure - byte arrays not same&quot;, expected, actual);
  }

  @Test
  public void testAssertEquals() {
    assertEquals(&quot;failure - strings not same&quot;, 5l, 5l);
  }

  @Test
  public void testAssertFalse() {
    assertFalse(&quot;failure - should be false&quot;, false);
  }

  @Test
  public void testAssertNotNull() {
    assertNotNull(&quot;should not be null&quot;, new Object());
  }

  @Test
  public void testAssertNotSame() {
    assertNotSame(&quot;should not be same Object&quot;, new Object(), new Object());
  }

  @Test
  public void testAssertNull() {
    assertNull(&quot;should be null&quot;, null);
  }

  @Test
  public void testAssertSame() {
    Integer aNumber = Integer.valueOf(768);
    assertSame(&quot;should be same&quot;, aNumber, aNumber);
  }

  // JUnit Matchers assertThat
  @Test
  public void testAssertThatBothContainsString() {
    assertThat(&quot;albumen&quot;, both(containsString(&quot;a&quot;)).and(containsString(&quot;b&quot;)));
  }

  @Test
  public void testAssertThathasItemsContainsString() {
    assertThat(Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), hasItems(&quot;one&quot;, &quot;three&quot;));
  }

  @Test
  public void testAssertThatEveryItemContainsString() {
    assertThat(Arrays.asList(new String[] { &quot;fun&quot;, &quot;ban&quot;, &quot;net&quot; }), everyItem(containsString(&quot;n&quot;)));
  }

  // Core Hamcrest Matchers with assertThat
  @Test
  public void testAssertThatHamcrestCoreMatchers() {
    assertThat(&quot;good&quot;, allOf(equalTo(&quot;good&quot;), startsWith(&quot;good&quot;)));
    assertThat(&quot;good&quot;, not(allOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;))));
    assertThat(&quot;good&quot;, anyOf(equalTo(&quot;bad&quot;), equalTo(&quot;good&quot;)));
    assertThat(7, not(CombinableMatcher.&amp;lt;Integer&amp;gt; either(equalTo(3)).or(equalTo(4))));
    assertThat(new Object(), not(sameInstance(new Object())));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上面的代码中，我们静态导入了&lt;code class=&quot;highlighter-rouge&quot;&gt;import static org.junit.Assert.*;&lt;/code&gt;后，在测试类中就可以直接使用&lt;code class=&quot;highlighter-rouge&quot;&gt;assertEquals&lt;/code&gt;这些方法了。是不是很方便！&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;常用的断言方法有：&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;assertTrue([message ,] condition);
assertFalse([message ,] condition);
assertEquals([message ,] expected, actual);
assertNotEquals([message ,] first, second);
assertArrayEquals([message ,] expecteds, actuals);
assertNotNull([message ,] object);
assertNull([message ,] object);
assertSame([message ,] expected, actual);
assertNotSame([message ,] unexpected, actual);
assertThat([message ,] actual, matcher);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;从上面的列表可以看出：&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;大部分断言方法的参数顺序都是:&lt;code class=&quot;highlighter-rouge&quot;&gt;[Message] 期待值  真实值&lt;/code&gt;，第一个参数是个可选字符串，出错时的描述信息。第二个参数是期待值，第三个参数是真实值。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;只有一个断言方法&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat&lt;/code&gt;的参数顺序例外：可选的出错提示信息、真实值和一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Matcher&lt;/code&gt;对象。它参数中的期待值与真实值的顺序，与其他断言方法的参数顺序正好相反。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这个&lt;code class=&quot;highlighter-rouge&quot;&gt;assertThat&lt;/code&gt;方法是断言中的神器，后面我们会在&lt;a href=&quot;junit-usage-3.html&quot;&gt;进阶三&lt;/a&gt;介绍！敬请期待吧！&lt;/p&gt;

&lt;h3 id=&quot;六小结&quot;&gt;&lt;a name=&quot;6&quot;&gt;&lt;/a&gt;六、小结&lt;/h3&gt;

&lt;p&gt;前面我们介绍了JUnit4的基本知识。至此，你已经可以使用JUnit4进行代码测试了。如果你想知道更多信息，可以继续看看&lt;a href=&quot;junit-usage-2.html&quot;&gt;JUnit 使用进阶二&lt;/a&gt;。&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>jekyll 教程入门</title>
   <link href="http://www.blogways.net/blog/2013/04/13/jekyll-usage.html"/>
   <updated>2013-04-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/13/jekyll-usage</id>
   <content type="html">&lt;h2 id=&quot;jekyll-教程入门&quot;&gt;jekyll 教程入门&lt;/h2&gt;

&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;安装jekyll&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;搭建网站框架&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;编写博文&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#4&quot;&gt;一些Jekyll网站例子及源码&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;jekyll&lt;/a&gt; 是一款简单的博客系统，也可以说是一个静态网站生成器。她有一个模版目录，存放整个静态网站的模版文件，可以通过&lt;a href=&quot;https://github.com/shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt;处理模版文件，把使用标记语言&lt;a href=&quot;http://en.wikipedia.org/wiki/Textile&quot;&gt;Textile&lt;/a&gt;或&lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;编写的内容文件，按照模版格式，转换成最终的静态网站页面。大名鼎鼎的GitHub Pages就是通过她实现的。&lt;/p&gt;

&lt;p&gt;在这里，我们将告诉你如果使用jekyll搭建一个简单的博客网站。&lt;/p&gt;

&lt;h3 id=&quot;一安装jekyll&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、安装jekyll&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;使用&lt;a href=&quot;http://rubygems.org/&quot;&gt;RubyGems&lt;/a&gt;安装jekyll。安装了Ruby之后，默认会自动安装RubyGems，也可以单独安装RubyGems.&lt;/p&gt;

&lt;p&gt;使用RubyGems安装jekyll很简单，命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果使用的标记语言是Markdown，则需要另外安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果使用的标记语言是Textile,则需要另外安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install RedCloth
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面三个可以一次性安装，如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll rdiscount RedCloth
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，如需安装和github pages相同版本的jekyll，那么不需要安装上面这几个，直接用下面命令安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install github-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果是Mac环境下面，可能会出现版本问题，无法安装，可以参考我的另外一篇博文——&lt;a href=&quot;/blog/2013/04/08/install-jekyll-on-mac.html&quot;&gt;MAC OS X 10.8 下安装jekyll&lt;/a&gt; 进行安装。&lt;/p&gt;

&lt;h3 id=&quot;二搭建博客网站框架&quot;&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、搭建博客网站框架&lt;/h3&gt;

&lt;p&gt;jekyll 的内核实际上就是一个格式文本转换引擎，她允许你使用标记语言Markdown或者Textile再或者原始的html语言，编写内容。她通过模版文件，将这些内容转换成最终的静态网页。&lt;/p&gt;

&lt;p&gt;一个简单的jekyll网站结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.
|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   `-- post.html
|-- _posts
|   |-- 2007-10-29-why-every-programmer-should-play-nethack.textile
|   `-- 2009-04-26-barcamp-boston-4-roundup.textile
|-- _site
`-- index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在这基本结构中，有几个关键的文件或者目录，其作用如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这是jekyll的主要配置文件。这些配置选项，大部分都可以在启动jekyll时，作为命令行参数执行。只不过，把这些选项配置在文件中，就省去记住他们，且每次执行jekyll时命令也简单一点。&lt;/p&gt;

    &lt;p&gt;关于jekyll的参数，其实系统已经设置了&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/Configuration&quot;&gt;默认值&lt;/a&gt;，如无特殊需要，空文件也可以。&lt;/p&gt;

    &lt;p&gt;个人推荐，可以添加两个参数：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; markdown: rdiscount
 pygments: true
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rdiscount&lt;/code&gt;&lt;/strong&gt;是markdown标记语言的一个转换引擎，比默认的&lt;code class=&quot;highlighter-rouge&quot;&gt;maruku&lt;/code&gt;性能要好一些。&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pygments&lt;/code&gt;&lt;/strong&gt;是支持语法高亮显示的工具。设置开通后，可以通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;highlight&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt; 标签在博文中嵌入语法高亮的代码。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_includes&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个目录的存在是区分高手和普通用户的，嘿嘿。在网站设计中，页面的共有部分，可以存储成一个单独的文件。这样设计可以方便以后的维护。而这个单独的公用文件就存放在这个目录里面。这里面的公用文件，可以被&lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;_post&lt;/code&gt;目录下面的文件嵌入。其嵌入方法，采用的是Liquid标签实现。比如：&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;file.ext&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;，就指在文件中嵌入公用文件&lt;code class=&quot;highlighter-rouge&quot;&gt;_includes/file.ext&lt;/code&gt;中的内容。&lt;/p&gt;

    &lt;p&gt;是不是很方便！？哈哈！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_layouts&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个目录下存放的是整个网站的模版文件，可以是一个文件，也可以是一套文件。这个要看整个网站是怎么规划了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个目录是存放你的博文的，整个网站搭建完成后，以后每次添加博文，只需要提交到这个目录下就可以了。&lt;/p&gt;

    &lt;p&gt;不过，编写的博文，必须符合一定的规则。见下面&lt;a href=&quot;#3&quot;&gt;编写博文&lt;/a&gt;小节内容。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这个目录，是jekyll运行之后生成的。存放着整个网站的最终静态页面。其中的内容，不用去关心。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html和其他的 HTML/Markdown/Textile文件&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;这些文件如果包含&lt;code class=&quot;highlighter-rouge&quot;&gt;YAML&lt;/code&gt;信息块，那么jekyll运行时就会自动对他进行转换。你网站根目录，以及任何不在上述目录下的文件(包括&lt;code class=&quot;highlighter-rouge&quot;&gt;.html&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;.markdown&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;.md&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;texitle&lt;/code&gt;文件，但不仅这些文件)。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;其他文件和目录&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;除了上述文件和目录，你还可以添加一些其他的文件或者目录。比如，添加css目录，存放网站的css文件；添加images目录，存放网站涉及到的图片资源。噢，对了，你还可以在网站的根目录下一个网站图标文件&lt;code class=&quot;highlighter-rouge&quot;&gt;favicon.ico&lt;/code&gt;，这样别人访问你的网站时，体验会更好一点。设计优秀的网站图标，能帮助访问者，更容易记住你的网站哦！&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;三编写博文&quot;&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、编写博文&lt;/h3&gt;

&lt;p&gt;从上一小节的内容，我们知道&lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt;目录下面存放的是我们的博文，这些博文必须满足一定的规则。这里，我将告诉大家相关的规则。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;博文的命名是有讲究的，必须符合&lt;code class=&quot;highlighter-rouge&quot;&gt;YEAR-MONTH-DAY-title.MARKUP&lt;/code&gt;这个格式。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博文的永久链接(PermaLink)生成规则很灵活，可以配置(在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;中)。系统内置三种格式：&lt;/p&gt;

    &lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt; 模版名 &lt;/th&gt;
 &lt;th&gt; 模版内容 &lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt; date &lt;/td&gt;
 &lt;td&gt; /:categories/:year/:month/:day/:title/  &lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt; pretty &lt;/td&gt;
 &lt;td&gt; /:categories/:year/:month/:day/:title/  &lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt; none &lt;/td&gt;
 &lt;td&gt; /:categories/:title.html &lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
 &lt;/table&gt;

    &lt;p&gt;目前系统默认格式是&lt;code class=&quot;highlighter-rouge&quot;&gt;date&lt;/code&gt;。你也可以修改，比如，在&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;中配置&lt;code class=&quot;highlighter-rouge&quot;&gt;permalink: pretty&lt;/code&gt;。这样就会生成类似&lt;code class=&quot;highlighter-rouge&quot;&gt;/2009/04/29/slap-chop/index.html&lt;/code&gt;这样的文件url.除了内置的格式，也可以自定义格式，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;permalink: /blog/:month-:day-:year/:title.html&lt;/code&gt;。是不是很酷？哈哈！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博文可以是用标记语言Markdown或者Textile再或者原始的html语言编写的文本。但是，博文的开头必须包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;YAML&lt;/code&gt;信息块。在这个&lt;code class=&quot;highlighter-rouge&quot;&gt;YAML&lt;/code&gt;信息块，包含一些信息。比如使用的模版，博文的标题等等。给个简单的例子吧，如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ---
 layout: post
 title: jekyll 教程入门
 ---
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;到此，基本内容已经讲完了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;四运行jekyll生成网站&quot;&gt;&lt;a name=&quot;4&quot;&gt;&lt;/a&gt;四、运行jekyll生成网站&lt;/h3&gt;

&lt;p&gt;在网站根目录下，运行&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll&lt;/code&gt;命令，就可以生成最终的静态网站内容目录&lt;code class=&quot;highlighter-rouge&quot;&gt;_site&lt;/code&gt;。如果，你还想通过浏览器访问，可以运行下面命令。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll --server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000&lt;/code&gt;就可以访问你做出来的网站了。&lt;/p&gt;

&lt;p&gt;如果你的博客网站是类似&lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:4000/blog/index.html&lt;/code&gt;这样的路径。那么，在运行时，需要添加参数&lt;code class=&quot;highlighter-rouge&quot;&gt;base-url&lt;/code&gt;来实现，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jekyll --base-url '/blog' --server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五一些jekyll网站例子及源码&quot;&gt;&lt;a name=&quot;5&quot;&gt;&lt;/a&gt;五、一些Jekyll网站例子及源码&lt;/h3&gt;

&lt;p&gt;下面给一些建在GitHub上面的jekyll博客，及其源码。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://tom.preston-werner.com/&quot;&gt;tom.preston-werner.com&lt;/a&gt;——&lt;a href=&quot;http://github.com/mojombo/mojombo.github.io&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://gitready.com/&quot;&gt;gitready.com&lt;/a&gt;——&lt;a href=&quot;http://github.com/gitready/gitready&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://zen.id.au/&quot;&gt;zen.id.au&lt;/a&gt;——&lt;a href=&quot;https://github.com/zensavona/zensavona.github.com&quot;&gt;源码&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>git服务器部署及使用</title>
   <link href="http://www.blogways.net/blog/2013/04/13/git.html"/>
   <updated>2013-04-13T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/13/git</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;Git是用于Linux内核开发的版本控制工具。与CVS、Subversion一类的集中式版本控制工具不同，它采用了分布式版本库的作法，不需要服务器端软件，就可以运作版本控制，使得源代码的发布和交流极其方便。Git的速度很快，这对于诸如Linux kernel这样的大项目来说自然很重要。Git最为出色的是它的合并追踪（merge tracing）能力。&lt;/p&gt;

&lt;p&gt;实际上内核开发团队决定开始开发和使用Git来作为内核开发的版本控制系统的时候，世界开源社群的反对声音不少，最大的理由是Git太艰涩难懂，从Git的内部工作机制来说，的确是这样。但是随着开发的深入，Git的正常使用都由一些友善的命令稿来执行，使Git变得非常好用。现在，越来越多的著名项目采用Git来管理项目开发。&lt;/p&gt;

&lt;h3 id=&quot;二实现原理&quot;&gt;二、实现原理&lt;/h3&gt;

&lt;p&gt;Git和其他版本控制系统（如CVS）有不少的差别，Git本身关心档案的整体性是否有改变，但多数的CVS，或Subversion系统则在乎档案内容的差异。因此Git更像一个档案系统，直接在本机上取得资料，不必连线到host端取资料回来。&lt;/p&gt;

&lt;h3 id=&quot;三安装git&quot;&gt;三、安装git&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;linux上安装：&lt;/p&gt;

    &lt;p&gt;linux上安装git可以源代码安装和预编译好的Git二进制安装包安装两种方式，
 本次安装是在redHat上采用源码安装的:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;主机上建立一个用户git&lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;root用户登录，修改/ect目录下sudoers文件，将git用户加入sudo列表&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;下载源代码 
 	&lt;a href=&quot;http://git-scm.com/download&quot;&gt;http://git-scm.com/download&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;上传redHat主机解压编译并安装&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $tar -zxf git-1.7.2.2.tar.gz
  $ cd git-1.7.2.2
  $ make prefix=/usr/local all
  $ sudo make prefix=/usr/local install 其中/usr/local为安装目录
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;修改git用户下 ~/.bash_profile文件（没有新建），添加PATH=$PATH:/usr/local/bin&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;修改git用户下.bashrc文件（没有新建），添加 PATH=$HOME/bin:$PATH&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;$git –version，显示git版本git version 1.8.1.6，表示git安装成功&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;windows上安装&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;下载msysGit安装包
&lt;a href=&quot;http://code.google.com/p/msysgit&quot;&gt; http://code.google.com/p/msysgit &lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;安装msysGit，右键运行git Bash，输入git –version，
显示git version 1.7.11.msysgit.1，windows上git安装成功&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;四git配置&quot;&gt;四、git配置&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;linux 上git服务器配置：&lt;/p&gt;

    &lt;p&gt;首先我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。
 Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。
 而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。
 这些变量可以存放在以下三个不同的地方：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; • /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用git config 时用
   --system 选项，读写的就是这个文件
 • ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用git config 时用
 		  --global 选项，读写的就是这个文件
 • 当前项目的 git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：所以
   .git/config 里的配置会覆盖/etc/  gitconfig 中的同名变量
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;配置的是你个人的用户名称和电子邮件地址&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	$ git config --global user.name &quot;tangsz&quot;
  	$ git config --global user.email &quot;tangsz@asiainfo-linkage.com&quot; 
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文本编辑器&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ git config --global core.editor vi
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;查看配置信息 git config –list&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;windows 上msysGit配置&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;生成公钥
      右键打开git Bash，输入ssh-keygen –C “你的email地址 “ –t rsa 就会为你生成一个 SSH Key，
      然后会询问一些保存文件的位置，设置密码神马的，直接回车，回车，回车，默认的就可以了，SSH 公
      钥默认储存在账户的主目录下的 ~/.ssh 目录something 和 something.pub 来命名的一对文件，
      这个 something 通常就是 id_dsa 或 id_rsa，有 .pub 后缀的文件就是公钥&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将公钥文件放到主机git用户.ssh目录下（没有此目录就新建），将公钥文件内容追加到  文件authorized_keys文件（没有就新建）尾部即可：&lt;/p&gt;

        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cat /tmp/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys 
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

  	这样后面windows与服务器交互clone、pull等操作时就不用频繁输入密码了
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;五服务器上部署git&quot;&gt;五、服务器上部署git&lt;/h3&gt;

&lt;p&gt;服务器上部署git仓库有很多种方式，这里简单介绍两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接在服务器上需建立仓库目录执行 git init，通常我们在服务器上建立的仓库都是裸仓库-即一个不含工作目录的仓库，所以我们这里执行git –bare init建立裸仓库，–bare表示建立的是裸仓库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本机clone一个裸仓库移到服务器上，如下：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  $ git clone --bare my_project my_project.git
  $ scp -r my_project.git user@192.168.4.19:/home/git
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;user为服务器上建立的git用户，192.168.4.19为主机地址，/home/git为裸仓库存放目录，这样所有对该服务器有 SSH 访问权限，并可读取 /home/git 目录的用户都可以用下面的命令克隆该项目&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：裸仓库建立完后，更改裸仓库目录下config文件添加&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[receive]
	denyCurrentBranch = ignore)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;否则本机push操作会报master branch is currently checked out&lt;/p&gt;

&lt;h3 id=&quot;六git操作&quot;&gt;六、git操作&lt;/h3&gt;

&lt;p&gt;git的操作需在实践中慢慢熟悉，这里简单介绍一些平时常用的：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;本地仓库操作&lt;/p&gt;

    &lt;p&gt;windows下命令行操作仓库在安装msysGit后只需右键执行git Bash就可以操作了，
 也可以下载TortoiseGit通过可视化操作本地及远程仓库，此处就简单介绍命令行操作仓库，不做TortoiseGit操作介绍&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;克隆一个仓库：git有git、ssh、http(s)几种协议，这里用的是ssh git clone git:192.168.4.19：/home/git/my_project.git git为服务器用户名、192.168.4.19为服务器地址、/home/git/my_project.git为服务器仓库目录&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git status  –检查文件&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git add 文件名   –新增文件&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git commit  –提交操作&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git log  –查看日志&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git commit –amend   –撤销提交&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git mv file_from file_to  –文件改名&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git diff  –查看working tree与index file的差别&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git rm  –删除文件&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;远程仓库操作&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;git remote -v –查看远程仓库&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git fetch [remote-name]  –获取remote-name库数据不merge&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git push [remote-name] [branch-name]  –上传数据都remote-name库branch-name分支&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git remote show origin      – 查看origin库信息&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git remote rename pb paul   —把 pb 改成 paul&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;git pull     –从远程获取最新版本并merge到本地,相当于git fetch 和 git merge&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 
 <entry>
   <title>创建SSH密钥，并连接GitHub</title>
   <link href="http://www.blogways.net/blog/2013/04/10/generating-ssh-keys-4-github.html"/>
   <updated>2013-04-10T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/10/generating-ssh-keys-4-github</id>
   <content type="html">&lt;div class=&quot;code fl&quot;&gt;
    &lt;dl&gt;
    &lt;dt&gt;目录&lt;/dt&gt;
    &lt;dd&gt;
    &lt;ol&gt;
        &lt;li&gt;&lt;a href=&quot;#1&quot;&gt;Windows环境下生成SSH Keys，并连接GitHub&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#2&quot;&gt;Mac环境下生成SSH Keys，并连接GitHub&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&quot;#3&quot;&gt;单机如何控制不同的SSH Keys连不同的Git环境?&lt;/a&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/dd&gt;
    &lt;/dl&gt;
&lt;/div&gt;

&lt;p&gt;我们可以使用SSH Keys在本机和GitHub之间建立一个安全的连接。下面，我们将手把手教您如何创建SSH Keys并将公钥加到你的GitHub账户中。&lt;/p&gt;

&lt;div class=&quot;clr&quot;&gt;&lt;/div&gt;

&lt;h3 id=&quot;一windows环境下生成ssh-key且连接github&quot;&gt;&lt;a name=&quot;1&quot;&gt;&lt;/a&gt;一、Windows环境下生成SSH key且连接GitHub&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;第一步看看是否存在ssh密钥keys&quot;&gt;第一步、看看是否存在SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;首先，我们需要看看是否看看本机是否存在SSH keys,打开Git Bash,并运行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd ~/.ssh
# 检查你本机用户home目录下是否存在.ssh目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。&lt;/p&gt;

&lt;h4 id=&quot;第二步创建一对新的ssh密钥keys&quot;&gt;第二步、创建一对新的SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;输入如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
# 这将按照你提供的邮箱地址，创建一对密钥
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;/c/Users/you/.ssh/github_rsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着，根据提示，你需要输入密码和确认密码。相关提示如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入完成之后，屏幕会显示如下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Your identification has been saved in /c/Users/you/.ssh/id_rsa.
Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;第三步在github账户中添加你的公钥&quot;&gt;第三步、在GitHub账户中添加你的公钥&lt;/h4&gt;

&lt;p&gt;运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clip &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;登陆GitHub,进入你的Account Settings. &lt;br /&gt;&lt;img src=&quot;/images/post/userbar-account-settings.png&quot; alt=&quot;Account Settings&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在左边菜单，点击”SSH Keys”. &lt;br /&gt; &lt;img src=&quot;/images/post/settings-sidebar-ssh-keys.png&quot; alt=&quot;SSH Keys&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;点击”Add SSH key”按钮.&lt;br /&gt; &lt;img src=&quot;/images/post/ssh-add-ssh-key.png&quot; alt=&quot;Add SSH key&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;粘贴你的密钥到key输入框中.&lt;br /&gt; &lt;img src=&quot;/images/post/ssh-key-paste.png&quot; alt=&quot;Paste key&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;点击”Add Key”按钮。&lt;br /&gt; &lt;img src=&quot;/images/post/ssh-add-key.png&quot; alt=&quot;Add Key&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;再弹出窗口，输入你的GitHub密码，点击确认按钮。&lt;/li&gt;
  &lt;li&gt;到此，大功告成了！&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;第四步测试&quot;&gt;第四步、测试&lt;/h4&gt;

&lt;p&gt;为了确认我们可以通过SSH连接GitHub，我们输入下面命令。输入后，会要求我们提供验证密码，输入之前创建的密码就ok了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可能会看到告警信息，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不用担心，直接输入yes。&lt;/p&gt;

&lt;p&gt;如果看到下面信息，就说明一切完美！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi username! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;二mac环境下生成ssh-key且连接github&quot;&gt;&lt;a name=&quot;2&quot;&gt;&lt;/a&gt;二、Mac环境下生成SSH key且连接GitHub&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;第一步看看是否存在ssh密钥keys-1&quot;&gt;第一步、看看是否存在SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;首先，我们需要看看是否看看本机是否存在SSH keys,打开终端(Terminal),并运行:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$cd ~/.ssh
# 检查你本机用户home目录下是否存在.ssh目录
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果，不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。&lt;/p&gt;

&lt;h4 id=&quot;第二步创建一对新的ssh密钥keys-1&quot;&gt;第二步、创建一对新的SSH密钥(keys)&lt;/h4&gt;

&lt;p&gt;输入如下命令：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ssh-keygen -t rsa -C &quot;your_email@example.com&quot;
# 这将按照你提供的邮箱地址，创建一对密钥
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如&lt;code class=&quot;highlighter-rouge&quot;&gt;/Users/you/.ssh/github_rsa&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;接着，根据提示，你需要输入密码和确认密码。相关提示如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Enter passphrase (empty for no passphrase): [Type a passphrase]
Enter same passphrase again: [Type passphrase again]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;输入完成之后，屏幕会显示如下信息：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Your identification has been saved in /Users/you/.ssh/id_rsa.
Your public key has been saved in /Users/you/.ssh/id_rsa.pub.
The key fingerprint is:
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;第三步在github账户中添加你的公钥-1&quot;&gt;第三步、在GitHub账户中添加你的公钥&lt;/h4&gt;

&lt;p&gt;运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pbcopy &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接着：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;登陆GitHub,进入你的Account Settings. &lt;br /&gt;&lt;img src=&quot;/images/post/userbar-account-settings.png&quot; alt=&quot;Account Settings&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;在左边菜单，点击”SSH Keys”. &lt;br /&gt; &lt;img src=&quot;/images/post/settings-sidebar-ssh-keys.png&quot; alt=&quot;SSH Keys&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;点击”Add SSH key”按钮.&lt;br /&gt; &lt;img src=&quot;/images/post/ssh-add-ssh-key.png&quot; alt=&quot;Add SSH key&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;粘贴你的密钥到key输入框中.&lt;br /&gt; &lt;img src=&quot;/images/post/ssh-key-paste.png&quot; alt=&quot;Paste key&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;点击”Add Key”按钮。&lt;br /&gt; &lt;img src=&quot;/images/post/ssh-add-key.png&quot; alt=&quot;Add Key&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;再弹出窗口，输入你的GitHub密码，点击确认按钮。&lt;/li&gt;
  &lt;li&gt;到此，大功告成了！&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;第四步测试-1&quot;&gt;第四步、测试&lt;/h4&gt;

&lt;p&gt;为了确认我们可以通过SSH连接GitHub，我们输入下面命令。输入后，会要求我们提供验证密码，输入之前创建的密码就ok了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh -T git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;你可能会看到告警信息，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不用担心，直接输入yes。&lt;/p&gt;

&lt;p&gt;如果看到下面信息，就说明一切完美！&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Hi username! You've successfully authenticated, but GitHub does not provide shell access.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;####【注意】&lt;/p&gt;

&lt;p&gt;如果前面没有将生成的密钥存放在默认的文件&lt;code class=&quot;highlighter-rouge&quot;&gt;id_rsa&lt;/code&gt;中（而是&lt;code class=&quot;highlighter-rouge&quot;&gt;my_rsa&lt;/code&gt;中）,那么&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh -T git@github.com&lt;/code&gt;命令就需要添加参数来执行。如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ ssh -T -i my_rsa git@github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;三单机如何控制不同的ssh-keys连不同的git环境&quot;&gt;&lt;a name=&quot;3&quot;&gt;&lt;/a&gt;三、单机如何控制不同的SSH Keys连不同的Git环境?&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;其实，一套SSH密钥是可以用在不同的SSH环境的.&lt;/p&gt;

&lt;p&gt;但是如果由于某种要求，需要用不同的SSH密钥连接不同的Git环境。假设具体场景是，已经建了密钥github_rsa，还需要创建work_rsa连接工作环境git仓库，那么，可以按下面操作进行：&lt;/p&gt;

&lt;h4 id=&quot;1-创建另一对密钥work_rsa&quot;&gt;1. 创建另一对密钥work_rsa.&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ssh-keygen -t rsa -C &quot;work@mail.com&quot;
#保存密钥为work_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;2-添加新身份信息&quot;&gt;2. 添加新身份信息&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ssh-add ～/.ssh/work_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;3-配置sshconfig&quot;&gt;3. 配置.ssh/config&lt;/h4&gt;

&lt;p&gt;我们需要通过Host别名，将不同的账号区分开来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host me.github.com
	HostName github.com
	PreferredAuthentications publickey
	IdentityFile ~/.ssh/github_rsa

Host work.comp.com
	HostName comp.com
	PreferredAuthentications publickey
	IdentityFile ~/.ssh/work_rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考文档:GitHub官方文档&lt;a href=&quot;https://help.github.com/articles/generating-ssh-keys&quot;&gt;Generating SSH Keys&lt;/a&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>MAC OS X 10.8 下安装jekyll</title>
   <link href="http://www.blogways.net/blog/2013/04/08/install-jekyll-on-mac.html"/>
   <updated>2013-04-08T00:00:00+08:00</updated>
   <id>http://www.blogways.net/blog/2013/04/08/install-jekyll-on-mac</id>
   <content type="html">&lt;h3 id=&quot;一概述&quot;&gt;一、概述&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki&quot;&gt;jekyll&lt;/a&gt; 是一款简单的博客系统，静态网站生成器。她有一个模版目录，存放整个静态网站的模版文件，可以通过&lt;a href=&quot;https://github.com/shopify/liquid/wiki&quot;&gt;Liquid&lt;/a&gt;处理模版文件，把使用标记语言&lt;a href=&quot;http://en.wikipedia.org/wiki/Textile&quot;&gt;Textile&lt;/a&gt;或&lt;a href=&quot;http://en.wikipedia.org/wiki/Markdown&quot;&gt;Markdown&lt;/a&gt;编写的内容文件，按照模版格式，转换成最终的静态网站页面。大名鼎鼎的GitHub Pages就是通过她实现的。&lt;/p&gt;

&lt;p&gt;本想在本机Macbook pro上装个jekyll,可是本机xcode自动安装了ruby 1.8.7版，导致无法通过当前版本的gem安装jekyll。使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem update --system&lt;/code&gt; 命令对gem进行升级，可是貌似没有升级成功。&lt;/p&gt;

&lt;p&gt;所以，我先装了个brew，通过brew安装了最新的ruby，最后通过新版gem成功安装了jekyll.整个过程记录如下。&lt;/p&gt;

&lt;h3 id=&quot;二安装homebrew&quot;&gt;二、安装Homebrew&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://mxcl.github.io/homebrew/index_zh-cn.html&quot;&gt;Homebrew&lt;/a&gt;落户于gitHub上，安装是否简单，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打开Terminal, 粘贴上面的语句.该脚本首先将会解释它要做什么, 然后暂停下来, 直到您确认继续. 更多的安装选项在&lt;a href=&quot;https://github.com/mxcl/homebrew/wiki/Installation&quot;&gt;这里&lt;/a&gt;可以看到 (需要10.5).&lt;/p&gt;

&lt;h3 id=&quot;三安装最新版ruby&quot;&gt;三、安装最新版ruby&lt;/h3&gt;

&lt;p&gt;Homebrew安装完成之后，通过她安装最新版ruby.命令如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install ruby
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最新版ruby安装完成之后，会提示你最新版本安装在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/opt/ruby/bin&lt;/code&gt;目录下面。原来的旧版仍然在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/bin&lt;/code&gt;下面.&lt;/p&gt;

&lt;p&gt;可以修改环境变量PATH的值，将新版本的路径在查找路径中前置。修改&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.bash_profile&lt;/code&gt;文件，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;export PATH=/usr/local/opt/ruby/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改后&lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.bash_profile&lt;/code&gt;或者重新打开一个Terminal，新版Ruby就生效了。&lt;/p&gt;

&lt;p&gt;可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;ruby --version&lt;/code&gt;查看版本号，我的新版信息如下:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruby 2.0.0p0 (2013-02-24 revision 39474) [x86_64-darwin12.3.0]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果，版本不对，就使用&lt;code class=&quot;highlighter-rouge&quot;&gt;which ruby&lt;/code&gt;看看，当前生效的ruby是否在&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/opt/ruby/bin&lt;/code&gt;下，不对，就修改环境变量PATH,如上。&lt;/p&gt;

&lt;h3 id=&quot;四安装jekyll&quot;&gt;四、安装jekyll&lt;/h3&gt;

&lt;p&gt;有了最新版的ruby,安装jekyll就简单了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果使用的标记语言是Markdown，则需要另外安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果使用的标记语言是Textile,则需要另外安装&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install RedCloth
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面三个可以一次性安装，如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install jekyll rdiscount RedCloth
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;说明：这里安装的jekyll、rdiscount、redcloth都安装在本机的&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/opt/ruby/bin&lt;/code&gt;目录下面。&lt;/p&gt;

&lt;p&gt;另外，如果想和github提供的page环境保持相同的版本，可以安装&lt;code class=&quot;highlighter-rouge&quot;&gt;github-pages&lt;/code&gt;，这个会保持与github的page版本一致。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gem install github-pages
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;五运行例子jekyll作者提供的例子tpw&quot;&gt;五、运行例子——jekyll作者提供的例子tpw&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;获取源码，并运行jekyll，命令如下:&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; cd ~
 mkdir webroot
 cd webroot
 git clone https://github.com/mojombo/tpw.git
 cd tpw
 jekyll --server
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;

    &lt;p&gt;界面显示启动信息，提示端口为4000&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;在浏览器访问&lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:4000&lt;/code&gt;，显示博客列表。&lt;/li&gt;
  &lt;li&gt;相当完美！&lt;/li&gt;
  &lt;li&gt;[说明]新版本的jekyll的命令发生了变化。&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll build&lt;/code&gt;用来编译程序；&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;用来编译并启动一个web服务。&lt;/li&gt;
&lt;/ol&gt;

</content>
 </entry>
 

</feed>
